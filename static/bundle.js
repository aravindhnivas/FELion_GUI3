
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function (marked) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var marked__default = /*#__PURE__*/_interopDefaultLegacy(marked);

    function noop$1() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$1;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root.host) {
            return root;
        }
        return document;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.1' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function openModalStore() {

    	const defaultValues = {modalTitle:"Title", type:"warning", modalContent: "Content", open: false, message:"Pre-message"};
        const { subscribe, set, update } = writable(defaultValues);

    	return {
    		subscribe, set, update, 
    		error(modalContent="", modalTitle = "Error Details", type = "danger", message = "Error Ocurred") {
                update(n => {return {modalTitle, type, modalContent, message, open: true}});

            },
    		info(modalContent="", modalTitle = "Output", type = "warning", message = "Output") {
                update(n => {return {modalTitle, type, modalContent, message, open: true}});

            },

    		
            reset: () => set(defaultValues)
    	};


    }
    const mainPreModal = openModalStore();

    /* node_modules\svelma\src\components\Icon.svelte generated by Svelte v3.42.1 */

    const file$1v = "node_modules\\svelma\\src\\components\\Icon.svelte";

    function create_fragment$1F(ctx) {
    	let span;
    	let i;
    	let i_class_value;
    	let span_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "" + (/*newPack*/ ctx[8] + " fa-" + /*icon*/ ctx[0] + " " + /*customClass*/ ctx[2] + " " + /*newCustomSize*/ ctx[6]));
    			add_location(i, file$1v, 53, 2, 1189);
    			attr_dev(span, "class", span_class_value = "icon " + /*size*/ ctx[1] + " " + /*newType*/ ctx[7] + " " + (/*isLeft*/ ctx[4] && 'is-left' || '') + " " + (/*isRight*/ ctx[5] && 'is-right' || ''));
    			toggle_class(span, "is-clickable", /*isClickable*/ ctx[3]);
    			add_location(span, file$1v, 52, 0, 1046);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*newPack, icon, customClass, newCustomSize*/ 325 && i_class_value !== (i_class_value = "" + (/*newPack*/ ctx[8] + " fa-" + /*icon*/ ctx[0] + " " + /*customClass*/ ctx[2] + " " + /*newCustomSize*/ ctx[6]))) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*size, newType, isLeft, isRight*/ 178 && span_class_value !== (span_class_value = "icon " + /*size*/ ctx[1] + " " + /*newType*/ ctx[7] + " " + (/*isLeft*/ ctx[4] && 'is-left' || '') + " " + (/*isRight*/ ctx[5] && 'is-right' || ''))) {
    				attr_dev(span, "class", span_class_value);
    			}

    			if (dirty & /*size, newType, isLeft, isRight, isClickable*/ 186) {
    				toggle_class(span, "is-clickable", /*isClickable*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let newPack;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { type = '' } = $$props;
    	let { pack = 'fas' } = $$props;
    	let { icon } = $$props;
    	let { size = '' } = $$props;
    	let { customClass = '' } = $$props;
    	let { customSize = '' } = $$props;
    	let { isClickable = false } = $$props;
    	let { isLeft = false } = $$props;
    	let { isRight = false } = $$props;
    	let newCustomSize = '';
    	let newType = '';

    	const writable_props = [
    		'type',
    		'pack',
    		'icon',
    		'size',
    		'customClass',
    		'customSize',
    		'isClickable',
    		'isLeft',
    		'isRight'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('pack' in $$props) $$invalidate(10, pack = $$props.pack);
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$props.customClass);
    		if ('customSize' in $$props) $$invalidate(11, customSize = $$props.customSize);
    		if ('isClickable' in $$props) $$invalidate(3, isClickable = $$props.isClickable);
    		if ('isLeft' in $$props) $$invalidate(4, isLeft = $$props.isLeft);
    		if ('isRight' in $$props) $$invalidate(5, isRight = $$props.isRight);
    	};

    	$$self.$capture_state = () => ({
    		type,
    		pack,
    		icon,
    		size,
    		customClass,
    		customSize,
    		isClickable,
    		isLeft,
    		isRight,
    		newCustomSize,
    		newType,
    		newPack
    	});

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('pack' in $$props) $$invalidate(10, pack = $$props.pack);
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('customClass' in $$props) $$invalidate(2, customClass = $$props.customClass);
    		if ('customSize' in $$props) $$invalidate(11, customSize = $$props.customSize);
    		if ('isClickable' in $$props) $$invalidate(3, isClickable = $$props.isClickable);
    		if ('isLeft' in $$props) $$invalidate(4, isLeft = $$props.isLeft);
    		if ('isRight' in $$props) $$invalidate(5, isRight = $$props.isRight);
    		if ('newCustomSize' in $$props) $$invalidate(6, newCustomSize = $$props.newCustomSize);
    		if ('newType' in $$props) $$invalidate(7, newType = $$props.newType);
    		if ('newPack' in $$props) $$invalidate(8, newPack = $$props.newPack);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pack*/ 1024) {
    			$$invalidate(8, newPack = pack || 'fas');
    		}

    		if ($$self.$$.dirty & /*customSize, size*/ 2050) {
    			{
    				if (customSize) $$invalidate(6, newCustomSize = customSize); else {
    					switch (size) {
    						case 'is-small':
    							break;
    						case 'is-medium':
    							$$invalidate(6, newCustomSize = 'fa-lg');
    							break;
    						case 'is-large':
    							$$invalidate(6, newCustomSize = 'fa-3x');
    							break;
    						default:
    							$$invalidate(6, newCustomSize = '');
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*type*/ 512) {
    			{
    				if (!type) $$invalidate(7, newType = '');
    				let splitType = [];

    				if (typeof type === 'string') {
    					splitType = type.split('-');
    				} else {
    					for (let key in type) {
    						if (type[key]) {
    							splitType = key.split('-');
    							break;
    						}
    					}
    				}

    				if (splitType.length <= 1) $$invalidate(7, newType = ''); else $$invalidate(7, newType = `has-text-${splitType[1]}`);
    			}
    		}
    	};

    	return [
    		icon,
    		size,
    		customClass,
    		isClickable,
    		isLeft,
    		isRight,
    		newCustomSize,
    		newType,
    		newPack,
    		type,
    		pack,
    		customSize,
    		click_handler
    	];
    }

    class Icon$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1F, create_fragment$1F, safe_not_equal, {
    			type: 9,
    			pack: 10,
    			icon: 0,
    			size: 1,
    			customClass: 2,
    			customSize: 11,
    			isClickable: 3,
    			isLeft: 4,
    			isRight: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$1F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*icon*/ ctx[0] === undefined && !('icon' in props)) {
    			console.warn("<Icon> was created without expected prop 'icon'");
    		}
    	}

    	get type() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pack() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pack(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customClass() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customClass(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customSize() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customSize(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isClickable() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isClickable(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isLeft() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isLeft(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isRight() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isRight(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicInOut(t) {
        return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }
    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const f = style.filter === 'none' ? '' : style.filter;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
        };
    }
    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }
    function draw(node, { delay = 0, speed, duration, easing = cubicInOut } = {}) {
        const len = node.getTotalLength();
        if (duration === undefined) {
            if (speed === undefined) {
                duration = 800;
            }
            else {
                duration = len / speed;
            }
        }
        else if (typeof duration === 'function') {
            duration = duration(len);
        }
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
        };
    }
    function crossfade(_a) {
        var { fallback } = _a, defaults = __rest(_a, ["fallback"]);
        const to_receive = new Map();
        const to_send = new Map();
        function crossfade(from, node, params) {
            const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = cubicOut } = assign(assign({}, defaults), params);
            const to = node.getBoundingClientRect();
            const dx = from.left - to.left;
            const dy = from.top - to.top;
            const dw = from.width / to.width;
            const dh = from.height / to.height;
            const d = Math.sqrt(dx * dx + dy * dy);
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            const opacity = +style.opacity;
            return {
                delay,
                duration: is_function(duration) ? duration(d) : duration,
                easing,
                css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
            };
        }
        function transition(items, counterparts, intro) {
            return (node, params) => {
                items.set(params.key, {
                    rect: node.getBoundingClientRect()
                });
                return () => {
                    if (counterparts.has(params.key)) {
                        const { rect } = counterparts.get(params.key);
                        counterparts.delete(params.key);
                        return crossfade(rect, node, params);
                    }
                    // if the node is disappearing altogether
                    // (i.e. wasn't claimed by the other list)
                    // then we need to supply an outro
                    items.delete(params.key);
                    return fallback && fallback(node, params, intro);
                };
            };
        }
        return [
            transition(to_send, to_receive, false),
            transition(to_receive, to_send, true)
        ];
    }

    var transitions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        blur: blur,
        crossfade: crossfade,
        draw: draw,
        fade: fade,
        fly: fly,
        scale: scale,
        slide: slide
    });

    function chooseAnimation(animation) {
      return typeof animation === 'function' ? animation : transitions[animation]
    }

    function isEnterKey(e) {
      return e.keyCode && e.keyCode === 13
    }

    function isEscKey(e) {
      return e.keyCode && e.keyCode === 27
    }

    function typeToIcon(type) {
      switch (type) {
        case 'is-info':
          return 'info-circle'
        case 'is-success':
          return 'check-circle'
        case 'is-warning':
          return 'exclamation-triangle'
        case 'is-danger':
          return 'exclamation-circle'
        default:
          return null
      }
    }

    /* node_modules\svelma\src\components\Dialog\Dialog.svelte generated by Svelte v3.42.1 */
    const file$1u = "node_modules\\svelma\\src\\components\\Dialog\\Dialog.svelte";

    // (206:0) {#if active}
    function create_if_block$I(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div3;
    	let t1;
    	let section;
    	let div2;
    	let t2;
    	let div1;
    	let p;
    	let t3;
    	let t4;
    	let footer;
    	let t5;
    	let button;
    	let t6;
    	let button_class_value;
    	let div3_transition;
    	let div4_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*title*/ ctx[2] && create_if_block_4$3(ctx);
    	let if_block1 = /*icon*/ ctx[6] && create_if_block_3$4(ctx);
    	let if_block2 = /*hasInput*/ ctx[8] && create_if_block_2$9(ctx);
    	let if_block3 = /*showCancel*/ ctx[9] && create_if_block_1$i(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			section = element("section");
    			div2 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div1 = element("div");
    			p = element("p");
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			footer = element("footer");
    			if (if_block3) if_block3.c();
    			t5 = space();
    			button = element("button");
    			t6 = text(/*confirmText*/ ctx[4]);
    			attr_dev(div0, "class", "modal-background");
    			add_location(div0, file$1u, 207, 4, 4875);
    			add_location(p, file$1u, 226, 12, 5650);
    			attr_dev(div1, "class", "media-content");
    			add_location(div1, file$1u, 225, 10, 5610);
    			attr_dev(div2, "class", "media");
    			add_location(div2, file$1u, 219, 8, 5413);
    			attr_dev(section, "class", "modal-card-body svelte-1fsuju2");
    			toggle_class(section, "is-titleless", !/*title*/ ctx[2]);
    			toggle_class(section, "is-flex", /*icon*/ ctx[6]);
    			add_location(section, file$1u, 218, 6, 5322);
    			attr_dev(button, "class", button_class_value = "button " + /*type*/ ctx[11] + " svelte-1fsuju2");
    			add_location(button, file$1u, 254, 8, 6455);
    			attr_dev(footer, "class", "modal-card-foot svelte-1fsuju2");
    			add_location(footer, file$1u, 245, 6, 6209);
    			attr_dev(div3, "class", "modal-card svelte-1fsuju2");
    			add_location(div3, file$1u, 208, 4, 4933);
    			attr_dev(div4, "class", div4_class_value = "modal dialog " + /*size*/ ctx[10] + " is-active" + " svelte-1fsuju2");
    			add_location(div4, file$1u, 206, 2, 4809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t1);
    			append_dev(div3, section);
    			append_dev(section, div2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			p.innerHTML = /*message*/ ctx[3];
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div3, t4);
    			append_dev(div3, footer);
    			if (if_block3) if_block3.m(footer, null);
    			append_dev(footer, t5);
    			append_dev(footer, button);
    			append_dev(button, t6);
    			/*button_binding_1*/ ctx[34](button);
    			/*div4_binding*/ ctx[35](div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*close*/ ctx[21], false, false, false),
    					listen_dev(button, "click", /*confirm*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*title*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					if_block0.m(div3, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*icon*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*message*/ 8) p.innerHTML = /*message*/ ctx[3];
    			if (/*hasInput*/ ctx[8]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_2$9(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*title*/ 4) {
    				toggle_class(section, "is-titleless", !/*title*/ ctx[2]);
    			}

    			if (dirty[0] & /*icon*/ 64) {
    				toggle_class(section, "is-flex", /*icon*/ ctx[6]);
    			}

    			if (/*showCancel*/ ctx[9]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$i(ctx);
    					if_block3.c();
    					if_block3.m(footer, t5);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || dirty[0] & /*confirmText*/ 16) set_data_dev(t6, /*confirmText*/ ctx[4]);

    			if (!current || dirty[0] & /*type*/ 2048 && button_class_value !== (button_class_value = "button " + /*type*/ ctx[11] + " svelte-1fsuju2")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (!current || dirty[0] & /*size*/ 1024 && div4_class_value !== (div4_class_value = "modal dialog " + /*size*/ ctx[10] + " is-active" + " svelte-1fsuju2")) {
    				attr_dev(div4, "class", div4_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*_animation*/ ctx[19], /*animProps*/ ctx[12], true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*_animation*/ ctx[19], /*animProps*/ ctx[12], false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*button_binding_1*/ ctx[34](null);
    			if (detaching && div3_transition) div3_transition.end();
    			/*div4_binding*/ ctx[35](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(206:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (210:6) {#if title}
    function create_if_block_4$3(ctx) {
    	let header;
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			header = element("header");
    			p = element("p");
    			t = text(/*title*/ ctx[2]);
    			attr_dev(p, "class", "modal-card-title");
    			add_location(p, file$1u, 211, 10, 5061);
    			attr_dev(header, "class", "modal-card-head svelte-1fsuju2");
    			add_location(header, file$1u, 210, 8, 5018);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(210:6) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (221:10) {#if icon}
    function create_if_block_3$4(ctx) {
    	let div;
    	let icon_1;
    	let current;

    	icon_1 = new Icon$1({
    			props: {
    				pack: /*iconPack*/ ctx[7],
    				icon: /*icon*/ ctx[6],
    				type: /*type*/ ctx[11],
    				size: "is-large"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon_1.$$.fragment);
    			attr_dev(div, "class", "media-left");
    			add_location(div, file$1u, 221, 12, 5466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty[0] & /*iconPack*/ 128) icon_1_changes.pack = /*iconPack*/ ctx[7];
    			if (dirty[0] & /*icon*/ 64) icon_1_changes.icon = /*icon*/ ctx[6];
    			if (dirty[0] & /*type*/ 2048) icon_1_changes.type = /*type*/ ctx[11];
    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(221:10) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (229:12) {#if hasInput}
    function create_if_block_2$9(ctx) {
    	let div1;
    	let div0;
    	let input_1;
    	let t0;
    	let p;
    	let t1;
    	let mounted;
    	let dispose;
    	let input_1_levels = [{ class: "input" }, /*newInputProps*/ ctx[18]];
    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			input_1 = element("input");
    			t0 = space();
    			p = element("p");
    			t1 = text(/*validationMessage*/ ctx[17]);
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-1fsuju2", true);
    			add_location(input_1, file$1u, 231, 18, 5791);
    			attr_dev(p, "class", "help is-danger");
    			add_location(p, file$1u, 237, 18, 6041);
    			attr_dev(div0, "class", "control");
    			add_location(div0, file$1u, 230, 16, 5751);
    			attr_dev(div1, "class", "field svelte-1fsuju2");
    			add_location(div1, file$1u, 229, 14, 5715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, input_1);
    			if (input_1.autofocus) input_1.focus();
    			set_input_value(input_1, /*prompt*/ ctx[1]);
    			/*input_1_binding*/ ctx[31](input_1);
    			append_dev(div0, t0);
    			append_dev(div0, p);
    			append_dev(p, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[30]),
    					listen_dev(input_1, "keyup", /*keyup_handler*/ ctx[32], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				{ class: "input" },
    				dirty[0] & /*newInputProps*/ 262144 && /*newInputProps*/ ctx[18]
    			]));

    			if (dirty[0] & /*prompt*/ 2 && input_1.value !== /*prompt*/ ctx[1]) {
    				set_input_value(input_1, /*prompt*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-1fsuju2", true);
    			if (dirty[0] & /*validationMessage*/ 131072) set_data_dev(t1, /*validationMessage*/ ctx[17]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*input_1_binding*/ ctx[31](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(229:12) {#if hasInput}",
    		ctx
    	});

    	return block;
    }

    // (247:8) {#if showCancel}
    function create_if_block_1$i(ctx) {
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*cancelText*/ ctx[5]);
    			attr_dev(button, "class", "button svelte-1fsuju2");
    			add_location(button, file$1u, 247, 10, 6277);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			/*button_binding*/ ctx[33](button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*cancel*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*cancelText*/ 32) set_data_dev(t, /*cancelText*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[33](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(247:8) {#if showCancel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1E(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*active*/ ctx[0] && create_if_block$I(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*keydown*/ ctx[23], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$I(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let _animation;
    	let newInputProps;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dialog', slots, []);
    	let { title = '' } = $$props;
    	let { message } = $$props;
    	let { confirmText = 'OK' } = $$props;
    	let { cancelText = 'Cancel' } = $$props;
    	let { focusOn = 'confirm' } = $$props;
    	let { icon = '' } = $$props;
    	let { iconPack = '' } = $$props;
    	let { hasInput = false } = $$props;
    	let { prompt = null } = $$props;
    	let { showCancel = false } = $$props;
    	let { size = '' } = $$props;
    	let { type = 'is-primary' } = $$props;
    	let { active = true } = $$props;
    	let { animation = 'scale' } = $$props;
    	let { animProps = { start: 1.2 } } = $$props;
    	let { inputProps = {} } = $$props;

    	// export let showClose = true
    	let resolve;

    	let { promise = new Promise(fulfil => resolve = fulfil) } = $$props;
    	let { subComponent = null } = $$props;
    	let { appendToBody = true } = $$props;
    	let modal;
    	let cancelButton;
    	let confirmButton;
    	let input;
    	let validationMessage = '';
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await tick();

    		if (hasInput) {
    			input.focus();
    		} else if (focusOn === 'cancel' && showCancel) {
    			cancelButton.focus();
    		} else {
    			confirmButton.focus();
    		}
    	});

    	function cancel() {
    		resolve(hasInput ? null : false);
    		close();
    	}

    	function close() {
    		resolve(hasInput ? null : false);
    		$$invalidate(0, active = false);
    		dispatch('destroyed');
    	}

    	async function confirm() {
    		if (input && !input.checkValidity()) {
    			$$invalidate(17, validationMessage = input.validationMessage);
    			await tick();
    			input.select();
    			return;
    		}

    		$$invalidate(17, validationMessage = '');
    		resolve(hasInput ? prompt : true);
    		close();
    	}

    	function keydown(e) {
    		if (active && isEscKey(e)) {
    			close();
    		}
    	}

    	const writable_props = [
    		'title',
    		'message',
    		'confirmText',
    		'cancelText',
    		'focusOn',
    		'icon',
    		'iconPack',
    		'hasInput',
    		'prompt',
    		'showCancel',
    		'size',
    		'type',
    		'active',
    		'animation',
    		'animProps',
    		'inputProps',
    		'promise',
    		'subComponent',
    		'appendToBody'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dialog> was created with unknown prop '${key}'`);
    	});

    	function input_1_input_handler() {
    		prompt = this.value;
    		$$invalidate(1, prompt);
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(16, input);
    		});
    	}

    	const keyup_handler = e => isEnterKey(e) && confirm();

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			cancelButton = $$value;
    			$$invalidate(14, cancelButton);
    		});
    	}

    	function button_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			confirmButton = $$value;
    			$$invalidate(15, confirmButton);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modal = $$value;
    			$$invalidate(13, modal);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('message' in $$props) $$invalidate(3, message = $$props.message);
    		if ('confirmText' in $$props) $$invalidate(4, confirmText = $$props.confirmText);
    		if ('cancelText' in $$props) $$invalidate(5, cancelText = $$props.cancelText);
    		if ('focusOn' in $$props) $$invalidate(24, focusOn = $$props.focusOn);
    		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
    		if ('iconPack' in $$props) $$invalidate(7, iconPack = $$props.iconPack);
    		if ('hasInput' in $$props) $$invalidate(8, hasInput = $$props.hasInput);
    		if ('prompt' in $$props) $$invalidate(1, prompt = $$props.prompt);
    		if ('showCancel' in $$props) $$invalidate(9, showCancel = $$props.showCancel);
    		if ('size' in $$props) $$invalidate(10, size = $$props.size);
    		if ('type' in $$props) $$invalidate(11, type = $$props.type);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('animation' in $$props) $$invalidate(25, animation = $$props.animation);
    		if ('animProps' in $$props) $$invalidate(12, animProps = $$props.animProps);
    		if ('inputProps' in $$props) $$invalidate(26, inputProps = $$props.inputProps);
    		if ('promise' in $$props) $$invalidate(27, promise = $$props.promise);
    		if ('subComponent' in $$props) $$invalidate(28, subComponent = $$props.subComponent);
    		if ('appendToBody' in $$props) $$invalidate(29, appendToBody = $$props.appendToBody);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		Icon: Icon$1,
    		chooseAnimation,
    		isEnterKey,
    		isEscKey,
    		title,
    		message,
    		confirmText,
    		cancelText,
    		focusOn,
    		icon,
    		iconPack,
    		hasInput,
    		prompt,
    		showCancel,
    		size,
    		type,
    		active,
    		animation,
    		animProps,
    		inputProps,
    		resolve,
    		promise,
    		subComponent,
    		appendToBody,
    		modal,
    		cancelButton,
    		confirmButton,
    		input,
    		validationMessage,
    		dispatch,
    		cancel,
    		close,
    		confirm,
    		keydown,
    		newInputProps,
    		_animation
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('message' in $$props) $$invalidate(3, message = $$props.message);
    		if ('confirmText' in $$props) $$invalidate(4, confirmText = $$props.confirmText);
    		if ('cancelText' in $$props) $$invalidate(5, cancelText = $$props.cancelText);
    		if ('focusOn' in $$props) $$invalidate(24, focusOn = $$props.focusOn);
    		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
    		if ('iconPack' in $$props) $$invalidate(7, iconPack = $$props.iconPack);
    		if ('hasInput' in $$props) $$invalidate(8, hasInput = $$props.hasInput);
    		if ('prompt' in $$props) $$invalidate(1, prompt = $$props.prompt);
    		if ('showCancel' in $$props) $$invalidate(9, showCancel = $$props.showCancel);
    		if ('size' in $$props) $$invalidate(10, size = $$props.size);
    		if ('type' in $$props) $$invalidate(11, type = $$props.type);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('animation' in $$props) $$invalidate(25, animation = $$props.animation);
    		if ('animProps' in $$props) $$invalidate(12, animProps = $$props.animProps);
    		if ('inputProps' in $$props) $$invalidate(26, inputProps = $$props.inputProps);
    		if ('resolve' in $$props) resolve = $$props.resolve;
    		if ('promise' in $$props) $$invalidate(27, promise = $$props.promise);
    		if ('subComponent' in $$props) $$invalidate(28, subComponent = $$props.subComponent);
    		if ('appendToBody' in $$props) $$invalidate(29, appendToBody = $$props.appendToBody);
    		if ('modal' in $$props) $$invalidate(13, modal = $$props.modal);
    		if ('cancelButton' in $$props) $$invalidate(14, cancelButton = $$props.cancelButton);
    		if ('confirmButton' in $$props) $$invalidate(15, confirmButton = $$props.confirmButton);
    		if ('input' in $$props) $$invalidate(16, input = $$props.input);
    		if ('validationMessage' in $$props) $$invalidate(17, validationMessage = $$props.validationMessage);
    		if ('newInputProps' in $$props) $$invalidate(18, newInputProps = $$props.newInputProps);
    		if ('_animation' in $$props) $$invalidate(19, _animation = $$props._animation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*animation*/ 33554432) {
    			$$invalidate(19, _animation = chooseAnimation(animation));
    		}

    		if ($$self.$$.dirty[0] & /*modal, active, appendToBody*/ 536879105) {
    			{
    				if (modal && active && appendToBody) {
    					modal.parentNode.removeChild(modal);
    					document.body.appendChild(modal);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*inputProps*/ 67108864) {
    			$$invalidate(18, newInputProps = { required: true, ...inputProps });
    		}
    	};

    	return [
    		active,
    		prompt,
    		title,
    		message,
    		confirmText,
    		cancelText,
    		icon,
    		iconPack,
    		hasInput,
    		showCancel,
    		size,
    		type,
    		animProps,
    		modal,
    		cancelButton,
    		confirmButton,
    		input,
    		validationMessage,
    		newInputProps,
    		_animation,
    		cancel,
    		close,
    		confirm,
    		keydown,
    		focusOn,
    		animation,
    		inputProps,
    		promise,
    		subComponent,
    		appendToBody,
    		input_1_input_handler,
    		input_1_binding,
    		keyup_handler,
    		button_binding,
    		button_binding_1,
    		div4_binding
    	];
    }

    class Dialog$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$1E,
    			create_fragment$1E,
    			safe_not_equal,
    			{
    				title: 2,
    				message: 3,
    				confirmText: 4,
    				cancelText: 5,
    				focusOn: 24,
    				icon: 6,
    				iconPack: 7,
    				hasInput: 8,
    				prompt: 1,
    				showCancel: 9,
    				size: 10,
    				type: 11,
    				active: 0,
    				animation: 25,
    				animProps: 12,
    				inputProps: 26,
    				promise: 27,
    				subComponent: 28,
    				appendToBody: 29
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$1E.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[3] === undefined && !('message' in props)) {
    			console.warn("<Dialog> was created without expected prop 'message'");
    		}
    	}

    	get title() {
    		return this.$$.ctx[2];
    	}

    	set title(title) {
    		this.$$set({ title });
    		flush();
    	}

    	get message() {
    		return this.$$.ctx[3];
    	}

    	set message(message) {
    		this.$$set({ message });
    		flush();
    	}

    	get confirmText() {
    		return this.$$.ctx[4];
    	}

    	set confirmText(confirmText) {
    		this.$$set({ confirmText });
    		flush();
    	}

    	get cancelText() {
    		return this.$$.ctx[5];
    	}

    	set cancelText(cancelText) {
    		this.$$set({ cancelText });
    		flush();
    	}

    	get focusOn() {
    		return this.$$.ctx[24];
    	}

    	set focusOn(focusOn) {
    		this.$$set({ focusOn });
    		flush();
    	}

    	get icon() {
    		return this.$$.ctx[6];
    	}

    	set icon(icon) {
    		this.$$set({ icon });
    		flush();
    	}

    	get iconPack() {
    		return this.$$.ctx[7];
    	}

    	set iconPack(iconPack) {
    		this.$$set({ iconPack });
    		flush();
    	}

    	get hasInput() {
    		return this.$$.ctx[8];
    	}

    	set hasInput(hasInput) {
    		this.$$set({ hasInput });
    		flush();
    	}

    	get prompt() {
    		return this.$$.ctx[1];
    	}

    	set prompt(prompt) {
    		this.$$set({ prompt });
    		flush();
    	}

    	get showCancel() {
    		return this.$$.ctx[9];
    	}

    	set showCancel(showCancel) {
    		this.$$set({ showCancel });
    		flush();
    	}

    	get size() {
    		return this.$$.ctx[10];
    	}

    	set size(size) {
    		this.$$set({ size });
    		flush();
    	}

    	get type() {
    		return this.$$.ctx[11];
    	}

    	set type(type) {
    		this.$$set({ type });
    		flush();
    	}

    	get active() {
    		return this.$$.ctx[0];
    	}

    	set active(active) {
    		this.$$set({ active });
    		flush();
    	}

    	get animation() {
    		return this.$$.ctx[25];
    	}

    	set animation(animation) {
    		this.$$set({ animation });
    		flush();
    	}

    	get animProps() {
    		return this.$$.ctx[12];
    	}

    	set animProps(animProps) {
    		this.$$set({ animProps });
    		flush();
    	}

    	get inputProps() {
    		return this.$$.ctx[26];
    	}

    	set inputProps(inputProps) {
    		this.$$set({ inputProps });
    		flush();
    	}

    	get promise() {
    		return this.$$.ctx[27];
    	}

    	set promise(promise) {
    		this.$$set({ promise });
    		flush();
    	}

    	get subComponent() {
    		return this.$$.ctx[28];
    	}

    	set subComponent(subComponent) {
    		this.$$set({ subComponent });
    		flush();
    	}

    	get appendToBody() {
    		return this.$$.ctx[29];
    	}

    	set appendToBody(appendToBody) {
    		this.$$set({ appendToBody });
    		flush();
    	}
    }

    function createDialog(props) {
      if (typeof props === 'string') props = { message: props };

      const dialog = new Dialog$1({
        target: document.body,
        props,
        intro: true,
      });

      dialog.$on('destroy', () => {
        dialog.$destroy;
      });

      return dialog.promise
    }

    function alert(props) {
      return createDialog(props);
    }

    function confirm(props) {
      if (typeof props === 'string') props = { message: props };

      return createDialog({ showCancel: true, ...props });
    }

    function prompt(props) {
      if (typeof props === 'string') props = { message: props };

      return createDialog({ hasInput: true, confirmText: 'Done', ...props });
    }

    Dialog$1.alert = alert;
    Dialog$1.confirm = confirm;
    Dialog$1.prompt = prompt;

    /* node_modules\svelma\src\components\Modal\Modal.svelte generated by Svelte v3.42.1 */
    const file$1t = "node_modules\\svelma\\src\\components\\Modal\\Modal.svelte";

    // (40:0) {#if active}
    function create_if_block$H(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let t1;
    	let div1;
    	let div2_transition;
    	let t2;
    	let div3_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let if_block = /*showClose*/ ctx[3] && create_if_block_1$h(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "modal-background");
    			add_location(div0, file$1t, 41, 4, 816);
    			attr_dev(div1, "class", "sub-component");
    			add_location(div1, file$1t, 44, 6, 1000);
    			attr_dev(div2, "class", "modal-content");
    			add_location(div2, file$1t, 42, 4, 874);
    			attr_dev(div3, "class", div3_class_value = "modal " + /*size*/ ctx[2] + " is-active");
    			add_location(div3, file$1t, 40, 2, 757);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div3, t2);
    			if (if_block) if_block.m(div3, null);
    			/*div3_binding*/ ctx[13](div3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*close*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*showClose*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$h(ctx);
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*size*/ 4 && div3_class_value !== (div3_class_value = "modal " + /*size*/ ctx[2] + " is-active")) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*_animation*/ ctx[5], /*animProps*/ ctx[1], true);
    					div2_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);

    			if (local) {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, /*_animation*/ ctx[5], /*animProps*/ ctx[1], false);
    				div2_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div2_transition) div2_transition.end();
    			if (if_block) if_block.d();
    			/*div3_binding*/ ctx[13](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(40:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (47:4) {#if showClose}
    function create_if_block_1$h(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "modal-close is-large");
    			attr_dev(button, "aria-label", "close");
    			add_location(button, file$1t, 47, 6, 1071);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(47:4) {#if showClose}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1D(ctx) {
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*active*/ ctx[0] && create_if_block$H(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*keydown*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$H(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let _animation;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['default']);
    	let { active = true } = $$props;
    	let { animation = 'scale' } = $$props;
    	let { animProps = { start: 1.2 } } = $$props;
    	let { size = '' } = $$props;
    	let { showClose = true } = $$props;
    	let { subComponent = null } = $$props;
    	let { onBody = true } = $$props;
    	let modal;

    	onMount(() => {
    		
    	});

    	function close() {
    		$$invalidate(0, active = false);
    	}

    	function keydown(e) {
    		if (active && isEscKey(e)) {
    			close();
    		}
    	}

    	const writable_props = [
    		'active',
    		'animation',
    		'animProps',
    		'size',
    		'showClose',
    		'subComponent',
    		'onBody'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modal = $$value;
    			$$invalidate(4, modal);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('animation' in $$props) $$invalidate(8, animation = $$props.animation);
    		if ('animProps' in $$props) $$invalidate(1, animProps = $$props.animProps);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('showClose' in $$props) $$invalidate(3, showClose = $$props.showClose);
    		if ('subComponent' in $$props) $$invalidate(9, subComponent = $$props.subComponent);
    		if ('onBody' in $$props) $$invalidate(10, onBody = $$props.onBody);
    		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		chooseAnimation,
    		isEscKey,
    		active,
    		animation,
    		animProps,
    		size,
    		showClose,
    		subComponent,
    		onBody,
    		modal,
    		close,
    		keydown,
    		_animation
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('animation' in $$props) $$invalidate(8, animation = $$props.animation);
    		if ('animProps' in $$props) $$invalidate(1, animProps = $$props.animProps);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('showClose' in $$props) $$invalidate(3, showClose = $$props.showClose);
    		if ('subComponent' in $$props) $$invalidate(9, subComponent = $$props.subComponent);
    		if ('onBody' in $$props) $$invalidate(10, onBody = $$props.onBody);
    		if ('modal' in $$props) $$invalidate(4, modal = $$props.modal);
    		if ('_animation' in $$props) $$invalidate(5, _animation = $$props._animation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animation*/ 256) {
    			$$invalidate(5, _animation = chooseAnimation(animation));
    		}

    		if ($$self.$$.dirty & /*modal, active, onBody*/ 1041) {
    			{
    				if (modal && active && onBody) {
    					modal.parentNode.removeChild(modal);
    					document.body.appendChild(modal);
    				}
    			}
    		}
    	};

    	return [
    		active,
    		animProps,
    		size,
    		showClose,
    		modal,
    		_animation,
    		close,
    		keydown,
    		animation,
    		subComponent,
    		onBody,
    		$$scope,
    		slots,
    		div3_binding
    	];
    }

    class Modal$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1D, create_fragment$1D, safe_not_equal, {
    			active: 0,
    			animation: 8,
    			animProps: 1,
    			size: 2,
    			showClose: 3,
    			subComponent: 9,
    			onBody: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$1D.name
    		});
    	}

    	get active() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animation() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animation(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClose() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClose(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subComponent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subComponent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onBody() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onBody(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    Modal$2.open = open;

    function open(props) {
      const modal = new Modal$2({
        target: document.body,
        props,
        intro: true
      });

      modal.close = () => modal.$destroy();

      return modal;
    }

    /* node_modules\svelma\src\components\Notices.svelte generated by Svelte v3.42.1 */

    const file$1s = "node_modules\\svelma\\src\\components\\Notices.svelte";

    function create_fragment$1C(ctx) {
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "notices " + /*positionClass*/ ctx[1] + " svelte-1mcog5q");
    			add_location(div, file$1s, 42, 0, 863);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[4](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*positionClass*/ 2 && div_class_value !== (div_class_value = "notices " + /*positionClass*/ ctx[1] + " svelte-1mcog5q")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const notices = {};

    function instance$1C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Notices', slots, []);
    	let { position = 'top' } = $$props;
    	let container;
    	let positionClass;

    	function insert(el) {
    		container.insertAdjacentElement('afterbegin', el);
    	}

    	const writable_props = ['position'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notices> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('position' in $$props) $$invalidate(2, position = $$props.position);
    	};

    	$$self.$capture_state = () => ({
    		notices,
    		position,
    		container,
    		positionClass,
    		insert
    	});

    	$$self.$inject_state = $$props => {
    		if ('position' in $$props) $$invalidate(2, position = $$props.position);
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('positionClass' in $$props) $$invalidate(1, positionClass = $$props.positionClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*position*/ 4) {
    			$$invalidate(1, positionClass = position === 'top' ? 'is-top' : 'is-bottom');
    		}
    	};

    	return [container, positionClass, position, insert, div_binding];
    }

    class Notices extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1C, create_fragment$1C, safe_not_equal, { position: 2, insert: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notices",
    			options,
    			id: create_fragment$1C.name
    		});
    	}

    	get position() {
    		throw new Error("<Notices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Notices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get insert() {
    		return this.$$.ctx[3];
    	}

    	set insert(value) {
    		throw new Error("<Notices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelma\src\components\Notice.svelte generated by Svelte v3.42.1 */

    const { Object: Object_1$3 } = globals;
    const file$1r = "node_modules\\svelma\\src\\components\\Notice.svelte";

    // (99:0) {#if active}
    function create_if_block$G(ctx) {
    	let div;
    	let div_class_value;
    	let div_aria_hidden_value;
    	let div_intro;
    	let div_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = "notice " + /*position*/ ctx[1] + " svelte-1ik1n9x");
    			attr_dev(div, "aria-hidden", div_aria_hidden_value = !/*active*/ ctx[0]);
    			add_location(div, file$1r, 99, 2, 1933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[10](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "outroend", /*remove*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*position*/ 2 && div_class_value !== (div_class_value = "notice " + /*position*/ ctx[1] + " svelte-1ik1n9x")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*active*/ 1 && div_aria_hidden_value !== (div_aria_hidden_value = !/*active*/ ctx[0])) {
    				attr_dev(div, "aria-hidden", div_aria_hidden_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, fly, { y: /*transitionY*/ ctx[4] });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (div_intro) div_intro.invalidate();

    			div_outro = create_out_transition(div, fade, {
    				duration: /*transitionOut*/ ctx[2] ? 400 : 0
    			});

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[10](null);
    			if (detaching && div_outro) div_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(99:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1B(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const allowedProps = ['active', 'position', 'duration'];

    function filterProps(props) {
    	const newProps = {};

    	Object.keys(props).forEach(key => {
    		if (allowedProps.includes(key)) newProps[key] = props[key];
    	});

    	return newProps;
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let transitionY;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Notice', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { active = true } = $$props;
    	let { position = 'is-top' } = $$props;
    	let { duration = 2000 } = $$props;
    	let { transitionOut = true } = $$props;
    	let el;
    	let parent;
    	let timer;

    	function close() {
    		$$invalidate(0, active = false);
    	}

    	function remove() {
    		clearTimeout(timer);

    		// Just making sure
    		$$invalidate(0, active = false);

    		dispatch('destroyed');
    	}

    	async function setupContainers() {
    		await tick;

    		if (!notices.top) {
    			notices.top = new Notices({
    					target: document.body,
    					props: { position: 'top' }
    				});
    		}

    		if (!notices.bottom) {
    			notices.bottom = new Notices({
    					target: document.body,
    					props: { position: 'bottom' }
    				});
    		}
    	}

    	function chooseParent() {
    		parent = notices.top;
    		if (position && position.indexOf('is-bottom') === 0) parent = notices.bottom;
    		parent.insert(el);
    	}

    	onMount(async () => {
    		await setupContainers();
    		chooseParent();

    		timer = setTimeout(
    			() => {
    				close();
    			},
    			duration
    		);
    	});

    	const writable_props = ['active', 'position', 'duration', 'transitionOut'];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notice> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			el = $$value;
    			$$invalidate(3, el);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('position' in $$props) $$invalidate(1, position = $$props.position);
    		if ('duration' in $$props) $$invalidate(6, duration = $$props.duration);
    		if ('transitionOut' in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		allowedProps,
    		filterProps,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		fly,
    		fade,
    		Notices,
    		notices,
    		dispatch,
    		active,
    		position,
    		duration,
    		transitionOut,
    		el,
    		parent,
    		timer,
    		close,
    		remove,
    		setupContainers,
    		chooseParent,
    		transitionY
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('position' in $$props) $$invalidate(1, position = $$props.position);
    		if ('duration' in $$props) $$invalidate(6, duration = $$props.duration);
    		if ('transitionOut' in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
    		if ('el' in $$props) $$invalidate(3, el = $$props.el);
    		if ('parent' in $$props) parent = $$props.parent;
    		if ('timer' in $$props) timer = $$props.timer;
    		if ('transitionY' in $$props) $$invalidate(4, transitionY = $$props.transitionY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*position*/ 2) {
    			$$invalidate(4, transitionY = ~position.indexOf('is-top') ? -200 : 200);
    		}
    	};

    	return [
    		active,
    		position,
    		transitionOut,
    		el,
    		transitionY,
    		remove,
    		duration,
    		close,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Notice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1B, create_fragment$1B, safe_not_equal, {
    			active: 0,
    			position: 1,
    			duration: 6,
    			transitionOut: 2,
    			close: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notice",
    			options,
    			id: create_fragment$1B.name
    		});
    	}

    	get active() {
    		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionOut() {
    		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionOut(value) {
    		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		return this.$$.ctx[7];
    	}

    	set close(value) {
    		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelma\src\components\Notification\Notification.svelte generated by Svelte v3.42.1 */
    const file$1q = "node_modules\\svelma\\src\\components\\Notification\\Notification.svelte";

    // (92:0) {#if active}
    function create_if_block$F(ctx) {
    	let article;
    	let t0;
    	let div1;
    	let t1;
    	let div0;
    	let article_class_value;
    	let article_transition;
    	let current;
    	let if_block0 = /*showClose*/ ctx[2] && create_if_block_2$8(ctx);
    	let if_block1 = /*icon*/ ctx[3] && create_if_block_1$g(ctx);
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			article = element("article");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "media-content");
    			add_location(div0, file$1q, 102, 6, 2846);
    			attr_dev(div1, "class", "media svelte-87qcq1");
    			add_location(div1, file$1q, 96, 4, 2677);
    			attr_dev(article, "class", article_class_value = "notification " + /*type*/ ctx[1] + " svelte-87qcq1");
    			add_location(article, file$1q, 92, 2, 2506);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			if (if_block0) if_block0.m(article, null);
    			append_dev(article, t0);
    			append_dev(article, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showClose*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					if_block0.m(article, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*icon*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*icon*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$g(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*type*/ 2 && article_class_value !== (article_class_value = "notification " + /*type*/ ctx[1] + " svelte-87qcq1")) {
    				attr_dev(article, "class", article_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, true);
    					article_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(default_slot, local);

    			if (local) {
    				if (!article_transition) article_transition = create_bidirectional_transition(article, fade, {}, false);
    				article_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && article_transition) article_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(92:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (94:4) {#if showClose}
    function create_if_block_2$8(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "delete");
    			attr_dev(button, "aria-label", /*ariaCloseLabel*/ ctx[5]);
    			add_location(button, file$1q, 94, 6, 2592);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaCloseLabel*/ 32) {
    				attr_dev(button, "aria-label", /*ariaCloseLabel*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(94:4) {#if showClose}",
    		ctx
    	});

    	return block;
    }

    // (98:6) {#if icon}
    function create_if_block_1$g(ctx) {
    	let div;
    	let icon_1;
    	let current;

    	icon_1 = new Icon$1({
    			props: {
    				pack: /*iconPack*/ ctx[4],
    				icon: /*newIcon*/ ctx[6],
    				size: "is-large"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon_1.$$.fragment);
    			attr_dev(div, "class", "media-left");
    			add_location(div, file$1q, 98, 8, 2722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_1_changes = {};
    			if (dirty & /*iconPack*/ 16) icon_1_changes.pack = /*iconPack*/ ctx[4];
    			if (dirty & /*newIcon*/ 64) icon_1_changes.icon = /*newIcon*/ ctx[6];
    			icon_1.$set(icon_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(98:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1A(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$F(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Notification', slots, ['default']);
    	let { type = '' } = $$props;
    	let { active = true } = $$props;
    	let { showClose = true } = $$props;
    	let { autoClose = false } = $$props;
    	let { duration = 2000 } = $$props;
    	let { icon = '' } = $$props;
    	let { iconPack = '' } = $$props;
    	let { ariaCloseLabel = '' } = $$props;

    	/** Text for notification, when used programmatically
     * @svelte-prop {String} message
     * */
    	/** Where the notification will show on the screen when used programmatically
     * @svelte-prop {String} [position=is-top-right]
     * @values <code>is-top</code>, <code>is-bottom</code>, <code>is-top-left</code>, <code>is-top-right</code>, <code>is-bottom-left</code>, <code>is-bottom-right</code>
     * */
    	const dispatch = createEventDispatcher();

    	let newIcon = '';
    	let timer;

    	function close() {
    		$$invalidate(0, active = false);
    		if (timer) clearTimeout(timer);
    		dispatch('close', active);
    	}

    	const writable_props = [
    		'type',
    		'active',
    		'showClose',
    		'autoClose',
    		'duration',
    		'icon',
    		'iconPack',
    		'ariaCloseLabel'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notification> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('showClose' in $$props) $$invalidate(2, showClose = $$props.showClose);
    		if ('autoClose' in $$props) $$invalidate(8, autoClose = $$props.autoClose);
    		if ('duration' in $$props) $$invalidate(9, duration = $$props.duration);
    		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
    		if ('iconPack' in $$props) $$invalidate(4, iconPack = $$props.iconPack);
    		if ('ariaCloseLabel' in $$props) $$invalidate(5, ariaCloseLabel = $$props.ariaCloseLabel);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		fly,
    		fade,
    		Icon: Icon$1,
    		Notice,
    		filterProps,
    		typeToIcon,
    		type,
    		active,
    		showClose,
    		autoClose,
    		duration,
    		icon,
    		iconPack,
    		ariaCloseLabel,
    		dispatch,
    		newIcon,
    		timer,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('showClose' in $$props) $$invalidate(2, showClose = $$props.showClose);
    		if ('autoClose' in $$props) $$invalidate(8, autoClose = $$props.autoClose);
    		if ('duration' in $$props) $$invalidate(9, duration = $$props.duration);
    		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
    		if ('iconPack' in $$props) $$invalidate(4, iconPack = $$props.iconPack);
    		if ('ariaCloseLabel' in $$props) $$invalidate(5, ariaCloseLabel = $$props.ariaCloseLabel);
    		if ('newIcon' in $$props) $$invalidate(6, newIcon = $$props.newIcon);
    		if ('timer' in $$props) timer = $$props.timer;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*icon, type*/ 10) {
    			{
    				if (icon === true) {
    					$$invalidate(6, newIcon = typeToIcon(type));
    				} else {
    					$$invalidate(6, newIcon = icon);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*active, autoClose, duration*/ 769) {
    			{
    				if (active && autoClose) {
    					timer = setTimeout(
    						() => {
    							if (active) close();
    						},
    						duration
    					);
    				}
    			}
    		}
    	};

    	return [
    		active,
    		type,
    		showClose,
    		icon,
    		iconPack,
    		ariaCloseLabel,
    		newIcon,
    		close,
    		autoClose,
    		duration,
    		$$scope,
    		slots
    	];
    }

    class Notification extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1A, create_fragment$1A, safe_not_equal, {
    			type: 1,
    			active: 0,
    			showClose: 2,
    			autoClose: 8,
    			duration: 9,
    			icon: 3,
    			iconPack: 4,
    			ariaCloseLabel: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notification",
    			options,
    			id: create_fragment$1A.name
    		});
    	}

    	get type() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClose() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClose(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoClose() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoClose(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconPack() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconPack(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaCloseLabel() {
    		throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaCloseLabel(value) {
    		throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelma\src\components\Notification\NotificationNotice.svelte generated by Svelte v3.42.1 */

    // (34:2) <Notification {...notificationProps}>
    function create_default_slot_1$h(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*message*/ ctx[0], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 1) html_tag.p(/*message*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(34:2) <Notification {...notificationProps}>",
    		ctx
    	});

    	return block;
    }

    // (33:0) <Notice {...props} transitionOut={true}>
    function create_default_slot$x(ctx) {
    	let notification;
    	let current;
    	const notification_spread_levels = [/*notificationProps*/ ctx[1]];

    	let notification_props = {
    		$$slots: { default: [create_default_slot_1$h] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notification_spread_levels.length; i += 1) {
    		notification_props = assign(notification_props, notification_spread_levels[i]);
    	}

    	notification = new Notification({
    			props: notification_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(notification.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notification, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notification_changes = (dirty & /*notificationProps*/ 2)
    			? get_spread_update(notification_spread_levels, [get_spread_object(/*notificationProps*/ ctx[1])])
    			: {};

    			if (dirty & /*$$scope, message*/ 129) {
    				notification_changes.$$scope = { dirty, ctx };
    			}

    			notification.$set(notification_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notification.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notification.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notification, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(33:0) <Notice {...props} transitionOut={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let notice;
    	let current;
    	const notice_spread_levels = [/*props*/ ctx[2], { transitionOut: true }];

    	let notice_props = {
    		$$slots: { default: [create_default_slot$x] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notice_spread_levels.length; i += 1) {
    		notice_props = assign(notice_props, notice_spread_levels[i]);
    	}

    	notice = new Notice({ props: notice_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(notice.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(notice, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const notice_changes = (dirty & /*props*/ 4)
    			? get_spread_update(notice_spread_levels, [get_spread_object(/*props*/ ctx[2]), notice_spread_levels[1]])
    			: {};

    			if (dirty & /*$$scope, notificationProps, message*/ 131) {
    				notice_changes.$$scope = { dirty, ctx };
    			}

    			notice.$set(notice_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let props;
    	let notificationProps;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NotificationNotice', slots, []);
    	let { message } = $$props;
    	let { duration = 2000 } = $$props;
    	let { position = 'is-top-right' } = $$props;

    	function removeNonNoficationProps(props) {
    		const newProps = {};
    		const blacklist = ['duration', 'message', 'position'];

    		Object.keys(props).forEach(key => {
    			if (!blacklist.includes(key)) newProps[key] = props[key];
    		});

    		return newProps;
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('message' in $$new_props) $$invalidate(0, message = $$new_props.message);
    		if ('duration' in $$new_props) $$invalidate(3, duration = $$new_props.duration);
    		if ('position' in $$new_props) $$invalidate(4, position = $$new_props.position);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		fly,
    		fade,
    		Notice,
    		filterProps,
    		Notification,
    		message,
    		duration,
    		position,
    		removeNonNoficationProps,
    		notificationProps,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('message' in $$props) $$invalidate(0, message = $$new_props.message);
    		if ('duration' in $$props) $$invalidate(3, duration = $$new_props.duration);
    		if ('position' in $$props) $$invalidate(4, position = $$new_props.position);
    		if ('notificationProps' in $$props) $$invalidate(1, notificationProps = $$new_props.notificationProps);
    		if ('props' in $$props) $$invalidate(2, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(2, props = {
    			...filterProps($$props),
    			duration,
    			position
    		});

    		$$invalidate(1, notificationProps = { ...removeNonNoficationProps($$props) });
    	};

    	$$props = exclude_internal_props($$props);
    	return [message, notificationProps, props, duration, position];
    }

    class NotificationNotice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1z, create_fragment$1z, safe_not_equal, { message: 0, duration: 3, position: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotificationNotice",
    			options,
    			id: create_fragment$1z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[0] === undefined && !('message' in props)) {
    			console.warn("<NotificationNotice> was created without expected prop 'message'");
    		}
    	}

    	get message() {
    		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<NotificationNotice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<NotificationNotice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    Notification.create = create$2;

    function create$2(props) {
      if (typeof props === 'string') props = { message: props };

      const notification = new NotificationNotice({
        target: document.body,
        props,
        intro: true,
      });

      notification.$on('destroyed', notification.$destroy);

      return notification
    }

    /* node_modules\svelma\src\components\Snackbar\Snackbar.svelte generated by Svelte v3.42.1 */

    const { Error: Error_1$2 } = globals;
    const file$1p = "node_modules\\svelma\\src\\components\\Snackbar\\Snackbar.svelte";

    // (96:4) {#if actionText}
    function create_if_block$E(ctx) {
    	let div;
    	let button;
    	let t;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t = text(/*actionText*/ ctx[2]);
    			attr_dev(button, "class", button_class_value = "button " + /*newType*/ ctx[5] + " svelte-b4y6vb");
    			add_location(button, file$1p, 97, 8, 2637);
    			attr_dev(div, "class", "action svelte-b4y6vb");
    			add_location(div, file$1p, 96, 6, 2590);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*action*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*actionText*/ 4) set_data_dev(t, /*actionText*/ ctx[2]);

    			if (dirty & /*newType*/ 32 && button_class_value !== (button_class_value = "button " + /*newType*/ ctx[5] + " svelte-b4y6vb")) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(96:4) {#if actionText}",
    		ctx
    	});

    	return block;
    }

    // (90:0) <Notice {...props} bind:this={notice} transitionOut={true}>
    function create_default_slot$w(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let div1_class_value;
    	let if_block = /*actionText*/ ctx[2] && create_if_block$E(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "text svelte-b4y6vb");
    			add_location(div0, file$1p, 91, 4, 2431);
    			attr_dev(div1, "class", div1_class_value = "snackbar " + /*background*/ ctx[1] + " svelte-b4y6vb");
    			attr_dev(div1, "role", "alert");
    			toggle_class(div1, "has-background-dark", !/*background*/ ctx[1]);
    			add_location(div1, file$1p, 90, 2, 2338);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = /*message*/ ctx[0];
    			append_dev(div1, t);
    			if (if_block) if_block.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
    			if (/*actionText*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$E(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*background*/ 2 && div1_class_value !== (div1_class_value = "snackbar " + /*background*/ ctx[1] + " svelte-b4y6vb")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (dirty & /*background, background*/ 2) {
    				toggle_class(div1, "has-background-dark", !/*background*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(90:0) <Notice {...props} bind:this={notice} transitionOut={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let notice_1;
    	let current;
    	const notice_1_spread_levels = [/*props*/ ctx[4], { transitionOut: true }];

    	let notice_1_props = {
    		$$slots: { default: [create_default_slot$w] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notice_1_spread_levels.length; i += 1) {
    		notice_1_props = assign(notice_1_props, notice_1_spread_levels[i]);
    	}

    	notice_1 = new Notice({ props: notice_1_props, $$inline: true });
    	/*notice_1_binding*/ ctx[11](notice_1);

    	const block = {
    		c: function create() {
    			create_component(notice_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(notice_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const notice_1_changes = (dirty & /*props*/ 16)
    			? get_spread_update(notice_1_spread_levels, [get_spread_object(/*props*/ ctx[4]), notice_1_spread_levels[1]])
    			: {};

    			if (dirty & /*$$scope, background, newType, actionText, message*/ 8231) {
    				notice_1_changes.$$scope = { dirty, ctx };
    			}

    			notice_1.$set(notice_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notice_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notice_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*notice_1_binding*/ ctx[11](null);
    			destroy_component(notice_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let newType;
    	let props;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Snackbar', slots, []);
    	let { message } = $$props;
    	let { duration = 3500 } = $$props;
    	let { position = 'is-bottom-right' } = $$props;
    	let { type = 'is-primary' } = $$props;
    	let { background = '' } = $$props;
    	let { actionText = 'OK' } = $$props;

    	let { onAction = () => {
    		
    	} } = $$props;

    	let notice;

    	function action() {
    		Promise.resolve(onAction()).then(() => notice.close());
    	}

    	onMount(() => {
    		if (typeof onAction !== 'function') throw new Error(`onAction ${onAction} is not a function`);
    	});

    	function notice_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			notice = $$value;
    			$$invalidate(3, notice);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('message' in $$new_props) $$invalidate(0, message = $$new_props.message);
    		if ('duration' in $$new_props) $$invalidate(7, duration = $$new_props.duration);
    		if ('position' in $$new_props) $$invalidate(8, position = $$new_props.position);
    		if ('type' in $$new_props) $$invalidate(9, type = $$new_props.type);
    		if ('background' in $$new_props) $$invalidate(1, background = $$new_props.background);
    		if ('actionText' in $$new_props) $$invalidate(2, actionText = $$new_props.actionText);
    		if ('onAction' in $$new_props) $$invalidate(10, onAction = $$new_props.onAction);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		fly,
    		fade,
    		Notice,
    		filterProps,
    		message,
    		duration,
    		position,
    		type,
    		background,
    		actionText,
    		onAction,
    		notice,
    		action,
    		props,
    		newType
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    		if ('message' in $$props) $$invalidate(0, message = $$new_props.message);
    		if ('duration' in $$props) $$invalidate(7, duration = $$new_props.duration);
    		if ('position' in $$props) $$invalidate(8, position = $$new_props.position);
    		if ('type' in $$props) $$invalidate(9, type = $$new_props.type);
    		if ('background' in $$props) $$invalidate(1, background = $$new_props.background);
    		if ('actionText' in $$props) $$invalidate(2, actionText = $$new_props.actionText);
    		if ('onAction' in $$props) $$invalidate(10, onAction = $$new_props.onAction);
    		if ('notice' in $$props) $$invalidate(3, notice = $$new_props.notice);
    		if ('props' in $$props) $$invalidate(4, props = $$new_props.props);
    		if ('newType' in $$props) $$invalidate(5, newType = $$new_props.newType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type*/ 512) {
    			// $: newBackground = background
    			$$invalidate(5, newType = type && type.replace(/^is-(.*)/, 'has-text-$1'));
    		}

    		$$invalidate(4, props = {
    			...filterProps($$props),
    			position,
    			duration
    		});
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		message,
    		background,
    		actionText,
    		notice,
    		props,
    		newType,
    		action,
    		duration,
    		position,
    		type,
    		onAction,
    		notice_1_binding
    	];
    }

    class Snackbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1y, create_fragment$1y, safe_not_equal, {
    			message: 0,
    			duration: 7,
    			position: 8,
    			type: 9,
    			background: 1,
    			actionText: 2,
    			onAction: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Snackbar",
    			options,
    			id: create_fragment$1y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[0] === undefined && !('message' in props)) {
    			console.warn("<Snackbar> was created without expected prop 'message'");
    		}
    	}

    	get message() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get actionText() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actionText(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onAction() {
    		throw new Error_1$2("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onAction(value) {
    		throw new Error_1$2("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    Snackbar.create = create$1;

    function create$1(props) {
      if (typeof props === 'string') props = { message: props };

      const snackbar = new Snackbar({
        target: document.body,
        props,
        intro: true,
      });

      snackbar.$on('destroyed', snackbar.$destroy);

      return snackbar;
    }

    /* node_modules\svelma\src\components\Toast\Toast.svelte generated by Svelte v3.42.1 */
    const file$1o = "node_modules\\svelma\\src\\components\\Toast\\Toast.svelte";

    // (49:0) <Notice {...filterProps($$props)}>
    function create_default_slot$v(ctx) {
    	let div1;
    	let div0;
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "text");
    			add_location(div0, file$1o, 50, 4, 1497);
    			attr_dev(div1, "class", div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-z18xt5");
    			attr_dev(div1, "role", "alert");
    			add_location(div1, file$1o, 49, 2, 1437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = /*message*/ ctx[0];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
    			if (dirty & /*type, newBackground*/ 6 && div1_class_value !== (div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-z18xt5")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(49:0) <Notice {...filterProps($$props)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1x(ctx) {
    	let notice;
    	let current;
    	const notice_spread_levels = [filterProps(/*$$props*/ ctx[3])];

    	let notice_props = {
    		$$slots: { default: [create_default_slot$v] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notice_spread_levels.length; i += 1) {
    		notice_props = assign(notice_props, notice_spread_levels[i]);
    	}

    	notice = new Notice({ props: notice_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(notice.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(notice, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const notice_changes = (dirty & /*filterProps, $$props*/ 8)
    			? get_spread_update(notice_spread_levels, [get_spread_object(filterProps(/*$$props*/ ctx[3]))])
    			: {};

    			if (dirty & /*$$scope, type, newBackground, message*/ 39) {
    				notice_changes.$$scope = { dirty, ctx };
    			}

    			notice.$set(notice_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let newBackground;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toast', slots, []);
    	let { message } = $$props;
    	let { type = 'is-dark' } = $$props;
    	let { background = '' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('message' in $$new_props) $$invalidate(0, message = $$new_props.message);
    		if ('type' in $$new_props) $$invalidate(1, type = $$new_props.type);
    		if ('background' in $$new_props) $$invalidate(4, background = $$new_props.background);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		fly,
    		fade,
    		Notice,
    		filterProps,
    		message,
    		type,
    		background,
    		newBackground
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ('message' in $$props) $$invalidate(0, message = $$new_props.message);
    		if ('type' in $$props) $$invalidate(1, type = $$new_props.type);
    		if ('background' in $$props) $$invalidate(4, background = $$new_props.background);
    		if ('newBackground' in $$props) $$invalidate(2, newBackground = $$new_props.newBackground);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*background, type*/ 18) {
    			$$invalidate(2, newBackground = background || type.replace(/^is-(.*)/, 'has-background-$1'));
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [message, type, newBackground, $$props, background];
    }

    class Toast extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1x, create_fragment$1x, safe_not_equal, { message: 0, type: 1, background: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toast",
    			options,
    			id: create_fragment$1x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[0] === undefined && !('message' in props)) {
    			console.warn("<Toast> was created without expected prop 'message'");
    		}
    	}

    	get message() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    Toast.create = create;

    function create(props) {
      if (typeof props === 'string') props = { message: props };

      const toast = new Toast({
        target: document.body,
        props,
        intro: true,
      });

      toast.$on('destroyed', toast.$destroy);

      return toast;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var bulmaExtensions_min = {exports: {}};

    (function (module, exports) {
    !function(e,t){module.exports=t();}("undefined"!=typeof self?self:commonjsGlobal,function(){return function(n){var o={};function r(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,r),t.l=!0,t.exports}return r.m=n,r.c=o,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n});},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=196)}([function(e,t,n){var h=n(115),m=36e5,p=6e4,v=/[T ]/,g=/:/,_=/^(\d{2})$/,y=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],b=/^(\d{4})/,x=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],M=/^-(\d{2})$/,k=/^-?(\d{3})$/,w=/^-?(\d{2})-?(\d{2})$/,D=/^-?W(\d{2})$/,S=/^-?W(\d{2})-?(\d{1})$/,j=/^(\d{2}([.,]\d*)?)$/,E=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,A=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,T=/([Z+-].*)$/,O=/^(Z)$/,Y=/^([+-])(\d{2})$/,H=/^([+-])(\d{2}):?(\d{2})$/;function X(e,t,n){t=t||0,n=n||0;var o=new Date(0);o.setUTCFullYear(e,0,4);var r=7*t+n+1-(o.getUTCDay()||7);return o.setUTCDate(o.getUTCDate()+r),o}e.exports=function(e,t){if(h(e))return new Date(e.getTime());if("string"!=typeof e)return new Date(e);var n=(t||{}).additionalDigits;n=null==n?2:Number(n);var o=function(e){var t,n={},o=e.split(v);if(g.test(o[0])?(n.date=null,t=o[0]):(n.date=o[0],t=o[1]),t){var r=T.exec(t);r?(n.time=t.replace(r[1],""),n.timezone=r[1]):n.time=t;}return n}(e),r=function(e,t){var n,o=y[t],r=x[t];if(n=b.exec(e)||r.exec(e)){var i=n[1];return {year:parseInt(i,10),restDateString:e.slice(i.length)}}if(n=_.exec(e)||o.exec(e)){var a=n[1];return {year:100*parseInt(a,10),restDateString:e.slice(a.length)}}return {year:null}}(o.date,n),i=r.year,a=function(e,t){if(null===t)return null;var n,o,r,i;if(0===e.length)return (o=new Date(0)).setUTCFullYear(t),o;if(n=M.exec(e))return o=new Date(0),r=parseInt(n[1],10)-1,o.setUTCFullYear(t,r),o;if(n=k.exec(e)){o=new Date(0);var a=parseInt(n[1],10);return o.setUTCFullYear(t,0,a),o}if(n=w.exec(e)){o=new Date(0),r=parseInt(n[1],10)-1;var s=parseInt(n[2],10);return o.setUTCFullYear(t,r,s),o}if(n=D.exec(e))return i=parseInt(n[1],10)-1,X(t,i);if(n=S.exec(e)){i=parseInt(n[1],10)-1;var u=parseInt(n[2],10)-1;return X(t,i,u)}return null}(r.restDateString,i);if(a){var s,u=a.getTime(),c=0;return o.time&&(c=function(e){var t,n,o;if(t=j.exec(e))return (n=parseFloat(t[1].replace(",",".")))%24*m;if(t=E.exec(e))return n=parseInt(t[1],10),o=parseFloat(t[2].replace(",",".")),n%24*m+o*p;if(t=A.exec(e)){n=parseInt(t[1],10),o=parseInt(t[2],10);var r=parseFloat(t[3].replace(",","."));return n%24*m+o*p+1e3*r}return null}(o.time)),o.timezone?(l=o.timezone,s=(d=O.exec(l))?0:(d=Y.exec(l))?(f=60*parseInt(d[2],10),"+"===d[1]?-f:f):(d=H.exec(l))?(f=60*parseInt(d[2],10)+parseInt(d[3],10),"+"===d[1]?-f:f):0):(s=new Date(u+c).getTimezoneOffset(),s=new Date(u+c+s*p).getTimezoneOffset()),new Date(u+c+s*p)}var l,d,f;return new Date(e)};},function(e,t){var r=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];e.exports=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);var o=r.concat(t).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+o.join("|")+"|.)","g")};},function(e,t,n){var s=n(0),u=n(3);e.exports=function(e){var t=s(e),n=t.getFullYear(),o=new Date(0);o.setFullYear(n+1,0,4),o.setHours(0,0,0,0);var r=u(o),i=new Date(0);i.setFullYear(n,0,4),i.setHours(0,0,0,0);var a=u(i);return t.getTime()>=r.getTime()?n+1:t.getTime()>=a.getTime()?n:n-1};},function(e,t,n){var o=n(78);e.exports=function(e){return o(e,{weekStartsOn:1})};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setHours(0,0,0,0),t};},function(e,t,n){var o=n(10),r=n(11);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setDate(n.getDate()+o),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e).getTime(),o=Number(t);return new Date(n+o)};},function(e,t,n){var o=n(2),r=n(3);e.exports=function(e){var t=o(e),n=new Date(0);return n.setFullYear(t,0,4),n.setHours(0,0,0,0),r(n)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e).getTime(),o=r(t).getTime();return n<o?-1:o<n?1:0};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"in "+o:o+" ago":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],n=["January","February","March","April","May","June","July","August","September","October","November","December"],o=["Su","Mo","Tu","We","Th","Fr","Sa"],r=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],i=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){var t=e%100;if(20<t||t<10)switch(t%10){case 1:return e+"st";case 2:return e+"nd";case 3:return e+"rd"}return e+"th"}(t[n](e))};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"أقل من ثانية واحدة",other:"أقل من {{count}} ثواني"},xSeconds:{one:"ثانية واحدة",other:"{{count}} ثواني"},halfAMinute:"نصف دقيقة",lessThanXMinutes:{one:"أقل من دقيقة",other:"أقل من {{count}} دقيقة"},xMinutes:{one:"دقيقة واحدة",other:"{{count}} دقائق"},aboutXHours:{one:"ساعة واحدة تقريباً",other:"{{count}} ساعات تقريباً"},xHours:{one:"ساعة واحدة",other:"{{count}} ساعات"},xDays:{one:"يوم واحد",other:"{{count}} أيام"},aboutXMonths:{one:"شهر واحد تقريباً",other:"{{count}} أشهر تقريباً"},xMonths:{one:"شهر واحد",other:"{{count}} أشهر"},aboutXYears:{one:"عام واحد تقريباً",other:"{{count}} أعوام تقريباً"},xYears:{one:"عام واحد",other:"{{count}} أعوام"},overXYears:{one:"أكثر من عام",other:"أكثر من {{count}} أعوام"},almostXYears:{one:"عام واحد تقريباً",other:"{{count}} أعوام تقريباً"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"في خلال "+o:"منذ "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"],n=["كانون الثاني يناير","شباط فبراير","آذار مارس","نيسان أبريل","أيار مايو","حزيران يونيو","تموز يوليو","آب أغسطس","أيلول سبتمبر","تشرين الأول أكتوبر","تشرين الثاني نوفمبر","كانون الأول ديسمبر"],o=["ح","ن","ث","ر","خ","ج","س"],r=["أحد","إثنين","ثلاثاء","أربعاء","خميس","جمعة","سبت"],i=["الأحد","الإثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],a=["صباح","مساء"],s=["ص","م"],u=["صباحاً","مساءاً"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(o){e[o+"o"]=function(e,t){return n=t[o](e),String(n);var n;};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"по-малко от секунда",other:"по-малко от {{count}} секунди"},xSeconds:{one:"1 секунда",other:"{{count}} секунди"},halfAMinute:"половин минута",lessThanXMinutes:{one:"по-малко от минута",other:"по-малко от {{count}} минути"},xMinutes:{one:"1 минута",other:"{{count}} минути"},aboutXHours:{one:"около час",other:"около {{count}} часа"},xHours:{one:"1 час",other:"{{count}} часа"},xDays:{one:"1 ден",other:"{{count}} дни"},aboutXMonths:{one:"около месец",other:"около {{count}} месеца"},xMonths:{one:"1 месец",other:"{{count}} месеца"},aboutXYears:{one:"около година",other:"около {{count}} години"},xYears:{one:"1 година",other:"{{count}} години"},overXYears:{one:"над година",other:"над {{count}} години"},almostXYears:{one:"почти година",other:"почти {{count}} години"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"след "+o:"преди "+o:o}}};},function(e,t,n){var u=n(1);e.exports=function(){var t=["яну","фев","мар","апр","май","юни","юли","авг","сеп","окт","ное","дек"],n=["януари","февруари","март","април","май","юни","юли","август","септември","октомври","ноември","декември"],o=["нд","пн","вт","ср","чт","пт","сб"],r=["нед","пон","вто","сря","чет","пет","съб"],i=["неделя","понеделник","вторник","сряда","четвъртък","петък","събота"],a=["сутринта","на обяд","следобед","вечерта"],e=function(e){var t=e.getHours();return 4<=t&&t<12?a[0]:12<=t&&t<14?a[1]:14<=t&&t<17?a[2]:a[3]},s={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:e,a:e,aa:e};return ["M","D","DDD","d","Q","W"].forEach(function(n){s[n+"o"]=function(e,t){return function(e){var t=e%100;if(20<t||t<10)switch(t%10){case 1:return e+"-ви";case 2:return e+"-ри"}return e+"-и"}(t[n](e))};}),{formatters:s,formattingTokensRegExp:u(s)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"menys d'un segon",other:"menys de {{count}} segons"},xSeconds:{one:"1 segon",other:"{{count}} segons"},halfAMinute:"mig minut",lessThanXMinutes:{one:"menys d'un minut",other:"menys de {{count}} minuts"},xMinutes:{one:"1 minut",other:"{{count}} minuts"},aboutXHours:{one:"aproximadament una hora",other:"aproximadament {{count}} hores"},xHours:{one:"1 hora",other:"{{count}} hores"},xDays:{one:"1 dia",other:"{{count}} dies"},aboutXMonths:{one:"aproximadament un mes",other:"aproximadament {{count}} mesos"},xMonths:{one:"1 mes",other:"{{count}} mesos"},aboutXYears:{one:"aproximadament un any",other:"aproximadament {{count}} anys"},xYears:{one:"1 any",other:"{{count}} anys"},overXYears:{one:"més d'un any",other:"més de {{count}} anys"},almostXYears:{one:"gairebé un any",other:"gairebé {{count}} anys"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"en "+o:"fa "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["gen","feb","mar","abr","mai","jun","jul","ago","set","oct","nov","des"],n=["gener","febrer","març","abril","maig","juny","juliol","agost","setembre","octobre","novembre","desembre"],o=["dg","dl","dt","dc","dj","dv","ds"],r=["dge","dls","dts","dcs","djs","dvs","dss"],i=["diumenge","dilluns","dimarts","dimecres","dijous","divendres","dissabte"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){switch(e){case 1:return "1r";case 2:return "2n";case 3:return "3r";case 4:return "4t";default:return e+"è"}}(t[n](e))};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){function c(e,t,n){var o,r,i=(o=e,1===(r=t)?o.one:2<=r&&r<=4?o.twoFour:o.other);return (i[n]||i).replace("{{count}}",t)}function l(e){var t="";return "almost"===e&&(t="skoro"),"about"===e&&(t="přibližně"),0<t.length?t+" ":""}function d(e){var t="";return "lessThan"===e&&(t="méně než"),"over"===e&&(t="více než"),0<t.length?t+" ":""}e.exports=function(){var u={xSeconds:{one:{regular:"vteřina",past:"vteřinou",future:"vteřinu"},twoFour:{regular:"{{count}} vteřiny",past:"{{count}} vteřinami",future:"{{count}} vteřiny"},other:{regular:"{{count}} vteřin",past:"{{count}} vteřinami",future:"{{count}} vteřin"}},halfAMinute:{other:{regular:"půl minuty",past:"půl minutou",future:"půl minuty"}},xMinutes:{one:{regular:"minuta",past:"minutou",future:"minutu"},twoFour:{regular:"{{count}} minuty",past:"{{count}} minutami",future:"{{count}} minuty"},other:{regular:"{{count}} minut",past:"{{count}} minutami",future:"{{count}} minut"}},xHours:{one:{regular:"hodina",past:"hodinou",future:"hodinu"},twoFour:{regular:"{{count}} hodiny",past:"{{count}} hodinami",future:"{{count}} hodiny"},other:{regular:"{{count}} hodin",past:"{{count}} hodinami",future:"{{count}} hodin"}},xDays:{one:{regular:"den",past:"dnem",future:"den"},twoFour:{regular:"{{count}} dni",past:"{{count}} dny",future:"{{count}} dni"},other:{regular:"{{count}} dní",past:"{{count}} dny",future:"{{count}} dní"}},xMonths:{one:{regular:"měsíc",past:"měsícem",future:"měsíc"},twoFour:{regular:"{{count}} měsíce",past:"{{count}} měsíci",future:"{{count}} měsíce"},other:{regular:"{{count}} měsíců",past:"{{count}} měsíci",future:"{{count}} měsíců"}},xYears:{one:{regular:"rok",past:"rokem",future:"rok"},twoFour:{regular:"{{count}} roky",past:"{{count}} roky",future:"{{count}} roky"},other:{regular:"{{count}} roků",past:"{{count}} roky",future:"{{count}} roků"}}};return {localize:function(e,t,n){n=n||{};var o,r,i=(o=e,["lessThan","about","over","almost"].filter(function(e){return !!o.match(new RegExp("^"+e))})[0]||""),a=(r=e.substring(i.length)).charAt(0).toLowerCase()+r.slice(1),s=u[a];return n.addSuffix?0<n.comparison?l(i)+"za "+d(i)+c(s,t,"future"):l(i)+"před "+d(i)+c(s,t,"past"):l(i)+d(i)+c(s,t,"regular")}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["led","úno","bře","dub","kvě","čvn","čvc","srp","zář","říj","lis","pro"],n=["leden","únor","březen","duben","květen","červen","červenec","srpen","září","říjen","listopad","prosinec"],o=["ne","po","út","st","čt","pá","so"],r=["ned","pon","úte","stř","čtv","pát","sob"],i=["neděle","pondělí","úterý","středa","čtvrtek","pátek","sobota"],a=["DOP.","ODP."],s=["dop.","odp."],u=["dopoledne","odpoledne"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"mindre end et sekund",other:"mindre end {{count}} sekunder"},xSeconds:{one:"1 sekund",other:"{{count}} sekunder"},halfAMinute:"et halvt minut",lessThanXMinutes:{one:"mindre end et minut",other:"mindre end {{count}} minutter"},xMinutes:{one:"1 minut",other:"{{count}} minutter"},aboutXHours:{one:"cirka 1 time",other:"cirka {{count}} timer"},xHours:{one:"1 time",other:"{{count}} timer"},xDays:{one:"1 dag",other:"{{count}} dage"},aboutXMonths:{one:"cirka 1 måned",other:"cirka {{count}} måneder"},xMonths:{one:"1 måned",other:"{{count}} måneder"},aboutXYears:{one:"cirka 1 år",other:"cirka {{count}} år"},xYears:{one:"1 år",other:"{{count}} år"},overXYears:{one:"over 1 år",other:"over {{count}} år"},almostXYears:{one:"næsten 1 år",other:"næsten {{count}} år"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"om "+o:o+" siden":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","maj","jun","jul","aug","sep","okt","nov","dec"],n=["januar","februar","marts","april","maj","juni","juli","august","september","oktober","november","december"],o=["sø","ma","ti","on","to","fr","lø"],r=["søn","man","tir","ons","tor","fre","lør"],i=["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var i={lessThanXSeconds:{standalone:{one:"weniger als eine Sekunde",other:"weniger als {{count}} Sekunden"},withPreposition:{one:"weniger als einer Sekunde",other:"weniger als {{count}} Sekunden"}},xSeconds:{standalone:{one:"eine Sekunde",other:"{{count}} Sekunden"},withPreposition:{one:"einer Sekunde",other:"{{count}} Sekunden"}},halfAMinute:{standalone:"eine halbe Minute",withPreposition:"einer halben Minute"},lessThanXMinutes:{standalone:{one:"weniger als eine Minute",other:"weniger als {{count}} Minuten"},withPreposition:{one:"weniger als einer Minute",other:"weniger als {{count}} Minuten"}},xMinutes:{standalone:{one:"eine Minute",other:"{{count}} Minuten"},withPreposition:{one:"einer Minute",other:"{{count}} Minuten"}},aboutXHours:{standalone:{one:"etwa eine Stunde",other:"etwa {{count}} Stunden"},withPreposition:{one:"etwa einer Stunde",other:"etwa {{count}} Stunden"}},xHours:{standalone:{one:"eine Stunde",other:"{{count}} Stunden"},withPreposition:{one:"einer Stunde",other:"{{count}} Stunden"}},xDays:{standalone:{one:"ein Tag",other:"{{count}} Tage"},withPreposition:{one:"einem Tag",other:"{{count}} Tagen"}},aboutXMonths:{standalone:{one:"etwa ein Monat",other:"etwa {{count}} Monate"},withPreposition:{one:"etwa einem Monat",other:"etwa {{count}} Monaten"}},xMonths:{standalone:{one:"ein Monat",other:"{{count}} Monate"},withPreposition:{one:"einem Monat",other:"{{count}} Monaten"}},aboutXYears:{standalone:{one:"etwa ein Jahr",other:"etwa {{count}} Jahre"},withPreposition:{one:"etwa einem Jahr",other:"etwa {{count}} Jahren"}},xYears:{standalone:{one:"ein Jahr",other:"{{count}} Jahre"},withPreposition:{one:"einem Jahr",other:"{{count}} Jahren"}},overXYears:{standalone:{one:"mehr als ein Jahr",other:"mehr als {{count}} Jahre"},withPreposition:{one:"mehr als einem Jahr",other:"mehr als {{count}} Jahren"}},almostXYears:{standalone:{one:"fast ein Jahr",other:"fast {{count}} Jahre"},withPreposition:{one:"fast einem Jahr",other:"fast {{count}} Jahren"}}};return {localize:function(e,t,n){var o,r=(n=n||{}).addSuffix?i[e].withPreposition:i[e].standalone;return o="string"==typeof r?r:1===t?r.one:r.other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"in "+o:"vor "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],n=["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],o=["So","Mo","Di","Mi","Do","Fr","Sa"],r=["Son","Mon","Die","Mit","Don","Fre","Sam"],i=["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"λιγότερο από ένα δευτερόλεπτο",other:"λιγότερο από {{count}} δευτερόλεπτα"},xSeconds:{one:"1 δευτερόλεπτο",other:"{{count}} δευτερόλεπτα"},halfAMinute:"μισό λεπτό",lessThanXMinutes:{one:"λιγότερο από ένα λεπτό",other:"λιγότερο από {{count}} λεπτά"},xMinutes:{one:"1 λεπτό",other:"{{count}} λεπτά"},aboutXHours:{one:"περίπου 1 ώρα",other:"περίπου {{count}} ώρες"},xHours:{one:"1 ώρα",other:"{{count}} ώρες"},xDays:{one:"1 ημέρα",other:"{{count}} ημέρες"},aboutXMonths:{one:"περίπου 1 μήνας",other:"περίπου {{count}} μήνες"},xMonths:{one:"1 μήνας",other:"{{count}} μήνες"},aboutXYears:{one:"περίπου 1 χρόνο",other:"περίπου {{count}} χρόνια"},xYears:{one:"1 χρόνο",other:"{{count}} χρόνια"},overXYears:{one:"πάνω από 1 χρόνο",other:"πάνω από {{count}} χρόνια"},almostXYears:{one:"περίπου 1 χρόνο",other:"περίπου {{count}} χρόνια"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"σε "+o:o+" πρίν":o}}};},function(e,t,n){var f=n(1);e.exports=function(){var t=["Ιαν","Φεβ","Μαρ","Απρ","Μαϊ","Ιουν","Ιουλ","Αυγ","Σεπ","Οκτ","Νοε","Δεκ"],n=["Ιανουάριος","Φεβρουάριος","Μάρτιος","Απρίλιος","Μάιος","Ιούνιος","Ιούλιος","Αύγουστος","Σεπτέμβριος","Οκτώβριος","Νοέμβριος","Δεκέμβριος"],o=["Ιανουαρίου","Φεβρουαρίου","Μαρτίου","Απριλίου","Μαΐου","Ιουνίου","Ιουλίου","Αυγούστου","Σεπτεμβρίου","Οκτωβρίου","Νοεμβρίου","Δεκεμβρίου"],r=["Κυ","Δε","Τρ","Τε","Πέ","Πα","Σά"],i=["Κυρ","Δευ","Τρί","Τετ","Πέμ","Παρ","Σάβ"],a=["Κυριακή","Δευτέρα","Τρίτη","Τετάρτη","Πέμπτη","Παρασκευή","Σάββατο"],s=["ΠΜ","ΜΜ"],u=["πμ","μμ"],c=["π.μ.","μ.μ."],l={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return r[e.getDay()]},ddd:function(e){return i[e.getDay()]},dddd:function(e){return a[e.getDay()]},A:function(e){return 1<=e.getHours()/12?s[1]:s[0]},a:function(e){return 1<=e.getHours()/12?u[1]:u[0]},aa:function(e){return 1<=e.getHours()/12?c[1]:c[0]}},d={M:"ος",D:"η",DDD:"η",d:"η",Q:"ο",W:"η"};return ["M","D","DDD","d","Q","W"].forEach(function(n){l[n+"o"]=function(e,t){return t[n](e)+d[n]};}),["D","Do","DD"].forEach(function(n){l[n+" MMMM"]=function(e,t){return (l[n]||t[n])(e,t)+" "+o[e.getMonth()]};}),{formatters:l,formattingTokensRegExp:f(l)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"malpli ol sekundo",other:"malpli ol {{count}} sekundoj"},xSeconds:{one:"1 sekundo",other:"{{count}} sekundoj"},halfAMinute:"duonminuto",lessThanXMinutes:{one:"malpli ol minuto",other:"malpli ol {{count}} minutoj"},xMinutes:{one:"1 minuto",other:"{{count}} minutoj"},aboutXHours:{one:"proksimume 1 horo",other:"proksimume {{count}} horoj"},xHours:{one:"1 horo",other:"{{count}} horoj"},xDays:{one:"1 tago",other:"{{count}} tagoj"},aboutXMonths:{one:"proksimume 1 monato",other:"proksimume {{count}} monatoj"},xMonths:{one:"1 monato",other:"{{count}} monatoj"},aboutXYears:{one:"proksimume 1 jaro",other:"proksimume {{count}} jaroj"},xYears:{one:"1 jaro",other:"{{count}} jaroj"},overXYears:{one:"pli ol 1 jaro",other:"pli ol {{count}} jaroj"},almostXYears:{one:"preskaŭ 1 jaro",other:"preskaŭ {{count}} jaroj"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"post "+o:"antaŭ "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","maj","jun","jul","aŭg","sep","okt","nov","dec"],n=["januaro","februaro","marto","aprilo","majo","junio","julio","aŭgusto","septembro","oktobro","novembro","decembro"],o=["di","lu","ma","me","ĵa","ve","sa"],r=["dim","lun","mar","mer","ĵaŭ","ven","sab"],i=["dimanĉo","lundo","mardo","merkredo","ĵaŭdo","vendredo","sabato"],a=["A.T.M.","P.T.M."],s=["a.t.m.","p.t.m."],u=["antaŭtagmeze","posttagmeze"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"-a"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"menos de un segundo",other:"menos de {{count}} segundos"},xSeconds:{one:"1 segundo",other:"{{count}} segundos"},halfAMinute:"medio minuto",lessThanXMinutes:{one:"menos de un minuto",other:"menos de {{count}} minutos"},xMinutes:{one:"1 minuto",other:"{{count}} minutos"},aboutXHours:{one:"alrededor de 1 hora",other:"alrededor de {{count}} horas"},xHours:{one:"1 hora",other:"{{count}} horas"},xDays:{one:"1 día",other:"{{count}} días"},aboutXMonths:{one:"alrededor de 1 mes",other:"alrededor de {{count}} meses"},xMonths:{one:"1 mes",other:"{{count}} meses"},aboutXYears:{one:"alrededor de 1 año",other:"alrededor de {{count}} años"},xYears:{one:"1 año",other:"{{count}} años"},overXYears:{one:"más de 1 año",other:"más de {{count}} años"},almostXYears:{one:"casi 1 año",other:"casi {{count}} años"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"en "+o:"hace "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["ene","feb","mar","abr","may","jun","jul","ago","sep","oct","nov","dic"],n=["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"],o=["do","lu","ma","mi","ju","vi","sa"],r=["dom","lun","mar","mié","jue","vie","sáb"],i=["domingo","lunes","martes","miércoles","jueves","viernes","sábado"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"º"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){function e(e){return e.replace(/sekuntia?/,"sekunnin")}function t(e){return e.replace(/minuuttia?/,"minuutin")}function n(e){return e.replace(/tuntia?/,"tunnin")}function o(e){return e.replace(/(kuukausi|kuukautta)/,"kuukauden")}function r(e){return e.replace(/(vuosi|vuotta)/,"vuoden")}var i={lessThanXSeconds:{one:"alle sekunti",other:"alle {{count}} sekuntia",futureTense:e},xSeconds:{one:"sekunti",other:"{{count}} sekuntia",futureTense:e},halfAMinute:{one:"puoli minuuttia",other:"puoli minuuttia",futureTense:function(e){return "puolen minuutin"}},lessThanXMinutes:{one:"alle minuutti",other:"alle {{count}} minuuttia",futureTense:t},xMinutes:{one:"minuutti",other:"{{count}} minuuttia",futureTense:t},aboutXHours:{one:"noin tunti",other:"noin {{count}} tuntia",futureTense:n},xHours:{one:"tunti",other:"{{count}} tuntia",futureTense:n},xDays:{one:"päivä",other:"{{count}} päivää",futureTense:function(e){return e.replace(/päivää?/,"päivän")}},aboutXMonths:{one:"noin kuukausi",other:"noin {{count}} kuukautta",futureTense:o},xMonths:{one:"kuukausi",other:"{{count}} kuukautta",futureTense:o},aboutXYears:{one:"noin vuosi",other:"noin {{count}} vuotta",futureTense:r},xYears:{one:"vuosi",other:"{{count}} vuotta",futureTense:r},overXYears:{one:"yli vuosi",other:"yli {{count}} vuotta",futureTense:r},almostXYears:{one:"lähes vuosi",other:"lähes {{count}} vuotta",futureTense:r}};return {localize:function(e,t,n){n=n||{};var o=i[e],r=1===t?o.one:o.other.replace("{{count}}",t);return n.addSuffix?0<n.comparison?o.futureTense(r)+" kuluttua":r+" sitten":r}}};},function(e,t,n){var a=n(1);e.exports=function(){var t=["tammi","helmi","maalis","huhti","touko","kesä","heinä","elo","syys","loka","marras","joulu"],n=["tammikuu","helmikuu","maaliskuu","huhtikuu","toukokuu","kesäkuu","heinäkuu","elokuu","syyskuu","lokakuu","marraskuu","joulukuu"],o=["su","ma","ti","ke","to","pe","la"],r=["sunnuntai","maanantai","tiistai","keskiviikko","torstai","perjantai","lauantai"];function e(e){return e.getHours()<12?"AP":"IP"}var i={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return o[e.getDay()]},dddd:function(e){return r[e.getDay()]},A:e,a:e,aa:e};return ["M","D","DDD","d","Q","W"].forEach(function(n){i[n+"o"]=function(e,t){return t[n](e).toString()+"."};}),{formatters:i,formattingTokensRegExp:a(i)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"mas maliit sa isang segundo",other:"mas maliit sa {{count}} segundo"},xSeconds:{one:"1 segundo",other:"{{count}} segundo"},halfAMinute:"kalahating minuto",lessThanXMinutes:{one:"mas maliit sa isang minuto",other:"mas maliit sa {{count}} minuto"},xMinutes:{one:"1 minuto",other:"{{count}} minuto"},aboutXHours:{one:"mga 1 oras",other:"mga {{count}} oras"},xHours:{one:"1 oras",other:"{{count}} oras"},xDays:{one:"1 araw",other:"{{count}} araw"},aboutXMonths:{one:"mga 1 buwan",other:"mga {{count}} buwan"},xMonths:{one:"1 buwan",other:"{{count}} buwan"},aboutXYears:{one:"mga 1 taon",other:"mga {{count}} taon"},xYears:{one:"1 taon",other:"{{count}} taon"},overXYears:{one:"higit sa 1 taon",other:"higit sa {{count}} taon"},almostXYears:{one:"halos 1 taon",other:"halos {{count}} taon"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"sa loob ng "+o:o+" ang nakalipas":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Ene","Peb","Mar","Abr","May","Hun","Hul","Ago","Set","Okt","Nob","Dis"],n=["Enero","Pebrero","Marso","Abril","Mayo","Hunyo","Hulyo","Agosto","Setyembre","Oktubre","Nobyembre","Disyembre"],o=["Li","Lu","Ma","Mi","Hu","Bi","Sa"],r=["Lin","Lun","Mar","Miy","Huw","Biy","Sab"],i=["Linggo","Lunes","Martes","Miyerkules","Huwebes","Biyernes","Sabado"],a=["NU","NT","NH","NG"],s=["nu","nt","nh","ng"],u=["ng umaga","ng tanghali","ng hapon","ng gabi"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 12<e.getHours()?e.getHours()%12<6?a[2]:a[3]:e.getHours()<12?a[0]:a[1]},a:function(e){return 12<e.getHours()?e.getHours()%12<6?s[2]:s[3]:e.getHours()<12?s[0]:s[1]},aa:function(e){return 12<e.getHours()?e.getHours()%12<6?u[2]:u[3]:e.getHours()<12?u[0]:u[1]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return "ika-"+t[n](e)};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"moins d’une seconde",other:"moins de {{count}} secondes"},xSeconds:{one:"1 seconde",other:"{{count}} secondes"},halfAMinute:"30 secondes",lessThanXMinutes:{one:"moins d’une minute",other:"moins de {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"environ 1 heure",other:"environ {{count}} heures"},xHours:{one:"1 heure",other:"{{count}} heures"},xDays:{one:"1 jour",other:"{{count}} jours"},aboutXMonths:{one:"environ 1 mois",other:"environ {{count}} mois"},xMonths:{one:"1 mois",other:"{{count}} mois"},aboutXYears:{one:"environ 1 an",other:"environ {{count}} ans"},xYears:{one:"1 an",other:"{{count}} ans"},overXYears:{one:"plus d’un an",other:"plus de {{count}} ans"},almostXYears:{one:"presqu’un an",other:"presque {{count}} ans"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"dans "+o:"il y a "+o:o}}};},function(e,t,n){var l=n(1);e.exports=function(){var t=["janv.","févr.","mars","avr.","mai","juin","juill.","août","sept.","oct.","nov.","déc."],n=["janvier","février","mars","avril","mai","juin","juillet","août","septembre","octobre","novembre","décembre"],o=["di","lu","ma","me","je","ve","sa"],r=["dim.","lun.","mar.","mer.","jeu.","ven.","sam."],i=["dimanche","lundi","mardi","mercredi","jeudi","vendredi","samedi"],a=["AM","PM"],s=["am","pm"],u=["du matin","de l’après-midi","du soir"],c={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){var t=e.getHours();return t<=12?u[0]:t<=16?u[1]:u[2]},Wo:function(e,t){return 1===(n=t.W(e))?"1re":n+"e";var n;}};return ["M","D","DDD","d","Q"].forEach(function(o){c[o+"o"]=function(e,t){return 1===(n=t[o](e))?"1er":n+"e";var n;};}),["MMM","MMMM"].forEach(function(o){c["Do "+o]=function(e,t){var n=1===e.getDate()?"Do":"D";return (c[n]||t[n])(e,t)+" "+c[o](e)};}),{formatters:c,formattingTokensRegExp:l(c)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:{standalone:"manje od 1 sekunde",withPrepositionAgo:"manje od 1 sekunde",withPrepositionIn:"manje od 1 sekundu"},dual:"manje od {{count}} sekunde",other:"manje od {{count}} sekundi"},xSeconds:{one:{standalone:"1 sekunda",withPrepositionAgo:"1 sekunde",withPrepositionIn:"1 sekundu"},dual:"{{count}} sekunde",other:"{{count}} sekundi"},halfAMinute:"pola minute",lessThanXMinutes:{one:{standalone:"manje od 1 minute",withPrepositionAgo:"manje od 1 minute",withPrepositionIn:"manje od 1 minutu"},dual:"manje od {{count}} minute",other:"manje od {{count}} minuta"},xMinutes:{one:{standalone:"1 minuta",withPrepositionAgo:"1 minute",withPrepositionIn:"1 minutu"},dual:"{{count}} minute",other:"{{count}} minuta"},aboutXHours:{one:{standalone:"oko 1 sat",withPrepositionAgo:"oko 1 sat",withPrepositionIn:"oko 1 sat"},dual:"oko {{count}} sata",other:"oko {{count}} sati"},xHours:{one:{standalone:"1 sat",withPrepositionAgo:"1 sat",withPrepositionIn:"1 sat"},dual:"{{count}} sata",other:"{{count}} sati"},xDays:{one:{standalone:"1 dan",withPrepositionAgo:"1 dan",withPrepositionIn:"1 dan"},dual:"{{count}} dana",other:"{{count}} dana"},aboutXMonths:{one:{standalone:"oko 1 mjesec",withPrepositionAgo:"oko 1 mjesec",withPrepositionIn:"oko 1 mjesec"},dual:"oko {{count}} mjeseca",other:"oko {{count}} mjeseci"},xMonths:{one:{standalone:"1 mjesec",withPrepositionAgo:"1 mjesec",withPrepositionIn:"1 mjesec"},dual:"{{count}} mjeseca",other:"{{count}} mjeseci"},aboutXYears:{one:{standalone:"oko 1 godinu",withPrepositionAgo:"oko 1 godinu",withPrepositionIn:"oko 1 godinu"},dual:"oko {{count}} godine",other:"oko {{count}} godina"},xYears:{one:{standalone:"1 godina",withPrepositionAgo:"1 godine",withPrepositionIn:"1 godinu"},dual:"{{count}} godine",other:"{{count}} godina"},overXYears:{one:{standalone:"preko 1 godinu",withPrepositionAgo:"preko 1 godinu",withPrepositionIn:"preko 1 godinu"},dual:"preko {{count}} godine",other:"preko {{count}} godina"},almostXYears:{one:{standalone:"gotovo 1 godinu",withPrepositionAgo:"gotovo 1 godinu",withPrepositionIn:"gotovo 1 godinu"},dual:"gotovo {{count}} godine",other:"gotovo {{count}} godina"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?n.addSuffix?0<n.comparison?r[e].one.withPrepositionIn:r[e].one.withPrepositionAgo:r[e].one.standalone:1<t%10&&t%10<5&&"1"!==String(t).substr(-2,1)?r[e].dual.replace("{{count}}",t):r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"za "+o:"prije "+o:o}}};},function(e,t,n){var d=n(1);e.exports=function(){var t=["sij","velj","ožu","tra","svi","lip","srp","kol","ruj","lis","stu","pro"],n=["siječanj","veljača","ožujak","travanj","svibanj","lipanj","srpanj","kolovoz","rujan","listopad","studeni","prosinac"],o=["siječnja","veljače","ožujka","travnja","svibnja","lipnja","srpnja","kolovoza","rujna","listopada","studenog","prosinca"],r=["ne","po","ut","sr","če","pe","su"],i=["ned","pon","uto","sri","čet","pet","sub"],a=["nedjelja","ponedjeljak","utorak","srijeda","četvrtak","petak","subota"],s=["ujutro","popodne"],u=["ujutro","popodne"],c=["ujutro","popodne"],l={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return r[e.getDay()]},ddd:function(e){return i[e.getDay()]},dddd:function(e){return a[e.getDay()]},A:function(e){return 1<=e.getHours()/12?s[1]:s[0]},a:function(e){return 1<=e.getHours()/12?u[1]:u[0]},aa:function(e){return 1<=e.getHours()/12?c[1]:c[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){l[n+"o"]=function(e,t){return t[n](e)+"."};}),["D","Do","DD"].forEach(function(n){l[n+" MMM"]=function(e,t){return (l[n]||t[n])(e,t)+" "+o[e.getMonth()]};}),{formatters:l,formattingTokensRegExp:d(l)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"kevesebb, mint egy másodperce",other:"kevesebb, mint {{count}} másodperce"},xSeconds:{one:"1 másodperce",other:"{{count}} másodperce"},halfAMinute:"fél perce",lessThanXMinutes:{one:"kevesebb, mint egy perce",other:"kevesebb, mint {{count}} perce"},xMinutes:{one:"1 perce",other:"{{count}} perce"},aboutXHours:{one:"közel 1 órája",other:"közel {{count}} órája"},xHours:{one:"1 órája",other:"{{count}} órája"},xDays:{one:"1 napja",other:"{{count}} napja"},aboutXMonths:{one:"közel 1 hónapja",other:"közel {{count}} hónapja"},xMonths:{one:"1 hónapja",other:"{{count}} hónapja"},aboutXYears:{one:"közel 1 éve",other:"közel {{count}} éve"},xYears:{one:"1 éve",other:"{{count}} éve"},overXYears:{one:"több, mint 1 éve",other:"több, mint {{count}} éve"},almostXYears:{one:"majdnem 1 éve",other:"majdnem {{count}} éve"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?""+o:o+"":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Jan","Feb","Már","Ápr","Máj","Jún","Júl","Aug","Sze","Okt","Nov","Dec"],n=["Január","Február","Március","Április","Május","Június","Július","Augusztus","Szeptember","Október","November","December"],o=["Va","Hé","Ke","Sze","Cs","Pé","Szo"],r=["Vas","Hét","Ked","Sze","Csü","Pén","Szo"],i=["Vasárnap","Hétfő","Kedd","Szerda","Csütörtök","Péntek","Szombat"],a=["DE","DU"],s=["de","du"],u=["délelőtt","délután"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){var t=e%100;if(20<t||t<10)switch(t%10){case 1:return e+"st";case 2:return e+"nd";case 3:return e+"rd"}return e+"th"}(t[n](e))};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"kurang dari 1 detik",other:"kurang dari {{count}} detik"},xSeconds:{one:"1 detik",other:"{{count}} detik"},halfAMinute:"setengah menit",lessThanXMinutes:{one:"kurang dari 1 menit",other:"kurang dari {{count}} menit"},xMinutes:{one:"1 menit",other:"{{count}} menit"},aboutXHours:{one:"sekitar 1 jam",other:"sekitar {{count}} jam"},xHours:{one:"1 jam",other:"{{count}} jam"},xDays:{one:"1 hari",other:"{{count}} hari"},aboutXMonths:{one:"sekitar 1 bulan",other:"sekitar {{count}} bulan"},xMonths:{one:"1 bulan",other:"{{count}} bulan"},aboutXYears:{one:"sekitar 1 tahun",other:"sekitar {{count}} tahun"},xYears:{one:"1 tahun",other:"{{count}} tahun"},overXYears:{one:"lebih dari 1 tahun",other:"lebih dari {{count}} tahun"},almostXYears:{one:"hampir 1 tahun",other:"hampir {{count}} tahun"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"dalam waktu "+o:o+" yang lalu":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Agu","Sep","Okt","Nov","Des"],n=["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"],o=["Mi","Sn","Sl","Ra","Ka","Ju","Sa"],r=["Min","Sen","Sel","Rab","Kam","Jum","Sab"],i=["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){switch(e){case 1:return "pertama";case 2:return "kedua";case 3:return "ketiga";default:return "ke-"+e}}(t[n](e))};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"minna en 1 sekúnda",other:"minna en {{count}} sekúndur"},xSeconds:{one:"1 sekúnda",other:"{{count}} sekúndur"},halfAMinute:"hálf mínúta",lessThanXMinutes:{one:"minna en 1 mínúta",other:"minna en {{count}} mínútur"},xMinutes:{one:"1 mínúta",other:"{{count}} mínútur"},aboutXHours:{one:"u.þ.b. 1 klukkustund",other:"u.þ.b. {{count}} klukkustundir"},xHours:{one:"1 klukkustund",other:"{{count}} klukkustundir"},xDays:{one:"1 dagur",other:"{{count}} dagar"},aboutXMonths:{one:"u.þ.b. 1 mánuður",other:"u.þ.b. {{count}} mánuðir"},xMonths:{one:"1 mánuður",other:"{{count}} mánuðir"},aboutXYears:{one:"u.þ.b. 1 ár",other:"u.þ.b. {{count}} ár"},xYears:{one:"1 ár",other:"{{count}} ár"},overXYears:{one:"meira en 1 ár",other:"meira en {{count}} ár"},almostXYears:{one:"næstum 1 ár",other:"næstum {{count}} ár"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"í "+o:o+" síðan":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","maí","jún","júl","ágú","sep","okt","nóv","des"],n=["janúar","febrúar","mars","apríl","maí","júní","júlí","ágúst","september","október","nóvember","desember"],o=["su","má","þr","mi","fi","fö","la"],r=["sun","mán","þri","mið","fim","fös","lau"],i=["sunnudaginn","mánudaginn","þriðjudaginn","miðvikudaginn","fimmtudaginn","föstudaginn","laugardaginn"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return ""+t[n](e)};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"meno di un secondo",other:"meno di {{count}} secondi"},xSeconds:{one:"un secondo",other:"{{count}} secondi"},halfAMinute:"alcuni secondi",lessThanXMinutes:{one:"meno di un minuto",other:"meno di {{count}} minuti"},xMinutes:{one:"un minuto",other:"{{count}} minuti"},aboutXHours:{one:"circa un'ora",other:"circa {{count}} ore"},xHours:{one:"un'ora",other:"{{count}} ore"},xDays:{one:"un giorno",other:"{{count}} giorni"},aboutXMonths:{one:"circa un mese",other:"circa {{count}} mesi"},xMonths:{one:"un mese",other:"{{count}} mesi"},aboutXYears:{one:"circa un anno",other:"circa {{count}} anni"},xYears:{one:"un anno",other:"{{count}} anni"},overXYears:{one:"più di un anno",other:"più di {{count}} anni"},almostXYears:{one:"quasi un anno",other:"quasi {{count}} anni"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"tra "+o:o+" fa":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["gen","feb","mar","apr","mag","giu","lug","ago","set","ott","nov","dic"],n=["gennaio","febbraio","marzo","aprile","maggio","giugno","luglio","agosto","settembre","ottobre","novembre","dicembre"],o=["do","lu","ma","me","gi","ve","sa"],r=["dom","lun","mar","mer","gio","ven","sab"],i=["domenica","lunedì","martedì","mercoledì","giovedì","venerdì","sabato"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"º"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"1秒以下",other:"{{count}}秒以下"},xSeconds:{one:"1秒",other:"{{count}}秒"},halfAMinute:"30秒ぐらい",lessThanXMinutes:{one:"1分以下",other:"{{count}}分以下"},xMinutes:{one:"1分",other:"{{count}}分"},aboutXHours:{one:"1時間ぐらい",other:"{{count}}時間ぐらい"},xHours:{one:"1時間",other:"{{count}}時間"},xDays:{one:"1日",other:"{{count}}日"},aboutXMonths:{one:"1ヶ月ぐらい",other:"{{count}}ヶ月ぐらい"},xMonths:{one:"1ヶ月",other:"{{count}}ヶ月"},aboutXYears:{one:"1年ぐらい",other:"{{count}}年ぐらい"},xYears:{one:"1年",other:"{{count}}年"},overXYears:{one:"1年以上",other:"{{count}}年以上"},almostXYears:{one:"1年以下",other:"{{count}}年以下"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?o+"後":o+"前":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],n=["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],o=["日","月","火","水","木","金","土"],r=["日曜","月曜","火曜","水曜","木曜","金曜","土曜"],i=["日曜日","月曜日","火曜日","水曜日","木曜日","金曜日","土曜日"],a=["午前","午後"],s=["午前","午後"],u=["午前","午後"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"日"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"1초 미만",other:"{{count}}초 미만"},xSeconds:{one:"1초",other:"{{count}}초"},halfAMinute:"30초",lessThanXMinutes:{one:"1분 미만",other:"{{count}}분 미만"},xMinutes:{one:"1분",other:"{{count}}분"},aboutXHours:{one:"약 1시간",other:"약 {{count}}시간"},xHours:{one:"1시간",other:"{{count}}시간"},xDays:{one:"1일",other:"{{count}}일"},aboutXMonths:{one:"약 1개월",other:"약 {{count}}개월"},xMonths:{one:"1개월",other:"{{count}}개월"},aboutXYears:{one:"약 1년",other:"약 {{count}}년"},xYears:{one:"1년",other:"{{count}}년"},overXYears:{one:"1년 이상",other:"{{count}}년 이상"},almostXYears:{one:"거의 1년",other:"거의 {{count}}년"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?o+" 후":o+" 전":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],n=["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],o=["일","월","화","수","목","금","토"],r=["일","월","화","수","목","금","토"],i=["일요일","월요일","화요일","수요일","목요일","금요일","토요일"],a=["오전","오후"],s=["오전","오후"],u=["오전","오후"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"일"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"помалку од секунда",other:"помалку од {{count}} секунди"},xSeconds:{one:"1 секунда",other:"{{count}} секунди"},halfAMinute:"половина минута",lessThanXMinutes:{one:"помалку од минута",other:"помалку од {{count}} минути"},xMinutes:{one:"1 минута",other:"{{count}} минути"},aboutXHours:{one:"околу 1 час",other:"околу {{count}} часа"},xHours:{one:"1 час",other:"{{count}} часа"},xDays:{one:"1 ден",other:"{{count}} дена"},aboutXMonths:{one:"околу 1 месец",other:"околу {{count}} месеци"},xMonths:{one:"1 месец",other:"{{count}} месеци"},aboutXYears:{one:"околу 1 година",other:"околу {{count}} години"},xYears:{one:"1 година",other:"{{count}} години"},overXYears:{one:"повеќе од 1 година",other:"повеќе од {{count}} години"},almostXYears:{one:"безмалку 1 година",other:"безмалку {{count}} години"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"за "+o:"пред "+o:o}}};},function(e,t,n){var s=n(1);e.exports=function(){var t=["јан","фев","мар","апр","мај","јун","јул","авг","сеп","окт","ное","дек"],n=["јануари","февруари","март","април","мај","јуни","јули","август","септември","октомври","ноември","декември"],o=["не","по","вт","ср","че","пе","са"],r=["нед","пон","вто","сре","чет","пет","саб"],i=["недела","понеделник","вторник","среда","четврток","петок","сабота"],a=["претпладне","попладне"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?a[1]:a[0]},aa:function(e){return 1<=e.getHours()/12?a[1]:a[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){var t=e%100;if(20<t||t<10)switch(t%10){case 1:return e+"-ви";case 2:return e+"-ри";case 7:case 8:return e+"-ми"}return e+"-ти"}(t[n](e))};}),{formatters:e,formattingTokensRegExp:s(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"mindre enn ett sekund",other:"mindre enn {{count}} sekunder"},xSeconds:{one:"ett sekund",other:"{{count}} sekunder"},halfAMinute:"et halvt minutt",lessThanXMinutes:{one:"mindre enn ett minutt",other:"mindre enn {{count}} minutter"},xMinutes:{one:"ett minutt",other:"{{count}} minutter"},aboutXHours:{one:"rundt en time",other:"rundt {{count}} timer"},xHours:{one:"en time",other:"{{count}} timer"},xDays:{one:"en dag",other:"{{count}} dager"},aboutXMonths:{one:"rundt en måned",other:"rundt {{count}} måneder"},xMonths:{one:"en måned",other:"{{count}} måneder"},aboutXYears:{one:"rundt ett år",other:"rundt {{count}} år"},xYears:{one:"ett år",other:"{{count}} år"},overXYears:{one:"over ett år",other:"over {{count}} år"},almostXYears:{one:"nesten ett år",other:"nesten {{count}} år"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"om "+o:o+" siden":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan.","feb.","mars","april","mai","juni","juli","aug.","sep.","okt.","nov.","des."],n=["januar","februar","mars","april","mai","juni","juli","august","september","oktober","november","desember"],o=["sø","ma","ti","on","to","fr","lø"],r=["sø.","ma.","ti.","on.","to.","fr.","lø."],i=["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"minder dan een seconde",other:"minder dan {{count}} seconden"},xSeconds:{one:"1 seconde",other:"{{count}} seconden"},halfAMinute:"een halve minuut",lessThanXMinutes:{one:"minder dan een minuut",other:"minder dan {{count}} minuten"},xMinutes:{one:"een minuut",other:"{{count}} minuten"},aboutXHours:{one:"ongeveer 1 uur",other:"ongeveer {{count}} uur"},xHours:{one:"1 uur",other:"{{count}} uur"},xDays:{one:"1 dag",other:"{{count}} dagen"},aboutXMonths:{one:"ongeveer 1 maand",other:"ongeveer {{count}} maanden"},xMonths:{one:"1 maand",other:"{{count}} maanden"},aboutXYears:{one:"ongeveer 1 jaar",other:"ongeveer {{count}} jaar"},xYears:{one:"1 jaar",other:"{{count}} jaar"},overXYears:{one:"meer dan 1 jaar",other:"meer dan {{count}} jaar"},almostXYears:{one:"bijna 1 jaar",other:"bijna {{count}} jaar"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"over "+o:o+" geleden":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","mei","jun","jul","aug","sep","okt","nov","dec"],n=["januari","februari","maart","april","mei","juni","juli","augustus","september","oktober","november","december"],o=["zo","ma","di","wo","do","vr","za"],r=["zon","maa","din","woe","don","vri","zat"],i=["zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"e"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){function i(e,t,n){n=n||"regular";var o=function(e,t){if(1===t)return e.one;var n=t%100;if(n<=20&&10<n)return e.other;var o=n%10;return 2<=o&&o<=4?e.twoFour:e.other}(e,t);return (o[n]||o).replace("{{count}}",t)}e.exports=function(){var r={lessThanXSeconds:{one:{regular:"mniej niż sekunda",past:"mniej niż sekundę",future:"mniej niż sekundę"},twoFour:"mniej niż {{count}} sekundy",other:"mniej niż {{count}} sekund"},xSeconds:{one:{regular:"sekunda",past:"sekundę",future:"sekundę"},twoFour:"{{count}} sekundy",other:"{{count}} sekund"},halfAMinute:{one:"pół minuty",twoFour:"pół minuty",other:"pół minuty"},lessThanXMinutes:{one:{regular:"mniej niż minuta",past:"mniej niż minutę",future:"mniej niż minutę"},twoFour:"mniej niż {{count}} minuty",other:"mniej niż {{count}} minut"},xMinutes:{one:{regular:"minuta",past:"minutę",future:"minutę"},twoFour:"{{count}} minuty",other:"{{count}} minut"},aboutXHours:{one:{regular:"około godzina",past:"około godziny",future:"około godzinę"},twoFour:"około {{count}} godziny",other:"około {{count}} godzin"},xHours:{one:{regular:"godzina",past:"godzinę",future:"godzinę"},twoFour:"{{count}} godziny",other:"{{count}} godzin"},xDays:{one:{regular:"dzień",past:"dzień",future:"1 dzień"},twoFour:"{{count}} dni",other:"{{count}} dni"},aboutXMonths:{one:"około miesiąc",twoFour:"około {{count}} miesiące",other:"około {{count}} miesięcy"},xMonths:{one:"miesiąc",twoFour:"{{count}} miesiące",other:"{{count}} miesięcy"},aboutXYears:{one:"około rok",twoFour:"około {{count}} lata",other:"około {{count}} lat"},xYears:{one:"rok",twoFour:"{{count}} lata",other:"{{count}} lat"},overXYears:{one:"ponad rok",twoFour:"ponad {{count}} lata",other:"ponad {{count}} lat"},almostXYears:{one:"prawie rok",twoFour:"prawie {{count}} lata",other:"prawie {{count}} lat"}};return {localize:function(e,t,n){var o=r[e];return (n=n||{}).addSuffix?0<n.comparison?"za "+i(o,t,"future"):i(o,t,"past")+" temu":i(o,t)}}};},function(e,t,n){var s=n(1);e.exports=function(){var t=["sty","lut","mar","kwi","maj","cze","lip","sie","wrz","paź","lis","gru"],n=["styczeń","luty","marzec","kwiecień","maj","czerwiec","lipiec","sierpień","wrzesień","październik","listopad","grudzień"],o=["nd","pn","wt","śr","cz","pt","sb"],r=["niedz.","pon.","wt.","śr.","czw.","piąt.","sob."],i=["niedziela","poniedziałek","wtorek","środa","czwartek","piątek","sobota"],a=["w nocy","rano","po południu","wieczorem"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){var t=e.getHours();return 17<=t?a[3]:12<=t?a[2]:4<=t?a[1]:a[0]}};return e.a=e.A,e.aa=e.A,["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e).toString()};}),{formatters:e,formattingTokensRegExp:s(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"menos de um segundo",other:"menos de {{count}} segundos"},xSeconds:{one:"1 segundo",other:"{{count}} segundos"},halfAMinute:"meio minuto",lessThanXMinutes:{one:"menos de um minuto",other:"menos de {{count}} minutos"},xMinutes:{one:"1 minuto",other:"{{count}} minutos"},aboutXHours:{one:"aproximadamente 1 hora",other:"aproximadamente {{count}} horas"},xHours:{one:"1 hora",other:"{{count}} horas"},xDays:{one:"1 dia",other:"{{count}} dias"},aboutXMonths:{one:"aproximadamente 1 mês",other:"aproximadamente {{count}} meses"},xMonths:{one:"1 mês",other:"{{count}} meses"},aboutXYears:{one:"aproximadamente 1 ano",other:"aproximadamente {{count}} anos"},xYears:{one:"1 ano",other:"{{count}} anos"},overXYears:{one:"mais de 1 ano",other:"mais de {{count}} anos"},almostXYears:{one:"quase 1 ano",other:"quase {{count}} anos"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"daqui a "+o:"há "+o:o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","fev","mar","abr","mai","jun","jul","ago","set","out","nov","dez"],n=["janeiro","fevereiro","março","abril","maio","junho","julho","agosto","setembro","outubro","novembro","dezembro"],o=["do","se","te","qa","qi","se","sa"],r=["dom","seg","ter","qua","qui","sex","sáb"],i=["domingo","segunda-feira","terça-feira","quarta-feira","quinta-feira","sexta-feira","sábado"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"º"};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"mai puțin de o secundă",other:"mai puțin de {{count}} secunde"},xSeconds:{one:"1 secundă",other:"{{count}} secunde"},halfAMinute:"jumătate de minut",lessThanXMinutes:{one:"mai puțin de un minut",other:"mai puțin de {{count}} minute"},xMinutes:{one:"1 minut",other:"{{count}} minute"},aboutXHours:{one:"circa 1 oră",other:"circa {{count}} ore"},xHours:{one:"1 oră",other:"{{count}} ore"},xDays:{one:"1 zi",other:"{{count}} zile"},aboutXMonths:{one:"circa 1 lună",other:"circa {{count}} luni"},xMonths:{one:"1 lună",other:"{{count}} luni"},aboutXYears:{one:"circa 1 an",other:"circa {{count}} ani"},xYears:{one:"1 an",other:"{{count}} ani"},overXYears:{one:"peste 1 an",other:"peste {{count}} ani"},almostXYears:{one:"aproape 1 an",other:"aproape {{count}} ani"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"în "+o:o+" în urmă":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["ian","feb","mar","apr","mai","iun","iul","aug","sep","oct","noi","dec"],n=["ianuarie","februarie","martie","aprilie","mai","iunie","iulie","august","septembrie","octombrie","noiembrie","decembrie"],o=["du","lu","ma","mi","jo","vi","sâ"],r=["dum","lun","mar","mie","joi","vin","sâm"],i=["duminică","luni","marți","miercuri","joi","vineri","sâmbăta"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e).toString()};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){function o(e,t){if(void 0!==e.one&&1===t)return e.one;var n=t%10,o=t%100;return 1===n&&11!==o?e.singularNominative.replace("{{count}}",t):2<=n&&n<=4&&(o<10||20<o)?e.singularGenitive.replace("{{count}}",t):e.pluralGenitive.replace("{{count}}",t)}function n(n){return function(e,t){return t.addSuffix?0<t.comparison?n.future?o(n.future,e):"через "+o(n.regular,e):n.past?o(n.past,e):o(n.regular,e)+" назад":o(n.regular,e)}}e.exports=function(){var o={lessThanXSeconds:n({regular:{one:"меньше секунды",singularNominative:"меньше {{count}} секунды",singularGenitive:"меньше {{count}} секунд",pluralGenitive:"меньше {{count}} секунд"},future:{one:"меньше, чем через секунду",singularNominative:"меньше, чем через {{count}} секунду",singularGenitive:"меньше, чем через {{count}} секунды",pluralGenitive:"меньше, чем через {{count}} секунд"}}),xSeconds:n({regular:{singularNominative:"{{count}} секунда",singularGenitive:"{{count}} секунды",pluralGenitive:"{{count}} секунд"},past:{singularNominative:"{{count}} секунду назад",singularGenitive:"{{count}} секунды назад",pluralGenitive:"{{count}} секунд назад"},future:{singularNominative:"через {{count}} секунду",singularGenitive:"через {{count}} секунды",pluralGenitive:"через {{count}} секунд"}}),halfAMinute:function(e,t){return t.addSuffix?0<t.comparison?"через полминуты":"полминуты назад":"полминуты"},lessThanXMinutes:n({regular:{one:"меньше минуты",singularNominative:"меньше {{count}} минуты",singularGenitive:"меньше {{count}} минут",pluralGenitive:"меньше {{count}} минут"},future:{one:"меньше, чем через минуту",singularNominative:"меньше, чем через {{count}} минуту",singularGenitive:"меньше, чем через {{count}} минуты",pluralGenitive:"меньше, чем через {{count}} минут"}}),xMinutes:n({regular:{singularNominative:"{{count}} минута",singularGenitive:"{{count}} минуты",pluralGenitive:"{{count}} минут"},past:{singularNominative:"{{count}} минуту назад",singularGenitive:"{{count}} минуты назад",pluralGenitive:"{{count}} минут назад"},future:{singularNominative:"через {{count}} минуту",singularGenitive:"через {{count}} минуты",pluralGenitive:"через {{count}} минут"}}),aboutXHours:n({regular:{singularNominative:"около {{count}} часа",singularGenitive:"около {{count}} часов",pluralGenitive:"около {{count}} часов"},future:{singularNominative:"приблизительно через {{count}} час",singularGenitive:"приблизительно через {{count}} часа",pluralGenitive:"приблизительно через {{count}} часов"}}),xHours:n({regular:{singularNominative:"{{count}} час",singularGenitive:"{{count}} часа",pluralGenitive:"{{count}} часов"}}),xDays:n({regular:{singularNominative:"{{count}} день",singularGenitive:"{{count}} дня",pluralGenitive:"{{count}} дней"}}),aboutXMonths:n({regular:{singularNominative:"около {{count}} месяца",singularGenitive:"около {{count}} месяцев",pluralGenitive:"около {{count}} месяцев"},future:{singularNominative:"приблизительно через {{count}} месяц",singularGenitive:"приблизительно через {{count}} месяца",pluralGenitive:"приблизительно через {{count}} месяцев"}}),xMonths:n({regular:{singularNominative:"{{count}} месяц",singularGenitive:"{{count}} месяца",pluralGenitive:"{{count}} месяцев"}}),aboutXYears:n({regular:{singularNominative:"около {{count}} года",singularGenitive:"около {{count}} лет",pluralGenitive:"около {{count}} лет"},future:{singularNominative:"приблизительно через {{count}} год",singularGenitive:"приблизительно через {{count}} года",pluralGenitive:"приблизительно через {{count}} лет"}}),xYears:n({regular:{singularNominative:"{{count}} год",singularGenitive:"{{count}} года",pluralGenitive:"{{count}} лет"}}),overXYears:n({regular:{singularNominative:"больше {{count}} года",singularGenitive:"больше {{count}} лет",pluralGenitive:"больше {{count}} лет"},future:{singularNominative:"больше, чем через {{count}} год",singularGenitive:"больше, чем через {{count}} года",pluralGenitive:"больше, чем через {{count}} лет"}}),almostXYears:n({regular:{singularNominative:"почти {{count}} год",singularGenitive:"почти {{count}} года",pluralGenitive:"почти {{count}} лет"},future:{singularNominative:"почти через {{count}} год",singularGenitive:"почти через {{count}} года",pluralGenitive:"почти через {{count}} лет"}})};return {localize:function(e,t,n){return n=n||{},o[e](t,n)}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["янв.","фев.","март","апр.","май","июнь","июль","авг.","сент.","окт.","нояб.","дек."],n=["январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],o=["января","февраля","марта","апреля","мая","июня","июля","августа","сентября","октября","ноября","декабря"],r=["вс","пн","вт","ср","чт","пт","сб"],i=["вск","пнд","втр","срд","чтв","птн","суб"],a=["воскресенье","понедельник","вторник","среда","четверг","пятница","суббота"],s=["ночи","утра","дня","вечера"],u={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return r[e.getDay()]},ddd:function(e){return i[e.getDay()]},dddd:function(e){return a[e.getDay()]},A:function(e){var t=e.getHours();return 17<=t?s[3]:12<=t?s[2]:4<=t?s[1]:s[0]},Do:function(e,t){return t.D(e)+"-е"},Wo:function(e,t){return t.W(e)+"-я"}};return u.a=u.A,u.aa=u.A,["M","DDD","d","Q"].forEach(function(n){u[n+"o"]=function(e,t){return t[n](e)+"-й"};}),["D","Do","DD"].forEach(function(n){u[n+" MMMM"]=function(e,t){return (u[n]||t[n])(e,t)+" "+o[e.getMonth()]};}),{formatters:u,formattingTokensRegExp:c(u)}};},function(e,t){function c(e,t,n){var o,r,i=(o=e,1===(r=t)?o.one:2<=r&&r<=4?o.twoFour:o.other);return (i[n]||i).replace("{{count}}",t)}function l(e){var t="";return "almost"===e&&(t="takmer"),"about"===e&&(t="približne"),0<t.length?t+" ":""}function d(e){var t="";return "lessThan"===e&&(t="menej než"),"over"===e&&(t="viac než"),0<t.length?t+" ":""}e.exports=function(){var u={xSeconds:{one:{regular:"sekunda",past:"sekundou",future:"sekundu"},twoFour:{regular:"{{count}} sekundy",past:"{{count}} sekundami",future:"{{count}} sekundy"},other:{regular:"{{count}} sekúnd",past:"{{count}} sekundami",future:"{{count}} sekúnd"}},halfAMinute:{other:{regular:"pol minúty",past:"pol minútou",future:"pol minúty"}},xMinutes:{one:{regular:"minúta",past:"minútou",future:"minútu"},twoFour:{regular:"{{count}} minúty",past:"{{count}} minútami",future:"{{count}} minúty"},other:{regular:"{{count}} minút",past:"{{count}} minútami",future:"{{count}} minút"}},xHours:{one:{regular:"hodina",past:"hodinou",future:"hodinu"},twoFour:{regular:"{{count}} hodiny",past:"{{count}} hodinami",future:"{{count}} hodiny"},other:{regular:"{{count}} hodín",past:"{{count}} hodinami",future:"{{count}} hodín"}},xDays:{one:{regular:"deň",past:"dňom",future:"deň"},twoFour:{regular:"{{count}} dni",past:"{{count}} dňami",future:"{{count}} dni"},other:{regular:"{{count}} dní",past:"{{count}} dňami",future:"{{count}} dní"}},xMonths:{one:{regular:"mesiac",past:"mesiacom",future:"mesiac"},twoFour:{regular:"{{count}} mesiace",past:"{{count}} mesiacmi",future:"{{count}} mesiace"},other:{regular:"{{count}} mesiacov",past:"{{count}} mesiacmi",future:"{{count}} mesiacov"}},xYears:{one:{regular:"rok",past:"rokom",future:"rok"},twoFour:{regular:"{{count}} roky",past:"{{count}} rokmi",future:"{{count}} roky"},other:{regular:"{{count}} rokov",past:"{{count}} rokmi",future:"{{count}} rokov"}}};return {localize:function(e,t,n){n=n||{};var o,r,i=(o=e,["lessThan","about","over","almost"].filter(function(e){return !!o.match(new RegExp("^"+e))})[0]||""),a=(r=e.substring(i.length)).charAt(0).toLowerCase()+r.slice(1),s=u[a];return n.addSuffix?0<n.comparison?l(i)+"za "+d(i)+c(s,t,"future"):l(i)+"pred "+d(i)+c(s,t,"past"):l(i)+d(i)+c(s,t,"regular")}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","máj","jún","júl","aug","sep","okt","nov","dec"],n=["január","február","marec","apríl","máj","jún","júl","august","september","október","november","december"],o=["ne","po","ut","st","št","pi","so"],r=["neď","pon","uto","str","štv","pia","sob"],i=["nedeľa","pondelok","utorok","streda","štvrtok","piatok","sobota"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"manj kot sekunda",two:"manj kot 2 sekundi",three:"manj kot {{count}} sekunde",other:"manj kot {{count}} sekund"},xSeconds:{one:"1 sekunda",two:"2 sekundi",three:"{{count}} sekunde",other:"{{count}} sekund"},halfAMinute:"pol minute",lessThanXMinutes:{one:"manj kot minuta",two:"manj kot 2 minuti",three:"manj kot {{count}} minute",other:"manj kot {{count}} minut"},xMinutes:{one:"1 minuta",two:"2 minuti",three:"{{count}} minute",other:"{{count}} minut"},aboutXHours:{one:"približno 1 ura",two:"približno 2 uri",three:"približno {{count}} ure",other:"približno {{count}} ur"},xHours:{one:"1 ura",two:"2 uri",three:"{{count}} ure",other:"{{count}} ur"},xDays:{one:"1 dan",two:"2 dni",three:"{{count}} dni",other:"{{count}} dni"},aboutXMonths:{one:"približno 1 mesec",two:"približno 2 meseca",three:"približno {{count}} mesece",other:"približno {{count}} mesecev"},xMonths:{one:"1 mesec",two:"2 meseca",three:"{{count}} meseci",other:"{{count}} mesecev"},aboutXYears:{one:"približno 1 leto",two:"približno 2 leti",three:"približno {{count}} leta",other:"približno {{count}} let"},xYears:{one:"1 leto",two:"2 leti",three:"{{count}} leta",other:"{{count}} let"},overXYears:{one:"več kot 1 leto",two:"več kot 2 leti",three:"več kot {{count}} leta",other:"več kot {{count}} let"},almostXYears:{one:"skoraj 1 leto",two:"skoraj 2 leti",three:"skoraj {{count}} leta",other:"skoraj {{count}} let"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:2===t?r[e].two:3===t||4===t?r[e].three.replace("{{count}}",t):r[e].other.replace("{{count}}",t),n.addSuffix?(o=o.replace(/(minut|sekund|ur)(a)/,"$1o"),"xMonths"===e&&(o=o.replace(/(mesec)(i)/,"$1e")),0<n.comparison?"čez "+o:o+" nazaj"):o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["jan","feb","mar","apr","maj","jun","jul","avg","sep","okt","nov","dec"],n=["januar","februar","marec","april","maj","junij","julij","avgust","september","oktober","november","december"],o=["ne","po","to","sr","če","pe","so"],r=["ned","pon","tor","sre","čet","pet","sob"],i=["nedelja","ponedeljek","torek","sreda","četrtek","petek","sobota"],a=["AM","PM"],s=["am","pm"],u=["a.m.","p.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e)+"."};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var i={lessThanXSeconds:{singular:"mindre än en sekund",plural:"mindre än {{count}} sekunder"},xSeconds:{singular:"en sekund",plural:"{{count}} sekunder"},halfAMinute:"en halv minut",lessThanXMinutes:{singular:"mindre än en minut",plural:"mindre än {{count}} minuter"},xMinutes:{singular:"en minut",plural:"{{count}} minuter"},aboutXHours:{singular:"ungefär en timme",plural:"ungefär {{count}} timmar"},xHours:{singular:"en timme",plural:"{{count}} timmar"},xDays:{singular:"en dag",plural:"{{count}} dagar"},aboutXMonths:{singular:"ungefär en månad",plural:"ungefär {{count}} månader"},xMonths:{singular:"en månad",plural:"{{count}} månader"},aboutXYears:{singular:"ungefär ett år",plural:"ungefär {{count}} år"},xYears:{singular:"ett år",plural:"{{count}} år"},overXYears:{singular:"över ett år",plural:"över {{count}} år"},almostXYears:{singular:"nästan ett år",plural:"nästan {{count}} år"}},a=["noll","en","två","tre","fyra","fem","sex","sju","åtta","nio","tio","elva","tolv"];return {localize:function(e,t,n){n=n||{};var o,r=i[e];return o="string"==typeof r?r:0===t||1<t?r.plural.replace("{{count}}",t<13?a[t]:t):r.singular,n.addSuffix?0<n.comparison?"om "+o:o+" sedan":o}}};},function(e,t,n){var s=n(1);e.exports=function(){var t=["jan","feb","mar","apr","maj","jun","jul","aug","sep","okt","nov","dec"],n=["januari","februari","mars","april","maj","juni","juli","augusti","september","oktober","november","december"],o=["sö","må","ti","on","to","fr","lö"],r=["sön","mån","tis","ons","tor","fre","lör"],i=["söndag","måndag","tisdag","onsdag","torsdag","fredag","lördag"],a=["f.m.","e.m."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},aa:function(e){return 1<=e.getHours()/12?a[1]:a[0]}};return e.A=e.aa,e.a=e.aa,["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){var t=e%100;if(20<t||t<10)switch(t%10){case 1:case 2:return e+":a"}return e+":e"}(t[n](e))};}),{formatters:e,formattingTokensRegExp:s(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"น้อยกว่า 1 วินาที",other:"น้อยกว่า {{count}} วินาที"},xSeconds:{one:"1 วินาที",other:"{{count}} วินาที"},halfAMinute:"ครึ่งนาที",lessThanXMinutes:{one:"น้อยกว่า 1 นาที",other:"น้อยกว่า {{count}} นาที"},xMinutes:{one:"1 นาที",other:"{{count}} นาที"},aboutXHours:{one:"ประมาณ 1 ชั่วโมง",other:"ประมาณ {{count}} ชั่วโมง"},xHours:{one:"1 ชั่วโมง",other:"{{count}} ชั่วโมง"},xDays:{one:"1 วัน",other:"{{count}} วัน"},aboutXMonths:{one:"ประมาณ 1 เดือน",other:"ประมาณ {{count}} เดือน"},xMonths:{one:"1 เดือน",other:"{{count}} เดือน"},aboutXYears:{one:"ประมาณ 1 ปี",other:"ประมาณ {{count}} ปี"},xYears:{one:"1 ปี",other:"{{count}} ปี"},overXYears:{one:"มากกว่า 1 ปี",other:"มากกว่า {{count}} ปี"},almostXYears:{one:"เกือบ 1 ปี",other:"เกือบ {{count}} ปี"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?"halfAMinute"===e?"ใน"+o:"ใน "+o:o+"ที่ผ่านมา":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["ม.ค.","ก.พ.","มี.ค.","เม.ย.","พ.ค.","มิ.ย.","ก.ค.","ส.ค.","ก.ย.","ต.ค.","พ.ย.","ธ.ค."],n=["มกราคาม","กุมภาพันธ์","มีนาคม","เมษายน","พฤษภาคม","มิถุนายน","กรกฎาคม","สิงหาคม","กันยายน","ตุลาคม","พฤศจิกายน","ธันวาคม"],o=["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],r=["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],i=["อาทิตย์","จันทร์","อังคาร","พุธ","พฤหัสบดี","ศุกร์","เสาร์"],a=["น."],s=["น."],u=["นาฬิกา"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return a[0]},a:function(e){return s[0]},aa:function(e){return u[0]}};return {formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var i={lessThanXSeconds:{one:"bir saniyeden az",other:"{{count}} saniyeden az"},xSeconds:{one:"1 saniye",other:"{{count}} saniye"},halfAMinute:"yarım dakika",lessThanXMinutes:{one:"bir dakikadan az",other:"{{count}} dakikadan az"},xMinutes:{one:"1 dakika",other:"{{count}} dakika"},aboutXHours:{one:"yaklaşık 1 saat",other:"yaklaşık {{count}} saat"},xHours:{one:"1 saat",other:"{{count}} saat"},xDays:{one:"1 gün",other:"{{count}} gün"},aboutXMonths:{one:"yaklaşık 1 ay",other:"yaklaşık {{count}} ay"},xMonths:{one:"1 ay",other:"{{count}} ay"},aboutXYears:{one:"yaklaşık 1 yıl",other:"yaklaşık {{count}} yıl"},xYears:{one:"1 yıl",other:"{{count}} yıl"},overXYears:{one:"1 yıldan fazla",other:"{{count}} yıldan fazla"},almostXYears:{one:"neredeyse 1 yıl",other:"neredeyse {{count}} yıl"}},a=["lessThanXSeconds","lessThanXMinutes","overXYears"];return {localize:function(e,t,n){var o;if(n=n||{},o="string"==typeof i[e]?i[e]:1===t?i[e].one:i[e].other.replace("{{count}}",t),n.addSuffix){var r="";return -1<a.indexOf(e)&&(r=" bir süre"),0<n.comparison?o+r+" içinde":o+r+" önce"}return o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["Oca","Şub","Mar","Nis","May","Haz","Tem","Ağu","Eyl","Eki","Kas","Ara"],n=["Ocak","Şubat","Mart","Nisan","Mayıs","Haziran","Temmuz","Ağustos","Eylül","Ekim","Kasım","Aralık"],o=["Pz","Pt","Sa","Ça","Pe","Cu","Ct"],r=["Paz","Pts","Sal","Çar","Per","Cum","Cts"],i=["Pazar","Pazartesi","Salı","Çarşamba","Perşembe","Cuma","Cumartesi"],a=["ÖÖ","ÖS"],s=["öö","ös"],u=["ö.ö.","ö.s."],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return function(e){var t={1:"'inci",2:"'inci",3:"'üncü",4:"'üncü",5:"'inci",6:"'ıncı",7:"'inci",8:"'inci",9:"'uncu",10:"'uncu",20:"'inci",30:"'uncu",50:"'inci",60:"'ıncı",70:"'inci",80:"'inci",90:"'ıncı",100:"'üncü"};if(0===e)return "0'ıncı";var n=e%10,o=e%100-n,r=100<=e?100:null;return e+(t[n]||t[o]||t[r])}(t[n](e))};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"不到 1 秒",other:"不到 {{count}} 秒"},xSeconds:{one:"1 秒",other:"{{count}} 秒"},halfAMinute:"半分钟",lessThanXMinutes:{one:"不到 1 分钟",other:"不到 {{count}} 分钟"},xMinutes:{one:"1 分钟",other:"{{count}} 分钟"},xHours:{one:"1 小时",other:"{{count}} 小时"},aboutXHours:{one:"大约 1 小时",other:"大约 {{count}} 小时"},xDays:{one:"1 天",other:"{{count}} 天"},aboutXMonths:{one:"大约 1 个月",other:"大约 {{count}} 个月"},xMonths:{one:"1 个月",other:"{{count}} 个月"},aboutXYears:{one:"大约 1 年",other:"大约 {{count}} 年"},xYears:{one:"1 年",other:"{{count}} 年"},overXYears:{one:"超过 1 年",other:"超过 {{count}} 年"},almostXYears:{one:"将近 1 年",other:"将近 {{count}} 年"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?o+"内":o+"前":o}}};},function(e,t,n){var s=n(1);e.exports=function(){var t=["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],n=["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],o=["日","一","二","三","四","五","六"],r=["周日","周一","周二","周三","周四","周五","周六"],i=["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],a=["上午","下午"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]}};return e.a=e.aa=e.A=function(e){return 1<=e.getHours()/12?a[1]:a[0]},["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e).toString()};}),{formatters:e,formattingTokensRegExp:s(e)}};},function(e,t){e.exports=function(){var r={lessThanXSeconds:{one:"少於 1 秒",other:"少於 {{count}} 秒"},xSeconds:{one:"1 秒",other:"{{count}} 秒"},halfAMinute:"半分鐘",lessThanXMinutes:{one:"少於 1 分鐘",other:"少於 {{count}} 分鐘"},xMinutes:{one:"1 分鐘",other:"{{count}} 分鐘"},xHours:{one:"1 小時",other:"{{count}} 小時"},aboutXHours:{one:"大約 1 小時",other:"大約 {{count}} 小時"},xDays:{one:"1 天",other:"{{count}} 天"},aboutXMonths:{one:"大約 1 個月",other:"大約 {{count}} 個月"},xMonths:{one:"1 個月",other:"{{count}} 個月"},aboutXYears:{one:"大約 1 年",other:"大約 {{count}} 年"},xYears:{one:"1 年",other:"{{count}} 年"},overXYears:{one:"超過 1 年",other:"超過 {{count}} 年"},almostXYears:{one:"將近 1 年",other:"將近 {{count}} 年"}};return {localize:function(e,t,n){var o;return n=n||{},o="string"==typeof r[e]?r[e]:1===t?r[e].one:r[e].other.replace("{{count}}",t),n.addSuffix?0<n.comparison?o+"內":o+"前":o}}};},function(e,t,n){var c=n(1);e.exports=function(){var t=["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],n=["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],o=["日","一","二","三","四","五","六"],r=["周日","周一","周二","周三","周四","周五","周六"],i=["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],a=["AM","PM"],s=["am","pm"],u=["上午","下午"],e={MMM:function(e){return t[e.getMonth()]},MMMM:function(e){return n[e.getMonth()]},dd:function(e){return o[e.getDay()]},ddd:function(e){return r[e.getDay()]},dddd:function(e){return i[e.getDay()]},A:function(e){return 1<=e.getHours()/12?a[1]:a[0]},a:function(e){return 1<=e.getHours()/12?s[1]:s[0]},aa:function(e){return 1<=e.getHours()/12?u[1]:u[0]}};return ["M","D","DDD","d","Q","W"].forEach(function(n){e[n+"o"]=function(e,t){return t[n](e).toString()};}),{formatters:e,formattingTokensRegExp:c(e)}};},function(e,t,n){var a=n(0);e.exports=function(e,t){var n=t&&Number(t.weekStartsOn)||0,o=a(e),r=o.getDay(),i=(r<n?7:0)+r-n;return o.setDate(o.getDate()-i),o.setHours(0,0,0,0),o};},function(e,t,n){var a=n(4);e.exports=function(e,t){var n=a(e),o=a(t),r=n.getTime()-6e4*n.getTimezoneOffset(),i=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-i)/864e5)};},function(e,t,n){var s=n(0),u=n(116);e.exports=function(e,t){var n=s(e),o=Number(t),r=n.getMonth()+o,i=new Date(0);i.setFullYear(n.getFullYear(),r,1),i.setHours(0,0,0,0);var a=u(i);return n.setMonth(r,Math.min(a,n.getDate())),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()-o.getTime()};},function(e,t,n){var o=n(12),r=n(13);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(14),r=n(15);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(16),r=n(17);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(18),r=n(19);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(20),r=n(21);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(22),r=n(23);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(24),r=n(25);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(26),r=n(27);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(28),r=n(29);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(30),r=n(31);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(32),r=n(33);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(34),r=n(35);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(36),r=n(37);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(38),r=n(39);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(40),r=n(41);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(42),r=n(43);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(44),r=n(45);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(46),r=n(47);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(48),r=n(49);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(50),r=n(51);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(52),r=n(53);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(54),r=n(55);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(56),r=n(57);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(58),r=n(59);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(60),r=n(61);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(62),r=n(63);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(64),r=n(65);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(66),r=n(67);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(68),r=n(69);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(70),r=n(71);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(72),r=n(73);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(74),r=n(75);e.exports={distanceInWords:o(),format:r()};},function(e,t,n){var o=n(76),r=n(77);e.exports={distanceInWords:o(),format:r()};},function(e,t){e.exports=function(e){return e instanceof Date};},function(e,t,n){var i=n(0);e.exports=function(e){var t=i(e),n=t.getFullYear(),o=t.getMonth(),r=new Date(0);return r.setFullYear(n,o+1,0),r.setHours(0,0,0,0),r.getDate()};},function(e,t,n){var o=n(6);e.exports=function(e,t){var n=Number(t);return o(e,7*n)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e).getTime(),o=r(t).getTime();return o<n?-1:n<o?1:0};},function(e,t,n){var a=n(0),s=n(133),u=n(9);e.exports=function(e,t){var n=a(e),o=a(t),r=u(n,o),i=Math.abs(s(n,o));return n.setMonth(n.getMonth()-r*i),r*(i-(u(n,o)===-r))};},function(e,t,n){var o=n(81);e.exports=function(e,t){var n=o(e,t)/1e3;return 0<n?Math.floor(n):Math.ceil(n)};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setHours(23,59,59,999),t};},function(e,t,n){var o=n(0),r=n(3),i=n(8);e.exports=function(e){var t=o(e),n=r(t).getTime()-i(t).getTime();return Math.round(n/6048e5)+1};},function(e,t,n){var i=n(78);e.exports=function(e,t,n){var o=i(e,n),r=i(t,n);return o.getTime()===r.getTime()};},function(e,t,n){e.exports={addDays:n(6),addHours:n(125),addISOYears:n(126),addMilliseconds:n(7),addMinutes:n(128),addMonths:n(80),addQuarters:n(129),addSeconds:n(130),addWeeks:n(117),addYears:n(131),areRangesOverlapping:n(202),closestIndexTo:n(203),closestTo:n(204),compareAsc:n(9),compareDesc:n(118),differenceInCalendarDays:n(79),differenceInCalendarISOWeeks:n(205),differenceInCalendarISOYears:n(132),differenceInCalendarMonths:n(133),differenceInCalendarQuarters:n(206),differenceInCalendarWeeks:n(207),differenceInCalendarYears:n(135),differenceInDays:n(136),differenceInHours:n(208),differenceInISOYears:n(209),differenceInMilliseconds:n(81),differenceInMinutes:n(210),differenceInMonths:n(119),differenceInQuarters:n(211),differenceInSeconds:n(120),differenceInWeeks:n(212),differenceInYears:n(213),distanceInWords:n(138),distanceInWordsStrict:n(214),distanceInWordsToNow:n(215),eachDay:n(216),endOfDay:n(121),endOfHour:n(217),endOfISOWeek:n(218),endOfISOYear:n(219),endOfMinute:n(220),endOfMonth:n(140),endOfQuarter:n(221),endOfSecond:n(222),endOfToday:n(223),endOfTomorrow:n(224),endOfWeek:n(139),endOfYear:n(225),endOfYesterday:n(226),format:n(227),getDate:n(228),getDay:n(229),getDayOfYear:n(141),getDaysInMonth:n(116),getDaysInYear:n(230),getHours:n(231),getISODay:n(145),getISOWeek:n(122),getISOWeeksInYear:n(232),getISOYear:n(2),getMilliseconds:n(233),getMinutes:n(234),getMonth:n(235),getOverlappingDaysInRanges:n(236),getQuarter:n(134),getSeconds:n(237),getTime:n(238),getYear:n(239),isAfter:n(240),isBefore:n(241),isDate:n(115),isEqual:n(242),isFirstDayOfMonth:n(243),isFriday:n(244),isFuture:n(245),isLastDayOfMonth:n(246),isLeapYear:n(144),isMonday:n(247),isPast:n(248),isSameDay:n(249),isSameHour:n(146),isSameISOWeek:n(148),isSameISOYear:n(149),isSameMinute:n(150),isSameMonth:n(152),isSameQuarter:n(153),isSameSecond:n(155),isSameWeek:n(123),isSameYear:n(157),isSaturday:n(250),isSunday:n(251),isThisHour:n(252),isThisISOWeek:n(253),isThisISOYear:n(254),isThisMinute:n(255),isThisMonth:n(256),isThisQuarter:n(257),isThisSecond:n(258),isThisWeek:n(259),isThisYear:n(260),isThursday:n(261),isToday:n(262),isTomorrow:n(263),isTuesday:n(264),isValid:n(143),isWednesday:n(265),isWeekend:n(266),isWithinRange:n(267),isYesterday:n(268),lastDayOfISOWeek:n(269),lastDayOfISOYear:n(270),lastDayOfMonth:n(271),lastDayOfQuarter:n(272),lastDayOfWeek:n(158),lastDayOfYear:n(273),max:n(274),min:n(275),parse:n(0),setDate:n(276),setDay:n(277),setDayOfYear:n(278),setHours:n(279),setISODay:n(280),setISOWeek:n(281),setISOYear:n(127),setMilliseconds:n(282),setMinutes:n(283),setMonth:n(159),setQuarter:n(284),setSeconds:n(285),setYear:n(286),startOfDay:n(4),startOfHour:n(147),startOfISOWeek:n(3),startOfISOYear:n(8),startOfMinute:n(151),startOfMonth:n(287),startOfQuarter:n(154),startOfSecond:n(156),startOfToday:n(288),startOfTomorrow:n(289),startOfWeek:n(78),startOfYear:n(142),startOfYesterday:n(290),subDays:n(291),subHours:n(292),subISOYears:n(137),subMilliseconds:n(293),subMinutes:n(294),subMonths:n(295),subQuarters:n(296),subSeconds:n(297),subWeeks:n(298),subYears:n(299)};},function(e,t,n){var o=n(7);e.exports=function(e,t){var n=Number(t);return o(e,36e5*n)};},function(e,t,n){var o=n(2),r=n(127);e.exports=function(e,t){var n=Number(t);return r(e,o(e)+n)};},function(e,t,n){var a=n(0),s=n(8),u=n(79);e.exports=function(e,t){var n=a(e),o=Number(t),r=u(n,s(n)),i=new Date(0);return i.setFullYear(o,0,4),i.setHours(0,0,0,0),(n=s(i)).setDate(n.getDate()+r),n};},function(e,t,n){var o=n(7);e.exports=function(e,t){var n=Number(t);return o(e,6e4*n)};},function(e,t,n){var o=n(80);e.exports=function(e,t){var n=Number(t);return o(e,3*n)};},function(e,t,n){var o=n(7);e.exports=function(e,t){var n=Number(t);return o(e,1e3*n)};},function(e,t,n){var o=n(80);e.exports=function(e,t){var n=Number(t);return o(e,12*n)};},function(e,t,n){var o=n(2);e.exports=function(e,t){return o(e)-o(t)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return 12*(n.getFullYear()-o.getFullYear())+(n.getMonth()-o.getMonth())};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return Math.floor(t.getMonth()/3)+1};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getFullYear()-o.getFullYear()};},function(e,t,n){var a=n(0),s=n(79),u=n(9);e.exports=function(e,t){var n=a(e),o=a(t),r=u(n,o),i=Math.abs(s(n,o));return n.setDate(n.getDate()-r*i),r*(i-(u(n,o)===-r))};},function(e,t,n){var o=n(126);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var v=n(118),g=n(0),_=n(120),y=n(119),b=n(5);e.exports=function(e,t,n){var o=n||{},r=v(e,t),i=o.locale,a=b.distanceInWords.localize;i&&i.distanceInWords&&i.distanceInWords.localize&&(a=i.distanceInWords.localize);var s,u,c={addSuffix:Boolean(o.addSuffix),comparison:r};0<r?(s=g(e),u=g(t)):(s=g(t),u=g(e));var l,d=_(u,s),f=u.getTimezoneOffset()-s.getTimezoneOffset(),h=Math.round(d/60)-f;if(h<2)return o.includeSeconds?d<5?a("lessThanXSeconds",5,c):d<10?a("lessThanXSeconds",10,c):d<20?a("lessThanXSeconds",20,c):d<40?a("halfAMinute",null,c):a(d<60?"lessThanXMinutes":"xMinutes",1,c):0===h?a("lessThanXMinutes",1,c):a("xMinutes",h,c);if(h<45)return a("xMinutes",h,c);if(h<90)return a("aboutXHours",1,c);if(h<1440)return a("aboutXHours",Math.round(h/60),c);if(h<2520)return a("xDays",1,c);if(h<43200)return a("xDays",Math.round(h/1440),c);if(h<86400)return a("aboutXMonths",l=Math.round(h/43200),c);if((l=y(u,s))<12)return a("xMonths",Math.round(h/43200),c);var m=l%12,p=Math.floor(l/12);return m<3?a("aboutXYears",p,c):m<9?a("overXYears",p,c):a("almostXYears",p+1,c)};},function(e,t,n){var a=n(0);e.exports=function(e,t){var n=t&&Number(t.weekStartsOn)||0,o=a(e),r=o.getDay(),i=6+(r<n?-7:0)-(r-n);return o.setDate(o.getDate()+i),o.setHours(23,59,59,999),o};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e),n=t.getMonth();return t.setFullYear(t.getFullYear(),n+1,0),t.setHours(23,59,59,999),t};},function(e,t,n){var o=n(0),r=n(142),i=n(79);e.exports=function(e){var t=o(e);return i(t,r(t))+1};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e),n=new Date(0);return n.setFullYear(t.getFullYear(),0,1),n.setHours(0,0,0,0),n};},function(e,t,n){var o=n(115);e.exports=function(e){if(o(e))return !isNaN(e);throw new TypeError(toString.call(e)+" is not an instance of Date")};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e).getFullYear();return t%400==0||t%4==0&&t%100!=0};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e).getDay();return 0===t&&(t=7),t};},function(e,t,n){var r=n(147);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setMinutes(0,0,0),t};},function(e,t,n){var o=n(123);e.exports=function(e,t){return o(e,t,{weekStartsOn:1})};},function(e,t,n){var r=n(8);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var r=n(151);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setSeconds(0,0),t};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getFullYear()===o.getFullYear()&&n.getMonth()===o.getMonth()};},function(e,t,n){var r=n(154);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var r=n(0);e.exports=function(e){var t=r(e),n=t.getMonth(),o=n-n%3;return t.setMonth(o,1),t.setHours(0,0,0,0),t};},function(e,t,n){var r=n(156);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setMilliseconds(0),t};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getFullYear()===o.getFullYear()};},function(e,t,n){var a=n(0);e.exports=function(e,t){var n=t&&Number(t.weekStartsOn)||0,o=a(e),r=o.getDay(),i=6+(r<n?-7:0)-(r-n);return o.setHours(0,0,0,0),o.setDate(o.getDate()+i),o};},function(e,t,n){var u=n(0),c=n(116);e.exports=function(e,t){var n=u(e),o=Number(t),r=n.getFullYear(),i=n.getDate(),a=new Date(0);a.setFullYear(r,o,15),a.setHours(0,0,0,0);var s=c(a);return n.setMonth(o,Math.min(i,s)),n};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t){e.exports={typings:"../../typings.d.ts"};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=n(197),r=n(199),i=n(305),a=n(308),s=n(311),u=n(314),c=n(317),l=n(320);t.default={bulmaAccordion:o.a,bulmaCalendar:r.a,bulmaCarousel:i.a,bulmaIconpicker:a.a,bulmaQuickview:s.a,bulmaSlider:u.a,bulmaSteps:c.a,bulmaTagsinput:l.a};},function(e,t,n){var r=n(198),i=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var a=Symbol("onBulmaAccordionClick"),o=function(e){function o(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o);var t=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(o.__proto__||Object.getPrototypeOf(o)).call(this));if(t.element="string"==typeof e?document.querySelector(e):e,!t.element)throw new Error("An invalid selector or non-DOM node has been provided.");return t._clickEvents=["click"],t[a]=t[a].bind(t),t.init(),t}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(o,r["a"]),i(o,[{key:"init",value:function(){this.items=this.element.querySelectorAll(".accordion")||[],this._bindEvents();}},{key:"destroy",value:function(){var n=this;this.items.forEach(function(t){n._clickEvents.forEach(function(e){t.removeEventListener(e,n[a],!1);});});}},{key:"_bindEvents",value:function(){var n=this;this.items.forEach(function(t){n._clickEvents.forEach(function(e){t.addEventListener(e,n[a],!1);});});}},{key:a,value:function(e){e.preventDefault();var t=e.currentTarget.closest(".accordion")||e.currentTarget;if(t.classList.contains("is-active"))t.classList.remove("is-active");else {var n=this.element.querySelector(".accordion.is-active");n&&n.classList.remove("is-active"),t.classList.add("is-active");}}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:".accordions",t=new Array,n=document.querySelectorAll(e);return [].forEach.call(n,function(e){setTimeout(function(){t.push(new o(e));},100);}),t}}]),o}();t.a=o;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){var o=n(200),u=n(201),c=n(124),i=(n.n(c),n(300)),a=n(301),s=n(302),l=n(303),d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},f=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var h=Symbol("onToggleDatePicker"),m=Symbol("onCloseDatePicker"),p=Symbol("onPreviousDatePicker"),v=Symbol("onNextDatePicker"),g=Symbol("onSelectMonthDatePicker"),_=Symbol("onMonthClickDatePicker"),y=Symbol("onSelectYearDatePicker"),b=Symbol("onYearClickDatePicker"),x=Symbol("onDateClickDatePicker"),M=Symbol("onDocumentClickDatePicker"),k=Symbol("onValidateClickDatePicker"),w=Symbol("onTodayClickDatePicker"),D=Symbol("onClearClickDatePicker"),S=Symbol("onCancelClickDatePicker"),j=!1;try{var r=Object.defineProperty({},"passive",{get:function(){j=!0;}});window.addEventListener("testPassive",null,r),window.removeEventListener("testPassive",null,r);}catch(e){}var E=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element=u.a(e)?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click","touch"],n.options=d({},a.a,t),n[h]=n[h].bind(n),n[m]=n[m].bind(n),n[p]=n[p].bind(n),n[v]=n[v].bind(n),n[g]=n[g].bind(n),n[_]=n[_].bind(n),n[y]=n[y].bind(n),n[b]=n[b].bind(n),n[x]=n[x].bind(n),n[M]=n[M].bind(n),n[k]=n[k].bind(n),n[w]=n[w].bind(n),n[D]=n[D].bind(n),n[S]=n[S].bind(n),n._init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,i["a"]),f(r,[{key:"isRange",value:function(){return this.options.isRange}},{key:"isOpen",value:function(){return this._open}},{key:"value",value:function(){if(!(0<arguments.length&&void 0!==arguments[0]?arguments[0]:null)){var e="";return this.options.isRange?this.startDate&&this._isValidDate(this.startDate)&&this.endDate&&this._isValidDate(this.endDate)&&(e=c.format(this.startDate,this.dateFormat,{locale:this.locale})+" - "+c.format(this.endDate,this.dateFormat,{locale:this.locale})):this.startDate&&this._isValidDate(this.startDate)&&(e=c.format(this.startDate,this._dateFormat,{locale:this.locale})),this.emit("date:selected",this.date,this),e}if(this.options.isRange){var t=this.element.value.split(" - ");t.length&&(this.startDate=new Date(t[0])),2===t.length&&(this.endDate=new Date(t[1]));}else this.startDate=new Date(this.element.value);}},{key:"clear",value:function(){this._clear();}},{key:"show",value:function(){this._snapshots=[],this._snapshot(),this.element.value&&this.value(this.element.value),this._visibleDate=this._isValidDate(this.startDate,this.minDate,this.maxDate)?this.startDate:this._visibleDate,this._refreshCalendar(),this._ui.body.dates.classList.add("is-active"),this._ui.body.months.classList.remove("is-active"),this._ui.body.years.classList.remove("is-active"),this._ui.navigation.previous.removeAttribute("disabled"),this._ui.navigation.next.removeAttribute("disabled"),this._ui.container.classList.add("is-active"),"default"===this.options.displayMode&&this._adjustPosition(),this._open=!0,this._focus=!0,this.emit("show",this);}},{key:"hide",value:function(){this._open=!1,this._focus=!1,this._ui.container.classList.remove("is-active"),this.emit("hide",this);}},{key:"destroy",value:function(){this._ui.container.remove();}},{key:M,value:function(e){j||e.preventDefault(),e.stopPropagation(),"inline"!==this.options.displayMode&&this._open&&this[m](e);}},{key:h,value:function(e){j||e.preventDefault(),e.stopPropagation(),this._open?this.hide():this.show();}},{key:k,value:function(e){j||e.preventDefault(),e.stopPropagation(),this[m](e);}},{key:w,value:function(e){j||e.preventDefault(),e.stopPropagation(),this.options.isRange?this._setStartAndEnd(new Date):this.startDate=new Date,this._visibleDate=this.startDate,this.element.value=this.value(),this._refreshCalendar();}},{key:D,value:function(e){j||e.preventDefault(),e.stopPropagation(),this._clear();}},{key:S,value:function(e){j||e.preventDefault(),e.stopPropagation(),this._snapshots.length&&(this.startDate=this._snapshots[0].start,this.endDate=this._snapshots[0].end),this.element.value=this.value(),this[m](e);}},{key:m,value:function(e){j||e.preventDefault(),e.stopPropagation(),this.hide();}},{key:p,value:function(e){j||e.preventDefault(),e.stopPropagation();var t=c.lastDayOfMonth(c.subMonths(new Date(c.getYear(this._visibleDate),c.getMonth(this._visibleDate)),1)),n=Math.min(c.getDaysInMonth(t),c.getDate(this._visibleDate));this._visibleDate=this.minDate?c.max(c.setDate(t,n),this.minDate):c.setDate(t,n),this._refreshCalendar();}},{key:v,value:function(e){j||e.preventDefault(),e.stopPropagation();var t=c.addMonths(this._visibleDate,1),n=Math.min(c.getDaysInMonth(t),c.getDate(this._visibleDate));this._visibleDate=this.maxDate?c.min(c.setDate(t,n),this.maxDate):c.setDate(t,n),this._refreshCalendar();}},{key:x,value:function(e){j||e.preventDefault(),e.stopPropagation(),e.currentTarget.classList.contains("is-disabled")||(this._setStartAndEnd(e.currentTarget.dataset.date),this._refreshCalendar(),("inline"===this.options.displayMode||this.options.closeOnSelect)&&(this.element.value=this.value()),(!this.options.isRange||this.startDate&&this._isValidDate(this.startDate)&&this.endDate&&this._isValidDate(this.endDate))&&this.options.closeOnSelect&&this.hide());}},{key:g,value:function(e){e.stopPropagation(),this._ui.body.dates.classList.remove("is-active"),this._ui.body.years.classList.remove("is-active"),this._ui.body.months.classList.add("is-active"),this._ui.navigation.previous.setAttribute("disabled","disabled"),this._ui.navigation.next.setAttribute("disabled","disabled");}},{key:y,value:function(e){e.stopPropagation(),this._ui.body.dates.classList.remove("is-active"),this._ui.body.months.classList.remove("is-active"),this._ui.body.years.classList.add("is-active"),this._ui.navigation.previous.setAttribute("disabled","disabled"),this._ui.navigation.next.setAttribute("disabled","disabled");var t=this._ui.body.years.querySelector(".calendar-year.is-active");t&&(this._ui.body.years.scrollTop=t.offsetTop-this._ui.body.years.offsetTop-this._ui.body.years.clientHeight/2);}},{key:_,value:function(e){j||e.preventDefault(),e.stopPropagation();var t=c.setMonth(this._visibleDate,parseInt(e.currentTarget.dataset.month)-1);this._visibleDate=this.minDate?c.max(t,this.minDate):t,this._visibleDate=this.maxDate?c.min(this._visibleDate,this.maxDate):this._visibleDate,this._refreshCalendar();}},{key:b,value:function(e){j||e.preventDefault(),e.stopPropagation();var t=c.setYear(this._visibleDate,parseInt(e.currentTarget.dataset.year));this._visibleDate=this.minDate?c.max(t,this.minDate):t,this._visibleDate=this.maxDate?c.min(this._visibleDate,this.maxDate):this._visibleDate,this._refreshCalendar();}},{key:"_init",value:function(){var i=this;this._id=o.a("datePicker"),this._snapshots=[],"date"===this.element.getAttribute("type").toLowerCase()&&this.element.setAttribute("type","text");var e=this.element.dataset?Object.keys(this.element.dataset).filter(function(e){return Object.keys(a.a).includes(e)}).reduce(function(e,t){return d({},e,(n={},o=t,r=i.element.dataset[t],o in n?Object.defineProperty(n,o,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[o]=r,n));var n,o,r;},{}):{};return this.options=d({},this.options,e),this.lang=this.options.lang,this.dateFormat=this.options.dateFormat||"MM/DD/YYYY",this._date={start:void 0,end:void 0},this._open=!1,"inline"!==this.options.displayMode&&window.matchMedia("screen and (max-width: 768px)").matches&&(this.options.displayMode="dialog"),this._initDates(),this._build(),this._bindEvents(),this.emit("ready",this),this}},{key:"_initDates",value:function(){this.minDate=this.options.minDate,this.maxDate=this.options.maxDate;var e=new Date,t=this._isValidDate(e,this.options.minDate,this.options.maxDate)?e:this.options.minDate;if(this.startDate=this.options.startDate,this.endDate=this.options.isRange?this.options.endDate:void 0,this.element.value)if(this.options.isRange){var n=this.element.value.split(" - ");n.length&&(this.startDate=new Date(n[0])),2===n.length&&(this.endDate=new Date(n[1]));}else this.startDate=new Date(this.element.value);if(this._visibleDate=this._isValidDate(this.startDate)?this.startDate:t,this.options.disabledDates){Array.isArray(this.options.disabledDates)||(this.options.disabledDates=[this.options.disabledDates]);for(var o=0;o<this.options.disabledDates.length;o++)this.options.disabledDates[o]=c.format(this.options.disabledDates[o],this.options.dateFormat,{locale:this.locale});}this._snapshot();}},{key:"_build",value:function(){var n=this,e=new Array(7).fill(c.startOfWeek(this._visibleDate)).map(function(e,t){return c.format(c.addDays(e,t+n.options.weekStart),"ddd",{locale:n.locale})}),t=new Array(12).fill(c.startOfWeek(this._visibleDate)).map(function(e,t){return c.format(c.addMonths(e,t),"MM",{locale:n.locale})}),o=new Array(100).fill(c.subYears(this._visibleDate,50)).map(function(e,t){return c.format(c.addYears(e,t),"YYYY",{locale:n.locale})}),r=document.createRange().createContextualFragment(Object(s.a)(d({},this.options,{id:this.id,date:this.date,locale:this.locale,visibleDate:this._visibleDate,labels:{from:this.options.labelFrom,to:this.options.labelTo,weekdays:e},months:t,years:o,isRange:this.options.isRange,month:c.format(this.month,"MM",{locale:this.locale})}))),i=r.querySelector("#"+this.id);if(this._ui={container:i,calendar:i.querySelector(".calendar"),overlay:"dialog"===this.options.displayMode?{background:i.querySelector(".modal-background"),close:i.querySelector(".modal-close")}:void 0,header:{container:i.querySelector(".calendar-header"),start:{container:i.querySelector(".calendar-selection-start"),day:i.querySelector(".calendar-selection-start .calendar-selection-day"),month:i.querySelector(".calendar-selection-start .calendar-selection-month"),weekday:i.querySelector(".calendar-selection-start .calendar-selection-weekday"),empty:i.querySelector(".calendar-selection-start .empty")},end:this.options.isRange?{container:i.querySelector(".calendar-selection-end"),day:i.querySelector(".calendar-selection-end .calendar-selection-day"),month:i.querySelector(".calendar-selection-end .calendar-selection-month"),weekday:i.querySelector(".calendar-selection-end .calendar-selection-weekday"),empty:i.querySelector(".calendar-selection-start .empty")}:void 0},navigation:{container:i.querySelector(".calendar-nav"),previous:i.querySelector(".calendar-nav-previous"),next:i.querySelector(".calendar-nav-next"),month:i.querySelector(".calendar-nav-month"),year:i.querySelector(".calendar-nav-year")},footer:{container:i.querySelector(".calendar-footer"),validate:i.querySelector(".calendar-footer-validate"),today:i.querySelector(".calendar-footer-today"),clear:i.querySelector(".calendar-footer-clear"),cancel:i.querySelector(".calendar-footer-cancel")},body:{dates:i.querySelector(".calendar-dates"),days:i.querySelector(".calendar-days"),weekdays:i.querySelector(".calendar-weekdays"),months:i.querySelector(".calendar-months"),years:i.querySelector(".calendar-years")}},this.options.showHeader||this._ui.header.container.classList.add("is-hidden"),this.options.showFooter||this._ui.footer.container.classList.add("is-hidden"),this.options.todayButton||this._ui.footer.todayB.classList.add("is-hidden"),this.options.clearButton||this._ui.footer.clear.classList.add("is-hidden"),"inline"===this.options.displayMode&&this._ui.footer.validate&&this._ui.footer.validate.classList.add("is-hidden"),"inline"===this.options.displayMode&&this._ui.footer.cancel&&this._ui.footer.cancel.classList.add("is-hidden"),this.options.closeOnSelect&&this._ui.footer.validate&&this._ui.footer.validate.classList.add("is-hidden"),"inline"===this.options.displayMode){var a=document.createElement("div");this.element.parentNode.insertBefore(a,this.element),a.appendChild(this.element),this.element.classList.add("is-hidden"),a.appendChild(r),i.classList.remove("datepicker"),this._refreshCalendar();}else document.body.appendChild(r);}},{key:"_bindEvents",value:function(){var n=this;window.addEventListener("scroll",function(){"default"===n.options.displayMode&&(console("Scroll"),n._adjustPosition());}),document.addEventListener("keydown",function(e){if(n._focus)switch(e.keyCode||e.which){case 37:n[p](e);break;case 39:n[v](e);}}),!0===this.options.toggleOnInputClick&&this._clickEvents.forEach(function(e){n.element.addEventListener(e,n[h]);}),"dialog"===this.options.displayMode&&this._ui.overlay&&(this._ui.overlay.close&&this._clickEvents.forEach(function(e){n.this._ui.overlay.close.addEventListener(e,n[m]);}),this.options.closeOnOverlayClick&&this._ui.overlay.background&&this._clickEvents.forEach(function(e){n._ui.overlay.background.addEventListener(e,n[m]);})),this._ui.navigation.previous&&this._clickEvents.forEach(function(e){n._ui.navigation.previous.addEventListener(e,n[p]);}),this._ui.navigation.next&&this._clickEvents.forEach(function(e){n._ui.navigation.next.addEventListener(e,n[v]);}),this._ui.navigation.month&&this._clickEvents.forEach(function(e){n._ui.navigation.month.addEventListener(e,n[g]);}),this._ui.navigation.year&&this._clickEvents.forEach(function(e){n._ui.navigation.year.addEventListener(e,n[y]);}),(this._ui.body.months.querySelectorAll(".calendar-month")||[]).forEach(function(t){n._clickEvents.forEach(function(e){t.addEventListener(e,n[_]);});}),(this._ui.body.years.querySelectorAll(".calendar-year")||[]).forEach(function(t){n._clickEvents.forEach(function(e){t.addEventListener(e,n[b]);});}),this._ui.footer.validate&&this._clickEvents.forEach(function(e){n._ui.footer.validate.addEventListener(e,n[k]);}),this._ui.footer.today&&this._clickEvents.forEach(function(e){n._ui.footer.today.addEventListener(e,n[w]);}),this._ui.footer.clear&&this._clickEvents.forEach(function(e){n._ui.footer.clear.addEventListener(e,n[D]);}),this._ui.footer.cancel&&this._clickEvents.forEach(function(e){n._ui.footer.cancel.addEventListener(e,n[S]);});}},{key:"_bindDaysEvents",value:function(){var o=this;[].forEach.call(this._ui.days,function(n){o._clickEvents.forEach(function(e){var t=o._isValidDate(new Date(n.dataset.date),o.minDate,o.maxDate)?o[x]:null;n.addEventListener(e,t);}),n.addEventListener("hover",function(e){e.preventDEfault();});});}},{key:"_renderDays",value:function(){var s=this,e=c.startOfWeek(c.startOfMonth(this._visibleDate)),t=c.endOfWeek(c.endOfMonth(this._visibleDate)),n=new Array(c.differenceInDays(t,e)+1).fill(e).map(function(e,t){var n=c.addDays(e,t+s.options.weekStart),o=c.isSameMonth(s._visibleDate,n),r=s.options.isRange&&c.isWithinRange(n,s.startDate,s.endDate),i=!!s.maxDate&&c.isAfter(n,s.maxDate);if(i=s.minDate?c.isBefore(n,s.minDate):i,s.options.disabledDates)for(var a=0;a<s.options.disabledDates.length;a++)c.getTime(n)==c.getTime(s.options.disabledDates[a])&&(i=!0);s.options.disabledWeekDays&&(u.a(s.options.disabledWeekDays)?s.options.disabledWeekDays.split(","):s.options.disabledWeekDays).forEach(function(e){c.getDay(n)==e&&(i=!0);});return {date:n,isRange:s.options.isRange,isToday:c.isToday(n),isStartDate:c.isEqual(s.startDate,n),isEndDate:c.isEqual(s.endDate,n),isDisabled:i,isThisMonth:o,isInRange:r}});this._ui.body.days.appendChild(document.createRange().createContextualFragment(Object(l.a)(n))),this._ui.days=this._ui.body.days.querySelectorAll(".calendar-date"),this._bindDaysEvents(),this.emit("rendered",this);}},{key:"_togglePreviousButton",value:function(){!(0<arguments.length&&void 0!==arguments[0])||arguments[0]?this._ui.navigation.previous.removeAttribute("disabled"):this._ui.navigation.previous.setAttribute("disabled","disabled");}},{key:"_toggleNextButton",value:function(){!(0<arguments.length&&void 0!==arguments[0])||arguments[0]?this._ui.navigation.next.removeAttribute("disabled"):this._ui.navigation.next.setAttribute("disabled","disabled");}},{key:"_setStartAndEnd",value:function(e){var r=this;this._snapshot(),this.options.isRange&&(!this._isValidDate(this.startDate)||this._isValidDate(this.startDate)&&this._isValidDate(this.endDate))?(this.startDate=new Date(e),this.endDate=void 0,this.emit("startDate:selected",this.date,this)):this.options.isRange&&!this._isValidDate(this.endDate)?c.isBefore(e,this.startDate)?(this.endDate=this.startDate,this.startDate=new Date(e),this.emit("startDate:selected",this.date,this),this.emit("endDate:selected",this.date,this)):c.isAfter(e,this.startDate)?(this.endDate=new Date(e),this.emit("endDate:selected",this.date,this)):(this.startDate=new Date(e),this.endDate=void 0):(this.startDate=new Date(e),this.endDate=void 0),this.options.isRange&&this._isValidDate(this.startDate)&&this._isValidDate(this.endDate)&&new Array(c.differenceInDays(this.endDate,this.startDate)+1).fill(this.startDate).map(function(e,t){var n=c.addDays(e,t),o=r._ui.body.dates.querySelector('.calendar-date[data-date="'+n.toString()+'"]');o&&(c.isEqual(r.startDate,n)&&o.classList.add("calendar-range-start"),c.isEqual(r.endDate,n)&&o.classList.add("calendar-range-end"),o.classList.add("calendar-range"));});}},{key:"_clear",value:function(){this.startDate=void 0,this.endDate=void 0,this.element.value=this.value(),"inline"!==this.options.displayMode&&this._open&&this.hide(),this._refreshCalendar();}},{key:"_refreshCalendar",value:function(){var t=this;return this._ui.body.days.innerHTML="",this.minDate&&0===c.differenceInMonths(this._visibleDate,this.minDate)?this._togglePreviousButton(!1):this._togglePreviousButton(),this.maxDate&&0===c.differenceInMonths(this._visibleDate,this.maxDate)?this._toggleNextButton(!1):this._toggleNextButton(),this._refreshCalendarHeader(),this._ui.navigation.month.innerHTML=c.format(this._visibleDate,"MMMM",{locale:this.locale}),this._ui.navigation.year.innerHTML=c.format(this._visibleDate,"YYYY",{locale:this.locale}),(this._ui.body.months.querySelectorAll(".calendar-month")||[]).forEach(function(e){e.classList.remove("is-active"),e.dataset.month===c.format(t._visibleDate,"MM",{locale:t.locale})&&e.classList.add("is-active");}),(this._ui.body.years.querySelectorAll(".calendar-year")||[]).forEach(function(e){e.classList.remove("is-active"),e.dataset.year===c.format(t._visibleDate,"YYYY",{locale:t.locale})&&e.classList.add("is-active");}),this._renderDays(),this._ui.body.dates.classList.add("is-active"),this._ui.body.months.classList.remove("is-active"),this._ui.body.years.classList.remove("is-active"),this._ui.navigation.previous.removeAttribute("disabled"),this._ui.navigation.next.removeAttribute("disabled"),this}},{key:"_refreshCalendarHeader",value:function(){this._ui.header.start.day.innerHTML=this._isValidDate(this.startDate)?c.getDate(this.startDate):"&nbsp;",this._ui.header.start.weekday.innerHTML=this._isValidDate(this.startDate)?c.format(this.startDate,"dddd",{locale:this.locale}):"&nbsp;",this._ui.header.start.month.innerHTML=this._isValidDate(this.startDate)?c.format(this.startDate,"MMMM YYYY",{locale:this.locale}):"&nbsp;",this._ui.header.end&&(this._ui.header.end.day.innerHTML=this.options.isRange&&this._isValidDate(this.endDate)?c.getDate(this.endDate):"&nbsp;",this._ui.header.end.weekday.innerHTML=this.options.isRange&&this._isValidDate(this.endDate)?c.format(this.endDate,"dddd",{locale:this.locale}):"&nbsp;",this._ui.header.end.month.innerHTML=this.options.isRange&&this._isValidDate(this.endDate)?c.format(this.endDate,"MMMM YYYY",{locale:this.locale}):"&nbsp;");}},{key:"_adjustPosition",value:function(){var e=void 0,t=void 0,n=void 0;if("function"==typeof this.element.getBoundingClientRect)e=(n=this.element.getBoundingClientRect()).left+window.pageXOffset,t=n.bottom+window.pageYOffset;else for(e=this.element.offsetLeft,t=this.element.offsetTop+this.element.offsetHeight;this.element=this.element.offsetParent;)e+=this.element.offsetLeft,t+=this.element.offsetTop;this._ui.container.style.position="absolute",this._ui.container.style.left=e+"px",this._ui.container.style.top=t+"px";}},{key:"_isValidDate",value:function(e,t,n){try{return !!e&&(!!c.isValid(e)&&(!t&&!n||(t&&n?c.isWithinRange(e,t,n):n?c.isBefore(e,n)||c.isEqual(e,n):c.isAfter(e,t)||c.isEqual(e,t))))}catch(e){return !1}}},{key:"_snapshot",value:function(){this._snapshots.push(d({},this._date));}},{key:"id",get:function(){return this._id}},{key:"lang",get:function(){return this._lang},set:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"en";this._lang=e,this._locale=n(304)("./"+e);}},{key:"locale",get:function(){return this._locale}},{key:"date",get:function(){return this._date||{start:void 0,end:void 0}}},{key:"startDate",get:function(){return this._date.start},set:function(e){this._date.start=e?this._isValidDate(e,this.minDate,this.maxDate)?c.startOfDay(e):this._date.start:void 0;}},{key:"endDate",get:function(){return this._date.end},set:function(e){this._date.end=e?this._isValidDate(e,this.minDate,this.maxDate)?c.startOfDay(e):this._date.end:void 0;}},{key:"minDate",get:function(){return this._minDate},set:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:void 0;return this._minDate=e?this._isValidDate(e)?c.startOfDay(e):this._minDate:void 0,this}},{key:"maxDate",get:function(){return this._maxDate},set:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;return this._maxDate=e?this._isValidDate(e)?c.startOfDay(e):this._maxDate:void 0,this}},{key:"dateFormat",get:function(){return this._dateFormat},set:function(e){return this._dateFormat=e,this}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'input[type="date"]',t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=u.a(e)?document.querySelectorAll(e):Array.isArray(e)?e:[e];return [].forEach.call(o,function(e){n.push(new r(e,t));}),n}}]),r}();t.a=E;},function(e,t,n){n.d(t,"a",function(){return o});var o=function(){return (0<arguments.length&&void 0!==arguments[0]?arguments[0]:"")+([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,function(e){return (e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)})};},function(e,t,n){n.d(t,"a",function(){return r});var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=function(e){return "string"==typeof e||!!e&&"object"===(void 0===e?"undefined":o(e))&&"[object String]"===Object.prototype.toString.call(e)};},function(e,t,n){var u=n(0);e.exports=function(e,t,n,o){var r=u(e).getTime(),i=u(t).getTime(),a=u(n).getTime(),s=u(o).getTime();if(i<r||s<a)throw new Error("The start of the range cannot be after the end of the range");return r<s&&a<i};},function(e,t,n){var s=n(0);e.exports=function(e,t){if(!(t instanceof Array))throw new TypeError(toString.call(t)+" is not an instance of Array");var r,i,a=s(e).getTime();return t.forEach(function(e,t){var n=s(e),o=Math.abs(a-n.getTime());(void 0===r||o<i)&&(r=t,i=o);}),r};},function(e,t,n){var a=n(0);e.exports=function(e,t){if(!(t instanceof Array))throw new TypeError(toString.call(t)+" is not an instance of Array");var o,r,i=a(e).getTime();return t.forEach(function(e){var t=a(e),n=Math.abs(i-t.getTime());(void 0===o||n<r)&&(o=t,r=n);}),o};},function(e,t,n){var a=n(3);e.exports=function(e,t){var n=a(e),o=a(t),r=n.getTime()-6e4*n.getTimezoneOffset(),i=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-i)/6048e5)};},function(e,t,n){var r=n(134),i=n(0);e.exports=function(e,t){var n=i(e),o=i(t);return 4*(n.getFullYear()-o.getFullYear())+(r(n)-r(o))};},function(e,t,n){var s=n(78);e.exports=function(e,t,n){var o=s(e,n),r=s(t,n),i=o.getTime()-6e4*o.getTimezoneOffset(),a=r.getTime()-6e4*r.getTimezoneOffset();return Math.round((i-a)/6048e5)};},function(e,t,n){var o=n(81);e.exports=function(e,t){var n=o(e,t)/36e5;return 0<n?Math.floor(n):Math.ceil(n)};},function(e,t,n){var a=n(0),s=n(132),u=n(9),c=n(137);e.exports=function(e,t){var n=a(e),o=a(t),r=u(n,o),i=Math.abs(s(n,o));return n=c(n,r*i),r*(i-(u(n,o)===-r))};},function(e,t,n){var o=n(81);e.exports=function(e,t){var n=o(e,t)/6e4;return 0<n?Math.floor(n):Math.ceil(n)};},function(e,t,n){var o=n(119);e.exports=function(e,t){var n=o(e,t)/3;return 0<n?Math.floor(n):Math.ceil(n)};},function(e,t,n){var o=n(136);e.exports=function(e,t){var n=o(e,t)/7;return 0<n?Math.floor(n):Math.ceil(n)};},function(e,t,n){var a=n(0),s=n(135),u=n(9);e.exports=function(e,t){var n=a(e),o=a(t),r=u(n,o),i=Math.abs(s(n,o));return n.setFullYear(n.getFullYear()-r*i),r*(i-(u(n,o)===-r))};},function(e,t,n){var p=n(118),v=n(0),g=n(120),_=n(5);e.exports=function(e,t,n){var o=n||{},r=p(e,t),i=o.locale,a=_.distanceInWords.localize;i&&i.distanceInWords&&i.distanceInWords.localize&&(a=i.distanceInWords.localize);var s,u,c,l={addSuffix:Boolean(o.addSuffix),comparison:r};0<r?(s=v(e),u=v(t)):(s=v(t),u=v(e));var d=Math[o.partialMethod?String(o.partialMethod):"floor"],f=g(u,s),h=u.getTimezoneOffset()-s.getTimezoneOffset(),m=d(f/60)-h;if("s"===(c=o.unit?String(o.unit):m<1?"s":m<60?"m":m<1440?"h":m<43200?"d":m<525600?"M":"Y"))return a("xSeconds",f,l);if("m"===c)return a("xMinutes",m,l);if("h"===c)return a("xHours",d(m/60),l);if("d"===c)return a("xDays",d(m/1440),l);if("M"===c)return a("xMonths",d(m/43200),l);if("Y"===c)return a("xYears",d(m/525600),l);throw new Error("Unknown unit: "+c)};},function(e,t,n){var o=n(138);e.exports=function(e,t){return o(Date.now(),e,t)};},function(e,t,n){var u=n(0);e.exports=function(e,t,n){var o=u(e),r=void 0!==n?n:1,i=u(t).getTime();if(o.getTime()>i)throw new Error("The first date cannot be after the second date");var a=[],s=o;for(s.setHours(0,0,0,0);s.getTime()<=i;)a.push(u(s)),s.setDate(s.getDate()+r);return a};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setMinutes(59,59,999),t};},function(e,t,n){var o=n(139);e.exports=function(e){return o(e,{weekStartsOn:1})};},function(e,t,n){var r=n(2),i=n(3);e.exports=function(e){var t=r(e),n=new Date(0);n.setFullYear(t+1,0,4),n.setHours(0,0,0,0);var o=i(n);return o.setMilliseconds(o.getMilliseconds()-1),o};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setSeconds(59,999),t};},function(e,t,n){var r=n(0);e.exports=function(e){var t=r(e),n=t.getMonth(),o=n-n%3+3;return t.setMonth(o,0),t.setHours(23,59,59,999),t};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setMilliseconds(999),t};},function(e,t,n){var o=n(121);e.exports=function(){return o(new Date)};},function(e,t){e.exports=function(){var e=new Date,t=e.getFullYear(),n=e.getMonth(),o=e.getDate(),r=new Date(0);return r.setFullYear(t,n,o+1),r.setHours(23,59,59,999),r};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e),n=t.getFullYear();return t.setFullYear(n+1,0,0),t.setHours(23,59,59,999),t};},function(e,t){e.exports=function(){var e=new Date,t=e.getFullYear(),n=e.getMonth(),o=e.getDate(),r=new Date(0);return r.setFullYear(t,n,o-1),r.setHours(23,59,59,999),r};},function(e,t,n){var o=n(141),r=n(122),i=n(2),u=n(0),c=n(143),l=n(5);var d={M:function(e){return e.getMonth()+1},MM:function(e){return s(e.getMonth()+1,2)},Q:function(e){return Math.ceil((e.getMonth()+1)/3)},D:function(e){return e.getDate()},DD:function(e){return s(e.getDate(),2)},DDD:function(e){return o(e)},DDDD:function(e){return s(o(e),3)},d:function(e){return e.getDay()},E:function(e){return e.getDay()||7},W:function(e){return r(e)},WW:function(e){return s(r(e),2)},YY:function(e){return s(e.getFullYear(),4).substr(2)},YYYY:function(e){return s(e.getFullYear(),4)},GG:function(e){return String(i(e)).substr(2)},GGGG:function(e){return i(e)},H:function(e){return e.getHours()},HH:function(e){return s(e.getHours(),2)},h:function(e){var t=e.getHours();return 0===t?12:12<t?t%12:t},hh:function(e){return s(d.h(e),2)},m:function(e){return e.getMinutes()},mm:function(e){return s(e.getMinutes(),2)},s:function(e){return e.getSeconds()},ss:function(e){return s(e.getSeconds(),2)},S:function(e){return Math.floor(e.getMilliseconds()/100)},SS:function(e){return s(Math.floor(e.getMilliseconds()/10),2)},SSS:function(e){return s(e.getMilliseconds(),3)},Z:function(e){return a(e.getTimezoneOffset(),":")},ZZ:function(e){return a(e.getTimezoneOffset())},X:function(e){return Math.floor(e.getTime()/1e3)},x:function(e){return e.getTime()}};function a(e,t){t=t||"";var n=0<e?"-":"+",o=Math.abs(e),r=o%60;return n+s(Math.floor(o/60),2)+t+s(r,2)}function s(e,t){for(var n=Math.abs(e).toString();n.length<t;)n="0"+n;return n}e.exports=function(e,t,n){var o=t?String(t):"YYYY-MM-DDTHH:mm:ss.SSSZ",r=(n||{}).locale,i=l.format.formatters,a=l.format.formattingTokensRegExp;r&&r.format&&r.format.formatters&&(i=r.format.formatters,r.format.formattingTokensRegExp&&(a=r.format.formattingTokensRegExp));var s=u(e);return c(s)?function(e,t,n){var o,r,i,a=e.match(n),s=a.length;for(o=0;o<s;o++)r=t[a[o]]||d[a[o]],a[o]=r||((i=a[o]).match(/\[[\s\S]/)?i.replace(/^\[|]$/g,""):i.replace(/\\/g,""));return function(e){for(var t="",n=0;n<s;n++)a[n]instanceof Function?t+=a[n](e,d):t+=a[n];return t}}(o,i,a)(s):"Invalid Date"};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getDate()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getDay()};},function(e,t,n){var o=n(144);e.exports=function(e){return o(e)?366:365};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getHours()};},function(e,t,n){var o=n(8),r=n(117);e.exports=function(e){var t=o(e),n=o(r(t,60)).valueOf()-t.valueOf();return Math.round(n/6048e5)};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getMilliseconds()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getMinutes()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getMonth()};},function(e,t,n){var c=n(0);e.exports=function(e,t,n,o){var r=c(e).getTime(),i=c(t).getTime(),a=c(n).getTime(),s=c(o).getTime();if(i<r||s<a)throw new Error("The start of the range cannot be after the end of the range");if(!(r<s&&a<i))return 0;var u=(i<s?i:s)-(a<r?r:a);return Math.ceil(u/864e5)};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getSeconds()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getFullYear()};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()>o.getTime()};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()<o.getTime()};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){return 1===o(e).getDate()};},function(e,t,n){var o=n(0);e.exports=function(e){return 5===o(e).getDay()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getTime()>(new Date).getTime()};},function(e,t,n){var o=n(0),r=n(121),i=n(140);e.exports=function(e){var t=o(e);return r(t).getTime()===i(t).getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){return 1===o(e).getDay()};},function(e,t,n){var o=n(0);e.exports=function(e){return o(e).getTime()<(new Date).getTime()};},function(e,t,n){var r=n(4);e.exports=function(e,t){var n=r(e),o=r(t);return n.getTime()===o.getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){return 6===o(e).getDay()};},function(e,t,n){var o=n(0);e.exports=function(e){return 0===o(e).getDay()};},function(e,t,n){var o=n(146);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(148);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(149);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(150);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(152);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(153);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(155);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(123);e.exports=function(e,t){return o(new Date,e,t)};},function(e,t,n){var o=n(157);e.exports=function(e){return o(new Date,e)};},function(e,t,n){var o=n(0);e.exports=function(e){return 4===o(e).getDay()};},function(e,t,n){var o=n(4);e.exports=function(e){return o(e).getTime()===o(new Date).getTime()};},function(e,t,n){var o=n(4);e.exports=function(e){var t=new Date;return t.setDate(t.getDate()+1),o(e).getTime()===o(t).getTime()};},function(e,t,n){var o=n(0);e.exports=function(e){return 2===o(e).getDay()};},function(e,t,n){var o=n(0);e.exports=function(e){return 3===o(e).getDay()};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e).getDay();return 0===t||6===t};},function(e,t,n){var a=n(0);e.exports=function(e,t,n){var o=a(e).getTime(),r=a(t).getTime(),i=a(n).getTime();if(i<r)throw new Error("The start of the range cannot be after the end of the range");return r<=o&&o<=i};},function(e,t,n){var o=n(4);e.exports=function(e){var t=new Date;return t.setDate(t.getDate()-1),o(e).getTime()===o(t).getTime()};},function(e,t,n){var o=n(158);e.exports=function(e){return o(e,{weekStartsOn:1})};},function(e,t,n){var r=n(2),i=n(3);e.exports=function(e){var t=r(e),n=new Date(0);n.setFullYear(t+1,0,4),n.setHours(0,0,0,0);var o=i(n);return o.setDate(o.getDate()-1),o};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e),n=t.getMonth();return t.setFullYear(t.getFullYear(),n+1,0),t.setHours(0,0,0,0),t};},function(e,t,n){var r=n(0);e.exports=function(e){var t=r(e),n=t.getMonth(),o=n-n%3+3;return t.setMonth(o,0),t.setHours(0,0,0,0),t};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e),n=t.getFullYear();return t.setFullYear(n+1,0,0),t.setHours(0,0,0,0),t};},function(e,t,n){var o=n(0);e.exports=function(){var e=Array.prototype.slice.call(arguments).map(function(e){return o(e)}),t=Math.max.apply(null,e);return new Date(t)};},function(e,t,n){var o=n(0);e.exports=function(){var e=Array.prototype.slice.call(arguments).map(function(e){return o(e)}),t=Math.min.apply(null,e);return new Date(t)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setDate(o),n};},function(e,t,n){var s=n(0),u=n(6);e.exports=function(e,t,n){var o=n&&Number(n.weekStartsOn)||0,r=s(e),i=Number(t),a=r.getDay();return u(r,((i%7+7)%7<o?7:0)+i-a)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setMonth(0),n.setDate(o),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setHours(o),n};},function(e,t,n){var i=n(0),a=n(6),s=n(145);e.exports=function(e,t){var n=i(e),o=Number(t),r=s(n);return a(n,o-r)};},function(e,t,n){var i=n(0),a=n(122);e.exports=function(e,t){var n=i(e),o=Number(t),r=a(n)-o;return n.setDate(n.getDate()-7*r),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setMilliseconds(o),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setMinutes(o),n};},function(e,t,n){var r=n(0),i=n(159);e.exports=function(e,t){var n=r(e),o=Number(t)-(Math.floor(n.getMonth()/3)+1);return i(n,n.getMonth()+3*o)};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setSeconds(o),n};},function(e,t,n){var r=n(0);e.exports=function(e,t){var n=r(e),o=Number(t);return n.setFullYear(o),n};},function(e,t,n){var o=n(0);e.exports=function(e){var t=o(e);return t.setDate(1),t.setHours(0,0,0,0),t};},function(e,t,n){var o=n(4);e.exports=function(){return o(new Date)};},function(e,t){e.exports=function(){var e=new Date,t=e.getFullYear(),n=e.getMonth(),o=e.getDate(),r=new Date(0);return r.setFullYear(t,n,o+1),r.setHours(0,0,0,0),r};},function(e,t){e.exports=function(){var e=new Date,t=e.getFullYear(),n=e.getMonth(),o=e.getDate(),r=new Date(0);return r.setFullYear(t,n,o-1),r.setHours(0,0,0,0),r};},function(e,t,n){var o=n(6);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(125);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(7);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(128);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(80);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(129);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(130);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(117);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=n(131);e.exports=function(e,t){var n=Number(t);return o(e,-n)};},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){var o={startDate:void 0,endDate:void 0,minDate:null,maxDate:null,isRange:!1,disabledDates:[],disabledWeekDays:void 0,lang:"en",dateFormat:"MM/DD/YYYY",displayMode:"default",showHeader:!0,showFooter:!0,todayButton:!0,clearButton:!0,labelFrom:"",labelTo:"",weekStart:0,closeOnOverlayClick:!0,closeOnSelect:!0,toggleOnInputClick:!0,icons:{previous:'<svg viewBox="0 0 50 80" xml:space="preserve">\n      <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="45.63,75.8 0.375,38.087 45.63,0.375 "/>\n    </svg>',next:'<svg viewBox="0 0 50 80" xml:space="preserve">\n      <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="0.375,0.375 45.63,38.087 0.375,75.8 "/>\n    </svg>'}};t.a=o;},function(e,t,n){var o=n(124);n.n(o);t.a=function(n){return "<div id='"+n.id+"' class=\"datepicker "+("dialog"===n.displayMode?"modal":"")+'">\n    '+("dialog"===n.displayMode?'<div class="modal-background"></div>':"")+'\n    <div class="calendar">\n      <div class="calendar-header">\n        <div class="calendar-selection-start">\n          <div class="calendar-selection-from'+(""===n.labels.from?" is-hidden":"")+'">'+n.labels.from+'</div>\n          <div class="calendar-selection-date">\n            <div class="calendar-selection-day"></div>\n            <div class="calendar-selection-details">\n              <div class="calendar-selection-month"></div>\n              <div class="calendar-selection-weekday"></div>\n            </div>\n          </div>\n        </div>\n  '+(n.isRange?'<div class="calendar-selection-end">\n          <div class="calendar-selection-to'+(""===n.labels.to?" is-hidden":"")+'">'+n.labels.to+'</div>\n          <div class="calendar-selection-date">\n            <div class="calendar-selection-day"></div>\n            <div class="calendar-selection-details">\n              <div class="calendar-selection-month"></div>\n              <div class="calendar-selection-weekday"></div>\n            </div>\n          </div>\n        </div>':"")+'\n      </div>\n      <div class="calendar-nav">\n        <button class="calendar-nav-previous button is-small is-text">'+n.icons.previous+'</button>\n        <div class="calendar-nav-month-year">\n          <div class="calendar-nav-month">'+Object(o.format)(n.visibleDate,"MMMM",{locale:n.locale})+'</div>\n          &nbsp;\n          <div class="calendar-nav-year">'+Object(o.format)(n.visibleDate,"YYYY",{locale:n.locale})+'</div>\n        </div>\n        <button class="calendar-nav-next button is-small is-text">'+n.icons.next+'</button>\n      </div>\n      <div class="calendar-body">\n        <div class="calendar-dates is-active">\n          <div class="calendar-weekdays">\n            '+n.labels.weekdays.map(function(e){return '<div class="calendar-date">'+e+"</div>"}).join("")+'\n          </div>\n          <div class="calendar-days"></div>\n        </div>\n        <div class="calendar-months">\n          '+new Array(12).fill(new Date("01/01/1970")).map(function(e,t){return '<div class="calendar-month" data-month="'+Object(o.format)(Object(o.addMonths)(e,t),"MM",{locale:n.locale})+'">'+Object(o.format)(Object(o.addMonths)(e,t),"MMM",{locale:n.locale})+"</div>"}).join("")+'\n        </div>\n        <div class="calendar-years">\n          '+n.years.map(function(e){return '<div class="calendar-year'+(e===Object(o.getMonth)(n.visibleDate)?" is-active":"")+'" data-year="'+e+'"><span class="item">'+e+"</span></div>"}).join("")+'\n        </div>\n      </div>\n      <div class="calendar-footer">\n        <button class="calendar-footer-validate has-text-success button is-small is-text">'+(n.icons.validate?n.icons.validate:"")+' Validate</button>\n        <button class="calendar-footer-today has-text-warning button is-small is-text">'+(n.icons.today?n.icons.today:"")+' Today</button>\n        <button class="calendar-footer-clear has-text-danger button is-small is-text">'+(n.icons.clear?n.icons.clear:"")+' Clear</button>\n        <button class="calendar-footer-cancel button is-small is-text">'+(n.icons.cancel?n.icons.cancel:"")+" Cancel</button>\n      </div>\n    </div>\n  </div>"};},function(e,t,n){t.a=function(e){return ""+e.map(function(e){return '<div data-date="'+e.date.toString()+'" class="calendar-date'+(e.isThisMonth?" is-current-month":"")+(e.isDisabled?" is-disabled":"")+(e.isRange&&e.isInRange?" calendar-range":"")+(e.isStartDate?" calendar-range-start":"")+(e.isEndDate?" calendar-range-end":"")+'">\n      <button class="date-item'+(e.isToday?" is-today":"")+(e.isStartDate?" is-active":"")+'">'+e.date.getDate()+"</button>\n  </div>"}).join("")};},function(e,t,n){var o={"./_lib/build_formatting_tokens_reg_exp":1,"./_lib/build_formatting_tokens_reg_exp/":1,"./_lib/build_formatting_tokens_reg_exp/index":1,"./_lib/build_formatting_tokens_reg_exp/index.js":1,"./_lib/package":160,"./_lib/package.json":160,"./ar":82,"./ar/":82,"./ar/build_distance_in_words_locale":12,"./ar/build_distance_in_words_locale/":12,"./ar/build_distance_in_words_locale/index":12,"./ar/build_distance_in_words_locale/index.js":12,"./ar/build_format_locale":13,"./ar/build_format_locale/":13,"./ar/build_format_locale/index":13,"./ar/build_format_locale/index.js":13,"./ar/index":82,"./ar/index.js":82,"./ar/package":161,"./ar/package.json":161,"./bg":83,"./bg/":83,"./bg/build_distance_in_words_locale":14,"./bg/build_distance_in_words_locale/":14,"./bg/build_distance_in_words_locale/index":14,"./bg/build_distance_in_words_locale/index.js":14,"./bg/build_format_locale":15,"./bg/build_format_locale/":15,"./bg/build_format_locale/index":15,"./bg/build_format_locale/index.js":15,"./bg/index":83,"./bg/index.js":83,"./bg/package":162,"./bg/package.json":162,"./ca":84,"./ca/":84,"./ca/build_distance_in_words_locale":16,"./ca/build_distance_in_words_locale/":16,"./ca/build_distance_in_words_locale/index":16,"./ca/build_distance_in_words_locale/index.js":16,"./ca/build_format_locale":17,"./ca/build_format_locale/":17,"./ca/build_format_locale/index":17,"./ca/build_format_locale/index.js":17,"./ca/index":84,"./ca/index.js":84,"./ca/package":163,"./ca/package.json":163,"./cs":85,"./cs/":85,"./cs/build_distance_in_words_locale":18,"./cs/build_distance_in_words_locale/":18,"./cs/build_distance_in_words_locale/index":18,"./cs/build_distance_in_words_locale/index.js":18,"./cs/build_format_locale":19,"./cs/build_format_locale/":19,"./cs/build_format_locale/index":19,"./cs/build_format_locale/index.js":19,"./cs/index":85,"./cs/index.js":85,"./cs/package":164,"./cs/package.json":164,"./da":86,"./da/":86,"./da/build_distance_in_words_locale":20,"./da/build_distance_in_words_locale/":20,"./da/build_distance_in_words_locale/index":20,"./da/build_distance_in_words_locale/index.js":20,"./da/build_format_locale":21,"./da/build_format_locale/":21,"./da/build_format_locale/index":21,"./da/build_format_locale/index.js":21,"./da/index":86,"./da/index.js":86,"./da/package":165,"./da/package.json":165,"./de":87,"./de/":87,"./de/build_distance_in_words_locale":22,"./de/build_distance_in_words_locale/":22,"./de/build_distance_in_words_locale/index":22,"./de/build_distance_in_words_locale/index.js":22,"./de/build_format_locale":23,"./de/build_format_locale/":23,"./de/build_format_locale/index":23,"./de/build_format_locale/index.js":23,"./de/index":87,"./de/index.js":87,"./de/package":166,"./de/package.json":166,"./el":88,"./el/":88,"./el/build_distance_in_words_locale":24,"./el/build_distance_in_words_locale/":24,"./el/build_distance_in_words_locale/index":24,"./el/build_distance_in_words_locale/index.js":24,"./el/build_format_locale":25,"./el/build_format_locale/":25,"./el/build_format_locale/index":25,"./el/build_format_locale/index.js":25,"./el/index":88,"./el/index.js":88,"./el/package":167,"./el/package.json":167,"./en":5,"./en/":5,"./en/build_distance_in_words_locale":10,"./en/build_distance_in_words_locale/":10,"./en/build_distance_in_words_locale/index":10,"./en/build_distance_in_words_locale/index.js":10,"./en/build_format_locale":11,"./en/build_format_locale/":11,"./en/build_format_locale/index":11,"./en/build_format_locale/index.js":11,"./en/index":5,"./en/index.js":5,"./en/package":168,"./en/package.json":168,"./eo":89,"./eo/":89,"./eo/build_distance_in_words_locale":26,"./eo/build_distance_in_words_locale/":26,"./eo/build_distance_in_words_locale/index":26,"./eo/build_distance_in_words_locale/index.js":26,"./eo/build_format_locale":27,"./eo/build_format_locale/":27,"./eo/build_format_locale/index":27,"./eo/build_format_locale/index.js":27,"./eo/index":89,"./eo/index.js":89,"./eo/package":169,"./eo/package.json":169,"./es":90,"./es/":90,"./es/build_distance_in_words_locale":28,"./es/build_distance_in_words_locale/":28,"./es/build_distance_in_words_locale/index":28,"./es/build_distance_in_words_locale/index.js":28,"./es/build_format_locale":29,"./es/build_format_locale/":29,"./es/build_format_locale/index":29,"./es/build_format_locale/index.js":29,"./es/index":90,"./es/index.js":90,"./es/package":170,"./es/package.json":170,"./fi":91,"./fi/":91,"./fi/build_distance_in_words_locale":30,"./fi/build_distance_in_words_locale/":30,"./fi/build_distance_in_words_locale/index":30,"./fi/build_distance_in_words_locale/index.js":30,"./fi/build_format_locale":31,"./fi/build_format_locale/":31,"./fi/build_format_locale/index":31,"./fi/build_format_locale/index.js":31,"./fi/index":91,"./fi/index.js":91,"./fi/package":171,"./fi/package.json":171,"./fil":92,"./fil/":92,"./fil/build_distance_in_words_locale":32,"./fil/build_distance_in_words_locale/":32,"./fil/build_distance_in_words_locale/index":32,"./fil/build_distance_in_words_locale/index.js":32,"./fil/build_format_locale":33,"./fil/build_format_locale/":33,"./fil/build_format_locale/index":33,"./fil/build_format_locale/index.js":33,"./fil/index":92,"./fil/index.js":92,"./fil/package":172,"./fil/package.json":172,"./fr":93,"./fr/":93,"./fr/build_distance_in_words_locale":34,"./fr/build_distance_in_words_locale/":34,"./fr/build_distance_in_words_locale/index":34,"./fr/build_distance_in_words_locale/index.js":34,"./fr/build_format_locale":35,"./fr/build_format_locale/":35,"./fr/build_format_locale/index":35,"./fr/build_format_locale/index.js":35,"./fr/index":93,"./fr/index.js":93,"./fr/package":173,"./fr/package.json":173,"./hr":94,"./hr/":94,"./hr/build_distance_in_words_locale":36,"./hr/build_distance_in_words_locale/":36,"./hr/build_distance_in_words_locale/index":36,"./hr/build_distance_in_words_locale/index.js":36,"./hr/build_format_locale":37,"./hr/build_format_locale/":37,"./hr/build_format_locale/index":37,"./hr/build_format_locale/index.js":37,"./hr/index":94,"./hr/index.js":94,"./hr/package":174,"./hr/package.json":174,"./hu":95,"./hu/":95,"./hu/build_distance_in_words_locale":38,"./hu/build_distance_in_words_locale/":38,"./hu/build_distance_in_words_locale/index":38,"./hu/build_distance_in_words_locale/index.js":38,"./hu/build_format_locale":39,"./hu/build_format_locale/":39,"./hu/build_format_locale/index":39,"./hu/build_format_locale/index.js":39,"./hu/index":95,"./hu/index.js":95,"./hu/package":175,"./hu/package.json":175,"./id":96,"./id/":96,"./id/build_distance_in_words_locale":40,"./id/build_distance_in_words_locale/":40,"./id/build_distance_in_words_locale/index":40,"./id/build_distance_in_words_locale/index.js":40,"./id/build_format_locale":41,"./id/build_format_locale/":41,"./id/build_format_locale/index":41,"./id/build_format_locale/index.js":41,"./id/index":96,"./id/index.js":96,"./id/package":176,"./id/package.json":176,"./is":97,"./is/":97,"./is/build_distance_in_words_locale":42,"./is/build_distance_in_words_locale/":42,"./is/build_distance_in_words_locale/index":42,"./is/build_distance_in_words_locale/index.js":42,"./is/build_format_locale":43,"./is/build_format_locale/":43,"./is/build_format_locale/index":43,"./is/build_format_locale/index.js":43,"./is/index":97,"./is/index.js":97,"./is/package":177,"./is/package.json":177,"./it":98,"./it/":98,"./it/build_distance_in_words_locale":44,"./it/build_distance_in_words_locale/":44,"./it/build_distance_in_words_locale/index":44,"./it/build_distance_in_words_locale/index.js":44,"./it/build_format_locale":45,"./it/build_format_locale/":45,"./it/build_format_locale/index":45,"./it/build_format_locale/index.js":45,"./it/index":98,"./it/index.js":98,"./it/package":178,"./it/package.json":178,"./ja":99,"./ja/":99,"./ja/build_distance_in_words_locale":46,"./ja/build_distance_in_words_locale/":46,"./ja/build_distance_in_words_locale/index":46,"./ja/build_distance_in_words_locale/index.js":46,"./ja/build_format_locale":47,"./ja/build_format_locale/":47,"./ja/build_format_locale/index":47,"./ja/build_format_locale/index.js":47,"./ja/index":99,"./ja/index.js":99,"./ja/package":179,"./ja/package.json":179,"./ko":100,"./ko/":100,"./ko/build_distance_in_words_locale":48,"./ko/build_distance_in_words_locale/":48,"./ko/build_distance_in_words_locale/index":48,"./ko/build_distance_in_words_locale/index.js":48,"./ko/build_format_locale":49,"./ko/build_format_locale/":49,"./ko/build_format_locale/index":49,"./ko/build_format_locale/index.js":49,"./ko/index":100,"./ko/index.js":100,"./ko/package":180,"./ko/package.json":180,"./mk":101,"./mk/":101,"./mk/build_distance_in_words_locale":50,"./mk/build_distance_in_words_locale/":50,"./mk/build_distance_in_words_locale/index":50,"./mk/build_distance_in_words_locale/index.js":50,"./mk/build_format_locale":51,"./mk/build_format_locale/":51,"./mk/build_format_locale/index":51,"./mk/build_format_locale/index.js":51,"./mk/index":101,"./mk/index.js":101,"./mk/package":181,"./mk/package.json":181,"./nb":102,"./nb/":102,"./nb/build_distance_in_words_locale":52,"./nb/build_distance_in_words_locale/":52,"./nb/build_distance_in_words_locale/index":52,"./nb/build_distance_in_words_locale/index.js":52,"./nb/build_format_locale":53,"./nb/build_format_locale/":53,"./nb/build_format_locale/index":53,"./nb/build_format_locale/index.js":53,"./nb/index":102,"./nb/index.js":102,"./nb/package":182,"./nb/package.json":182,"./nl":103,"./nl/":103,"./nl/build_distance_in_words_locale":54,"./nl/build_distance_in_words_locale/":54,"./nl/build_distance_in_words_locale/index":54,"./nl/build_distance_in_words_locale/index.js":54,"./nl/build_format_locale":55,"./nl/build_format_locale/":55,"./nl/build_format_locale/index":55,"./nl/build_format_locale/index.js":55,"./nl/index":103,"./nl/index.js":103,"./nl/package":183,"./nl/package.json":183,"./package":184,"./package.json":184,"./pl":104,"./pl/":104,"./pl/build_distance_in_words_locale":56,"./pl/build_distance_in_words_locale/":56,"./pl/build_distance_in_words_locale/index":56,"./pl/build_distance_in_words_locale/index.js":56,"./pl/build_format_locale":57,"./pl/build_format_locale/":57,"./pl/build_format_locale/index":57,"./pl/build_format_locale/index.js":57,"./pl/index":104,"./pl/index.js":104,"./pl/package":185,"./pl/package.json":185,"./pt":105,"./pt/":105,"./pt/build_distance_in_words_locale":58,"./pt/build_distance_in_words_locale/":58,"./pt/build_distance_in_words_locale/index":58,"./pt/build_distance_in_words_locale/index.js":58,"./pt/build_format_locale":59,"./pt/build_format_locale/":59,"./pt/build_format_locale/index":59,"./pt/build_format_locale/index.js":59,"./pt/index":105,"./pt/index.js":105,"./pt/package":186,"./pt/package.json":186,"./ro":106,"./ro/":106,"./ro/build_distance_in_words_locale":60,"./ro/build_distance_in_words_locale/":60,"./ro/build_distance_in_words_locale/index":60,"./ro/build_distance_in_words_locale/index.js":60,"./ro/build_format_locale":61,"./ro/build_format_locale/":61,"./ro/build_format_locale/index":61,"./ro/build_format_locale/index.js":61,"./ro/index":106,"./ro/index.js":106,"./ro/package":187,"./ro/package.json":187,"./ru":107,"./ru/":107,"./ru/build_distance_in_words_locale":62,"./ru/build_distance_in_words_locale/":62,"./ru/build_distance_in_words_locale/index":62,"./ru/build_distance_in_words_locale/index.js":62,"./ru/build_format_locale":63,"./ru/build_format_locale/":63,"./ru/build_format_locale/index":63,"./ru/build_format_locale/index.js":63,"./ru/index":107,"./ru/index.js":107,"./ru/package":188,"./ru/package.json":188,"./sk":108,"./sk/":108,"./sk/build_distance_in_words_locale":64,"./sk/build_distance_in_words_locale/":64,"./sk/build_distance_in_words_locale/index":64,"./sk/build_distance_in_words_locale/index.js":64,"./sk/build_format_locale":65,"./sk/build_format_locale/":65,"./sk/build_format_locale/index":65,"./sk/build_format_locale/index.js":65,"./sk/index":108,"./sk/index.js":108,"./sk/package":189,"./sk/package.json":189,"./sl":109,"./sl/":109,"./sl/build_distance_in_words_locale":66,"./sl/build_distance_in_words_locale/":66,"./sl/build_distance_in_words_locale/index":66,"./sl/build_distance_in_words_locale/index.js":66,"./sl/build_format_locale":67,"./sl/build_format_locale/":67,"./sl/build_format_locale/index":67,"./sl/build_format_locale/index.js":67,"./sl/index":109,"./sl/index.js":109,"./sl/package":190,"./sl/package.json":190,"./sv":110,"./sv/":110,"./sv/build_distance_in_words_locale":68,"./sv/build_distance_in_words_locale/":68,"./sv/build_distance_in_words_locale/index":68,"./sv/build_distance_in_words_locale/index.js":68,"./sv/build_format_locale":69,"./sv/build_format_locale/":69,"./sv/build_format_locale/index":69,"./sv/build_format_locale/index.js":69,"./sv/index":110,"./sv/index.js":110,"./sv/package":191,"./sv/package.json":191,"./th":111,"./th/":111,"./th/build_distance_in_words_locale":70,"./th/build_distance_in_words_locale/":70,"./th/build_distance_in_words_locale/index":70,"./th/build_distance_in_words_locale/index.js":70,"./th/build_format_locale":71,"./th/build_format_locale/":71,"./th/build_format_locale/index":71,"./th/build_format_locale/index.js":71,"./th/index":111,"./th/index.js":111,"./th/package":192,"./th/package.json":192,"./tr":112,"./tr/":112,"./tr/build_distance_in_words_locale":72,"./tr/build_distance_in_words_locale/":72,"./tr/build_distance_in_words_locale/index":72,"./tr/build_distance_in_words_locale/index.js":72,"./tr/build_format_locale":73,"./tr/build_format_locale/":73,"./tr/build_format_locale/index":73,"./tr/build_format_locale/index.js":73,"./tr/index":112,"./tr/index.js":112,"./tr/package":193,"./tr/package.json":193,"./zh_cn":113,"./zh_cn/":113,"./zh_cn/build_distance_in_words_locale":74,"./zh_cn/build_distance_in_words_locale/":74,"./zh_cn/build_distance_in_words_locale/index":74,"./zh_cn/build_distance_in_words_locale/index.js":74,"./zh_cn/build_format_locale":75,"./zh_cn/build_format_locale/":75,"./zh_cn/build_format_locale/index":75,"./zh_cn/build_format_locale/index.js":75,"./zh_cn/index":113,"./zh_cn/index.js":113,"./zh_cn/package":194,"./zh_cn/package.json":194,"./zh_tw":114,"./zh_tw/":114,"./zh_tw/build_distance_in_words_locale":76,"./zh_tw/build_distance_in_words_locale/":76,"./zh_tw/build_distance_in_words_locale/index":76,"./zh_tw/build_distance_in_words_locale/index.js":76,"./zh_tw/build_format_locale":77,"./zh_tw/build_format_locale/":77,"./zh_tw/build_format_locale/index":77,"./zh_tw/build_format_locale/index.js":77,"./zh_tw/index":114,"./zh_tw/index.js":114,"./zh_tw/package":195,"./zh_tw/package.json":195};function r(e){return n(i(e))}function i(e){var t=o[e];if(!(t+1))throw new Error("Cannot find module '"+e+"'.");return t}r.keys=function(){return Object.keys(o)},r.resolve=i,(e.exports=r).id=304;},function(e,t,n){var o=n(306),i=n(307),a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var u="carousel:ready",c="carousel:slide:before",l="carousel:slide:after",d=Symbol("onSwipeStart"),f=Symbol("onSwipeMove"),h=Symbol("onSwipeEnd"),m=!1;try{var r=Object.defineProperty({},"passive",{get:function(){m=!0;}});window.addEventListener("testPassive",null,r),window.removeEventListener("testPassive",null,r);}catch(e){}var p=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element="string"==typeof e?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=a({},i.a,t),n.element.dataset.autoplay&&(n.options.autoplay=n.element.dataset.autoplay),n.element.dataset.delay&&(n.options.delay=n.element.dataset.delay),n.element.dataset.size&&!n.element.classList.contains("carousel-animate-fade")&&(n.options.size=n.element.dataset.size),n.element.classList.contains("carousel-animate-fade")&&(n.options.size=1),n.forceHiddenNavigation=!1,n[d]=n[d].bind(n),n[f]=n[f].bind(n),n[h]=n[h].bind(n),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),s(r,[{key:"init",value:function(){this.container=this.element.querySelector(".carousel-container"),this.items=this.element.querySelectorAll(".carousel-item"),this.currentItem={element:this.element,node:this.element.querySelector(".carousel-item.is-active"),pos:-1},this.currentItem.pos=this.currentItem.node?Array.from(this.items).indexOf(this.currentItem.node):-1,this.currentItem.node||(this.currentItem.node=this.items[0],this.currentItem.node.classList.add("is-active"),this.currentItem.pos=0),this.forceHiddenNavigation=this.items.length<=1;var e=this.element.querySelectorAll("img");[].forEach.call(e,function(e){e.setAttribute("draggable",!1);}),this._resize(),this._setOrder(),this._initNavigation(),this._bindEvents(),this.options.autoplay&&this._autoPlay(this.options.delay),this.emit(u,this.currentItem);}},{key:"_resize",value:function(){var t=this,e=window.getComputedStyle(this.element),n=parseInt(e.getPropertyValue("width"),10);if(1<this.options.size&&(this.options.size>=Array.from(this.items).length?this.offset=0:this.offset=n/this.options.size,this.container.style.left=0-this.offset+"px",this.container.style.transform="translateX("+this.offset+"px)",[].forEach.call(this.items,function(e){e.style.flexBasis=t.offset+"px";})),this.element.classList.contains("carousel-animate-fade")&&this.items.length){var o=this.items[0].querySelector("img"),r=1;o.naturalWidth?(r=n/o.naturalWidth,this.container.style.height=o.naturalHeight*r+"px"):o.onload=function(){r=n/o.naturalWidth,t.container.style.height=o.naturalHeight*r+"px";};}}},{key:"_bindEvents",value:function(){var t=this;this.previousControl&&this._clickEvents.forEach(function(e){t.previousControl.addEventListener(e,function(e){m||e.preventDefault(),t._autoPlayInterval&&(clearInterval(t._autoPlayInterval),t._autoPlay(t.optionsdelay)),t._slide("previous");},!!m&&{passive:!0});}),this.nextControl&&this._clickEvents.forEach(function(e){t.nextControl.addEventListener(e,function(e){m||e.preventDefault(),t._autoPlayInterval&&(clearInterval(t._autoPlayInterval),t._autoPlay(t.options.delay)),t._slide("next");},!!m&&{passive:!0});}),this.element.addEventListener("touchstart",this[d],!!m&&{passive:!0}),this.element.addEventListener("mousedown",this[d],!!m&&{passive:!0}),this.element.addEventListener("touchmove",this[f],!!m&&{passive:!0}),this.element.addEventListener("mousemove",this[f],!!m&&{passive:!0}),this.element.addEventListener("touchend",this[h],!!m&&{passive:!0}),this.element.addEventListener("mouseup",this[h],!!m&&{passive:!0});}},{key:"destroy",value:function(){this.element.removeEventListener("touchstart",this[d],!!m&&{passive:!0}),this.element.removeEventListener("mousedown",this[d],!!m&&{passive:!0}),this.element.removeEventListener("touchmove",this[f],!!m&&{passive:!0}),this.element.removeEventListener("mousemove",this[f],!!m&&{passive:!0}),this.element.removeEventListener("touchend",this[h],!!m&&{passive:!0}),this.element.removeEventListener("mouseup",this[h],!!m&&{passive:!0});}},{key:d,value:function(e){m||e.preventDefault(),e="changedTouches"in(e=e||window.event)?e.changedTouches[0]:e,this._touch={start:{time:(new Date).getTime(),x:e.pageX,y:e.pageY},dist:{x:0,y:0}};}},{key:f,value:function(e){m||e.preventDefault();}},{key:h,value:function(e){m||e.preventDefault(),e="changedTouches"in(e=e||window.event)?e.changedTouches[0]:e,this._touch.dist={x:e.pageX-this._touch.start.x,y:e.pageY-this._touch.start.y},this._handleGesture();}},{key:"_handleGesture",value:function(){(new Date).getTime()-this._touch.start.time<=this.options.allowedTime&&Math.abs(this._touch.dist.x)>=this.options.threshold&&Math.abs(this._touch.dist.y)<=this.options.restraint&&(this._touch.dist.x<0?this._slide("next"):this._slide("previous"));}},{key:"_initNavigation",value:function(){this.previousControl=this.element.querySelector(".carousel-nav-left"),this.nextControl=this.element.querySelector(".carousel-nav-right"),(this.items.length<=1||this.forceHiddenNavigation)&&(this.container&&(this.container.style.left="0"),this.previousControl&&(this.previousControl.style.display="none"),this.nextControl&&(this.nextControl.style.display="none"));}},{key:"_setOrder",value:function(){this.currentItem.node.style.order="1",this.currentItem.node.style.zIndex="1";var e,t=this.currentItem.node,n=void 0,o=void 0;for(n=o=2,e=Array.from(this.items).length;2<=e?o<=e:e<=o;n=2<=e?++o:--o)(t=this._next(t)).style.order=""+n%Array.from(this.items).length,t.style.zIndex="0";}},{key:"_next",value:function(e){return e.nextElementSibling?e.nextElementSibling:this.items[0]}},{key:"_previous",value:function(e){return e.previousElementSibling?e.previousElementSibling:this.items[this.items.length-1]}},{key:"_slide",value:function(){var e=this,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"next";this.items.length&&(this.oldItemNode=this.currentItem.node,this.emit(c,this.currentItem),"previous"===t?(this.currentItem.node=this._previous(this.currentItem.node),this.element.classList.contains("carousel-animate-fade")||(this.element.classList.add("is-reversing"),this.container.style.transform="translateX("+-Math.abs(this.offset)+"px)")):(this.currentItem.node=this._next(this.currentItem.node),this.element.classList.remove("is-reversing"),this.container.style.transform="translateX("+Math.abs(this.offset)+"px)"),this.currentItem.node.classList.add("is-active"),this.oldItemNode.classList.remove("is-active"),this.element.classList.remove("carousel-animated"),setTimeout(function(){e.element.classList.add("carousel-animated");},50),this._setOrder(),this.emit(l,this.currentItem));}},{key:"_autoPlay",value:function(){var e=this,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:5e3;this._autoPlayInterval=setInterval(function(){e._slide("next");},t);}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:".carousel, .hero-carousel",t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=p;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={size:1,autoplay:!1,delay:5e3,threshold:50,restraint:100,allowedTime:500};},function(e,t,n){var o=n(309),i=n(310),c=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],o=!0,r=!1,i=void 0;try{for(var a,s=e[Symbol.iterator]();!(o=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);o=!0);}catch(e){r=!0,i=e;}finally{try{!o&&s.return&&s.return();}finally{if(r)throw i}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element="string"==typeof e?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=a({},i.a,t),n.icons=[],n.id="iconPicker"+(new Date).getTime(),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),s(r,[{key:"init",value:function(){var r=this;this.createModal(),this.createPreview(),this.options.iconSets.forEach(function(n){var o;o=n.css,new Promise(function(e,t){var n=document.createElement("link");n.type="text/css",n.rel="stylesheet",n.onload=function(){e();},n.href=o,document.querySelector('link[href="'+o+'"]')||document.querySelector("head").append(n);}),fetch(n.css,{mode:"cors"}).then(function(e){return e.text()}).then(function(e){r.icons[n.name]=r.parseCSS(e,n.prefix||"fa-",n.displayPrefix||""),r.modalSetTabs.querySelector("a").click();var t=new Event("touchstart");r.modalSetTabs.querySelector("a").dispatchEvent(t);});});}},{key:"createPreview",value:function(){var t=this;this.preview=document.createElement("div"),this.preview.className="icon is-large",this.preview.classList.add("iconpicker-preview");var n=document.createElement("i");(n.className="iconpicker-icon-preview",this.element.value.length)&&this.element.value.split(" ").forEach(function(e){n.classList.add(e);});this.preview.appendChild(n),this._clickEvents.forEach(function(e){t.preview.addEventListener(e,function(e){e.preventDefault(),t.modal.classList.add("is-active");});}),this.element.parentNode.insertBefore(this.preview,this.element.nextSibling);}},{key:"parseCSS",value:function(e){for(var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"fa-",n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"",o=new RegExp("\\."+t+"([^\\.!:]*)::?before\\s*{\\s*content:\\s*[\"|']\\\\[^'|\"]*[\"|'];?\\s*}","g"),r=[],i=void 0,a=void 0;a=o.exec(e);)i={prefix:t,selector:t+a[1].trim(":"),name:this.ucwords(a[1]).trim(":"),filter:a[1].trim(":"),displayPrefix:n},r[a[1]]=i;return 0==Object.getOwnPropertyNames(this.icons).length&&console.warn("No icons found in CSS file"),r}},{key:"ucwords",value:function(e){return (e+"").replace(/^(.)|\s+(.)/g,function(e){return e.toUpperCase()})}},{key:"drawIcons",value:function(e){if(this.iconsList.innerHTML="",e){var t=!0,n=!1,o=void 0;try{for(var r,i=Object.entries(e)[Symbol.iterator]();!(t=(r=i.next()).done);t=!0){var a=r.value,s=c(a,2),u=(s[0],s[1]);this.iconsList.appendChild(this.createIconPreview(u));}}catch(e){n=!0,o=e;}finally{try{!t&&i.return&&i.return();}finally{if(n)throw o}}}}},{key:"createIconPreview",value:function(e){var t=this,n=(document.createElement("a"));n.dataset.title=e.name,n.setAttribute("title",e.name),n.dataset.icon=e.selector,n.dataset.filter=e.filter;var o=document.createElement("i");return o.className="iconpicker-icon-preview",e.displayPrefix.length&&e.displayPrefix.split(" ").forEach(function(e){o.classList.add(e);}),o.classList.add(e.selector),n.appendChild(o),this._clickEvents.forEach(function(e){n.addEventListener(e,function(e){e.preventDefault(),t.preview.innerHTML="",t.element.value=e.target.classList,t.element.dispatchEvent(new Event("change")),t.preview.appendChild(e.target.cloneNode(!0)),t.modal.classList.remove("is-active");});}),n}},{key:"createModal",value:function(){var o=this;this.modal=document.createElement("div"),this.modal.className="modal",this.modal.classList.add("iconpicker-modal"),this.modal.id=this.id;var e=document.createElement("div");e.className="modal-background";var t=document.createElement("div");t.className="modal-card";var n=document.createElement("header");n.className="modal-card-head";var r=document.createElement("p");r.className="modal-card-title",r.innerHTML="iconPicker",this.modalHeaderSearch=document.createElement("input"),this.modalHeaderSearch.setAttribute("type","search"),this.modalHeaderSearch.setAttribute("placeholder","Search"),this.modalHeaderSearch.className="iconpicker-search",this.modalHeaderSearch.addEventListener("input",function(e){o.filter(e.target.value);});var i=document.createElement("button");if(i.className="delete",this._clickEvents.forEach(function(e){i.addEventListener(e,function(e){e.preventDefault(),o.modal.classList.remove("is-active");});}),t.appendChild(n),this.modalBody=document.createElement("section"),this.modalBody.className="modal-card-body",1<=this.options.iconSets.length){var a=document.createElement("div");a.className="iconpicker-sets",a.classList.add("tabs"),this.modalSetTabs=document.createElement("ul"),this.options.iconSets.forEach(function(e){var t=document.createElement("li"),n=document.createElement("a");n.dataset.iconset=e.name,n.innerHTML=e.name,o._clickEvents.forEach(function(e){n.addEventListener(e,function(e){e.preventDefault();var t=o.modalSetTabs.querySelectorAll(".is-active");[].forEach.call(t,function(e){e.classList.remove("is-active");}),e.target.parentNode.classList.add("is-active"),o.drawIcons(o.icons[e.target.dataset.iconset]),o.filter(o.modalHeaderSearch.value);});}),t.appendChild(n),o.modalSetTabs.appendChild(t);}),a.appendChild(this.modalSetTabs),t.appendChild(a);}this.iconsList=document.createElement("div"),this.iconsList.className="iconpicker-icons",n.appendChild(r),n.appendChild(this.modalHeaderSearch),n.appendChild(i),this.modalBody.appendChild(this.iconsList),t.appendChild(this.modalBody),this.modal.appendChild(e),this.modal.appendChild(t),document.body.appendChild(this.modal);}},{key:"filter",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"";""!==e?(this.iconsList.querySelectorAll("[data-filter]").forEach(function(e){e.classList.remove("is-hidden");}),this.iconsList.querySelectorAll('[data-filter]:not([data-filter*="'+e+'"])').forEach(function(e){e.classList.add("is-hidden");})):this.iconsList.querySelectorAll("[data-filter]").forEach(function(e){e.classList.remove("is-hidden");});}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'[data-action="iconPicker"]',t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=r;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={iconSets:[{name:"simpleLine",css:"https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.4.1/css/simple-line-icons.css",prefix:"icon-",displayPrefix:""},{name:"fontAwesome",css:"https://use.fontawesome.com/releases/v5.0.13/css/all.css",prefix:"fa-",displayPrefix:"fas fa-icon"}]};},function(e,t,n){var o=n(312),i=n(313),a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var u=Symbol("onQuickviewShowClick"),c=Symbol("onQuickviewDismissClick"),r=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element="string"==typeof e?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=a({},i.a,t),n[u]=n[u].bind(n),n[c]=n[c].bind(n),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),s(r,[{key:"init",value:function(){this.quickview=document.getElementById(this.element.dataset.target),this.dismissElements=document.querySelectorAll('[data-dismiss="quickview"]'),this._bindEvents(),this.emit("quickview:ready",{element:this.element,quickview:this.quickview});}},{key:"_bindEvents",value:function(){var n=this;this._clickEvents.forEach(function(e){n.element.addEventListener(e,n[u],!1);}),[].forEach.call(this.dismissElements,function(t){n._clickEvents.forEach(function(e){t.addEventListener(e,n[c],!1);});});}},{key:u,value:function(e){this.quickview.classList.add("is-active"),this.emit("quickview:show",{element:this.element,quickview:this.quickview});}},{key:c,value:function(e){this.quickview.classList.remove("is-active"),this.emit("quickview:hide",{element:this.element,quickview:this.quickview});}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'[data-show="quickview"]',t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=r;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={};},function(e,t,n){var o=n(315),i=n(316),a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var u=Symbol("onSliderInput"),r=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element="string"==typeof e?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=a({},i.a,t),n[u]=n[u].bind(n),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),s(r,[{key:"init",value:function(){if(this._id="bulmaSlider"+(new Date).getTime()+Math.floor(Math.random()*Math.floor(9999)),this.output=this._findOutputForSlider(),this.output&&this.element.classList.contains("has-output-tooltip")){var e=this._getSliderOutputPosition();this.output.style.left=e.position;}this.emit("bulmaslider:ready",this.element.value);}},{key:"_findOutputForSlider",value:function(){var t=this,e=document.getElementsByTagName("output");return [].forEach.call(e,function(e){if(e.htmlFor==t.element.getAttribute("id"))return e}),null}},{key:"_getSliderOutputPosition",value:function(){var e,t=window.getComputedStyle(this.element,null),n=parseInt(t.getPropertyValue("width"),10);e=this.element.getAttribute("min")?this.element.getAttribute("min"):0;var o=(this.element.value-e)/(this.element.getAttribute("max")-e);return {position:(o<0?0:1<o?n:n*o)+"px"}}},{key:"_bindEvents",value:function(){this.output&&this.element.addEventListener("input",this[u],!1);}},{key:u,value:function(e){if(e.preventDefault(),this.element.classList.contains("has-output-tooltip")){var t=this._getSliderOutputPosition();this.output.style.left=t.position;}var n=this.output.hasAttribute("data-prefix")?this.output.getAttribute("data-prefix"):"",o=this.output.hasAttribute("data-postfix")?this.output.getAttribute("data-postfix"):"";this.output.value=n+this.element.value+o,this.emit("bulmaslider:ready",this.element.value);}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'input[type="range"].slider',t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=r;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={};},function(e,t,n){var o=n(318),i=n(319),a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var u=Symbol("onStepsPrevious"),c=Symbol("onStepsNext"),r=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element="string"==typeof e?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=a({},i.a,t),n[u]=n[u].bind(n),n[c]=n[c].bind(n),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),s(r,[{key:"init",value:function(){this._id="bulmaSteps"+(new Date).getTime()+Math.floor(Math.random()*Math.floor(9999)),this.steps=this.element.querySelectorAll(this.options.selector),this.contents=this.element.querySelectorAll(this.options.selector_content),this.previous_btn=this.element.querySelector(this.options.previous_selector),this.next_btn=this.element.querySelector(this.options.next_selector),[].forEach.call(this.steps,function(e,t){e.setAttribute("data-step-id",t);}),this.steps&&this.steps.length&&(this.activate_step(0),this.updateActions(this.steps[0])),this._bindEvents(),this.emit("bulmasteps:ready",this.element.value);}},{key:"_bindEvents",value:function(){var n=this;null!=this.previous_btn&&this._clickEvents.forEach(function(e){n.previous_btn.addEventListener(e,n[u],!1);}),null!=this.next_btn&&this._clickEvents.forEach(function(e){n.next_btn.addEventListener(e,n[c],!1);}),this.options.stepClickable&&[].forEach.call(this.steps,function(e,t){n._clickEvents.forEach(function(e){for(;t>n.current_id;)n[c](e);for(;t<n.current_id;)n[u](e);});});}},{key:u,value:function(e){e.preventDefault(),e.target.getAttribute("disabled")||this.previous_step();}},{key:c,value:function(e){e.preventDefault(),e.target.getAttribute("disabled")||this.next_step();}},{key:"get_current_step_id",value:function(){for(var e=0;e<this.steps.length;e++){var t=this.steps[e];if(t.classList.contains(this.options.active_class))return parseInt(t.getAttribute("data-step-id"))}return null}},{key:"updateActions",value:function(e){var t=parseInt(e.getAttribute("data-step-id"));0==t?(null!=this.previous_btn&&this.previous_btn.setAttribute("disabled","disabled"),null!=this.next_btn&&this.next_btn.removeAttribute("disabled","disabled")):t==this.steps.length-1?(null!=this.previous_btn&&this.previous_btn.removeAttribute("disabled","disabled"),null!=this.next_btn&&this.next_btn.setAttribute("disabled","disabled")):(null!=this.previous_btn&&this.previous_btn.removeAttribute("disabled","disabled"),null!=this.next_btn&&this.next_btn.removeAttribute("disabled","disabled"));}},{key:"next_step",value:function(){var e=this.get_current_step_id();if(null!=e){var t=e+1,n=[];if(void 0!==this.options.beforeNext&&null!=this.options.beforeNext&&this.options.beforeNext&&(n=this.options.beforeNext(e)),this.emit("bulmasteps:before:next",e),void 0===n&&(n=[]),0<n.length){this.emit("bulmasteps:errors",n);for(var o=0;o<n.length;o++)void 0!==this.options.onError&&null!=this.options.onError&&this.options.onError&&this.options.onError(n[o]);}else t>=this.steps.length-1&&(void 0!==this.options.onFinish&&null!=this.options.onFinish&&this.options.onFinish&&this.options.onFinish(e),this.emit("bulmasteps:finish",e)),t<this.steps.length&&(this.complete_step(e),this.activate_step(t));}}},{key:"previous_step",value:function(){var e=this.get_current_step_id();null!=e&&(this.uncomplete_step(e-1),this.activate_step(e-1));}},{key:"activate_step",value:function(e){this.updateActions(this.steps[e]);for(var t=0;t<this.steps.length;t++){this.steps[t]!=this.steps[e]&&this.deactivate_step(t);}this.steps[e].classList.add(this.options.active_class),void 0!==this.contents[e]&&this.contents[e].classList.add(this.options.active_class),void 0!==this.options.onShow&&null!=this.options.onShow&&this.options.onShow&&this.options.onShow(e),this.emit("bulmasteps:step:show",e);}},{key:"complete_step",value:function(e){this.steps[e].classList.add(this.options.completed_class),this.emit("bulmasteps:step:completed",e);}},{key:"uncomplete_step",value:function(e){this.steps[e].classList.remove(this.options.completed_class),this.emit("bulmasteps:step:uncompleted",e);}},{key:"deactivate_step",value:function(e){this.steps[e].classList.remove(this.options.active_class),void 0!==this.contents[e]&&this.contents[e].classList.remove(this.options.active_class);}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:".steps",t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=r;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={selector:".step-item",selector_content:".step-content",previous_selector:'[data-nav="previous"]',next_selector:'[data-nav="next"]',active_class:"is-active",completed_class:"is-completed",stepClickable:!1,beforeNext:null,onShow:null,onFinish:null,onError:null};},function(e,t,n){var o=n(321),i=n(322),a=n(323),s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},u=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(e){function r(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,r);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));if(n.element=a.a(e)?document.querySelector(e):e,!n.element)throw new Error("An invalid selector or non-DOM node has been provided.");return n._clickEvents=["click"],n.options=s({},i.a,t),n.element.dataset.hasOwnProperty("lowercase")&&(n.options.lowercase=n.element.dataset("lowercase")),n.element.dataset.hasOwnProperty("uppercase")&&(n.options.lowercase=n.element.dataset("uppercase")),n.element.dataset.hasOwnProperty("duplicates")&&(n.options.lowercase=n.element.dataset("duplicates")),n.init(),n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}(r,o["a"]),u(r,[{key:"init",value:function(){if(!this.options.disabled){this.tags=[],this.container=document.createElement("div"),this.container.className="tagsinput",this.container.classList.add("field"),this.container.classList.add("is-grouped"),this.container.classList.add("is-grouped-multiline"),this.container.classList.add("input");var e=this.element.getAttribute("type");e&&"tags"!==e||(e="text"),this.input=document.createElement("input"),this.input.setAttribute("type",e),this.element.getAttribute("placeholder")?this.input.setAttribute("placeholder",this.element.getAttribute("placeholder")):this.input.setAttribute("placeholder","Add a Tag"),this.container.appendChild(this.input);var t=this.element.nextSibling;this.element.parentNode[t?"insertBefore":"appendChild"](this.container,t),this.element.style.cssText="position:absolute;left:0;top:0;width:1px;height:1px;opacity:0.01;",this.element.tabIndex=-1,this.enable();}}},{key:"enable",value:function(){var a=this;this.enabled||this.options.disabled||(this.element.addEventListener("focus",function(){a.container.classList.add("is-focused"),a.select(Array.prototype.slice.call(a.container.querySelectorAll(".tag:not(.is-delete)")).pop());}),this.input.addEventListener("focus",function(){a.container.classList.add("is-focused"),a.select(Array.prototype.slice.call(a.container.querySelectorAll(".tag:not(.is-delete)")).pop());}),this.input.addEventListener("blur",function(){a.container.classList.remove("is-focused"),a.select(Array.prototype.slice.call(a.container.querySelectorAll(".tag:not(.is-delete)")).pop()),a.savePartial();}),this.input.addEventListener("keydown",function(e){var t=e.charCode||e.keyCode||e.which,n=void 0,o=a.container.querySelector(".tag.is-active"),r=Array.prototype.slice.call(a.container.querySelectorAll(".tag:not(.is-delete)")).pop(),i=a.caretAtStart(a.input);if(o&&(n=a.container.querySelector('[data-tag="'+o.innerHTML.trim()+'"]')),a.setInputWidth(),13===t||t===a.options.delimiter.charCodeAt(0)||188===t||9===t){if(!a.input.value&&(t!==a.options.delimiter.charCodeAt(0)||188===t))return;a.savePartial();}else if(46===t&&n)n.nextSibling?a.select(n.nextSibling.querySelector(".tag")):n.previousSibling&&a.select(n.previousSibling.querySelector(".tag")),a.container.removeChild(n),a.tags.splice(a.tags.indexOf(n.getAttribute("data-tag")),1),a.setInputWidth(),a.save();else if(8===t)if(n)n.previousSibling?a.select(n.previousSibling.querySelector(".tag")):n.nextSibling&&a.select(n.nextSibling.querySelector(".tag")),a.container.removeChild(n),a.tags.splice(a.tags.indexOf(n.getAttribute("data-tag")),1),a.setInputWidth(),a.save();else {if(!r||!i)return;a.select(r);}else if(37===t)if(n)n.previousSibling&&a.select(n.previousSibling.querySelector(".tag"));else {if(!i)return;a.select(r);}else {if(39!==t)return a.select();if(!n)return;a.select(n.nextSibling.querySelector(".tag"));}return e.preventDefault(),!1}),this.input.addEventListener("input",function(){a.element.value=a.getValue(),a.element.dispatchEvent(new Event("input"));}),this.input.addEventListener("paste",function(){return setTimeout(savePartial,0)}),this.container.addEventListener("mousedown",function(e){a.refocus(e);}),this.container.addEventListener("touchstart",function(e){a.refocus(e);}),this.savePartial(this.element.value),this.enabled=!0);}},{key:"disable",value:function(){this.enabled&&!this.options.disabled&&(this.reset(),this.enabled=!1);}},{key:"select",value:function(e){var t=this.container.querySelector(".is-active");t&&t.classList.remove("is-active"),e&&e.classList.add("is-active");}},{key:"addTag",value:function(e){var i=this;if(~e.indexOf(this.options.delimiter)&&(e=e.split(this.options.delimiter)),Array.isArray(e))return e.forEach(function(e){i.addTag(e);});var t=e&&e.trim();if(!t)return !1;if("true"==this.options.lowercase&&(t=t.toLowerCase()),"true"==this.options.uppercase&&(t=t.toUpperCase()),this.options.duplicates||-1===this.tags.indexOf(t)){this.tags.push(t);var n=document.createElement("div");n.className="control",n.setAttribute("data-tag",t);var o=document.createElement("div");o.className="tags",o.classList.add("has-addons");var r=document.createElement("span");if(r.className="tag",r.classList.add("is-active"),this.select(r),r.innerHTML=t,o.appendChild(r),this.options.allowDelete){var a=document.createElement("a");a.className="tag",a.classList.add("is-delete"),this._clickEvents.forEach(function(e){a.addEventListener(e,function(e){var t=void 0,n=e.target.parentNode,o=Array.prototype.slice.call(i.container.querySelectorAll(".tag")).pop(),r=i.caretAtStart(i.input);if(n&&(t=i.container.querySelector('[data-tag="'+n.innerText.trim()+'"]')),t)i.select(t.previousSibling),i.container.removeChild(t),i.tags.splice(i.tags.indexOf(t.getAttribute("data-tag")),1),i.setInputWidth(),i.save();else {if(!o||!r)return;i.select(o);}});}),o.appendChild(a);}n.appendChild(o),this.container.insertBefore(n,this.input);}}},{key:"getValue",value:function(){return this.tags.join(this.options.delimiter)}},{key:"setValue",value:function(e){var t=this;Array.prototype.slice.call(this.container.querySelectorAll(".tag")).forEach(function(e){t.tags.splice(t.tags.indexOf(e.innerHTML),1),t.container.removeChild(e);}),this.savePartial(e);}},{key:"setInputWidth",value:function(){var e=Array.prototype.slice.call(this.container.querySelectorAll(".control")).pop();this.container.offsetWidth&&(this.input.style.width=Math.max(this.container.offsetWidth-(e?e.offsetLeft+e.offsetWidth:30)-30,this.container.offsetWidth/4)+"px");}},{key:"savePartial",value:function(e){"string"==typeof e||Array.isArray(e)||(e=this.input.value),!1!==this.addTag(e)&&(this.input.value="",this.save(),this.setInputWidth());}},{key:"save",value:function(){this.element.value=this.tags.join(this.options.delimiter),this.element.dispatchEvent(new Event("change"));}},{key:"caretAtStart",value:function(t){try{return 0===t.selectionStart&&0===t.selectionEnd}catch(e){return ""===t.value}}},{key:"refocus",value:function(e){return e.target.classList.contains("tag")&&this.select(e.target),e.target===this.input?this.select():(this.input.focus(),e.preventDefault(),!1)}},{key:"reset",value:function(){this.tags=[];}},{key:"destroy",value:function(){this.disable(),this.reset(),this.element=null;}}],[{key:"attach",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'input[type="tags"]',t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=new Array,o=document.querySelectorAll(e);return [].forEach.call(o,function(e){setTimeout(function(){n.push(new r(e,t));},100);}),n}}]),r}();t.a=r;},function(e,t,n){var o=function(){function o(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e}}();var r=function(){function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._listeners=new Map(e),this._middlewares=new Map;}return o(t,[{key:"listenerCount",value:function(e){return this._listeners.has(e)?this._listeners.get(e).length:0}},{key:"removeListeners",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=1<arguments.length&&void 0!==arguments[1]&&arguments[1];null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeListeners(e,n)}):(this._listeners.delete(e),n&&this.removeMiddleware(e)):this._listeners=new Map;}},{key:"middleware",value:function(e,t){var n=this;Array.isArray(e)?name.forEach(function(e){return n.middleware(e,t)}):(Array.isArray(this._middlewares.get(e))||this._middlewares.set(e,[]),this._middlewares.get(e).push(t));}},{key:"removeMiddleware",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e?Array.isArray(e)?name.forEach(function(e){return t.removeMiddleware(e)}):this._middlewares.delete(e):this._middlewares=new Map;}},{key:"on",value:function(e,t){var n=this,o=2<arguments.length&&void 0!==arguments[2]&&arguments[2];if(Array.isArray(e))e.forEach(function(e){return n.on(e,t)});else {var r=(e=e.toString()).split(/,|, | /);1<r.length?r.forEach(function(e){return n.on(e,t)}):(Array.isArray(this._listeners.get(e))||this._listeners.set(e,[]),this._listeners.get(e).push({once:o,callback:t}));}}},{key:"once",value:function(e,t){this.on(e,t,!0);}},{key:"emit",value:function(n,o){var r=this,i=2<arguments.length&&void 0!==arguments[2]&&arguments[2];n=n.toString();var a=this._listeners.get(n),s=null,u=0,c=i;if(Array.isArray(a))for(a.forEach(function(e,t){i||(s=r._middlewares.get(n),Array.isArray(s)?(s.forEach(function(e){e(o,function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;null!==e&&(o=e),u++;},n);}),u>=s.length&&(c=!0)):c=!0),c&&(e.once&&(a[t]=null),e.callback(o));});-1!==a.indexOf(null);)a.splice(a.indexOf(null),1);}}]),t}();t.a=r;},function(e,t,n){t.a={disabled:!1,delimiter:",",allowDelete:!0,lowercase:!1,uppercase:!1,duplicates:!0};},function(e,t,n){n.d(t,"a",function(){return r});var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=function(e){return "string"==typeof e||!!e&&"object"===(void 0===e?"undefined":o(e))&&"[object String]"===Object.prototype.toString.call(e)};}]).default});
    }(bulmaExtensions_min));

    function plot(mainTitle, xtitle, ytitle, data, plotArea, logScale=null) {

        let dataLayout = {
            title: mainTitle,
            xaxis: { title: xtitle },
            yaxis: { title: ytitle , type: logScale},
            hovermode: 'closest',

            autosize: true,
            height: 450,
        };

        // if (filetype == 'mass') { dataLayout.yaxis.type = "log" }

        let dataPlot = [];

        for (let x in data) { dataPlot.push(data[x]); }

        try { Plotly.react(plotArea, dataPlot, dataLayout, { editable: true }); } catch (err) { console.log("Error occured while plotting\n", err); }
    }

    function subplot(mainTitle, xtitle, ytitle, data, plotArea, x2, y2, data2) {

        let dataLayout = {
            title: mainTitle,
            xaxis: { domain: [0, 0.4], title: xtitle },
            yaxis: { title: ytitle },
            xaxis2: { domain: [0.5, 1], title: x2 },
            yaxis2: { anchor: "x2", title: y2, overlaying: 'y', },

            yaxis3: { anchor: 'free', overlaying: 'y', side: 'right', title: "Measured (mJ)", position: 0.97 },
            autosize: true,
            height: 450,

        };
        let dataPlot1 = [];

        for (let x in data) { dataPlot1.push(data[x]); }

        let dataPlot2 = [];
        for (let x in data2) { dataPlot2.push(data2[x]); }

        Plotly.react(plotArea, dataPlot1.concat(dataPlot2), dataLayout, { editable: true });

    }

    function resizableDiv({ 
        div, 
        change = { width: true, height: true }, 
        edges = { left: false, right: false, bottom: false, top: false }
        } = {}) {
        
            document.querySelector(div)?.style.setProperty("touch-action", "none");

        interact(div).resizable({
            edges,
            modifiers: [
                // keep the edges inside the parent

                interact.modifiers.restrictEdges({ outer: 'parent' }),
                interact.modifiers.restrictSize({ min: { width: 50, height: 50 }, max: { width: 500 } })
            ],
            inertia: true



        }).on('resizemove', function (event) {
            let target = event.target;
            let x = (parseFloat(target.getAttribute('data-x')) || 0);
            let y = (parseFloat(target.getAttribute('data-y')) || 0);
            if (change.width) {
                target.style.width = event.rect.width + 'px';
                if (event.rect.width <= 50) {
                    if (target.classList.contains("filebrowser")) { target.style.display = "none"; }
                }
            }
            if (change.height) target.style.height = event.rect.height + 'px';

            // translate when resizing from top or left edges
            x += event.deltaRect.left;
            y += event.deltaRect.top;

            target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px,' + y + 'px)';
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        });
    }
    resizableDiv({ div: ".left_container__div", edges: { right: true }, change: { width: true, height: false } });

    const db_file_location = pathResolve(appInfo.userData, appInfo.isPackaged ? "db.json" : "db-dev.json" );
    window.db = JSONdb(db_file_location);
    const mainLocation = appInfo.isPackaged ? appInfo.module : __dirname + "../";
    const unpackedLocation =  pathResolve(mainLocation, appInfo.isPackaged ? "../resources/app.asar.unpacked/" : "../" );

    if(!db.get("pythonpath")) {
        db.set("pythonpath", pathResolve(unpackedLocation, "python3/python"));
    }
    db.set("pythonscript", pathResolve(unpackedLocation, "static/assets/python_files"));

    const pythonpath = writable(db.get("pythonpath"));
    const pythonscript = writable(db.get("pythonscript"));

    const pyVersion = writable("");
    const developerMode = writable(!appInfo.isPackaged);
    const suppressInitialDeveloperWarning = writable(db.get("suppressInitialDeveloperWarning") || false);

    // import { mainPreModal } from "../../svelteWritable";
    // import { spawn, exec } from "child_process"
    window.checkPython = function checkPython({ defaultPy } = {}) {
        if (!defaultPy) { defaultPy = get_store_value(pythonpath); }
        console.log("Python path checking \n", defaultPy);

        return execFile(`${defaultPy}`, ["-V"])
    };

    window.computePy_func = function computePy_func({ e = null, pyfile = "", args = "", general = false, openShell = false } = {}) {
        

        return new Promise((resolve, reject) => {

            let target;
            if (!general) {
                target = e.target;
                target.classList.toggle("is-loading");

            }

            checkPython()

                .then(res => {
                    console.log(res);
                    if (general) {
                        console.log("Sending general arguments: ", args);
                        window.createToast("Process Started");
                        const py = spawn(
                            get_store_value(pythonpath), [pathJoin(get_store_value(pythonscript), pyfile), args], { detached: true, stdio: 'pipe', shell: openShell }

                        );

                        if (e) {


                            const pyEvent = new CustomEvent('pyEvent', { bubbles: false, detail: { py, pyfile } });
                            e.target.dispatchEvent(pyEvent);
                            console.log("pyEvent dispatched");
                        }

                        let error = "", error_occured_py=false;
                        let dataReceived="";
                        py.on("close", () => {

                            console.log("Closed");

                            if (error) {error_occured_py=true; reject(error); console.log("error Ocurred: ", error); } 
                            if (e) {
                                const pyEventClosed = new CustomEvent('pyEventClosed', { bubbles: false, detail: { py, pyfile, dataReceived, error_occured_py } });
                                e.target.dispatchEvent(pyEventClosed);
                                console.log("pyEventClosed dispatched");
                            }
                        });
                        py.stderr.on("data", (err) => { 
                            error = String.fromCharCode.apply(null, err);
                            console.log(`Error Ocurred: ${error}`); 
                        });

                        py.stdout.on("data", (data) => {

                            // dataReceived += `${data.toString()}\n`
                            dataReceived += `${String.fromCharCode.apply(null, data)}\n`;
                            console.log(`Output from python: ${dataReceived}`);
                            if (e) {
                                const pyEventData = new CustomEvent('pyEventData', { bubbles: false, detail: { py, pyfile, dataReceived } });
                                e.target.dispatchEvent(pyEventData);

                                console.log("pyEventData dispatched");

                            }
                        });


                        py.unref();

                        py.ref();
                    } else {

                        let py = null;
                        try { py = spawn(get_store_value(pythonpath), [pathResolve(get_store_value(pythonscript), pyfile), args]); }
                        catch (err) { reject("Error accessing python. Set python location properly in Settings\n" + err); }

                        if (e) {

                            const pyEvent = new CustomEvent('pyEvent', { bubbles: false, detail: { py, pyfile } });
                            e.target.dispatchEvent(pyEvent);
                            console.log("pyEvent dispatched");
                        }

                        window.createToast("Process Started");
                        let dataReceived = "";
                        py.stdout.on("data", data => {
                            // console.log(typeof data, data)
                            console.log("Ouput from python");
                            // dataReceived += data.toString("utf8")
                            dataReceived += String.fromCharCode.apply(null, data);
                            console.log(dataReceived);

                            if (e) {

                                const pyEventData = new CustomEvent('pyEventData', { bubbles: false, detail: { py, pyfile, dataReceived } });
                                e.target.dispatchEvent(pyEventData);

                                console.log("pyEventData dispatched");

                            }
                        });

                        let errContent = "";
                        let error_occured_py = false;
                        py.stderr.on("data", err => {
                            errContent += String.fromCharCode.apply(null, err);
                            error_occured_py = true;
                        });

                        py.on("close", () => {
                            if (!error_occured_py) {
                                const dataFile = basename(pyfile).split(".")[0];
                                const outputFile = pathJoin(appInfo.temp, "FELion_GUI3", dataFile + "_data.json");

                                if (!fs.existsSync(outputFile)) {
                                    return reject(`${outputFile} doesn't exist.`)
                                }
                                let dataFromPython = fs.readFileSync(outputFile);

                                window.dataFromPython = dataFromPython = JSON.parse(dataFromPython);
                                console.log(dataFromPython);


                                resolve(dataFromPython);
                            
                            } else { reject(errContent);  console.log(errContent);}
                            if (e) {

                                const pyEventClosed = new CustomEvent('pyEventClosed', { bubbles: false, detail: { py, pyfile, dataReceived, error_occured_py } });
                                e.target.dispatchEvent(pyEventClosed);
                                console.log("pyEventClosed dispatched");

                            }

                            target.classList.toggle("is-loading");
                            console.log("Process closed");

                        });

                    }

                }).catch(err => { reject(err.stack); });

        })
    };

    const activateChangelog = writable(false);
    const windowLoaded = writable(false);
    const updateAvailable = writable(false);
    const newVersion = writable("");
    const updating = writable(false);





    window.createToast = (msg, type = "primary") => Toast.create({ message: msg, position: "is-top", type: `is-${type}` });
    window.sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    window.handleError = (error) => mainPreModal.error(error.stack || error );

    window.onerror = function (message, source, lineno, colno, error) {
        console.error(error);
        Snackbar.create({ message: error.name, position: "is-top", type: `is-danger` });
        const modalContent =  `${error.name}: ${message}\nsource: ${source}\nlineno: ${lineno}\tcolno: ${colno}`;
        window.handleError(modalContent);
    };

    window.targetElement = (id) => document.getElementById(id);
    window.getPageStatus = (id) => targetElement(id).style.display !== "none";
    window.showpage = (id) => { targetElement(id).style.display = "block"; };
    window.hidepage = (id) => { targetElement(id).style.display = "none"; };
    window.togglepage = (id) => {
        getPageStatus(id) ? targetElement(id).style.display = "none" : targetElement(id).style.display = "block";
    };

    window.asyncForEach = async (array, callback) => {
        for (let index = 0; index < array.length; index++) {await callback(array[index], index, array);}
    };

    window.addEventListener('DOMContentLoaded', (event) => {
        console.log('DOM fully loaded and parsed');
        windowLoaded.set(true);
        bulmaExtensions_min.exports.bulmaQuickview.attach();
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFoundation = /** @class */ (function () {
        function MDCFoundation(adapter) {
            if (adapter === void 0) { adapter = {}; }
            this.adapter_ = adapter;
        }
        Object.defineProperty(MDCFoundation, "cssClasses", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports every
                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "strings", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "numbers", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
                return {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "defaultAdapter", {
            get: function () {
                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
                // validation.
                return {};
            },
            enumerable: true,
            configurable: true
        });
        MDCFoundation.prototype.init = function () {
            // Subclasses should override this method to perform initialization routines (registering events, etc.)
        };
        MDCFoundation.prototype.destroy = function () {
            // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        };
        return MDCFoundation;
    }());

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCComponent = /** @class */ (function () {
        function MDCComponent(root, foundation) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            this.root_ = root;
            this.initialize.apply(this, __spread(args));
            // Note that we initialize foundation here and not within the constructor's default param so that
            // this.root_ is defined and can be used within the foundation class.
            this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
            this.foundation_.init();
            this.initialSyncWithDOM();
        }
        MDCComponent.attachTo = function (root) {
            // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
            // returns an instantiated component with its root set to that element. Also note that in the cases of
            // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
            // from getDefaultFoundation().
            return new MDCComponent(root, new MDCFoundation({}));
        };
        /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */
        MDCComponent.prototype.initialize = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
            // Subclasses can override this to do any additional setup work that would be considered part of a
            // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
            // initialized. Any additional arguments besides root and foundation will be passed in here.
        };
        MDCComponent.prototype.getDefaultFoundation = function () {
            // Subclasses must override this method to return a properly configured foundation class for the
            // component.
            throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' +
                'foundation class');
        };
        MDCComponent.prototype.initialSyncWithDOM = function () {
            // Subclasses should override this method if they need to perform work to synchronize with a host DOM
            // object. An example of this would be a form control wrapper that needs to synchronize its internal state
            // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
            // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        };
        MDCComponent.prototype.destroy = function () {
            // Subclasses may implement this method to release any resources / deregister any listeners they have
            // attached. An example of this might be deregistering a resize event from the window object.
            this.foundation_.destroy();
        };
        MDCComponent.prototype.listen = function (evtType, handler, options) {
            this.root_.addEventListener(evtType, handler, options);
        };
        MDCComponent.prototype.unlisten = function (evtType, handler, options) {
            this.root_.removeEventListener(evtType, handler, options);
        };
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.
         */
        MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {
            if (shouldBubble === void 0) { shouldBubble = false; }
            var evt;
            if (typeof CustomEvent === 'function') {
                evt = new CustomEvent(evtType, {
                    bubbles: shouldBubble,
                    detail: evtData,
                });
            }
            else {
                evt = document.createEvent('CustomEvent');
                evt.initCustomEvent(evtType, shouldBubble, false, evtData);
            }
            this.root_.dispatchEvent(evt);
        };
        return MDCComponent;
    }());

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from applyPassive to avoid redundant processing to detect
     * passive event listener support.
     */
    var supportsPassive_;
    /**
     * Determine whether the current browser supports passive event listeners, and
     * if so, use them.
     */
    function applyPassive(globalObj, forceRefresh) {
        if (globalObj === void 0) { globalObj = window; }
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (supportsPassive_ === undefined || forceRefresh) {
            var isSupported_1 = false;
            try {
                globalObj.document.addEventListener('test', function () { return undefined; }, {
                    get passive() {
                        isSupported_1 = true;
                        return isSupported_1;
                    },
                });
            }
            catch (e) {
            } // tslint:disable-line:no-empty cannot throw error due to tests. tslint also disables console.log.
            supportsPassive_ = isSupported_1;
        }
        return supportsPassive_ ? { passive: true } : false;
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */
    function closest(element, selector) {
        if (element.closest) {
            return element.closest(selector);
        }
        var el = element;
        while (el) {
            if (matches$1(el, selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    function matches$1(element, selector) {
        var nativeMatches = element.matches
            || element.webkitMatchesSelector
            || element.msMatchesSelector;
        return nativeMatches.call(element, selector);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$m = {
        // Ripple is a special case where the "root" component is really a "mixin" of sorts,
        // given that it's an 'upgrade' to an existing component. That being said it is the root
        // CSS class that all other CSS classes derive from.
        BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
        FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
        FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
        ROOT: 'mdc-ripple-upgraded',
        UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    };
    var strings$p = {
        VAR_FG_SCALE: '--mdc-ripple-fg-scale',
        VAR_FG_SIZE: '--mdc-ripple-fg-size',
        VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
        VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
        VAR_LEFT: '--mdc-ripple-left',
        VAR_TOP: '--mdc-ripple-top',
    };
    var numbers$9 = {
        DEACTIVATION_TIMEOUT_MS: 225,
        FG_DEACTIVATION_MS: 150,
        INITIAL_ORIGIN_SCALE: 0.6,
        PADDING: 10,
        TAP_DELAY_MS: 300,
    };

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to
     * detect CSS custom variable support.
     */
    var supportsCssVariables_;
    function detectEdgePseudoVarBug(windowObj) {
        // Detect versions of Edge with buggy var() support
        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
        var document = windowObj.document;
        var node = document.createElement('div');
        node.className = 'mdc-ripple-surface--test-edge-var-bug';
        // Append to head instead of body because this script might be invoked in the
        // head, in which case the body doesn't exist yet. The probe works either way.
        document.head.appendChild(node);
        // The bug exists if ::before style ends up propagating to the parent element.
        // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
        // but Firefox is known to support CSS custom properties correctly.
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
        var computedStyle = windowObj.getComputedStyle(node);
        var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return hasPseudoVarBug;
    }
    function supportsCssVariables(windowObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        var CSS = windowObj.CSS;
        var supportsCssVars = supportsCssVariables_;
        if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
            return supportsCssVariables_;
        }
        var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
        if (!supportsFunctionPresent) {
            return false;
        }
        var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
        // See: https://bugs.webkit.org/show_bug.cgi?id=154669
        // See: README section on Safari
        var weAreFeatureDetectingSafari10plus = (CSS.supports('(--css-vars: yes)') &&
            CSS.supports('color', '#00000000'));
        if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
            supportsCssVars = !detectEdgePseudoVarBug(windowObj);
        }
        else {
            supportsCssVars = false;
        }
        if (!forceRefresh) {
            supportsCssVariables_ = supportsCssVars;
        }
        return supportsCssVars;
    }
    function getNormalizedEventCoords(evt, pageOffset, clientRect) {
        if (!evt) {
            return { x: 0, y: 0 };
        }
        var x = pageOffset.x, y = pageOffset.y;
        var documentX = x + clientRect.left;
        var documentY = y + clientRect.top;
        var normalizedX;
        var normalizedY;
        // Determine touch point relative to the ripple container.
        if (evt.type === 'touchstart') {
            var touchEvent = evt;
            normalizedX = touchEvent.changedTouches[0].pageX - documentX;
            normalizedY = touchEvent.changedTouches[0].pageY - documentY;
        }
        else {
            var mouseEvent = evt;
            normalizedX = mouseEvent.pageX - documentX;
            normalizedY = mouseEvent.pageY - documentY;
        }
        return { x: normalizedX, y: normalizedY };
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = [
        'touchstart', 'pointerdown', 'mousedown', 'keydown',
    ];
    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = [
        'touchend', 'pointerup', 'mouseup', 'contextmenu',
    ];
    // simultaneous nested activations
    var activatedTargets = [];
    var MDCRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCRippleFoundation, _super);
        function MDCRippleFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCRippleFoundation.defaultAdapter, adapter)) || this;
            _this.activationAnimationHasEnded_ = false;
            _this.activationTimer_ = 0;
            _this.fgDeactivationRemovalTimer_ = 0;
            _this.fgScale_ = '0';
            _this.frame_ = { width: 0, height: 0 };
            _this.initialSize_ = 0;
            _this.layoutFrame_ = 0;
            _this.maxRadius_ = 0;
            _this.unboundedCoords_ = { left: 0, top: 0 };
            _this.activationState_ = _this.defaultActivationState_();
            _this.activationTimerCallback_ = function () {
                _this.activationAnimationHasEnded_ = true;
                _this.runDeactivationUXLogicIfReady_();
            };
            _this.activateHandler_ = function (e) { return _this.activate_(e); };
            _this.deactivateHandler_ = function () { return _this.deactivate_(); };
            _this.focusHandler_ = function () { return _this.handleFocus(); };
            _this.blurHandler_ = function () { return _this.handleBlur(); };
            _this.resizeHandler_ = function () { return _this.layout(); };
            return _this;
        }
        Object.defineProperty(MDCRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$m;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "strings", {
            get: function () {
                return strings$p;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "numbers", {
            get: function () {
                return numbers$9;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    browserSupportsCssVars: function () { return true; },
                    computeBoundingRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    containsEventTarget: function () { return true; },
                    deregisterDocumentInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    deregisterResizeHandler: function () { return undefined; },
                    getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },
                    isSurfaceActive: function () { return true; },
                    isSurfaceDisabled: function () { return true; },
                    isUnbounded: function () { return true; },
                    registerDocumentInteractionHandler: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    registerResizeHandler: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    updateCssVariable: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCRippleFoundation.prototype.init = function () {
            var _this = this;
            var supportsPressRipple = this.supportsPressRipple_();
            this.registerRootHandlers_(supportsPressRipple);
            if (supportsPressRipple) {
                var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter_.addClass(ROOT_1);
                    if (_this.adapter_.isUnbounded()) {
                        _this.adapter_.addClass(UNBOUNDED_1);
                        // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                        _this.layoutInternal_();
                    }
                });
            }
        };
        MDCRippleFoundation.prototype.destroy = function () {
            var _this = this;
            if (this.supportsPressRipple_()) {
                if (this.activationTimer_) {
                    clearTimeout(this.activationTimer_);
                    this.activationTimer_ = 0;
                    this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
                }
                if (this.fgDeactivationRemovalTimer_) {
                    clearTimeout(this.fgDeactivationRemovalTimer_);
                    this.fgDeactivationRemovalTimer_ = 0;
                    this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
                }
                var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter_.removeClass(ROOT_2);
                    _this.adapter_.removeClass(UNBOUNDED_2);
                    _this.removeCssVars_();
                });
            }
            this.deregisterRootHandlers_();
            this.deregisterDeactivationHandlers_();
        };
        /**
         * @param evt Optional event containing position information.
         */
        MDCRippleFoundation.prototype.activate = function (evt) {
            this.activate_(evt);
        };
        MDCRippleFoundation.prototype.deactivate = function () {
            this.deactivate_();
        };
        MDCRippleFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
            }
            this.layoutFrame_ = requestAnimationFrame(function () {
                _this.layoutInternal_();
                _this.layoutFrame_ = 0;
            });
        };
        MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
            var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
            if (unbounded) {
                this.adapter_.addClass(UNBOUNDED);
            }
            else {
                this.adapter_.removeClass(UNBOUNDED);
            }
        };
        MDCRippleFoundation.prototype.handleFocus = function () {
            var _this = this;
            requestAnimationFrame(function () {
                return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
            });
        };
        MDCRippleFoundation.prototype.handleBlur = function () {
            var _this = this;
            requestAnimationFrame(function () {
                return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
            });
        };
        /**
         * We compute this property so that we are not querying information about the client
         * until the point in time where the foundation requests it. This prevents scenarios where
         * client-side feature-detection may happen too early, such as when components are rendered on the server
         * and then initialized at mount time on the client.
         */
        MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
            return this.adapter_.browserSupportsCssVars();
        };
        MDCRippleFoundation.prototype.defaultActivationState_ = function () {
            return {
                activationEvent: undefined,
                hasDeactivationUXRun: false,
                isActivated: false,
                isProgrammatic: false,
                wasActivatedByPointer: false,
                wasElementMadeActive: false,
            };
        };
        /**
         * supportsPressRipple Passed from init to save a redundant function call
         */
        MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
            var _this = this;
            if (supportsPressRipple) {
                ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                    _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
                });
                if (this.adapter_.isUnbounded()) {
                    this.adapter_.registerResizeHandler(this.resizeHandler_);
                }
            }
            this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
            this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        };
        MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
            var _this = this;
            if (evt.type === 'keydown') {
                this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
            }
            else {
                POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                    _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
                });
            }
        };
        MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
            var _this = this;
            ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
            });
            this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
            this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
            if (this.adapter_.isUnbounded()) {
                this.adapter_.deregisterResizeHandler(this.resizeHandler_);
            }
        };
        MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
            var _this = this;
            this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
            });
        };
        MDCRippleFoundation.prototype.removeCssVars_ = function () {
            var _this = this;
            var rippleStrings = MDCRippleFoundation.strings;
            var keys = Object.keys(rippleStrings);
            keys.forEach(function (key) {
                if (key.indexOf('VAR_') === 0) {
                    _this.adapter_.updateCssVariable(rippleStrings[key], null);
                }
            });
        };
        MDCRippleFoundation.prototype.activate_ = function (evt) {
            var _this = this;
            if (this.adapter_.isSurfaceDisabled()) {
                return;
            }
            var activationState = this.activationState_;
            if (activationState.isActivated) {
                return;
            }
            // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
            var previousActivationEvent = this.previousActivationEvent_;
            var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
            if (isSameInteraction) {
                return;
            }
            activationState.isActivated = true;
            activationState.isProgrammatic = evt === undefined;
            activationState.activationEvent = evt;
            activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
            var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) { return _this.adapter_.containsEventTarget(target); });
            if (hasActivatedChild) {
                // Immediately reset activation state, while preserving logic that prevents touch follow-on events
                this.resetActivationState_();
                return;
            }
            if (evt !== undefined) {
                activatedTargets.push(evt.target);
                this.registerDeactivationHandlers_(evt);
            }
            activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
            if (activationState.wasElementMadeActive) {
                this.animateActivation_();
            }
            requestAnimationFrame(function () {
                // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
                activatedTargets = [];
                if (!activationState.wasElementMadeActive
                    && evt !== undefined
                    && (evt.key === ' ' || evt.keyCode === 32)) {
                    // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                    // active states inconsistently when they're called within event handling code:
                    // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                    // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                    // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                    // variable is set within a rAF callback for a submit button interaction (#2241).
                    activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
                    if (activationState.wasElementMadeActive) {
                        _this.animateActivation_();
                    }
                }
                if (!activationState.wasElementMadeActive) {
                    // Reset activation state immediately if element was not made active.
                    _this.activationState_ = _this.defaultActivationState_();
                }
            });
        };
        MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
            return (evt !== undefined && evt.type === 'keydown') ? this.adapter_.isSurfaceActive() : true;
        };
        MDCRippleFoundation.prototype.animateActivation_ = function () {
            var _this = this;
            var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
            var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
            var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
            this.layoutInternal_();
            var translateStart = '';
            var translateEnd = '';
            if (!this.adapter_.isUnbounded()) {
                var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
                translateStart = startPoint.x + "px, " + startPoint.y + "px";
                translateEnd = endPoint.x + "px, " + endPoint.y + "px";
            }
            this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
            this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
            // Cancel any ongoing activation/deactivation animations
            clearTimeout(this.activationTimer_);
            clearTimeout(this.fgDeactivationRemovalTimer_);
            this.rmBoundedActivationClasses_();
            this.adapter_.removeClass(FG_DEACTIVATION);
            // Force layout in order to re-trigger the animation.
            this.adapter_.computeBoundingRect();
            this.adapter_.addClass(FG_ACTIVATION);
            this.activationTimer_ = setTimeout(function () { return _this.activationTimerCallback_(); }, DEACTIVATION_TIMEOUT_MS);
        };
        MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
            var _a = this.activationState_, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
            var startPoint;
            if (wasActivatedByPointer) {
                startPoint = getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
            }
            else {
                startPoint = {
                    x: this.frame_.width / 2,
                    y: this.frame_.height / 2,
                };
            }
            // Center the element around the start point.
            startPoint = {
                x: startPoint.x - (this.initialSize_ / 2),
                y: startPoint.y - (this.initialSize_ / 2),
            };
            var endPoint = {
                x: (this.frame_.width / 2) - (this.initialSize_ / 2),
                y: (this.frame_.height / 2) - (this.initialSize_ / 2),
            };
            return { startPoint: startPoint, endPoint: endPoint };
        };
        MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
            var _this = this;
            // This method is called both when a pointing device is released, and when the activation animation ends.
            // The deactivation animation should only run after both of those occur.
            var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
            var _a = this.activationState_, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
            var activationHasEnded = hasDeactivationUXRun || !isActivated;
            if (activationHasEnded && this.activationAnimationHasEnded_) {
                this.rmBoundedActivationClasses_();
                this.adapter_.addClass(FG_DEACTIVATION);
                this.fgDeactivationRemovalTimer_ = setTimeout(function () {
                    _this.adapter_.removeClass(FG_DEACTIVATION);
                }, numbers$9.FG_DEACTIVATION_MS);
            }
        };
        MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
            this.activationAnimationHasEnded_ = false;
            this.adapter_.computeBoundingRect();
        };
        MDCRippleFoundation.prototype.resetActivationState_ = function () {
            var _this = this;
            this.previousActivationEvent_ = this.activationState_.activationEvent;
            this.activationState_ = this.defaultActivationState_();
            // Touch devices may fire additional events for the same interaction within a short time.
            // Store the previous event until it's safe to assume that subsequent events are for new interactions.
            setTimeout(function () { return _this.previousActivationEvent_ = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        };
        MDCRippleFoundation.prototype.deactivate_ = function () {
            var _this = this;
            var activationState = this.activationState_;
            // This can happen in scenarios such as when you have a keyup event that blurs the element.
            if (!activationState.isActivated) {
                return;
            }
            var state = __assign({}, activationState);
            if (activationState.isProgrammatic) {
                requestAnimationFrame(function () { return _this.animateDeactivation_(state); });
                this.resetActivationState_();
            }
            else {
                this.deregisterDeactivationHandlers_();
                requestAnimationFrame(function () {
                    _this.activationState_.hasDeactivationUXRun = true;
                    _this.animateDeactivation_(state);
                    _this.resetActivationState_();
                });
            }
        };
        MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
            var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
            if (wasActivatedByPointer || wasElementMadeActive) {
                this.runDeactivationUXLogicIfReady_();
            }
        };
        MDCRippleFoundation.prototype.layoutInternal_ = function () {
            var _this = this;
            this.frame_ = this.adapter_.computeBoundingRect();
            var maxDim = Math.max(this.frame_.height, this.frame_.width);
            // Surface diameter is treated differently for unbounded vs. bounded ripples.
            // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
            // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
            // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
            // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
            // `overflow: hidden`.
            var getBoundedRadius = function () {
                var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
                return hypotenuse + MDCRippleFoundation.numbers.PADDING;
            };
            this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();
            // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
            this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
            this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
            this.updateLayoutCssVars_();
        };
        MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
            var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
            this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
            this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
            if (this.adapter_.isUnbounded()) {
                this.unboundedCoords_ = {
                    left: Math.round((this.frame_.width / 2) - (this.initialSize_ / 2)),
                    top: Math.round((this.frame_.height / 2) - (this.initialSize_ / 2)),
                };
                this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
                this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
            }
        };
        return MDCRippleFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRipple = /** @class */ (function (_super) {
        __extends(MDCRipple, _super);
        function MDCRipple() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.disabled = false;
            return _this;
        }
        MDCRipple.attachTo = function (root, opts) {
            if (opts === void 0) { opts = { isUnbounded: undefined }; }
            var ripple = new MDCRipple(root);
            // Only override unbounded behavior if option is explicitly specified
            if (opts.isUnbounded !== undefined) {
                ripple.unbounded = opts.isUnbounded;
            }
            return ripple;
        };
        MDCRipple.createAdapter = function (instance) {
            return {
                addClass: function (className) { return instance.root_.classList.add(className); },
                browserSupportsCssVars: function () { return supportsCssVariables(window); },
                computeBoundingRect: function () { return instance.root_.getBoundingClientRect(); },
                containsEventTarget: function (target) { return instance.root_.contains(target); },
                deregisterDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.removeEventListener(evtType, handler, applyPassive());
                },
                deregisterInteractionHandler: function (evtType, handler) {
                    return instance.root_.removeEventListener(evtType, handler, applyPassive());
                },
                deregisterResizeHandler: function (handler) { return window.removeEventListener('resize', handler); },
                getWindowPageOffset: function () { return ({ x: window.pageXOffset, y: window.pageYOffset }); },
                isSurfaceActive: function () { return matches$1(instance.root_, ':active'); },
                isSurfaceDisabled: function () { return Boolean(instance.disabled); },
                isUnbounded: function () { return Boolean(instance.unbounded); },
                registerDocumentInteractionHandler: function (evtType, handler) {
                    return document.documentElement.addEventListener(evtType, handler, applyPassive());
                },
                registerInteractionHandler: function (evtType, handler) {
                    return instance.root_.addEventListener(evtType, handler, applyPassive());
                },
                registerResizeHandler: function (handler) { return window.addEventListener('resize', handler); },
                removeClass: function (className) { return instance.root_.classList.remove(className); },
                updateCssVariable: function (varName, value) { return instance.root_.style.setProperty(varName, value); },
            };
        };
        Object.defineProperty(MDCRipple.prototype, "unbounded", {
            get: function () {
                return Boolean(this.unbounded_);
            },
            set: function (unbounded) {
                this.unbounded_ = Boolean(unbounded);
                this.setUnbounded_();
            },
            enumerable: true,
            configurable: true
        });
        MDCRipple.prototype.activate = function () {
            this.foundation_.activate();
        };
        MDCRipple.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        MDCRipple.prototype.layout = function () {
            this.foundation_.layout();
        };
        MDCRipple.prototype.getDefaultFoundation = function () {
            return new MDCRippleFoundation(MDCRipple.createAdapter(this));
        };
        MDCRipple.prototype.initialSyncWithDOM = function () {
            var root = this.root_;
            this.unbounded = 'mdcRippleIsUnbounded' in root.dataset;
        };
        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         */
        MDCRipple.prototype.setUnbounded_ = function () {
            this.foundation_.setUnbounded(Boolean(this.unbounded_));
        };
        return MDCRipple;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$l = {
        ACTIVE: 'mdc-tab-indicator--active',
        FADE: 'mdc-tab-indicator--fade',
        NO_TRANSITION: 'mdc-tab-indicator--no-transition',
    };
    var strings$o = {
        CONTENT_SELECTOR: '.mdc-tab-indicator__content',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCTabIndicatorFoundation, _super);
        function MDCTabIndicatorFoundation(adapter) {
            return _super.call(this, __assign({}, MDCTabIndicatorFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCTabIndicatorFoundation, "cssClasses", {
            get: function () {
                return cssClasses$l;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabIndicatorFoundation, "strings", {
            get: function () {
                return strings$o;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabIndicatorFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    computeContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    setContentStyleProperty: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabIndicatorFoundation.prototype.computeContentClientRect = function () {
            return this.adapter_.computeContentClientRect();
        };
        return MDCTabIndicatorFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /* istanbul ignore next: subclass is not a branch statement */
    var MDCFadingTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCFadingTabIndicatorFoundation, _super);
        function MDCFadingTabIndicatorFoundation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCFadingTabIndicatorFoundation.prototype.activate = function () {
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        MDCFadingTabIndicatorFoundation.prototype.deactivate = function () {
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        return MDCFadingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /* istanbul ignore next: subclass is not a branch statement */
    var MDCSlidingTabIndicatorFoundation = /** @class */ (function (_super) {
        __extends(MDCSlidingTabIndicatorFoundation, _super);
        function MDCSlidingTabIndicatorFoundation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCSlidingTabIndicatorFoundation.prototype.activate = function (previousIndicatorClientRect) {
            // Early exit if no indicator is present to handle cases where an indicator
            // may be activated without a prior indicator state
            if (!previousIndicatorClientRect) {
                this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
                return;
            }
            // This animation uses the FLIP approach. You can read more about it at the link below:
            // https://aerotwist.com/blog/flip-your-animations/
            // Calculate the dimensions based on the dimensions of the previous indicator
            var currentClientRect = this.computeContentClientRect();
            var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
            var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
            this.adapter_.setContentStyleProperty('transform', "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
            // Force repaint before updating classes and transform to ensure the transform properly takes effect
            this.computeContentClientRect();
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            this.adapter_.setContentStyleProperty('transform', '');
        };
        MDCSlidingTabIndicatorFoundation.prototype.deactivate = function () {
            this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        };
        return MDCSlidingTabIndicatorFoundation;
    }(MDCTabIndicatorFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabIndicator = /** @class */ (function (_super) {
        __extends(MDCTabIndicator, _super);
        function MDCTabIndicator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabIndicator.attachTo = function (root) {
            return new MDCTabIndicator(root);
        };
        MDCTabIndicator.prototype.initialize = function () {
            this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTabIndicator.prototype.computeContentClientRect = function () {
            return this.foundation_.computeContentClientRect();
        };
        MDCTabIndicator.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                computeContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
                setContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
            };
            // tslint:enable:object-literal-sort-keys
            if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
                return new MDCFadingTabIndicatorFoundation(adapter);
            }
            // Default to the sliding indicator
            return new MDCSlidingTabIndicatorFoundation(adapter);
        };
        MDCTabIndicator.prototype.activate = function (previousIndicatorClientRect) {
            this.foundation_.activate(previousIndicatorClientRect);
        };
        MDCTabIndicator.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        return MDCTabIndicator;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$k = {
        ACTIVE: 'mdc-tab--active',
    };
    var strings$n = {
        ARIA_SELECTED: 'aria-selected',
        CONTENT_SELECTOR: '.mdc-tab__content',
        INTERACTED_EVENT: 'MDCTab:interacted',
        RIPPLE_SELECTOR: '.mdc-tab__ripple',
        TABINDEX: 'tabIndex',
        TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabFoundation = /** @class */ (function (_super) {
        __extends(MDCTabFoundation, _super);
        function MDCTabFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabFoundation.defaultAdapter, adapter)) || this;
            _this.focusOnActivate_ = true;
            return _this;
        }
        Object.defineProperty(MDCTabFoundation, "cssClasses", {
            get: function () {
                return cssClasses$k;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabFoundation, "strings", {
            get: function () {
                return strings$n;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setAttr: function () { return undefined; },
                    activateIndicator: function () { return undefined; },
                    deactivateIndicator: function () { return undefined; },
                    notifyInteracted: function () { return undefined; },
                    getOffsetLeft: function () { return 0; },
                    getOffsetWidth: function () { return 0; },
                    getContentOffsetLeft: function () { return 0; },
                    getContentOffsetWidth: function () { return 0; },
                    focus: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabFoundation.prototype.handleClick = function () {
            // It's up to the parent component to keep track of the active Tab and
            // ensure we don't activate a Tab that's already active.
            this.adapter_.notifyInteracted();
        };
        MDCTabFoundation.prototype.isActive = function () {
            return this.adapter_.hasClass(cssClasses$k.ACTIVE);
        };
        /**
         * Sets whether the tab should focus itself when activated
         */
        MDCTabFoundation.prototype.setFocusOnActivate = function (focusOnActivate) {
            this.focusOnActivate_ = focusOnActivate;
        };
        /**
         * Activates the Tab
         */
        MDCTabFoundation.prototype.activate = function (previousIndicatorClientRect) {
            this.adapter_.addClass(cssClasses$k.ACTIVE);
            this.adapter_.setAttr(strings$n.ARIA_SELECTED, 'true');
            this.adapter_.setAttr(strings$n.TABINDEX, '0');
            this.adapter_.activateIndicator(previousIndicatorClientRect);
            if (this.focusOnActivate_) {
                this.adapter_.focus();
            }
        };
        /**
         * Deactivates the Tab
         */
        MDCTabFoundation.prototype.deactivate = function () {
            // Early exit
            if (!this.isActive()) {
                return;
            }
            this.adapter_.removeClass(cssClasses$k.ACTIVE);
            this.adapter_.setAttr(strings$n.ARIA_SELECTED, 'false');
            this.adapter_.setAttr(strings$n.TABINDEX, '-1');
            this.adapter_.deactivateIndicator();
        };
        /**
         * Returns the dimensions of the Tab
         */
        MDCTabFoundation.prototype.computeDimensions = function () {
            var rootWidth = this.adapter_.getOffsetWidth();
            var rootLeft = this.adapter_.getOffsetLeft();
            var contentWidth = this.adapter_.getContentOffsetWidth();
            var contentLeft = this.adapter_.getContentOffsetLeft();
            return {
                contentLeft: rootLeft + contentLeft,
                contentRight: rootLeft + contentLeft + contentWidth,
                rootLeft: rootLeft,
                rootRight: rootLeft + rootWidth,
            };
        };
        return MDCTabFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTab = /** @class */ (function (_super) {
        __extends(MDCTab, _super);
        function MDCTab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTab.attachTo = function (root) {
            return new MDCTab(root);
        };
        MDCTab.prototype.initialize = function (rippleFactory, tabIndicatorFactory) {
            if (rippleFactory === void 0) { rippleFactory = function (el, foundation) { return new MDCRipple(el, foundation); }; }
            if (tabIndicatorFactory === void 0) { tabIndicatorFactory = function (el) { return new MDCTabIndicator(el); }; }
            this.id = this.root_.id;
            var rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
            var rippleAdapter = __assign({}, MDCRipple.createAdapter(this), { addClass: function (className) { return rippleSurface.classList.add(className); }, removeClass: function (className) { return rippleSurface.classList.remove(className); }, updateCssVariable: function (varName, value) { return rippleSurface.style.setProperty(varName, value); } });
            var rippleFoundation = new MDCRippleFoundation(rippleAdapter);
            this.ripple_ = rippleFactory(this.root_, rippleFoundation);
            var tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
            this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
            this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTab.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleClick_ = function () { return _this.foundation_.handleClick(); };
            this.listen('click', this.handleClick_);
        };
        MDCTab.prototype.destroy = function () {
            this.unlisten('click', this.handleClick_);
            this.ripple_.destroy();
            _super.prototype.destroy.call(this);
        };
        MDCTab.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                activateIndicator: function (previousIndicatorClientRect) { return _this.tabIndicator_.activate(previousIndicatorClientRect); },
                deactivateIndicator: function () { return _this.tabIndicator_.deactivate(); },
                notifyInteracted: function () { return _this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, { tabId: _this.id }, true /* bubble */); },
                getOffsetLeft: function () { return _this.root_.offsetLeft; },
                getOffsetWidth: function () { return _this.root_.offsetWidth; },
                getContentOffsetLeft: function () { return _this.content_.offsetLeft; },
                getContentOffsetWidth: function () { return _this.content_.offsetWidth; },
                focus: function () { return _this.root_.focus(); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabFoundation(adapter);
        };
        Object.defineProperty(MDCTab.prototype, "active", {
            /**
             * Getter for the active state of the tab
             */
            get: function () {
                return this.foundation_.isActive();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTab.prototype, "focusOnActivate", {
            set: function (focusOnActivate) {
                this.foundation_.setFocusOnActivate(focusOnActivate);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Activates the tab
         */
        MDCTab.prototype.activate = function (computeIndicatorClientRect) {
            this.foundation_.activate(computeIndicatorClientRect);
        };
        /**
         * Deactivates the tab
         */
        MDCTab.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        /**
         * Returns the indicator's client rect
         */
        MDCTab.prototype.computeIndicatorClientRect = function () {
            return this.tabIndicator_.computeContentClientRect();
        };
        MDCTab.prototype.computeDimensions = function () {
            return this.foundation_.computeDimensions();
        };
        /**
         * Focuses the tab
         */
        MDCTab.prototype.focus = function () {
            this.root_.focus();
        };
        return MDCTab;
    }(MDCComponent));

    function forwardEventsBuilder(component, additionalEvents = []) {
      const events = [
        'focus', 'blur',
        'fullscreenchange', 'fullscreenerror', 'scroll',
        'cut', 'copy', 'paste',
        'keydown', 'keypress', 'keyup',
        'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel',
        'drag', 'dragend', 'dragenter', 'dragstart', 'dragleave', 'dragover', 'drop',
        'touchcancel', 'touchend', 'touchmove', 'touchstart',
        'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave', 'gotpointercapture', 'lostpointercapture',
        ...additionalEvents
      ];

      function forward(e) {
        bubble(component, e);
      }

      return node => {
        const destructors = [];

        for (let i = 0; i < events.length; i++) {
          destructors.push(listen(node, events[i], forward));
        }

        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
          }
        }
      };
    }

    function exclude(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};

      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf('$');
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }

      return newObj;
    }

    function prefixFilter(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};

      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }

      return newObj;
    }

    function useActions(node, actions) {
      let objects = [];

      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray = Array.isArray(actions[i]);
          const action = isArray ? actions[i][0] : actions[i];
          if (isArray && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }

      return {
        update(actions) {
          if ((actions && actions.length || 0) != objects.length) {
            throw new Error('You must not change the length of an actions array.');
          }

          if (actions) {
            for (let i = 0; i < actions.length; i++) {
              if (objects[i] && 'update' in objects[i]) {
                const isArray = Array.isArray(actions[i]);
                if (isArray && actions[i].length > 1) {
                  objects[i].update(actions[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },

        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && 'destroy' in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      }
    }

    /* node_modules\@smui\tab-indicator\TabIndicator.svelte generated by Svelte v3.42.1 */
    const file$1n = "node_modules\\@smui\\tab-indicator\\TabIndicator.svelte";

    function create_fragment$1w(ctx) {
    	let span1;
    	let span0;
    	let span0_class_value;
    	let span0_aria_hidden_value;
    	let useActions_action;
    	let span1_class_value;
    	let useActions_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let span0_levels = [
    		{
    			class: span0_class_value = "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === 'underline'
    			? 'mdc-tab-indicator__content--underline'
    			: '') + "\n      " + (/*type*/ ctx[3] === 'icon'
    			? 'mdc-tab-indicator__content--icon'
    			: '') + "\n    "
    		},
    		{
    			"aria-hidden": span0_aria_hidden_value = /*type*/ ctx[3] === 'icon' ? 'true' : 'false'
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[9], 'content$'), ['use', 'class'])
    	];

    	let span0_data = {};

    	for (let i = 0; i < span0_levels.length; i += 1) {
    		span0_data = assign(span0_data, span0_levels[i]);
    	}

    	let span1_levels = [
    		{
    			class: span1_class_value = "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? 'mdc-tab-indicator--active' : '') + "\n    " + (/*transition*/ ctx[4] === 'fade'
    			? 'mdc-tab-indicator--fade'
    			: '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[9], ['use', 'class', 'active', 'type', 'transition', 'content$'])
    	];

    	let span1_data = {};

    	for (let i = 0; i < span1_levels.length; i += 1) {
    		span1_data = assign(span1_data, span1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span0, span0_data);
    			add_location(span0, file$1n, 12, 2, 322);
    			set_attributes(span1, span1_data);
    			add_location(span1, file$1n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);

    			if (default_slot) {
    				default_slot.m(span0, null);
    			}

    			/*span1_binding*/ ctx[15](span1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span0, /*content$use*/ ctx[5])),
    					action_destroyer(useActions_action_1 = useActions.call(null, span1, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[8].call(null, span1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span0, span0_data = get_spread_update(span0_levels, [
    				(!current || dirty & /*content$class, type*/ 72 && span0_class_value !== (span0_class_value = "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === 'underline'
    				? 'mdc-tab-indicator__content--underline'
    				: '') + "\n      " + (/*type*/ ctx[3] === 'icon'
    				? 'mdc-tab-indicator__content--icon'
    				: '') + "\n    ")) && { class: span0_class_value },
    				(!current || dirty & /*type*/ 8 && span0_aria_hidden_value !== (span0_aria_hidden_value = /*type*/ ctx[3] === 'icon' ? 'true' : 'false')) && { "aria-hidden": span0_aria_hidden_value },
    				dirty & /*$$props*/ 512 && exclude(prefixFilter(/*$$props*/ ctx[9], 'content$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/ 32) useActions_action.update.call(null, /*content$use*/ ctx[5]);

    			set_attributes(span1, span1_data = get_spread_update(span1_levels, [
    				(!current || dirty & /*className, active, transition*/ 22 && span1_class_value !== (span1_class_value = "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? 'mdc-tab-indicator--active' : '') + "\n    " + (/*transition*/ ctx[4] === 'fade'
    				? 'mdc-tab-indicator--fade'
    				: '') + "\n  ")) && { class: span1_class_value },
    				dirty & /*$$props*/ 512 && exclude(/*$$props*/ ctx[9], ['use', 'class', 'active', 'type', 'transition', 'content$'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			if (default_slot) default_slot.d(detaching);
    			/*span1_binding*/ ctx[15](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabIndicator', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { type = 'underline' } = $$props;
    	let { transition = 'slide' } = $$props;
    	let { content$use = [] } = $$props;
    	let { content$class = '' } = $$props;
    	let element;
    	let tabIndicator;
    	let instantiate = getContext('SMUI:tab-indicator:instantiate');
    	let getInstance = getContext('SMUI:tab-indicator:getInstance');

    	onMount(async () => {
    		if (instantiate !== false) {
    			tabIndicator = new MDCTabIndicator(element);
    		} else {
    			tabIndicator = await getInstance();
    		}
    	});

    	onDestroy(() => {
    		tabIndicator && tabIndicator.destroy();
    	});

    	function activate(...args) {
    		return tabIndicator.activate(...args);
    	}

    	function deactivate(...args) {
    		return tabIndicator.deactivate(...args);
    	}

    	function computeContentClientRect(...args) {
    		return tabIndicator.computeContentClientRect(...args);
    	}

    	function span1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(2, active = $$new_props.active);
    		if ('type' in $$new_props) $$invalidate(3, type = $$new_props.type);
    		if ('transition' in $$new_props) $$invalidate(4, transition = $$new_props.transition);
    		if ('content$use' in $$new_props) $$invalidate(5, content$use = $$new_props.content$use);
    		if ('content$class' in $$new_props) $$invalidate(6, content$class = $$new_props.content$class);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTabIndicator,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		active,
    		type,
    		transition,
    		content$use,
    		content$class,
    		element,
    		tabIndicator,
    		instantiate,
    		getInstance,
    		activate,
    		deactivate,
    		computeContentClientRect
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(2, active = $$new_props.active);
    		if ('type' in $$props) $$invalidate(3, type = $$new_props.type);
    		if ('transition' in $$props) $$invalidate(4, transition = $$new_props.transition);
    		if ('content$use' in $$props) $$invalidate(5, content$use = $$new_props.content$use);
    		if ('content$class' in $$props) $$invalidate(6, content$class = $$new_props.content$class);
    		if ('element' in $$props) $$invalidate(7, element = $$new_props.element);
    		if ('tabIndicator' in $$props) tabIndicator = $$new_props.tabIndicator;
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		active,
    		type,
    		transition,
    		content$use,
    		content$class,
    		element,
    		forwardEvents,
    		$$props,
    		activate,
    		deactivate,
    		computeContentClientRect,
    		$$scope,
    		slots,
    		span1_binding
    	];
    }

    class TabIndicator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1w, create_fragment$1w, safe_not_equal, {
    			use: 0,
    			class: 1,
    			active: 2,
    			type: 3,
    			transition: 4,
    			content$use: 5,
    			content$class: 6,
    			activate: 10,
    			deactivate: 11,
    			computeContentClientRect: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabIndicator",
    			options,
    			id: create_fragment$1w.name
    		});
    	}

    	get use() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$use() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$use(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$class() {
    		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$class(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[10];
    	}

    	set activate(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[11];
    	}

    	set deactivate(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeContentClientRect() {
    		return this.$$.ctx[12];
    	}

    	set computeContentClientRect(value) {
    		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\tab\Tab.svelte generated by Svelte v3.42.1 */

    const { Error: Error_1$1 } = globals;
    const file$1m = "node_modules\\@smui\\tab\\Tab.svelte";
    const get_tab_indicator_slot_changes_1 = dirty => ({});
    const get_tab_indicator_slot_context_1 = ctx => ({});
    const get_tab_indicator_slot_changes = dirty => ({});
    const get_tab_indicator_slot_context = ctx => ({});

    // (24:4) {#if indicatorSpanOnlyContent}
    function create_if_block_2$7(ctx) {
    	let tabindicator;
    	let current;

    	const tabindicator_spread_levels = [
    		{ active: /*active*/ ctx[0] },
    		prefixFilter(/*$$props*/ ctx[12], 'tabIndicator$')
    	];

    	let tabindicator_props = {
    		$$slots: { default: [create_default_slot_1$g] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
    	}

    	tabindicator = new TabIndicator({
    			props: tabindicator_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabindicator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabindicator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabindicator_changes = (dirty & /*active, prefixFilter, $$props*/ 4097)
    			? get_spread_update(tabindicator_spread_levels, [
    					dirty & /*active*/ 1 && { active: /*active*/ ctx[0] },
    					dirty & /*prefixFilter, $$props*/ 4096 && get_spread_object(prefixFilter(/*$$props*/ ctx[12], 'tabIndicator$'))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 8388608) {
    				tabindicator_changes.$$scope = { dirty, ctx };
    			}

    			tabindicator.$set(tabindicator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabindicator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabindicator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabindicator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(24:4) {#if indicatorSpanOnlyContent}",
    		ctx
    	});

    	return block;
    }

    // (25:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >
    function create_default_slot_1$g(ctx) {
    	let current;
    	const tab_indicator_slot_template = /*#slots*/ ctx[21]["tab-indicator"];
    	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[23], get_tab_indicator_slot_context);

    	const block = {
    		c: function create() {
    			if (tab_indicator_slot) tab_indicator_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (tab_indicator_slot) {
    				tab_indicator_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tab_indicator_slot) {
    				if (tab_indicator_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						tab_indicator_slot,
    						tab_indicator_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(tab_indicator_slot_template, /*$$scope*/ ctx[23], dirty, get_tab_indicator_slot_changes),
    						get_tab_indicator_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab_indicator_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab_indicator_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(25:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#if !indicatorSpanOnlyContent}
    function create_if_block_1$f(ctx) {
    	let tabindicator;
    	let current;

    	const tabindicator_spread_levels = [
    		{ active: /*active*/ ctx[0] },
    		prefixFilter(/*$$props*/ ctx[12], 'tabIndicator$')
    	];

    	let tabindicator_props = {
    		$$slots: { default: [create_default_slot$u] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
    	}

    	tabindicator = new TabIndicator({
    			props: tabindicator_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabindicator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabindicator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabindicator_changes = (dirty & /*active, prefixFilter, $$props*/ 4097)
    			? get_spread_update(tabindicator_spread_levels, [
    					dirty & /*active*/ 1 && { active: /*active*/ ctx[0] },
    					dirty & /*prefixFilter, $$props*/ 4096 && get_spread_object(prefixFilter(/*$$props*/ ctx[12], 'tabIndicator$'))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 8388608) {
    				tabindicator_changes.$$scope = { dirty, ctx };
    			}

    			tabindicator.$set(tabindicator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabindicator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabindicator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabindicator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(31:2) {#if !indicatorSpanOnlyContent}",
    		ctx
    	});

    	return block;
    }

    // (32:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >
    function create_default_slot$u(ctx) {
    	let current;
    	const tab_indicator_slot_template = /*#slots*/ ctx[21]["tab-indicator"];
    	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[23], get_tab_indicator_slot_context_1);

    	const block = {
    		c: function create() {
    			if (tab_indicator_slot) tab_indicator_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (tab_indicator_slot) {
    				tab_indicator_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (tab_indicator_slot) {
    				if (tab_indicator_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						tab_indicator_slot,
    						tab_indicator_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(tab_indicator_slot_template, /*$$scope*/ ctx[23], dirty, get_tab_indicator_slot_changes_1),
    						get_tab_indicator_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab_indicator_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab_indicator_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(32:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >",
    		ctx
    	});

    	return block;
    }

    // (37:2) {#if ripple}
    function create_if_block$D(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "mdc-tab__ripple");
    			add_location(span, file$1m, 37, 4, 1093);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(37:2) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1v(ctx) {
    	let button;
    	let span;
    	let t0;
    	let span_class_value;
    	let useActions_action;
    	let t1;
    	let t2;
    	let button_class_value;
    	let button_tabindex_value;
    	let useActions_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[21].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);
    	let if_block0 = /*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_2$7(ctx);

    	let span_levels = [
    		{
    			class: span_class_value = "mdc-tab__content " + /*content$class*/ ctx[8]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[12], 'content$'), ['use', 'class'])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	let if_block1 = !/*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_1$f(ctx);
    	let if_block2 = /*ripple*/ ctx[3] && create_if_block$D(ctx);

    	let button_levels = [
    		{
    			class: button_class_value = "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? 'mdc-tab--active' : '') + "\n    " + (/*stacked*/ ctx[4] ? 'mdc-tab--stacked' : '') + "\n    " + (/*minWidth*/ ctx[5] ? 'mdc-tab--min-width' : '') + "\n  "
    		},
    		{ role: "tab" },
    		{ "aria-selected": /*active*/ ctx[0] },
    		{
    			tabindex: button_tabindex_value = /*active*/ ctx[0] ? '0' : '-1'
    		},
    		exclude(/*$$props*/ ctx[12], [
    			'use',
    			'class',
    			'ripple',
    			'active',
    			'stacked',
    			'minWidth',
    			'indicatorSpanOnlyContent',
    			'focusOnActivate',
    			'content$',
    			'tabIndicator$'
    		])
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			span = element("span");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			set_attributes(span, span_data);
    			add_location(span, file$1m, 17, 2, 517);
    			set_attributes(button, button_data);
    			add_location(button, file$1m, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, span);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			append_dev(span, t0);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(button, t1);
    			if (if_block1) if_block1.m(button, null);
    			append_dev(button, t2);
    			if (if_block2) if_block2.m(button, null);
    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[22](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*content$use*/ ctx[7])),
    					action_destroyer(useActions_action_1 = useActions.call(null, button, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[10].call(null, button)),
    					listen_dev(button, "MDCTab:interacted", /*interactedHandler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*indicatorSpanOnlyContent*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*indicatorSpanOnlyContent*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*content$class*/ 256 && span_class_value !== (span_class_value = "mdc-tab__content " + /*content$class*/ ctx[8])) && { class: span_class_value },
    				dirty & /*$$props*/ 4096 && exclude(prefixFilter(/*$$props*/ ctx[12], 'content$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/ 128) useActions_action.update.call(null, /*content$use*/ ctx[7]);

    			if (!/*indicatorSpanOnlyContent*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*indicatorSpanOnlyContent*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(button, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*ripple*/ ctx[3]) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$D(ctx);
    					if_block2.c();
    					if_block2.m(button, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty & /*className, active, stacked, minWidth*/ 53 && button_class_value !== (button_class_value = "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? 'mdc-tab--active' : '') + "\n    " + (/*stacked*/ ctx[4] ? 'mdc-tab--stacked' : '') + "\n    " + (/*minWidth*/ ctx[5] ? 'mdc-tab--min-width' : '') + "\n  ")) && { class: button_class_value },
    				{ role: "tab" },
    				(!current || dirty & /*active*/ 1) && { "aria-selected": /*active*/ ctx[0] },
    				(!current || dirty & /*active*/ 1 && button_tabindex_value !== (button_tabindex_value = /*active*/ ctx[0] ? '0' : '-1')) && { tabindex: button_tabindex_value },
    				dirty & /*$$props*/ 4096 && exclude(/*$$props*/ ctx[12], [
    					'use',
    					'class',
    					'ripple',
    					'active',
    					'stacked',
    					'minWidth',
    					'indicatorSpanOnlyContent',
    					'focusOnActivate',
    					'content$',
    					'tabIndicator$'
    				])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 2) useActions_action_1.update.call(null, /*use*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*button_binding*/ ctx[22](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default','tab-indicator']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCTab:interacted']);
    	let activeEntry = getContext('SMUI:tab:active');
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { tab: tabEntry } = $$props;
    	let { ripple = true } = $$props;
    	let { active = tabEntry === activeEntry } = $$props;
    	let { stacked = false } = $$props;
    	let { minWidth = false } = $$props;
    	let { indicatorSpanOnlyContent = false } = $$props;
    	let { focusOnActivate = true } = $$props;
    	let { content$use = [] } = $$props;
    	let { content$class = '' } = $$props;
    	let element;
    	let tab;
    	let instantiate = getContext('SMUI:tab:instantiate');
    	let getInstance = getContext('SMUI:tab:getInstance');
    	let tabIndicatorPromiseResolve;
    	let tabIndicatorPromise = new Promise(resolve => tabIndicatorPromiseResolve = resolve);
    	setContext('SMUI:tab-indicator:instantiate', false);
    	setContext('SMUI:tab-indicator:getInstance', getTabIndicatorInstancePromise);
    	setContext('SMUI:label:context', 'tab');
    	setContext('SMUI:icon:context', 'tab');

    	if (!tabEntry) {
    		throw new Error('The tab property is required! It should be passed down from the TabBar to the Tab.');
    	}

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(20, tab = new MDCTab(element));
    		} else {
    			$$invalidate(20, tab = await getInstance(tabEntry));
    		}

    		tabIndicatorPromiseResolve(tab.tabIndicator_);

    		if (!ripple) {
    			tab.ripple_ && tab.ripple_.destroy();
    		}
    	});

    	onDestroy(() => {
    		tab && tab.destroy();
    	});

    	function getTabIndicatorInstancePromise() {
    		return tabIndicatorPromise;
    	}

    	function interactedHandler() {
    		$$invalidate(0, active = tab.active);
    	}

    	function activate(...args) {
    		$$invalidate(0, active = true);
    		return tab.activate(...args);
    	}

    	function deactivate(...args) {
    		$$invalidate(0, active = false);
    		return tab.deactivate(...args);
    	}

    	function focus(...args) {
    		return tab.focus(...args);
    	}

    	function computeIndicatorClientRect(...args) {
    		return tab.computeIndicatorClientRect(...args);
    	}

    	function computeDimensions(...args) {
    		return tab.computeDimensions(...args);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(9, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('tab' in $$new_props) $$invalidate(13, tabEntry = $$new_props.tab);
    		if ('ripple' in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('active' in $$new_props) $$invalidate(0, active = $$new_props.active);
    		if ('stacked' in $$new_props) $$invalidate(4, stacked = $$new_props.stacked);
    		if ('minWidth' in $$new_props) $$invalidate(5, minWidth = $$new_props.minWidth);
    		if ('indicatorSpanOnlyContent' in $$new_props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    		if ('focusOnActivate' in $$new_props) $$invalidate(14, focusOnActivate = $$new_props.focusOnActivate);
    		if ('content$use' in $$new_props) $$invalidate(7, content$use = $$new_props.content$use);
    		if ('content$class' in $$new_props) $$invalidate(8, content$class = $$new_props.content$class);
    		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTab,
    		onMount,
    		onDestroy,
    		setContext,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		TabIndicator,
    		forwardEvents,
    		activeEntry,
    		use,
    		className,
    		tabEntry,
    		ripple,
    		active,
    		stacked,
    		minWidth,
    		indicatorSpanOnlyContent,
    		focusOnActivate,
    		content$use,
    		content$class,
    		element,
    		tab,
    		instantiate,
    		getInstance,
    		tabIndicatorPromiseResolve,
    		tabIndicatorPromise,
    		getTabIndicatorInstancePromise,
    		interactedHandler,
    		activate,
    		deactivate,
    		focus,
    		computeIndicatorClientRect,
    		computeDimensions
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    		if ('activeEntry' in $$props) activeEntry = $$new_props.activeEntry;
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('tabEntry' in $$props) $$invalidate(13, tabEntry = $$new_props.tabEntry);
    		if ('ripple' in $$props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('active' in $$props) $$invalidate(0, active = $$new_props.active);
    		if ('stacked' in $$props) $$invalidate(4, stacked = $$new_props.stacked);
    		if ('minWidth' in $$props) $$invalidate(5, minWidth = $$new_props.minWidth);
    		if ('indicatorSpanOnlyContent' in $$props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    		if ('focusOnActivate' in $$props) $$invalidate(14, focusOnActivate = $$new_props.focusOnActivate);
    		if ('content$use' in $$props) $$invalidate(7, content$use = $$new_props.content$use);
    		if ('content$class' in $$props) $$invalidate(8, content$class = $$new_props.content$class);
    		if ('element' in $$props) $$invalidate(9, element = $$new_props.element);
    		if ('tab' in $$props) $$invalidate(20, tab = $$new_props.tab);
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    		if ('tabIndicatorPromiseResolve' in $$props) tabIndicatorPromiseResolve = $$new_props.tabIndicatorPromiseResolve;
    		if ('tabIndicatorPromise' in $$props) tabIndicatorPromise = $$new_props.tabIndicatorPromise;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tab, focusOnActivate*/ 1064960) {
    			if (tab) {
    				$$invalidate(20, tab.focusOnActivate = focusOnActivate, tab);
    			}
    		}

    		if ($$self.$$.dirty & /*tab, active*/ 1048577) {
    			if (tab && tab.active !== active) {
    				$$invalidate(0, active = tab.active);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		active,
    		use,
    		className,
    		ripple,
    		stacked,
    		minWidth,
    		indicatorSpanOnlyContent,
    		content$use,
    		content$class,
    		element,
    		forwardEvents,
    		interactedHandler,
    		$$props,
    		tabEntry,
    		focusOnActivate,
    		activate,
    		deactivate,
    		focus,
    		computeIndicatorClientRect,
    		computeDimensions,
    		tab,
    		slots,
    		button_binding,
    		$$scope
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1v, create_fragment$1v, safe_not_equal, {
    			use: 1,
    			class: 2,
    			tab: 13,
    			ripple: 3,
    			active: 0,
    			stacked: 4,
    			minWidth: 5,
    			indicatorSpanOnlyContent: 6,
    			focusOnActivate: 14,
    			content$use: 7,
    			content$class: 8,
    			activate: 15,
    			deactivate: 16,
    			focus: 17,
    			computeIndicatorClientRect: 18,
    			computeDimensions: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$1v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabEntry*/ ctx[13] === undefined && !('tab' in props)) {
    			console.warn("<Tab> was created without expected prop 'tab'");
    		}
    	}

    	get use() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stacked() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stacked(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minWidth() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minWidth(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSpanOnlyContent() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSpanOnlyContent(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusOnActivate() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusOnActivate(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$use() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$use(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content$class() {
    		throw new Error_1$1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content$class(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[15];
    	}

    	set activate(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[16];
    	}

    	set deactivate(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[17];
    	}

    	set focus(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeIndicatorClientRect() {
    		return this.$$.ctx[18];
    	}

    	set computeIndicatorClientRect(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get computeDimensions() {
    		return this.$$.ctx[19];
    	}

    	set computeDimensions(value) {
    		throw new Error_1$1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Label.svelte generated by Svelte v3.42.1 */
    const file$1l = "node_modules\\@smui\\common\\Label.svelte";

    function create_fragment$1u(ctx) {
    	let span;
    	let span_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	let span_levels = [
    		{
    			class: span_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === 'button'
    			? 'mdc-button__label'
    			: '') + "\n    " + (/*context*/ ctx[3] === 'fab' ? 'mdc-fab__label' : '') + "\n    " + (/*context*/ ctx[3] === 'chip' ? 'mdc-chip__text' : '') + "\n    " + (/*context*/ ctx[3] === 'tab'
    			? 'mdc-tab__text-label'
    			: '') + "\n    " + (/*context*/ ctx[3] === 'image-list'
    			? 'mdc-image-list__label'
    			: '') + "\n    " + (/*context*/ ctx[3] === 'snackbar'
    			? 'mdc-snackbar__label'
    			: '') + "\n  "
    		},
    		/*context*/ ctx[3] === 'snackbar'
    		? { role: 'status', 'aria-live': 'polite' }
    		: {},
    		exclude(/*$$props*/ ctx[4], ['use', 'class'])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$1l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, span))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === 'button'
    				? 'mdc-button__label'
    				: '') + "\n    " + (/*context*/ ctx[3] === 'fab' ? 'mdc-fab__label' : '') + "\n    " + (/*context*/ ctx[3] === 'chip' ? 'mdc-chip__text' : '') + "\n    " + (/*context*/ ctx[3] === 'tab'
    				? 'mdc-tab__text-label'
    				: '') + "\n    " + (/*context*/ ctx[3] === 'image-list'
    				? 'mdc-image-list__label'
    				: '') + "\n    " + (/*context*/ ctx[3] === 'snackbar'
    				? 'mdc-snackbar__label'
    				: '') + "\n  ")) && { class: span_class_value },
    				/*context*/ ctx[3] === 'snackbar'
    				? { role: 'status', 'aria-live': 'polite' }
    				: {},
    				dirty & /*$$props*/ 16 && exclude(/*$$props*/ ctx[4], ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	const context = getContext('SMUI:label:context');

    	$$self.$$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		context
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, className, forwardEvents, context, $$props, $$scope, slots];
    }

    class Label$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1u, create_fragment$1u, safe_not_equal, { use: 0, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$1u.name
    		});
    	}

    	get use() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Icon.svelte generated by Svelte v3.42.1 */
    const file$1k = "node_modules\\@smui\\common\\Icon.svelte";

    function create_fragment$1t(ctx) {
    	let i;
    	let i_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	let i_levels = [
    		{
    			class: i_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === 'button'
    			? 'mdc-button__icon'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'fab' ? 'mdc-fab__icon' : '') + "\n    " + (/*context*/ ctx[7] === 'icon-button'
    			? 'mdc-icon-button__icon'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'icon-button' && /*on*/ ctx[2]
    			? 'mdc-icon-button__icon--on'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'chip' ? 'mdc-chip__icon' : '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*leading*/ ctx[3]
    			? 'mdc-chip__icon--leading'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*leadingHidden*/ ctx[4]
    			? 'mdc-chip__icon--leading-hidden'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*trailing*/ ctx[5]
    			? 'mdc-chip__icon--trailing'
    			: '') + "\n    " + (/*context*/ ctx[7] === 'tab' ? 'mdc-tab__icon' : '') + "\n  "
    		},
    		{ "aria-hidden": "true" },
    		exclude(/*$$props*/ ctx[8], ['use', 'class', 'on', 'leading', 'leadingHidden', 'trailing'])
    	];

    	let i_data = {};

    	for (let i = 0; i < i_levels.length; i += 1) {
    		i_data = assign(i_data, i_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			i = element("i");
    			if (default_slot) default_slot.c();
    			set_attributes(i, i_data);
    			add_location(i, file$1k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);

    			if (default_slot) {
    				default_slot.m(i, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, i, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[6].call(null, i))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(i, i_data = get_spread_update(i_levels, [
    				(!current || dirty & /*className, on, leading, leadingHidden, trailing*/ 62 && i_class_value !== (i_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === 'button'
    				? 'mdc-button__icon'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'fab' ? 'mdc-fab__icon' : '') + "\n    " + (/*context*/ ctx[7] === 'icon-button'
    				? 'mdc-icon-button__icon'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'icon-button' && /*on*/ ctx[2]
    				? 'mdc-icon-button__icon--on'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'chip' ? 'mdc-chip__icon' : '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*leading*/ ctx[3]
    				? 'mdc-chip__icon--leading'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*leadingHidden*/ ctx[4]
    				? 'mdc-chip__icon--leading-hidden'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'chip' && /*trailing*/ ctx[5]
    				? 'mdc-chip__icon--trailing'
    				: '') + "\n    " + (/*context*/ ctx[7] === 'tab' ? 'mdc-tab__icon' : '') + "\n  ")) && { class: i_class_value },
    				{ "aria-hidden": "true" },
    				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ['use', 'class', 'on', 'leading', 'leadingHidden', 'trailing'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { on = false } = $$props;
    	let { leading = false } = $$props;
    	let { leadingHidden = false } = $$props;
    	let { trailing = false } = $$props;
    	const context = getContext('SMUI:icon:context');

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('on' in $$new_props) $$invalidate(2, on = $$new_props.on);
    		if ('leading' in $$new_props) $$invalidate(3, leading = $$new_props.leading);
    		if ('leadingHidden' in $$new_props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
    		if ('trailing' in $$new_props) $$invalidate(5, trailing = $$new_props.trailing);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		on,
    		leading,
    		leadingHidden,
    		trailing,
    		context
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('on' in $$props) $$invalidate(2, on = $$new_props.on);
    		if ('leading' in $$props) $$invalidate(3, leading = $$new_props.leading);
    		if ('leadingHidden' in $$props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
    		if ('trailing' in $$props) $$invalidate(5, trailing = $$new_props.trailing);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		on,
    		leading,
    		leadingHidden,
    		trailing,
    		forwardEvents,
    		context,
    		$$props,
    		$$scope,
    		slots
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1t, create_fragment$1t, safe_not_equal, {
    			use: 0,
    			class: 1,
    			on: 2,
    			leading: 3,
    			leadingHidden: 4,
    			trailing: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$1t.name
    		});
    	}

    	get use() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leading() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leading(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leadingHidden() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leadingHidden(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trailing() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trailing(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$j = {
        ANIMATING: 'mdc-tab-scroller--animating',
        SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll',
        SCROLL_TEST: 'mdc-tab-scroller__test',
    };
    var strings$m = {
        AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
        CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTL = /** @class */ (function () {
        function MDCTabScrollerRTL(adapter) {
            this.adapter_ = adapter;
        }
        return MDCTabScrollerRTL;
    }());

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLDefault = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLDefault, _super);
        function MDCTabScrollerRTLDefault() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLDefault.prototype.getScrollPositionRTL = function () {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var right = this.calculateScrollEdges_().right;
            // Scroll values on most browsers are ints instead of floats so we round
            return Math.round(right - currentScrollLeft);
        };
        MDCTabScrollerRTLDefault.prototype.scrollToRTL = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLDefault.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLDefault.prototype.getAnimatingScrollPosition = function (scrollX) {
            return scrollX;
        };
        MDCTabScrollerRTLDefault.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: 0,
                right: contentWidth - rootWidth,
            };
        };
        MDCTabScrollerRTLDefault.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.left, scrollX), edges.right);
        };
        return MDCTabScrollerRTLDefault;
    }(MDCTabScrollerRTL));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLNegative = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLNegative, _super);
        function MDCTabScrollerRTLNegative() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLNegative.prototype.getScrollPositionRTL = function (translateX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            return Math.round(translateX - currentScrollLeft);
        };
        MDCTabScrollerRTLNegative.prototype.scrollToRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(-scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLNegative.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: clampedScrollLeft - currentScrollLeft,
            };
        };
        MDCTabScrollerRTLNegative.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
            return scrollX - translateX;
        };
        MDCTabScrollerRTLNegative.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: rootWidth - contentWidth,
                right: 0,
            };
        };
        MDCTabScrollerRTLNegative.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.max(Math.min(edges.right, scrollX), edges.left);
        };
        return MDCTabScrollerRTLNegative;
    }(MDCTabScrollerRTL));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerRTLReverse = /** @class */ (function (_super) {
        __extends(MDCTabScrollerRTLReverse, _super);
        function MDCTabScrollerRTLReverse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScrollerRTLReverse.prototype.getScrollPositionRTL = function (translateX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            // Scroll values on most browsers are ints instead of floats so we round
            return Math.round(currentScrollLeft - translateX);
        };
        MDCTabScrollerRTLReverse.prototype.scrollToRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: currentScrollLeft - clampedScrollLeft,
            };
        };
        MDCTabScrollerRTLReverse.prototype.incrementScrollRTL = function (scrollX) {
            var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
            return {
                finalScrollPosition: clampedScrollLeft,
                scrollDelta: currentScrollLeft - clampedScrollLeft,
            };
        };
        MDCTabScrollerRTLReverse.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
            return scrollX + translateX;
        };
        MDCTabScrollerRTLReverse.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: contentWidth - rootWidth,
                right: 0,
            };
        };
        MDCTabScrollerRTLReverse.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.right, scrollX), edges.left);
        };
        return MDCTabScrollerRTLReverse;
    }(MDCTabScrollerRTL));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScrollerFoundation = /** @class */ (function (_super) {
        __extends(MDCTabScrollerFoundation, _super);
        function MDCTabScrollerFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabScrollerFoundation.defaultAdapter, adapter)) || this;
            /**
             * Controls whether we should handle the transitionend and interaction events during the animation.
             */
            _this.isAnimating_ = false;
            return _this;
        }
        Object.defineProperty(MDCTabScrollerFoundation, "cssClasses", {
            get: function () {
                return cssClasses$j;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabScrollerFoundation, "strings", {
            get: function () {
                return strings$m;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabScrollerFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    eventTargetMatchesSelector: function () { return false; },
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    addScrollAreaClass: function () { return undefined; },
                    setScrollAreaStyleProperty: function () { return undefined; },
                    setScrollContentStyleProperty: function () { return undefined; },
                    getScrollContentStyleValue: function () { return ''; },
                    setScrollAreaScrollLeft: function () { return undefined; },
                    getScrollAreaScrollLeft: function () { return 0; },
                    getScrollContentOffsetWidth: function () { return 0; },
                    getScrollAreaOffsetWidth: function () { return 0; },
                    computeScrollAreaClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    computeScrollContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    computeHorizontalScrollbarHeight: function () { return 0; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTabScrollerFoundation.prototype.init = function () {
            // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
            // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
            var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
            this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
            this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
        };
        /**
         * Computes the current visual scroll position
         */
        MDCTabScrollerFoundation.prototype.getScrollPosition = function () {
            if (this.isRTL_()) {
                return this.computeCurrentScrollPositionRTL_();
            }
            var currentTranslateX = this.calculateCurrentTranslateX_();
            var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
            return scrollLeft - currentTranslateX;
        };
        /**
         * Handles interaction events that occur during transition
         */
        MDCTabScrollerFoundation.prototype.handleInteraction = function () {
            // Early exit if we aren't animating
            if (!this.isAnimating_) {
                return;
            }
            // Prevent other event listeners from handling this event
            this.stopScrollAnimation_();
        };
        /**
         * Handles the transitionend event
         */
        MDCTabScrollerFoundation.prototype.handleTransitionEnd = function (evt) {
            // Early exit if we aren't animating or the event was triggered by a different element.
            var evtTarget = evt.target;
            if (!this.isAnimating_ ||
                !this.adapter_.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
                return;
            }
            this.isAnimating_ = false;
            this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        };
        /**
         * Increment the scroll value by the scrollXIncrement
         * @param scrollXIncrement The value by which to increment the scroll position
         */
        MDCTabScrollerFoundation.prototype.incrementScroll = function (scrollXIncrement) {
            // Early exit for non-operational increment values
            if (scrollXIncrement === 0) {
                return;
            }
            if (this.isRTL_()) {
                return this.incrementScrollRTL_(scrollXIncrement);
            }
            this.incrementScroll_(scrollXIncrement);
        };
        /**
         * Scrolls to the given scrollX value
         */
        MDCTabScrollerFoundation.prototype.scrollTo = function (scrollX) {
            if (this.isRTL_()) {
                return this.scrollToRTL_(scrollX);
            }
            this.scrollTo_(scrollX);
        };
        /**
         * @return Browser-specific {@link MDCTabScrollerRTL} instance.
         */
        MDCTabScrollerFoundation.prototype.getRTLScroller = function () {
            if (!this.rtlScrollerInstance_) {
                this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
            }
            return this.rtlScrollerInstance_;
        };
        /**
         * @return translateX value from a CSS matrix transform function string.
         */
        MDCTabScrollerFoundation.prototype.calculateCurrentTranslateX_ = function () {
            var transformValue = this.adapter_.getScrollContentStyleValue('transform');
            // Early exit if no transform is present
            if (transformValue === 'none') {
                return 0;
            }
            // The transform value comes back as a matrix transformation in the form
            // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
            // we're going to grab all the parenthesized values, strip out tx, and
            // parse it.
            var match = /\((.+?)\)/.exec(transformValue);
            if (!match) {
                return 0;
            }
            var matrixParams = match[1];
            // tslint:disable-next-line:ban-ts-ignore "Unused vars" should be a linter warning, not a compiler error.
            // @ts-ignore These unused variables should retain their semantic names for clarity.
            var _a = __read(matrixParams.split(','), 6); _a[0]; _a[1]; _a[2]; _a[3]; var tx = _a[4]; _a[5];
            return parseFloat(tx); // tslint:disable-line:ban
        };
        /**
         * Calculates a safe scroll value that is > 0 and < the max scroll value
         * @param scrollX The distance to scroll
         */
        MDCTabScrollerFoundation.prototype.clampScrollValue_ = function (scrollX) {
            var edges = this.calculateScrollEdges_();
            return Math.min(Math.max(edges.left, scrollX), edges.right);
        };
        MDCTabScrollerFoundation.prototype.computeCurrentScrollPositionRTL_ = function () {
            var translateX = this.calculateCurrentTranslateX_();
            return this.getRTLScroller().getScrollPositionRTL(translateX);
        };
        MDCTabScrollerFoundation.prototype.calculateScrollEdges_ = function () {
            var contentWidth = this.adapter_.getScrollContentOffsetWidth();
            var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
            return {
                left: 0,
                right: contentWidth - rootWidth,
            };
        };
        /**
         * Internal scroll method
         * @param scrollX The new scroll position
         */
        MDCTabScrollerFoundation.prototype.scrollTo_ = function (scrollX) {
            var currentScrollX = this.getScrollPosition();
            var safeScrollX = this.clampScrollValue_(scrollX);
            var scrollDelta = safeScrollX - currentScrollX;
            this.animate_({
                finalScrollPosition: safeScrollX,
                scrollDelta: scrollDelta,
            });
        };
        /**
         * Internal RTL scroll method
         * @param scrollX The new scroll position
         */
        MDCTabScrollerFoundation.prototype.scrollToRTL_ = function (scrollX) {
            var animation = this.getRTLScroller().scrollToRTL(scrollX);
            this.animate_(animation);
        };
        /**
         * Internal increment scroll method
         * @param scrollX The new scroll position increment
         */
        MDCTabScrollerFoundation.prototype.incrementScroll_ = function (scrollX) {
            var currentScrollX = this.getScrollPosition();
            var targetScrollX = scrollX + currentScrollX;
            var safeScrollX = this.clampScrollValue_(targetScrollX);
            var scrollDelta = safeScrollX - currentScrollX;
            this.animate_({
                finalScrollPosition: safeScrollX,
                scrollDelta: scrollDelta,
            });
        };
        /**
         * Internal increment scroll RTL method
         * @param scrollX The new scroll position RTL increment
         */
        MDCTabScrollerFoundation.prototype.incrementScrollRTL_ = function (scrollX) {
            var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
            this.animate_(animation);
        };
        /**
         * Animates the tab scrolling
         * @param animation The animation to apply
         */
        MDCTabScrollerFoundation.prototype.animate_ = function (animation) {
            var _this = this;
            // Early exit if translateX is 0, which means there's no animation to perform
            if (animation.scrollDelta === 0) {
                return;
            }
            this.stopScrollAnimation_();
            // This animation uses the FLIP approach.
            // Read more here: https://aerotwist.com/blog/flip-your-animations/
            this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
            this.adapter_.setScrollContentStyleProperty('transform', "translateX(" + animation.scrollDelta + "px)");
            // Force repaint
            this.adapter_.computeScrollAreaClientRect();
            requestAnimationFrame(function () {
                _this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
                _this.adapter_.setScrollContentStyleProperty('transform', 'none');
            });
            this.isAnimating_ = true;
        };
        /**
         * Stops scroll animation
         */
        MDCTabScrollerFoundation.prototype.stopScrollAnimation_ = function () {
            this.isAnimating_ = false;
            var currentScrollPosition = this.getAnimatingScrollPosition_();
            this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
            this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
            this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
        };
        /**
         * Gets the current scroll position during animation
         */
        MDCTabScrollerFoundation.prototype.getAnimatingScrollPosition_ = function () {
            var currentTranslateX = this.calculateCurrentTranslateX_();
            var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
            if (this.isRTL_()) {
                return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
            }
            return scrollLeft - currentTranslateX;
        };
        /**
         * Determines the RTL Scroller to use
         */
        MDCTabScrollerFoundation.prototype.rtlScrollerFactory_ = function () {
            // Browsers have three different implementations of scrollLeft in RTL mode,
            // dependent on the browser. The behavior is based off the max LTR
            // scrollLeft value and 0.
            //
            // * Default scrolling in RTL *
            //    - Left-most value: 0
            //    - Right-most value: Max LTR scrollLeft value
            //
            // * Negative scrolling in RTL *
            //    - Left-most value: Negated max LTR scrollLeft value
            //    - Right-most value: 0
            //
            // * Reverse scrolling in RTL *
            //    - Left-most value: Max LTR scrollLeft value
            //    - Right-most value: 0
            //
            // We use those principles below to determine which RTL scrollLeft
            // behavior is implemented in the current browser.
            var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
            var newScrollLeft = this.adapter_.getScrollAreaScrollLeft();
            // If the newScrollLeft value is negative,then we know that the browser has
            // implemented negative RTL scrolling, since all other implementations have
            // only positive values.
            if (newScrollLeft < 0) {
                // Undo the scrollLeft test check
                this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
                return new MDCTabScrollerRTLNegative(this.adapter_);
            }
            var rootClientRect = this.adapter_.computeScrollAreaClientRect();
            var contentClientRect = this.adapter_.computeScrollContentClientRect();
            var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            // By calculating the clientRect of the root element and the clientRect of
            // the content element, we can determine how much the scroll value changed
            // when we performed the scrollLeft subtraction above.
            if (rightEdgeDelta === newScrollLeft) {
                return new MDCTabScrollerRTLReverse(this.adapter_);
            }
            return new MDCTabScrollerRTLDefault(this.adapter_);
        };
        MDCTabScrollerFoundation.prototype.isRTL_ = function () {
            return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
        };
        return MDCTabScrollerFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
     */
    var horizontalScrollbarHeight_;
    /**
     * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
     * May return 0 (e.g. on OS X browsers under default configuration).
     */
    function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
        if (shouldCacheResult === void 0) { shouldCacheResult = true; }
        if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
            return horizontalScrollbarHeight_;
        }
        var el = documentObj.createElement('div');
        el.classList.add(cssClasses$j.SCROLL_TEST);
        documentObj.body.appendChild(el);
        var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
        documentObj.body.removeChild(el);
        if (shouldCacheResult) {
            horizontalScrollbarHeight_ = horizontalScrollbarHeight;
        }
        return horizontalScrollbarHeight;
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTabScroller = /** @class */ (function (_super) {
        __extends(MDCTabScroller, _super);
        function MDCTabScroller() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabScroller.attachTo = function (root) {
            return new MDCTabScroller(root);
        };
        MDCTabScroller.prototype.initialize = function () {
            this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
            this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
        };
        MDCTabScroller.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleInteraction_ = function () { return _this.foundation_.handleInteraction(); };
            this.handleTransitionEnd_ = function (evt) { return _this.foundation_.handleTransitionEnd(evt); };
            this.area_.addEventListener('wheel', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('touchstart', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('pointerdown', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('mousedown', this.handleInteraction_, applyPassive());
            this.area_.addEventListener('keydown', this.handleInteraction_, applyPassive());
            this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
        };
        MDCTabScroller.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.area_.removeEventListener('wheel', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('touchstart', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('pointerdown', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('mousedown', this.handleInteraction_, applyPassive());
            this.area_.removeEventListener('keydown', this.handleInteraction_, applyPassive());
            this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
        };
        MDCTabScroller.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                eventTargetMatchesSelector: function (evtTarget, selector) { return matches$1(evtTarget, selector); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                addScrollAreaClass: function (className) { return _this.area_.classList.add(className); },
                setScrollAreaStyleProperty: function (prop, value) { return _this.area_.style.setProperty(prop, value); },
                setScrollContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
                getScrollContentStyleValue: function (propName) { return window.getComputedStyle(_this.content_).getPropertyValue(propName); },
                setScrollAreaScrollLeft: function (scrollX) { return _this.area_.scrollLeft = scrollX; },
                getScrollAreaScrollLeft: function () { return _this.area_.scrollLeft; },
                getScrollContentOffsetWidth: function () { return _this.content_.offsetWidth; },
                getScrollAreaOffsetWidth: function () { return _this.area_.offsetWidth; },
                computeScrollAreaClientRect: function () { return _this.area_.getBoundingClientRect(); },
                computeScrollContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
                computeHorizontalScrollbarHeight: function () { return computeHorizontalScrollbarHeight(document); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabScrollerFoundation(adapter);
        };
        /**
         * Returns the current visual scroll position
         */
        MDCTabScroller.prototype.getScrollPosition = function () {
            return this.foundation_.getScrollPosition();
        };
        /**
         * Returns the width of the scroll content
         */
        MDCTabScroller.prototype.getScrollContentWidth = function () {
            return this.content_.offsetWidth;
        };
        /**
         * Increments the scroll value by the given amount
         * @param scrollXIncrement The pixel value by which to increment the scroll value
         */
        MDCTabScroller.prototype.incrementScroll = function (scrollXIncrement) {
            this.foundation_.incrementScroll(scrollXIncrement);
        };
        /**
         * Scrolls to the given pixel position
         * @param scrollX The pixel value to scroll to
         */
        MDCTabScroller.prototype.scrollTo = function (scrollX) {
            this.foundation_.scrollTo(scrollX);
        };
        return MDCTabScroller;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$l = {
        ARROW_LEFT_KEY: 'ArrowLeft',
        ARROW_RIGHT_KEY: 'ArrowRight',
        END_KEY: 'End',
        ENTER_KEY: 'Enter',
        HOME_KEY: 'Home',
        SPACE_KEY: 'Space',
        TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
        TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
        TAB_SELECTOR: '.mdc-tab',
    };
    var numbers$8 = {
        ARROW_LEFT_KEYCODE: 37,
        ARROW_RIGHT_KEYCODE: 39,
        END_KEYCODE: 35,
        ENTER_KEYCODE: 13,
        EXTRA_SCROLL_AMOUNT: 20,
        HOME_KEYCODE: 36,
        SPACE_KEYCODE: 32,
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var ACCEPTABLE_KEYS = new Set();
    // IE11 has no support for new Set with iterable so we need to initialize this by hand
    ACCEPTABLE_KEYS.add(strings$l.ARROW_LEFT_KEY);
    ACCEPTABLE_KEYS.add(strings$l.ARROW_RIGHT_KEY);
    ACCEPTABLE_KEYS.add(strings$l.END_KEY);
    ACCEPTABLE_KEYS.add(strings$l.HOME_KEY);
    ACCEPTABLE_KEYS.add(strings$l.ENTER_KEY);
    ACCEPTABLE_KEYS.add(strings$l.SPACE_KEY);
    var KEYCODE_MAP = new Map();
    // IE11 has no support for new Map with iterable so we need to initialize this by hand
    KEYCODE_MAP.set(numbers$8.ARROW_LEFT_KEYCODE, strings$l.ARROW_LEFT_KEY);
    KEYCODE_MAP.set(numbers$8.ARROW_RIGHT_KEYCODE, strings$l.ARROW_RIGHT_KEY);
    KEYCODE_MAP.set(numbers$8.END_KEYCODE, strings$l.END_KEY);
    KEYCODE_MAP.set(numbers$8.HOME_KEYCODE, strings$l.HOME_KEY);
    KEYCODE_MAP.set(numbers$8.ENTER_KEYCODE, strings$l.ENTER_KEY);
    KEYCODE_MAP.set(numbers$8.SPACE_KEYCODE, strings$l.SPACE_KEY);
    var MDCTabBarFoundation = /** @class */ (function (_super) {
        __extends(MDCTabBarFoundation, _super);
        function MDCTabBarFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTabBarFoundation.defaultAdapter, adapter)) || this;
            _this.useAutomaticActivation_ = false;
            return _this;
        }
        Object.defineProperty(MDCTabBarFoundation, "strings", {
            get: function () {
                return strings$l;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBarFoundation, "numbers", {
            get: function () {
                return numbers$8;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBarFoundation, "defaultAdapter", {
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    scrollTo: function () { return undefined; },
                    incrementScroll: function () { return undefined; },
                    getScrollPosition: function () { return 0; },
                    getScrollContentWidth: function () { return 0; },
                    getOffsetWidth: function () { return 0; },
                    isRTL: function () { return false; },
                    setActiveTab: function () { return undefined; },
                    activateTabAtIndex: function () { return undefined; },
                    deactivateTabAtIndex: function () { return undefined; },
                    focusTabAtIndex: function () { return undefined; },
                    getTabIndicatorClientRectAtIndex: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                    getTabDimensionsAtIndex: function () { return ({ rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 }); },
                    getPreviousActiveTabIndex: function () { return -1; },
                    getFocusedTabIndex: function () { return -1; },
                    getIndexOfTabById: function () { return -1; },
                    getTabListLength: function () { return 0; },
                    notifyTabActivated: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Switches between automatic and manual activation modes.
         * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
         */
        MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {
            this.useAutomaticActivation_ = useAutomaticActivation;
        };
        MDCTabBarFoundation.prototype.activateTab = function (index) {
            var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();
            if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
                return;
            }
            var previousClientRect;
            if (previousActiveIndex !== -1) {
                this.adapter_.deactivateTabAtIndex(previousActiveIndex);
                previousClientRect = this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex);
            }
            this.adapter_.activateTabAtIndex(index, previousClientRect);
            this.scrollIntoView(index);
            this.adapter_.notifyTabActivated(index);
        };
        MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {
            // Get the key from the event
            var key = this.getKeyFromEvent_(evt);
            // Early exit if the event key isn't one of the keyboard navigation keys
            if (key === undefined) {
                return;
            }
            // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple
            if (!this.isActivationKey_(key)) {
                evt.preventDefault();
            }
            if (this.useAutomaticActivation_) {
                if (this.isActivationKey_(key)) {
                    return;
                }
                var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
                this.adapter_.setActiveTab(index);
                this.scrollIntoView(index);
            }
            else {
                var focusedTabIndex = this.adapter_.getFocusedTabIndex();
                if (this.isActivationKey_(key)) {
                    this.adapter_.setActiveTab(focusedTabIndex);
                }
                else {
                    var index = this.determineTargetFromKey_(focusedTabIndex, key);
                    this.adapter_.focusTabAtIndex(index);
                    this.scrollIntoView(index);
                }
            }
        };
        /**
         * Handles the MDCTab:interacted event
         */
        MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {
            this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
        };
        /**
         * Scrolls the tab at the given index into view
         * @param index The tab index to make visible
         */
        MDCTabBarFoundation.prototype.scrollIntoView = function (index) {
            // Early exit if the index is out of range
            if (!this.indexIsInRange_(index)) {
                return;
            }
            // Always scroll to 0 if scrolling to the 0th index
            if (index === 0) {
                return this.adapter_.scrollTo(0);
            }
            // Always scroll to the max value if scrolling to the Nth index
            // MDCTabScroller.scrollTo() will never scroll past the max possible value
            if (index === this.adapter_.getTabListLength() - 1) {
                return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
            }
            if (this.isRTL_()) {
                return this.scrollIntoViewRTL_(index);
            }
            this.scrollIntoView_(index);
        };
        /**
         * Private method for determining the index of the destination tab based on what key was pressed
         * @param origin The original index from which to determine the destination
         * @param key The name of the key
         */
        MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {
            var isRTL = this.isRTL_();
            var maxIndex = this.adapter_.getTabListLength() - 1;
            var shouldGoToEnd = key === strings$l.END_KEY;
            var shouldDecrement = key === strings$l.ARROW_LEFT_KEY && !isRTL || key === strings$l.ARROW_RIGHT_KEY && isRTL;
            var shouldIncrement = key === strings$l.ARROW_RIGHT_KEY && !isRTL || key === strings$l.ARROW_LEFT_KEY && isRTL;
            var index = origin;
            if (shouldGoToEnd) {
                index = maxIndex;
            }
            else if (shouldDecrement) {
                index -= 1;
            }
            else if (shouldIncrement) {
                index += 1;
            }
            else {
                index = 0;
            }
            if (index < 0) {
                index = maxIndex;
            }
            else if (index > maxIndex) {
                index = 0;
            }
            return index;
        };
        /**
         * Calculates the scroll increment that will make the tab at the given index visible
         * @param index The index of the tab
         * @param nextIndex The index of the next tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the Tab Bar
         */
        MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {
            var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
            var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
            var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
            var leftIncrement = relativeContentRight - numbers$8.EXTRA_SCROLL_AMOUNT;
            var rightIncrement = relativeContentLeft + numbers$8.EXTRA_SCROLL_AMOUNT;
            if (nextIndex < index) {
                return Math.min(leftIncrement, 0);
            }
            return Math.max(rightIncrement, 0);
        };
        /**
         * Calculates the scroll increment that will make the tab at the given index visible in RTL
         * @param index The index of the tab
         * @param nextIndex The index of the next tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the Tab Bar
         * @param scrollContentWidth The width of the scroll content
         */
        MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
            var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
            var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
            var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
            var leftIncrement = relativeContentRight + numbers$8.EXTRA_SCROLL_AMOUNT;
            var rightIncrement = relativeContentLeft - numbers$8.EXTRA_SCROLL_AMOUNT;
            if (nextIndex > index) {
                return Math.max(leftIncrement, 0);
            }
            return Math.min(rightIncrement, 0);
        };
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar
         * @param index The index of the tab
         * @param tabDimensions The dimensions of the tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the tab bar
         */
        MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {
            /**
             * Tabs are laid out in the Tab Scroller like this:
             *
             *    Scroll Position
             *    +---+
             *    |   |   Bar Width
             *    |   +-----------------------------------+
             *    |   |                                   |
             *    |   V                                   V
             *    |   +-----------------------------------+
             *    V   |             Tab Scroller          |
             *    +------------+--------------+-------------------+
             *    |    Tab     |      Tab     |        Tab        |
             *    +------------+--------------+-------------------+
             *        |                                   |
             *        +-----------------------------------+
             *
             * To determine the next adjacent index, we look at the Tab root left and
             * Tab root right, both relative to the scroll position. If the Tab root
             * left is less than 0, then we know it's out of view to the left. If the
             * Tab root right minus the bar width is greater than 0, we know the Tab is
             * out of view to the right. From there, we either increment or decrement
             * the index.
             */
            var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
            var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
            var relativeRootDelta = relativeRootLeft + relativeRootRight;
            var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
            var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
            if (leftEdgeIsCloser) {
                return index - 1;
            }
            if (rightEdgeIsCloser) {
                return index + 1;
            }
            return -1;
        };
        /**
         * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
         * @param index The index of the tab
         * @param tabDimensions The dimensions of the tab
         * @param scrollPosition The current scroll position
         * @param barWidth The width of the tab bar
         * @param scrollContentWidth The width of the scroller content
         */
        MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
            var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
            var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
            var rootDelta = rootLeft + rootRight;
            var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
            var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
            if (leftEdgeIsCloser) {
                return index + 1;
            }
            if (rightEdgeIsCloser) {
                return index - 1;
            }
            return -1;
        };
        /**
         * Returns the key associated with a keydown event
         * @param evt The keydown event
         */
        MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {
            if (ACCEPTABLE_KEYS.has(evt.key)) {
                return evt.key;
            }
            return KEYCODE_MAP.get(evt.keyCode);
        };
        MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {
            return key === strings$l.SPACE_KEY || key === strings$l.ENTER_KEY;
        };
        /**
         * Returns whether a given index is inclusively between the ends
         * @param index The index to test
         */
        MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {
            return index >= 0 && index < this.adapter_.getTabListLength();
        };
        /**
         * Returns the view's RTL property
         */
        MDCTabBarFoundation.prototype.isRTL_ = function () {
            return this.adapter_.isRTL();
        };
        /**
         * Scrolls the tab at the given index into view for left-to-right user agents.
         * @param index The index of the tab to scroll into view
         */
        MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {
            var scrollPosition = this.adapter_.getScrollPosition();
            var barWidth = this.adapter_.getOffsetWidth();
            var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
            var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);
            if (!this.indexIsInRange_(nextIndex)) {
                return;
            }
            var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
            this.adapter_.incrementScroll(scrollIncrement);
        };
        /**
         * Scrolls the tab at the given index into view in RTL
         * @param index The tab index to make visible
         */
        MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {
            var scrollPosition = this.adapter_.getScrollPosition();
            var barWidth = this.adapter_.getOffsetWidth();
            var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
            var scrollWidth = this.adapter_.getScrollContentWidth();
            var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
            if (!this.indexIsInRange_(nextIndex)) {
                return;
            }
            var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
            this.adapter_.incrementScroll(scrollIncrement);
        };
        return MDCTabBarFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$k = MDCTabBarFoundation.strings;
    var tabIdCounter = 0;
    var MDCTabBar = /** @class */ (function (_super) {
        __extends(MDCTabBar, _super);
        function MDCTabBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTabBar.attachTo = function (root) {
            return new MDCTabBar(root);
        };
        Object.defineProperty(MDCTabBar.prototype, "focusOnActivate", {
            set: function (focusOnActivate) {
                this.tabList_.forEach(function (tab) { return tab.focusOnActivate = focusOnActivate; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTabBar.prototype, "useAutomaticActivation", {
            set: function (useAutomaticActivation) {
                this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
            },
            enumerable: true,
            configurable: true
        });
        MDCTabBar.prototype.initialize = function (tabFactory, tabScrollerFactory) {
            if (tabFactory === void 0) { tabFactory = function (el) { return new MDCTab(el); }; }
            if (tabScrollerFactory === void 0) { tabScrollerFactory = function (el) { return new MDCTabScroller(el); }; }
            this.tabList_ = this.instantiateTabs_(tabFactory);
            this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
        };
        MDCTabBar.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleTabInteraction_ = function (evt) { return _this.foundation_.handleTabInteraction(evt); };
            this.handleKeyDown_ = function (evt) { return _this.foundation_.handleKeyDown(evt); };
            this.listen(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
            this.listen('keydown', this.handleKeyDown_);
            for (var i = 0; i < this.tabList_.length; i++) {
                if (this.tabList_[i].active) {
                    this.scrollIntoView(i);
                    break;
                }
            }
        };
        MDCTabBar.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.unlisten(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
            this.unlisten('keydown', this.handleKeyDown_);
            this.tabList_.forEach(function (tab) { return tab.destroy(); });
            if (this.tabScroller_) {
                this.tabScroller_.destroy();
            }
        };
        MDCTabBar.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                scrollTo: function (scrollX) { return _this.tabScroller_.scrollTo(scrollX); },
                incrementScroll: function (scrollXIncrement) { return _this.tabScroller_.incrementScroll(scrollXIncrement); },
                getScrollPosition: function () { return _this.tabScroller_.getScrollPosition(); },
                getScrollContentWidth: function () { return _this.tabScroller_.getScrollContentWidth(); },
                getOffsetWidth: function () { return _this.root_.offsetWidth; },
                isRTL: function () { return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
                setActiveTab: function (index) { return _this.foundation_.activateTab(index); },
                activateTabAtIndex: function (index, clientRect) { return _this.tabList_[index].activate(clientRect); },
                deactivateTabAtIndex: function (index) { return _this.tabList_[index].deactivate(); },
                focusTabAtIndex: function (index) { return _this.tabList_[index].focus(); },
                getTabIndicatorClientRectAtIndex: function (index) { return _this.tabList_[index].computeIndicatorClientRect(); },
                getTabDimensionsAtIndex: function (index) { return _this.tabList_[index].computeDimensions(); },
                getPreviousActiveTabIndex: function () {
                    for (var i = 0; i < _this.tabList_.length; i++) {
                        if (_this.tabList_[i].active) {
                            return i;
                        }
                    }
                    return -1;
                },
                getFocusedTabIndex: function () {
                    var tabElements = _this.getTabElements_();
                    var activeElement = document.activeElement;
                    return tabElements.indexOf(activeElement);
                },
                getIndexOfTabById: function (id) {
                    for (var i = 0; i < _this.tabList_.length; i++) {
                        if (_this.tabList_[i].id === id) {
                            return i;
                        }
                    }
                    return -1;
                },
                getTabListLength: function () { return _this.tabList_.length; },
                notifyTabActivated: function (index) {
                    return _this.emit(strings$k.TAB_ACTIVATED_EVENT, { index: index }, true);
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTabBarFoundation(adapter);
        };
        /**
         * Activates the tab at the given index
         * @param index The index of the tab
         */
        MDCTabBar.prototype.activateTab = function (index) {
            this.foundation_.activateTab(index);
        };
        /**
         * Scrolls the tab at the given index into view
         * @param index THe index of the tab
         */
        MDCTabBar.prototype.scrollIntoView = function (index) {
            this.foundation_.scrollIntoView(index);
        };
        /**
         * Returns all the tab elements in a nice clean array
         */
        MDCTabBar.prototype.getTabElements_ = function () {
            return [].slice.call(this.root_.querySelectorAll(strings$k.TAB_SELECTOR));
        };
        /**
         * Instantiates tab components on all child tab elements
         */
        MDCTabBar.prototype.instantiateTabs_ = function (tabFactory) {
            return this.getTabElements_().map(function (el) {
                el.id = el.id || "mdc-tab-" + ++tabIdCounter;
                return tabFactory(el);
            });
        };
        /**
         * Instantiates tab scroller component on the child tab scroller element
         */
        MDCTabBar.prototype.instantiateTabScroller_ = function (tabScrollerFactory) {
            var tabScrollerElement = this.root_.querySelector(strings$k.TAB_SCROLLER_SELECTOR);
            if (tabScrollerElement) {
                return tabScrollerFactory(tabScrollerElement);
            }
            return null;
        };
        return MDCTabBar;
    }(MDCComponent));

    /* node_modules\@smui\tab-scroller\TabScroller.svelte generated by Svelte v3.42.1 */
    const file$1j = "node_modules\\@smui\\tab-scroller\\TabScroller.svelte";

    function create_fragment$1s(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let div0_class_value;
    	let useActions_action;
    	let div1_class_value;
    	let useActions_action_1;
    	let div2_class_value;
    	let useActions_action_2;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	let div0_levels = [
    		{
    			class: div0_class_value = "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[8], 'scrollContent$'), ['use', 'class'])
    	];

    	let div0_data = {};

    	for (let i = 0; i < div0_levels.length; i += 1) {
    		div0_data = assign(div0_data, div0_levels[i]);
    	}

    	let div1_levels = [
    		{
    			class: div1_class_value = "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[8], 'scrollArea$'), ['use', 'class'])
    	];

    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	let div2_levels = [
    		{
    			class: div2_class_value = "mdc-tab-scroller " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[8], ['use', 'class', 'scrollArea$', 'scrollContent$'])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div0, div0_data);
    			add_location(div0, file$1j, 12, 4, 371);
    			set_attributes(div1, div1_data);
    			add_location(div1, file$1j, 7, 2, 188);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$1j, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div2_binding*/ ctx[15](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div0, /*scrollContent$use*/ ctx[4])),
    					action_destroyer(useActions_action_1 = useActions.call(null, div1, /*scrollArea$use*/ ctx[2])),
    					action_destroyer(useActions_action_2 = useActions.call(null, div2, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, div2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div0, div0_data = get_spread_update(div0_levels, [
    				(!current || dirty & /*scrollContent$class*/ 32 && div0_class_value !== (div0_class_value = "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5])) && { class: div0_class_value },
    				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], 'scrollContent$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*scrollContent$use*/ 16) useActions_action.update.call(null, /*scrollContent$use*/ ctx[4]);

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty & /*scrollArea$class*/ 8 && div1_class_value !== (div1_class_value = "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3])) && { class: div1_class_value },
    				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], 'scrollArea$'), ['use', 'class'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*scrollArea$use*/ 4) useActions_action_1.update.call(null, /*scrollArea$use*/ ctx[2]);

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = "mdc-tab-scroller " + /*className*/ ctx[1])) && { class: div2_class_value },
    				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ['use', 'class', 'scrollArea$', 'scrollContent$'])
    			]));

    			if (useActions_action_2 && is_function(useActions_action_2.update) && dirty & /*use*/ 1) useActions_action_2.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    			/*div2_binding*/ ctx[15](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabScroller', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { scrollArea$use = [] } = $$props;
    	let { scrollArea$class = '' } = $$props;
    	let { scrollContent$use = [] } = $$props;
    	let { scrollContent$class = '' } = $$props;
    	let element;
    	let tabScroller;
    	let instantiate = getContext('SMUI:tab-scroller:instantiate');
    	let getInstance = getContext('SMUI:tab-scroller:getInstance');

    	onMount(async () => {
    		if (instantiate !== false) {
    			tabScroller = new MDCTabScroller(element);
    		} else {
    			tabScroller = await getInstance();
    		}
    	});

    	onDestroy(() => {
    		tabScroller && tabScroller.destroy();
    	});

    	function scrollTo(...args) {
    		return tabScroller.scrollTo(...args);
    	}

    	function incrementScroll(...args) {
    		return tabScroller.incrementScroll(...args);
    	}

    	function getScrollPosition(...args) {
    		return tabScroller.getScrollPosition(...args);
    	}

    	function getScrollContentWidth(...args) {
    		return tabScroller.getScrollContentWidth(...args);
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(6, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('scrollArea$use' in $$new_props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
    		if ('scrollArea$class' in $$new_props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
    		if ('scrollContent$use' in $$new_props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
    		if ('scrollContent$class' in $$new_props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTabScroller,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		scrollArea$use,
    		scrollArea$class,
    		scrollContent$use,
    		scrollContent$class,
    		element,
    		tabScroller,
    		instantiate,
    		getInstance,
    		scrollTo,
    		incrementScroll,
    		getScrollPosition,
    		getScrollContentWidth
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('scrollArea$use' in $$props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
    		if ('scrollArea$class' in $$props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
    		if ('scrollContent$use' in $$props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
    		if ('scrollContent$class' in $$props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
    		if ('element' in $$props) $$invalidate(6, element = $$new_props.element);
    		if ('tabScroller' in $$props) tabScroller = $$new_props.tabScroller;
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		scrollArea$use,
    		scrollArea$class,
    		scrollContent$use,
    		scrollContent$class,
    		element,
    		forwardEvents,
    		$$props,
    		scrollTo,
    		incrementScroll,
    		getScrollPosition,
    		getScrollContentWidth,
    		$$scope,
    		slots,
    		div2_binding
    	];
    }

    class TabScroller extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1s, create_fragment$1s, safe_not_equal, {
    			use: 0,
    			class: 1,
    			scrollArea$use: 2,
    			scrollArea$class: 3,
    			scrollContent$use: 4,
    			scrollContent$class: 5,
    			scrollTo: 9,
    			incrementScroll: 10,
    			getScrollPosition: 11,
    			getScrollContentWidth: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabScroller",
    			options,
    			id: create_fragment$1s.name
    		});
    	}

    	get use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollArea$use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollArea$use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollArea$class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollArea$class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollContent$use() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollContent$use(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollContent$class() {
    		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollContent$class(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollTo() {
    		return this.$$.ctx[9];
    	}

    	set scrollTo(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get incrementScroll() {
    		return this.$$.ctx[10];
    	}

    	set incrementScroll(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getScrollPosition() {
    		return this.$$.ctx[11];
    	}

    	set getScrollPosition(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getScrollContentWidth() {
    		return this.$$.ctx[12];
    	}

    	set getScrollContentWidth(value) {
    		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\tab-bar\TabBar.svelte generated by Svelte v3.42.1 */
    const file$1i = "node_modules\\@smui\\tab-bar\\TabBar.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	child_ctx[30] = i;
    	return child_ctx;
    }

    const get_default_slot_changes$1 = dirty => ({ tab: dirty & /*tabs*/ 4 });
    const get_default_slot_context$1 = ctx => ({ tab: /*tab*/ ctx[28] });

    // (13:4) {#each tabs as tab, i (key(tab))}
    function create_each_block$h(key_2, ctx) {
    	let first;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context$1);

    	const block = {
    		key: key_2,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (default_slot) default_slot.c();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, tabs*/ 524292)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(13:4) {#each tabs as tab, i (key(tab))}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >
    function create_default_slot$t(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*tabs*/ ctx[2];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*key*/ ctx[3](/*tab*/ ctx[28]);
    	validate_each_keys(ctx, each_value, get_each_context$h, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$h(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$scope, tabs, key*/ 524300) {
    				each_value = /*tabs*/ ctx[2];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$h, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$h, each_1_anchor, get_each_context$h);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1r(ctx) {
    	let div;
    	let tabscroller;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const tabscroller_spread_levels = [prefixFilter(/*$$props*/ ctx[7], 'tabScroller$')];

    	let tabscroller_props = {
    		$$slots: { default: [create_default_slot$t] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < tabscroller_spread_levels.length; i += 1) {
    		tabscroller_props = assign(tabscroller_props, tabscroller_spread_levels[i]);
    	}

    	tabscroller = new TabScroller({ props: tabscroller_props, $$inline: true });

    	let div_levels = [
    		{
    			class: div_class_value = "mdc-tab-bar " + /*className*/ ctx[1]
    		},
    		{ role: "tablist" },
    		exclude(/*$$props*/ ctx[7], [
    			'use',
    			'class',
    			'tabs',
    			'key',
    			'focusOnActivate',
    			'useAutomaticActivation',
    			'activeIndex',
    			'tabScroller$'
    		])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabscroller.$$.fragment);
    			set_attributes(div, div_data);
    			add_location(div, file$1i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabscroller, div, null);
    			/*div_binding*/ ctx[18](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, div)),
    					listen_dev(div, "MDCTabBar:activated", /*activatedHandler*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const tabscroller_changes = (dirty & /*prefixFilter, $$props*/ 128)
    			? get_spread_update(tabscroller_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[7], 'tabScroller$'))])
    			: {};

    			if (dirty & /*$$scope, tabs*/ 524292) {
    				tabscroller_changes.$$scope = { dirty, ctx };
    			}

    			tabscroller.$set(tabscroller_changes);

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "mdc-tab-bar " + /*className*/ ctx[1])) && { class: div_class_value },
    				{ role: "tablist" },
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], [
    					'use',
    					'class',
    					'tabs',
    					'key',
    					'focusOnActivate',
    					'useAutomaticActivation',
    					'activeIndex',
    					'tabScroller$'
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabscroller.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabscroller.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabscroller);
    			/*div_binding*/ ctx[18](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabBar', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCTabBar:activated']);

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { tabs = [] } = $$props;
    	let { key = tab => tab } = $$props;
    	let { focusOnActivate = true } = $$props;
    	let { useAutomaticActivation = true } = $$props;
    	let { activeIndex = uninitializedValue } = $$props;
    	let { active = uninitializedValue } = $$props;

    	if (activeIndex === uninitializedValue && active === uninitializedValue) {
    		activeIndex = 0;
    		active = tabs[0];
    	} else if (activeIndex === uninitializedValue) {
    		activeIndex = tabs.indexOf(active);
    	} else if (active === uninitializedValue) {
    		active = tabs[activeIndex];
    	}

    	let element;
    	let tabBar;
    	let tabScrollerPromiseResolve;
    	let tabScrollerPromise = new Promise(resolve => tabScrollerPromiseResolve = resolve);
    	let tabPromiseResolve = [];
    	let tabPromise = tabs.map((tab, i) => new Promise(resolve => tabPromiseResolve[i] = resolve));
    	setContext('SMUI:tab-scroller:instantiate', false);
    	setContext('SMUI:tab-scroller:getInstance', getTabScrollerInstancePromise);
    	setContext('SMUI:tab:instantiate', false);
    	setContext('SMUI:tab:getInstance', getTabInstancePromise);
    	setContext('SMUI:tab:active', active);
    	let previousActiveIndex = activeIndex;
    	let previousActive = active;

    	onMount(() => {
    		$$invalidate(14, tabBar = new MDCTabBar(element));
    		tabScrollerPromiseResolve(tabBar.tabScroller_);

    		for (let i = 0; i < tabs.length; i++) {
    			tabPromiseResolve[i](tabBar.tabList_[i]);
    		}
    	});

    	onDestroy(() => {
    		tabBar && tabBar.destroy();
    	});

    	function getTabScrollerInstancePromise() {
    		return tabScrollerPromise;
    	}

    	function getTabInstancePromise(tabEntry) {
    		return tabPromise[tabs.indexOf(tabEntry)];
    	}

    	function updateIndexAfterActivate(index) {
    		$$invalidate(8, activeIndex = index);
    		$$invalidate(15, previousActiveIndex = index);
    		$$invalidate(9, active = tabs[index]);
    		$$invalidate(16, previousActive = tabs[index]);
    	}

    	function activatedHandler(e) {
    		updateIndexAfterActivate(e.detail.index);
    	}

    	function activateTab(index, ...args) {
    		updateIndexAfterActivate(index);
    		return tabBar.activateTab(index, ...args);
    	}

    	function scrollIntoView(...args) {
    		return tabBar.scrollIntoView(...args);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('tabs' in $$new_props) $$invalidate(2, tabs = $$new_props.tabs);
    		if ('key' in $$new_props) $$invalidate(3, key = $$new_props.key);
    		if ('focusOnActivate' in $$new_props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
    		if ('useAutomaticActivation' in $$new_props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
    		if ('activeIndex' in $$new_props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
    		if ('active' in $$new_props) $$invalidate(9, active = $$new_props.active);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTabBar,
    		onMount,
    		onDestroy,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		TabScroller,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		tabs,
    		key,
    		focusOnActivate,
    		useAutomaticActivation,
    		activeIndex,
    		active,
    		element,
    		tabBar,
    		tabScrollerPromiseResolve,
    		tabScrollerPromise,
    		tabPromiseResolve,
    		tabPromise,
    		previousActiveIndex,
    		previousActive,
    		getTabScrollerInstancePromise,
    		getTabInstancePromise,
    		updateIndexAfterActivate,
    		activatedHandler,
    		activateTab,
    		scrollIntoView
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('uninitializedValue' in $$props) uninitializedValue = $$new_props.uninitializedValue;
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$new_props.tabs);
    		if ('key' in $$props) $$invalidate(3, key = $$new_props.key);
    		if ('focusOnActivate' in $$props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
    		if ('useAutomaticActivation' in $$props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
    		if ('activeIndex' in $$props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
    		if ('active' in $$props) $$invalidate(9, active = $$new_props.active);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('tabBar' in $$props) $$invalidate(14, tabBar = $$new_props.tabBar);
    		if ('tabScrollerPromiseResolve' in $$props) tabScrollerPromiseResolve = $$new_props.tabScrollerPromiseResolve;
    		if ('tabScrollerPromise' in $$props) tabScrollerPromise = $$new_props.tabScrollerPromise;
    		if ('tabPromiseResolve' in $$props) tabPromiseResolve = $$new_props.tabPromiseResolve;
    		if ('tabPromise' in $$props) tabPromise = $$new_props.tabPromise;
    		if ('previousActiveIndex' in $$props) $$invalidate(15, previousActiveIndex = $$new_props.previousActiveIndex);
    		if ('previousActive' in $$props) $$invalidate(16, previousActive = $$new_props.previousActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tabBar, focusOnActivate*/ 17408) {
    			if (tabBar) {
    				$$invalidate(14, tabBar.focusOnActivate = focusOnActivate, tabBar);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, useAutomaticActivation*/ 18432) {
    			if (tabBar) {
    				$$invalidate(14, tabBar.useAutomaticActivation = useAutomaticActivation, tabBar);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, tabs, activeIndex*/ 16644) {
    			if (tabBar) {
    				$$invalidate(9, active = tabs[activeIndex]);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, previousActiveIndex, activeIndex*/ 49408) {
    			if (tabBar && previousActiveIndex !== activeIndex) {
    				activateTab(activeIndex);
    			}
    		}

    		if ($$self.$$.dirty & /*tabBar, previousActive, active, tabs*/ 82436) {
    			if (tabBar && previousActive !== active) {
    				activateTab(tabs.indexOf(active));
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		tabs,
    		key,
    		element,
    		forwardEvents,
    		activatedHandler,
    		$$props,
    		activeIndex,
    		active,
    		focusOnActivate,
    		useAutomaticActivation,
    		activateTab,
    		scrollIntoView,
    		tabBar,
    		previousActiveIndex,
    		previousActive,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class TabBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1r, create_fragment$1r, safe_not_equal, {
    			use: 0,
    			class: 1,
    			tabs: 2,
    			key: 3,
    			focusOnActivate: 10,
    			useAutomaticActivation: 11,
    			activeIndex: 8,
    			active: 9,
    			activateTab: 12,
    			scrollIntoView: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabBar",
    			options,
    			id: create_fragment$1r.name
    		});
    	}

    	get use() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusOnActivate() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusOnActivate(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useAutomaticActivation() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useAutomaticActivation(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeIndex() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeIndex(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activateTab() {
    		return this.$$.ctx[12];
    	}

    	set activateTab(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollIntoView() {
    		return this.$$.ctx[13];
    	}

    	set scrollIntoView(value) {
    		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Navbar.svelte generated by Svelte v3.42.1 */

    const { console: console_1$k } = globals;

    const file$1h = "src\\components\\Navbar.svelte";

    // (34:14) <Label>
    function create_default_slot_2$b(ctx) {
    	let t_value = /*tab*/ ctx[5] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tab*/ 32 && t_value !== (t_value = /*tab*/ ctx[5] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(34:14) <Label>",
    		ctx
    	});

    	return block;
    }

    // (34:2) <Tab {tab}>
    function create_default_slot_1$f(ctx) {
    	let label;
    	let current;

    	label = new Label$1({
    			props: {
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, tab*/ 96) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(34:2) <Tab {tab}>",
    		ctx
    	});

    	return block;
    }

    // (33:1) <TabBar tabs={navItems} let:tab bind:active>
    function create_default_slot$s(ctx) {
    	let tab;
    	let current;

    	tab = new Tab({
    			props: {
    				tab: /*tab*/ ctx[5],
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab_changes = {};
    			if (dirty & /*tab*/ 32) tab_changes.tab = /*tab*/ ctx[5];

    			if (dirty & /*$$scope, tab*/ 96) {
    				tab_changes.$$scope = { dirty, ctx };
    			}

    			tab.$set(tab_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(33:1) <TabBar tabs={navItems} let:tab bind:active>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let div;
    	let tabbar;
    	let updating_active;
    	let current;
    	let mounted;
    	let dispose;

    	function tabbar_active_binding(value) {
    		/*tabbar_active_binding*/ ctx[4](value);
    	}

    	let tabbar_props = {
    		tabs: /*navItems*/ ctx[0],
    		$$slots: {
    			default: [create_default_slot$s, ({ tab }) => ({ 5: tab }), ({ tab }) => tab ? 32 : 0]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[1] !== void 0) {
    		tabbar_props.active = /*active*/ ctx[1];
    	}

    	tabbar = new TabBar({ props: tabbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabbar, 'active', tabbar_active_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabbar.$$.fragment);
    			attr_dev(div, "class", "box animated fadeInDown svelte-9go030");
    			attr_dev(div, "id", "navbar");
    			set_style(div, "display", "none");
    			add_location(div, file$1h, 31, 0, 736);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabbar, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*navigate*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const tabbar_changes = {};
    			if (dirty & /*navItems*/ 1) tabbar_changes.tabs = /*navItems*/ ctx[0];

    			if (dirty & /*$$scope, tab*/ 96) {
    				tabbar_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 2) {
    				updating_active = true;
    				tabbar_changes.active = /*active*/ ctx[1];
    				add_flush_callback(() => updating_active = false);
    			}

    			tabbar.$set(tabbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabbar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const activePage = writable("");

    function instance$1q($$self, $$props, $$invalidate) {
    	let $activePage,
    		$$unsubscribe_activePage = noop$1;

    	validate_store(activePage, 'activePage');
    	component_subscribe($$self, activePage, $$value => $$invalidate(3, $activePage = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_activePage());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, []);
    	let { navItems } = $$props;
    	let active = db.get('active_tab') || 'Home';

    	const navigate = () => {
    		navItems.forEach(item => item == active ? showpage(item) : hidepage(item));
    	};

    	onMount(() => {
    		showpage("navbar");
    		navigate();
    	});

    	const writable_props = ['navItems'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$k.warn(`<Navbar> was created with unknown prop '${key}'`);
    	});

    	function tabbar_active_binding(value) {
    		active = value;
    		$$invalidate(1, active);
    	}

    	$$self.$$set = $$props => {
    		if ('navItems' in $$props) $$invalidate(0, navItems = $$props.navItems);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		activePage,
    		Tab,
    		Label: Label$1,
    		TabBar,
    		onMount,
    		navItems,
    		active,
    		navigate,
    		$activePage
    	});

    	$$self.$inject_state = $$props => {
    		if ('navItems' in $$props) $$invalidate(0, navItems = $$props.navItems);
    		if ('active' in $$props) $$invalidate(1, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*active*/ 2) {
    			set_store_value(activePage, $activePage = active, $activePage);
    		}

    		if ($$self.$$.dirty & /*$activePage*/ 8) {
    			console.log(`Current page: ${$activePage}`);
    		}

    		if ($$self.$$.dirty & /*$activePage*/ 8) {
    			db.set('active_tab', $activePage);
    		}
    	};

    	return [navItems, active, navigate, $activePage, tabbar_active_binding];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1q, create_fragment$1q, safe_not_equal, { navItems: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$1q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*navItems*/ ctx[0] === undefined && !('navItems' in props)) {
    			console_1$k.warn("<Navbar> was created without expected prop 'navItems'");
    		}
    	}

    	get navItems() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navItems(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Footer.svelte generated by Svelte v3.42.1 */

    const file$1g = "src\\components\\Footer.svelte";

    function create_fragment$1p(ctx) {
    	let nav;
    	let div4;
    	let div1;
    	let div0;
    	let p0;
    	let t1;
    	let div3;
    	let div2;
    	let p1;
    	let p2;

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "Developed at Dr.Brünken's group FELion@FELIX";
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			p1 = element("p");
    			p1.textContent = "2021 © AN Marimuthu";
    			p2 = element("p");
    			add_location(p0, file$1g, 10, 8, 258);
    			attr_dev(div0, "class", "navbar-item");
    			add_location(div0, file$1g, 9, 6, 223);
    			attr_dev(div1, "class", "navbar-start");
    			add_location(div1, file$1g, 8, 4, 189);
    			add_location(p1, file$1g, 20, 8, 423);
    			add_location(p2, file$1g, 20, 35, 450);
    			attr_dev(div2, "class", "navbar-item");
    			add_location(div2, file$1g, 17, 6, 384);
    			attr_dev(div3, "class", "navbar-end");
    			add_location(div3, file$1g, 15, 4, 350);
    			attr_dev(div4, "class", "navbar-menu");
    			add_location(div4, file$1g, 6, 2, 156);
    			attr_dev(nav, "class", "navbar is-fixed-bottom animated fadeInUp svelte-1p4s5kp");
    			attr_dev(nav, "id", "footer");
    			set_style(nav, "display", status);
    			add_location(nav, file$1g, 5, 0, 61);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p0);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, p1);
    			append_dev(div2, p2);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Footer$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1p, create_fragment$1p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$1p.name
    		});
    	}
    }

    /* src\components\starterpage_animations\Simplewave.svelte generated by Svelte v3.42.1 */

    const file$1f = "src\\components\\starterpage_animations\\Simplewave.svelte";
    const get_footer_slot_changes$2 = dirty => ({});
    const get_footer_slot_context$2 = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});

    function create_fragment$1o(ctx) {
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let svg;
    	let defs;
    	let path;
    	let g;
    	let use0;
    	let use1;
    	let use2;
    	let use3;
    	let t1;
    	let div3;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[1].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[0], get_header_slot_context);
    	const footer_slot_template = /*#slots*/ ctx[1].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[0], get_footer_slot_context$2);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			if (header_slot) header_slot.c();
    			t0 = space();
    			div1 = element("div");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			path = svg_element("path");
    			g = svg_element("g");
    			use0 = svg_element("use");
    			use1 = svg_element("use");
    			use2 = svg_element("use");
    			use3 = svg_element("use");
    			t1 = space();
    			div3 = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div0, "class", "inner-header svelte-1q3wxze");
    			add_location(div0, file$1f, 62, 8, 1012);
    			attr_dev(path, "id", "gentle-wave");
    			attr_dev(path, "d", "M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z");
    			add_location(path, file$1f, 71, 20, 1362);
    			add_location(defs, file$1f, 70, 16, 1334);
    			xlink_attr(use0, "xlink:href", "#gentle-wave");
    			attr_dev(use0, "x", "48");
    			attr_dev(use0, "y", "0");
    			attr_dev(use0, "fill", "rgba(255,255,255,0.7");
    			attr_dev(use0, "class", "svelte-1q3wxze");
    			add_location(use0, file$1f, 75, 20, 1551);
    			xlink_attr(use1, "xlink:href", "#gentle-wave");
    			attr_dev(use1, "x", "48");
    			attr_dev(use1, "y", "3");
    			attr_dev(use1, "fill", "rgba(255,255,255,0.5)");
    			attr_dev(use1, "class", "svelte-1q3wxze");
    			add_location(use1, file$1f, 76, 20, 1647);
    			xlink_attr(use2, "xlink:href", "#gentle-wave");
    			attr_dev(use2, "x", "48");
    			attr_dev(use2, "y", "5");
    			attr_dev(use2, "fill", "rgba(255,255,255,0.3)");
    			attr_dev(use2, "class", "svelte-1q3wxze");
    			add_location(use2, file$1f, 77, 20, 1744);
    			xlink_attr(use3, "xlink:href", "#gentle-wave");
    			attr_dev(use3, "x", "48");
    			attr_dev(use3, "y", "7");
    			attr_dev(use3, "fill", "#fff");
    			attr_dev(use3, "class", "svelte-1q3wxze");
    			add_location(use3, file$1f, 79, 20, 1859);
    			attr_dev(g, "class", "parallax svelte-1q3wxze");
    			add_location(g, file$1f, 74, 16, 1509);
    			attr_dev(svg, "class", "waves svelte-1q3wxze");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "viewBox", "0 24 150 28");
    			attr_dev(svg, "preserveAspectRatio", "none");
    			attr_dev(svg, "shape-rendering", "auto");
    			add_location(svg, file$1f, 68, 12, 1145);
    			attr_dev(div1, "class", "waves svelte-1q3wxze");
    			add_location(div1, file$1f, 67, 8, 1112);
    			attr_dev(div2, "class", "home-header svelte-1q3wxze");
    			add_location(div2, file$1f, 60, 4, 975);
    			attr_dev(div3, "class", "home-footer svelte-1q3wxze");
    			add_location(div3, file$1f, 88, 4, 2021);
    			attr_dev(div4, "class", "animated fadeIn slower home-container svelte-1q3wxze");
    			add_location(div4, file$1f, 59, 0, 918);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div0);

    			if (header_slot) {
    				header_slot.m(div0, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, svg);
    			append_dev(svg, defs);
    			append_dev(defs, path);
    			append_dev(svg, g);
    			append_dev(g, use0);
    			append_dev(g, use1);
    			append_dev(g, use2);
    			append_dev(g, use3);
    			append_dev(div4, t1);
    			append_dev(div4, div3);

    			if (footer_slot) {
    				footer_slot.m(div3, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[0], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}

    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[0], dirty, get_footer_slot_changes$2),
    						get_footer_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (header_slot) header_slot.d(detaching);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Simplewave', slots, ['header','footer']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Simplewave> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Simplewave extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1o, create_fragment$1o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Simplewave",
    			options,
    			id: create_fragment$1o.name
    		});
    	}
    }

    /* src\Pages\Home.svelte generated by Svelte v3.42.1 */
    const file$1e = "src\\Pages\\Home.svelte";

    // (28:4) {#if $windowLoaded}
    function create_if_block$C(ctx) {
    	let await_block_anchor;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 1,
    		blocks: [,,,]
    	};

    	handle_promise(window.sleep(500), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(28:4) {#if $windowLoaded}",
    		ctx
    	});

    	return block;
    }

    // (1:0)   <script>    import Simplewave from "../components/starterpage_animations/Simplewave.svelte";    import {windowLoaded}
    function create_catch_block(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0)   <script>    import Simplewave from \\\"../components/starterpage_animations/Simplewave.svelte\\\";    import {windowLoaded}",
    		ctx
    	});

    	return block;
    }

    // (30:43)           <Simplewave>              <svelte:fragment slot="header">              <h1 class="title">FELion Spectrum Analyser</h1>              <h1 class="subtitle">To analyse FELIX data for FELion Instrument</h1>            </svelte:fragment>              <svelte:fragment slot="footer">              <p>Developed at Dr.Br&uuml;nken's group FELion@FELIX | 2021 &copy; AN Marimuthu</p>            </svelte:fragment>          </Simplewave>        {/await}
    function create_then_block(ctx) {
    	let simplewave;
    	let current;

    	simplewave = new Simplewave({
    			props: {
    				$$slots: {
    					footer: [create_footer_slot$2],
    					header: [create_header_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(simplewave.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(simplewave, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(simplewave.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(simplewave.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(simplewave, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(30:43)           <Simplewave>              <svelte:fragment slot=\\\"header\\\">              <h1 class=\\\"title\\\">FELion Spectrum Analyser</h1>              <h1 class=\\\"subtitle\\\">To analyse FELIX data for FELion Instrument</h1>            </svelte:fragment>              <svelte:fragment slot=\\\"footer\\\">              <p>Developed at Dr.Br&uuml;nken's group FELion@FELIX | 2021 &copy; AN Marimuthu</p>            </svelte:fragment>          </Simplewave>        {/await}",
    		ctx
    	});

    	return block;
    }

    // (33:10) <svelte:fragment slot="header">
    function create_header_slot(ctx) {
    	let h10;
    	let t1;
    	let h11;

    	const block = {
    		c: function create() {
    			h10 = element("h1");
    			h10.textContent = "FELion Spectrum Analyser";
    			t1 = space();
    			h11 = element("h1");
    			h11.textContent = "To analyse FELIX data for FELion Instrument";
    			attr_dev(h10, "class", "title svelte-1v9fp82");
    			add_location(h10, file$1e, 33, 12, 642);
    			attr_dev(h11, "class", "subtitle svelte-1v9fp82");
    			add_location(h11, file$1e, 34, 12, 703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h11, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h11);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot.name,
    		type: "slot",
    		source: "(33:10) <svelte:fragment slot=\\\"header\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:10) <svelte:fragment slot="footer">
    function create_footer_slot$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Developed at Dr.Brünken's group FELion@FELIX | 2021 © AN Marimuthu";
    			attr_dev(p, "class", "svelte-1v9fp82");
    			add_location(p, file$1e, 38, 12, 861);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot$2.name,
    		type: "slot",
    		source: "(38:10) <svelte:fragment slot=\\\"footer\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0)   <script>    import Simplewave from "../components/starterpage_animations/Simplewave.svelte";    import {windowLoaded}
    function create_pending_block(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(1:0)   <script>    import Simplewave from \\\"../components/starterpage_animations/Simplewave.svelte\\\";    import {windowLoaded}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let section;
    	let current;
    	let if_block = /*$windowLoaded*/ ctx[0] && create_if_block$C(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			if (if_block) if_block.c();
    			attr_dev(section, "class", "section animated fadeIn svelte-1v9fp82");
    			attr_dev(section, "id", "Home");
    			set_style(section, "display", "none");
    			add_location(section, file$1e, 25, 0, 411);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$windowLoaded*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$windowLoaded*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$C(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let $windowLoaded;
    	validate_store(windowLoaded, 'windowLoaded');
    	component_subscribe($$self, windowLoaded, $$value => $$invalidate(0, $windowLoaded = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Simplewave, windowLoaded, $windowLoaded });
    	return [$windowLoaded];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$1n.name
    		});
    	}
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$i = {
        LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
        LABEL_SHAKE: 'mdc-floating-label--shake',
        ROOT: 'mdc-floating-label',
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFloatingLabelFoundation = /** @class */ (function (_super) {
        __extends(MDCFloatingLabelFoundation, _super);
        function MDCFloatingLabelFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCFloatingLabelFoundation.defaultAdapter, adapter)) || this;
            _this.shakeAnimationEndHandler_ = function () { return _this.handleShakeAnimationEnd_(); };
            return _this;
        }
        Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
            get: function () {
                return cssClasses$i;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
            /**
             * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    getWidth: function () { return 0; },
                    registerInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCFloatingLabelFoundation.prototype.init = function () {
            this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        };
        MDCFloatingLabelFoundation.prototype.destroy = function () {
            this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        };
        /**
         * Returns the width of the label element.
         */
        MDCFloatingLabelFoundation.prototype.getWidth = function () {
            return this.adapter_.getWidth();
        };
        /**
         * Styles the label to produce a shake animation to indicate an error.
         * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
         */
        MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
            var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
            if (shouldShake) {
                this.adapter_.addClass(LABEL_SHAKE);
            }
            else {
                this.adapter_.removeClass(LABEL_SHAKE);
            }
        };
        /**
         * Styles the label to float or dock.
         * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
         */
        MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
            var _a = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
            if (shouldFloat) {
                this.adapter_.addClass(LABEL_FLOAT_ABOVE);
            }
            else {
                this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
                this.adapter_.removeClass(LABEL_SHAKE);
            }
        };
        MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd_ = function () {
            var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
            this.adapter_.removeClass(LABEL_SHAKE);
        };
        return MDCFloatingLabelFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFloatingLabel = /** @class */ (function (_super) {
        __extends(MDCFloatingLabel, _super);
        function MDCFloatingLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCFloatingLabel.attachTo = function (root) {
            return new MDCFloatingLabel(root);
        };
        /**
         * Styles the label to produce the label shake for errors.
         * @param shouldShake If true, shakes the label by adding a CSS class; otherwise, stops shaking by removing the class.
         */
        MDCFloatingLabel.prototype.shake = function (shouldShake) {
            this.foundation_.shake(shouldShake);
        };
        /**
         * Styles the label to float/dock.
         * @param shouldFloat If true, floats the label by adding a CSS class; otherwise, docks it by removing the class.
         */
        MDCFloatingLabel.prototype.float = function (shouldFloat) {
            this.foundation_.float(shouldFloat);
        };
        MDCFloatingLabel.prototype.getWidth = function () {
            return this.foundation_.getWidth();
        };
        MDCFloatingLabel.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                getWidth: function () { return _this.root_.scrollWidth; },
                registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
                deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCFloatingLabelFoundation(adapter);
        };
        return MDCFloatingLabel;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$h = {
        LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
        LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCLineRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCLineRippleFoundation, _super);
        function MDCLineRippleFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCLineRippleFoundation.defaultAdapter, adapter)) || this;
            _this.transitionEndHandler_ = function (evt) { return _this.handleTransitionEnd(evt); };
            return _this;
        }
        Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$h;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
            /**
             * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setStyle: function () { return undefined; },
                    registerEventHandler: function () { return undefined; },
                    deregisterEventHandler: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCLineRippleFoundation.prototype.init = function () {
            this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        };
        MDCLineRippleFoundation.prototype.destroy = function () {
            this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        };
        MDCLineRippleFoundation.prototype.activate = function () {
            this.adapter_.removeClass(cssClasses$h.LINE_RIPPLE_DEACTIVATING);
            this.adapter_.addClass(cssClasses$h.LINE_RIPPLE_ACTIVE);
        };
        MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
            this.adapter_.setStyle('transform-origin', xCoordinate + "px center");
        };
        MDCLineRippleFoundation.prototype.deactivate = function () {
            this.adapter_.addClass(cssClasses$h.LINE_RIPPLE_DEACTIVATING);
        };
        MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
            // Wait for the line ripple to be either transparent or opaque
            // before emitting the animation end event
            var isDeactivating = this.adapter_.hasClass(cssClasses$h.LINE_RIPPLE_DEACTIVATING);
            if (evt.propertyName === 'opacity') {
                if (isDeactivating) {
                    this.adapter_.removeClass(cssClasses$h.LINE_RIPPLE_ACTIVE);
                    this.adapter_.removeClass(cssClasses$h.LINE_RIPPLE_DEACTIVATING);
                }
            }
        };
        return MDCLineRippleFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCLineRipple = /** @class */ (function (_super) {
        __extends(MDCLineRipple, _super);
        function MDCLineRipple() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCLineRipple.attachTo = function (root) {
            return new MDCLineRipple(root);
        };
        /**
         * Activates the line ripple
         */
        MDCLineRipple.prototype.activate = function () {
            this.foundation_.activate();
        };
        /**
         * Deactivates the line ripple
         */
        MDCLineRipple.prototype.deactivate = function () {
            this.foundation_.deactivate();
        };
        /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         */
        MDCLineRipple.prototype.setRippleCenter = function (xCoordinate) {
            this.foundation_.setRippleCenter(xCoordinate);
        };
        MDCLineRipple.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                setStyle: function (propertyName, value) { return _this.root_.style.setProperty(propertyName, value); },
                registerEventHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
                deregisterEventHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCLineRippleFoundation(adapter);
        };
        return MDCLineRipple;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$j = {
        NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch',
    };
    var numbers$7 = {
        // This should stay in sync with $mdc-notched-outline-padding * 2.
        NOTCH_ELEMENT_PADDING: 8,
    };
    var cssClasses$g = {
        NO_LABEL: 'mdc-notched-outline--no-label',
        OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
        OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCNotchedOutlineFoundation = /** @class */ (function (_super) {
        __extends(MDCNotchedOutlineFoundation, _super);
        function MDCNotchedOutlineFoundation(adapter) {
            return _super.call(this, __assign({}, MDCNotchedOutlineFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
            get: function () {
                return strings$j;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
            get: function () {
                return cssClasses$g;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
            get: function () {
                return numbers$7;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
            /**
             * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setNotchWidthProperty: function () { return undefined; },
                    removeNotchWidthProperty: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds the outline notched selector and updates the notch width calculated based off of notchWidth.
         */
        MDCNotchedOutlineFoundation.prototype.notch = function (notchWidth) {
            var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
            if (notchWidth > 0) {
                notchWidth += numbers$7.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
            }
            this.adapter_.setNotchWidthProperty(notchWidth);
            this.adapter_.addClass(OUTLINE_NOTCHED);
        };
        /**
         * Removes notched outline selector to close the notch in the outline.
         */
        MDCNotchedOutlineFoundation.prototype.closeNotch = function () {
            var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
            this.adapter_.removeClass(OUTLINE_NOTCHED);
            this.adapter_.removeNotchWidthProperty();
        };
        return MDCNotchedOutlineFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCNotchedOutline = /** @class */ (function (_super) {
        __extends(MDCNotchedOutline, _super);
        function MDCNotchedOutline() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCNotchedOutline.attachTo = function (root) {
            return new MDCNotchedOutline(root);
        };
        MDCNotchedOutline.prototype.initialSyncWithDOM = function () {
            this.notchElement_ = this.root_.querySelector(strings$j.NOTCH_ELEMENT_SELECTOR);
            var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation.cssClasses.ROOT);
            if (label) {
                label.style.transitionDuration = '0s';
                this.root_.classList.add(cssClasses$g.OUTLINE_UPGRADED);
                requestAnimationFrame(function () {
                    label.style.transitionDuration = '';
                });
            }
            else {
                this.root_.classList.add(cssClasses$g.NO_LABEL);
            }
        };
        /**
         * Updates classes and styles to open the notch to the specified width.
         * @param notchWidth The notch width in the outline.
         */
        MDCNotchedOutline.prototype.notch = function (notchWidth) {
            this.foundation_.notch(notchWidth);
        };
        /**
         * Updates classes and styles to close the notch.
         */
        MDCNotchedOutline.prototype.closeNotch = function () {
            this.foundation_.closeNotch();
        };
        MDCNotchedOutline.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                setNotchWidthProperty: function (width) { return _this.notchElement_.style.setProperty('width', width + 'px'); },
                removeNotchWidthProperty: function () { return _this.notchElement_.style.removeProperty('width'); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCNotchedOutlineFoundation(adapter);
        };
        return MDCNotchedOutline;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$f = {
        ROOT: 'mdc-text-field-character-counter',
    };
    var strings$i = {
        ROOT_SELECTOR: "." + cssClasses$f.ROOT,
    };

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldCharacterCounterFoundation = /** @class */ (function (_super) {
        __extends(MDCTextFieldCharacterCounterFoundation, _super);
        function MDCTextFieldCharacterCounterFoundation(adapter) {
            return _super.call(this, __assign({}, MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "cssClasses", {
            get: function () {
                return cssClasses$f;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "strings", {
            get: function () {
                return strings$i;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "defaultAdapter", {
            /**
             * See {@link MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return types.
             */
            get: function () {
                return {
                    setContent: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldCharacterCounterFoundation.prototype.setCounterValue = function (currentLength, maxLength) {
            currentLength = Math.min(currentLength, maxLength);
            this.adapter_.setContent(currentLength + " / " + maxLength);
        };
        return MDCTextFieldCharacterCounterFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldCharacterCounter = /** @class */ (function (_super) {
        __extends(MDCTextFieldCharacterCounter, _super);
        function MDCTextFieldCharacterCounter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTextFieldCharacterCounter.attachTo = function (root) {
            return new MDCTextFieldCharacterCounter(root);
        };
        Object.defineProperty(MDCTextFieldCharacterCounter.prototype, "foundation", {
            get: function () {
                return this.foundation_;
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldCharacterCounter.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                setContent: function (content) {
                    _this.root_.textContent = content;
                },
            };
            return new MDCTextFieldCharacterCounterFoundation(adapter);
        };
        return MDCTextFieldCharacterCounter;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$h = {
        ARIA_CONTROLS: 'aria-controls',
        ICON_SELECTOR: '.mdc-text-field__icon',
        INPUT_SELECTOR: '.mdc-text-field__input',
        LABEL_SELECTOR: '.mdc-floating-label',
        LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
        OUTLINE_SELECTOR: '.mdc-notched-outline',
    };
    var cssClasses$e = {
        DENSE: 'mdc-text-field--dense',
        DISABLED: 'mdc-text-field--disabled',
        FOCUSED: 'mdc-text-field--focused',
        FULLWIDTH: 'mdc-text-field--fullwidth',
        HELPER_LINE: 'mdc-text-field-helper-line',
        INVALID: 'mdc-text-field--invalid',
        NO_LABEL: 'mdc-text-field--no-label',
        OUTLINED: 'mdc-text-field--outlined',
        ROOT: 'mdc-text-field',
        TEXTAREA: 'mdc-text-field--textarea',
        WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
        WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon',
    };
    var numbers$6 = {
        DENSE_LABEL_SCALE: 0.923,
        LABEL_SCALE: 0.75,
    };
    /**
     * Whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
     * under the "Validation-related attributes" section.
     */
    var VALIDATION_ATTR_WHITELIST$1 = [
        'pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength',
    ];
    /**
     * Label should always float for these types as they show some UI even if value is empty.
     */
    var ALWAYS_FLOAT_TYPES = [
        'color', 'date', 'datetime-local', 'month', 'range', 'time', 'week',
    ];

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
    var INTERACTION_EVENTS$2 = ['click', 'keydown'];
    var MDCTextFieldFoundation = /** @class */ (function (_super) {
        __extends(MDCTextFieldFoundation, _super);
        /**
         * @param adapter
         * @param foundationMap Map from subcomponent names to their subfoundations.
         */
        function MDCTextFieldFoundation(adapter, foundationMap) {
            if (foundationMap === void 0) { foundationMap = {}; }
            var _this = _super.call(this, __assign({}, MDCTextFieldFoundation.defaultAdapter, adapter)) || this;
            _this.isFocused_ = false;
            _this.receivedUserInput_ = false;
            _this.isValid_ = true;
            _this.useNativeValidation_ = true;
            _this.helperText_ = foundationMap.helperText;
            _this.characterCounter_ = foundationMap.characterCounter;
            _this.leadingIcon_ = foundationMap.leadingIcon;
            _this.trailingIcon_ = foundationMap.trailingIcon;
            _this.inputFocusHandler_ = function () { return _this.activateFocus(); };
            _this.inputBlurHandler_ = function () { return _this.deactivateFocus(); };
            _this.inputInputHandler_ = function () { return _this.handleInput(); };
            _this.setPointerXOffset_ = function (evt) { return _this.setTransformOrigin(evt); };
            _this.textFieldInteractionHandler_ = function () { return _this.handleTextFieldInteraction(); };
            _this.validationAttributeChangeHandler_ = function (attributesList) { return _this.handleValidationAttributeChange(attributesList); };
            return _this;
        }
        Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
            get: function () {
                return cssClasses$e;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "strings", {
            get: function () {
                return strings$h;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "numbers", {
            get: function () {
                return numbers$6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat_", {
            get: function () {
                var type = this.getNativeInput_().type;
                return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
            get: function () {
                return this.shouldAlwaysFloat_ || this.isFocused_ || Boolean(this.getValue()) || this.isBadInput_();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
            get: function () {
                return !this.isFocused_ && !this.isValid() && Boolean(this.getValue());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
            /**
             * See {@link MDCTextFieldAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return true; },
                    registerTextFieldInteractionHandler: function () { return undefined; },
                    deregisterTextFieldInteractionHandler: function () { return undefined; },
                    registerInputInteractionHandler: function () { return undefined; },
                    deregisterInputInteractionHandler: function () { return undefined; },
                    registerValidationAttributeChangeHandler: function () { return new MutationObserver(function () { return undefined; }); },
                    deregisterValidationAttributeChangeHandler: function () { return undefined; },
                    getNativeInput: function () { return null; },
                    isFocused: function () { return false; },
                    activateLineRipple: function () { return undefined; },
                    deactivateLineRipple: function () { return undefined; },
                    setLineRippleTransformOrigin: function () { return undefined; },
                    shakeLabel: function () { return undefined; },
                    floatLabel: function () { return undefined; },
                    hasLabel: function () { return false; },
                    getLabelWidth: function () { return 0; },
                    hasOutline: function () { return false; },
                    notchOutline: function () { return undefined; },
                    closeOutline: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldFoundation.prototype.init = function () {
            var _this = this;
            if (this.adapter_.isFocused()) {
                this.inputFocusHandler_();
            }
            else if (this.adapter_.hasLabel() && this.shouldFloat) {
                this.notchOutline(true);
                this.adapter_.floatLabel(true);
            }
            this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
            this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
            this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
            POINTERDOWN_EVENTS.forEach(function (evtType) {
                _this.adapter_.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
            });
            INTERACTION_EVENTS$2.forEach(function (evtType) {
                _this.adapter_.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
            });
            this.validationObserver_ =
                this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
            this.setCharacterCounter_(this.getValue().length);
        };
        MDCTextFieldFoundation.prototype.destroy = function () {
            var _this = this;
            this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
            this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
            this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
            POINTERDOWN_EVENTS.forEach(function (evtType) {
                _this.adapter_.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
            });
            INTERACTION_EVENTS$2.forEach(function (evtType) {
                _this.adapter_.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
            });
            this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
        };
        /**
         * Handles user interactions with the Text Field.
         */
        MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
            var nativeInput = this.adapter_.getNativeInput();
            if (nativeInput && nativeInput.disabled) {
                return;
            }
            this.receivedUserInput_ = true;
        };
        /**
         * Handles validation attribute changes
         */
        MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
            var _this = this;
            attributesList.some(function (attributeName) {
                if (VALIDATION_ATTR_WHITELIST$1.indexOf(attributeName) > -1) {
                    _this.styleValidity_(true);
                    return true;
                }
                return false;
            });
            if (attributesList.indexOf('maxlength') > -1) {
                this.setCharacterCounter_(this.getValue().length);
            }
        };
        /**
         * Opens/closes the notched outline.
         */
        MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
            if (!this.adapter_.hasOutline()) {
                return;
            }
            if (openNotch) {
                var isDense = this.adapter_.hasClass(cssClasses$e.DENSE);
                var labelScale = isDense ? numbers$6.DENSE_LABEL_SCALE : numbers$6.LABEL_SCALE;
                var labelWidth = this.adapter_.getLabelWidth() * labelScale;
                this.adapter_.notchOutline(labelWidth);
            }
            else {
                this.adapter_.closeOutline();
            }
        };
        /**
         * Activates the text field focus state.
         */
        MDCTextFieldFoundation.prototype.activateFocus = function () {
            this.isFocused_ = true;
            this.styleFocused_(this.isFocused_);
            this.adapter_.activateLineRipple();
            if (this.adapter_.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter_.floatLabel(this.shouldFloat);
                this.adapter_.shakeLabel(this.shouldShake);
            }
            if (this.helperText_) {
                this.helperText_.showToScreenReader();
            }
        };
        /**
         * Sets the line ripple's transform origin, so that the line ripple activate
         * animation will animate out from the user's click location.
         */
        MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
            var touches = evt.touches;
            var targetEvent = touches ? touches[0] : evt;
            var targetClientRect = targetEvent.target.getBoundingClientRect();
            var normalizedX = targetEvent.clientX - targetClientRect.left;
            this.adapter_.setLineRippleTransformOrigin(normalizedX);
        };
        /**
         * Handles input change of text input and text area.
         */
        MDCTextFieldFoundation.prototype.handleInput = function () {
            this.autoCompleteFocus();
            this.setCharacterCounter_(this.getValue().length);
        };
        /**
         * Activates the Text Field's focus state in cases when the input value
         * changes without user input (e.g. programmatically).
         */
        MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
            if (!this.receivedUserInput_) {
                this.activateFocus();
            }
        };
        /**
         * Deactivates the Text Field's focus state.
         */
        MDCTextFieldFoundation.prototype.deactivateFocus = function () {
            this.isFocused_ = false;
            this.adapter_.deactivateLineRipple();
            var isValid = this.isValid();
            this.styleValidity_(isValid);
            this.styleFocused_(this.isFocused_);
            if (this.adapter_.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter_.floatLabel(this.shouldFloat);
                this.adapter_.shakeLabel(this.shouldShake);
            }
            if (!this.shouldFloat) {
                this.receivedUserInput_ = false;
            }
        };
        MDCTextFieldFoundation.prototype.getValue = function () {
            return this.getNativeInput_().value;
        };
        /**
         * @param value The value to set on the input Element.
         */
        MDCTextFieldFoundation.prototype.setValue = function (value) {
            // Prevent Safari from moving the caret to the end of the input when the value has not changed.
            if (this.getValue() !== value) {
                this.getNativeInput_().value = value;
            }
            this.setCharacterCounter_(value.length);
            var isValid = this.isValid();
            this.styleValidity_(isValid);
            if (this.adapter_.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter_.floatLabel(this.shouldFloat);
                this.adapter_.shakeLabel(this.shouldShake);
            }
        };
        /**
         * @return The custom validity state, if set; otherwise, the result of a native validity check.
         */
        MDCTextFieldFoundation.prototype.isValid = function () {
            return this.useNativeValidation_
                ? this.isNativeInputValid_() : this.isValid_;
        };
        /**
         * @param isValid Sets the custom validity state of the Text Field.
         */
        MDCTextFieldFoundation.prototype.setValid = function (isValid) {
            this.isValid_ = isValid;
            this.styleValidity_(isValid);
            var shouldShake = !isValid && !this.isFocused_;
            if (this.adapter_.hasLabel()) {
                this.adapter_.shakeLabel(shouldShake);
            }
        };
        /**
         * Enables or disables the use of native validation. Use this for custom validation.
         * @param useNativeValidation Set this to false to ignore native input validation.
         */
        MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
            this.useNativeValidation_ = useNativeValidation;
        };
        MDCTextFieldFoundation.prototype.isDisabled = function () {
            return this.getNativeInput_().disabled;
        };
        /**
         * @param disabled Sets the text-field disabled or enabled.
         */
        MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
            this.getNativeInput_().disabled = disabled;
            this.styleDisabled_(disabled);
        };
        /**
         * @param content Sets the content of the helper text.
         */
        MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
            if (this.helperText_) {
                this.helperText_.setContent(content);
            }
        };
        /**
         * Sets the aria label of the leading icon.
         */
        MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
            if (this.leadingIcon_) {
                this.leadingIcon_.setAriaLabel(label);
            }
        };
        /**
         * Sets the text content of the leading icon.
         */
        MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
            if (this.leadingIcon_) {
                this.leadingIcon_.setContent(content);
            }
        };
        /**
         * Sets the aria label of the trailing icon.
         */
        MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
            if (this.trailingIcon_) {
                this.trailingIcon_.setAriaLabel(label);
            }
        };
        /**
         * Sets the text content of the trailing icon.
         */
        MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
            if (this.trailingIcon_) {
                this.trailingIcon_.setContent(content);
            }
        };
        /**
         * Sets character counter values that shows characters used and the total character limit.
         */
        MDCTextFieldFoundation.prototype.setCharacterCounter_ = function (currentLength) {
            if (!this.characterCounter_) {
                return;
            }
            var maxLength = this.getNativeInput_().maxLength;
            if (maxLength === -1) {
                throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
            }
            this.characterCounter_.setCounterValue(currentLength, maxLength);
        };
        /**
         * @return True if the Text Field input fails in converting the user-supplied value.
         */
        MDCTextFieldFoundation.prototype.isBadInput_ = function () {
            // The badInput property is not supported in IE 11 💩.
            return this.getNativeInput_().validity.badInput || false;
        };
        /**
         * @return The result of native validity checking (ValidityState.valid).
         */
        MDCTextFieldFoundation.prototype.isNativeInputValid_ = function () {
            return this.getNativeInput_().validity.valid;
        };
        /**
         * Styles the component based on the validity state.
         */
        MDCTextFieldFoundation.prototype.styleValidity_ = function (isValid) {
            var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
            if (isValid) {
                this.adapter_.removeClass(INVALID);
            }
            else {
                this.adapter_.addClass(INVALID);
            }
            if (this.helperText_) {
                this.helperText_.setValidity(isValid);
            }
        };
        /**
         * Styles the component based on the focused state.
         */
        MDCTextFieldFoundation.prototype.styleFocused_ = function (isFocused) {
            var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
            if (isFocused) {
                this.adapter_.addClass(FOCUSED);
            }
            else {
                this.adapter_.removeClass(FOCUSED);
            }
        };
        /**
         * Styles the component based on the disabled state.
         */
        MDCTextFieldFoundation.prototype.styleDisabled_ = function (isDisabled) {
            var _a = MDCTextFieldFoundation.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
            if (isDisabled) {
                this.adapter_.addClass(DISABLED);
                this.adapter_.removeClass(INVALID);
            }
            else {
                this.adapter_.removeClass(DISABLED);
            }
            if (this.leadingIcon_) {
                this.leadingIcon_.setDisabled(isDisabled);
            }
            if (this.trailingIcon_) {
                this.trailingIcon_.setDisabled(isDisabled);
            }
        };
        /**
         * @return The native text input element from the host environment, or an object with the same shape for unit tests.
         */
        MDCTextFieldFoundation.prototype.getNativeInput_ = function () {
            // this.adapter_ may be undefined in foundation unit tests. This happens when testdouble is creating a mock object
            // and invokes the shouldShake/shouldFloat getters (which in turn call getValue(), which calls this method) before
            // init() has been called from the MDCTextField constructor. To work around that issue, we return a dummy object.
            var nativeInput = this.adapter_ ? this.adapter_.getNativeInput() : null;
            return nativeInput || {
                disabled: false,
                maxLength: -1,
                type: 'input',
                validity: {
                    badInput: false,
                    valid: true,
                },
                value: '',
            };
        };
        return MDCTextFieldFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$d = {
        HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
        HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg',
        ROOT: 'mdc-text-field-helper-text',
    };
    var strings$g = {
        ARIA_HIDDEN: 'aria-hidden',
        ROLE: 'role',
        ROOT_SELECTOR: "." + cssClasses$d.ROOT,
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldHelperTextFoundation = /** @class */ (function (_super) {
        __extends(MDCTextFieldHelperTextFoundation, _super);
        function MDCTextFieldHelperTextFoundation(adapter) {
            return _super.call(this, __assign({}, MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCTextFieldHelperTextFoundation, "cssClasses", {
            get: function () {
                return cssClasses$d;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldHelperTextFoundation, "strings", {
            get: function () {
                return strings$g;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldHelperTextFoundation, "defaultAdapter", {
            /**
             * See {@link MDCTextFieldHelperTextAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setAttr: function () { return undefined; },
                    removeAttr: function () { return undefined; },
                    setContent: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the content of the helper text field.
         */
        MDCTextFieldHelperTextFoundation.prototype.setContent = function (content) {
            this.adapter_.setContent(content);
        };
        /**
         * @param isPersistent Sets the persistency of the helper text.
         */
        MDCTextFieldHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
            if (isPersistent) {
                this.adapter_.addClass(cssClasses$d.HELPER_TEXT_PERSISTENT);
            }
            else {
                this.adapter_.removeClass(cssClasses$d.HELPER_TEXT_PERSISTENT);
            }
        };
        /**
         * @param isValidation True to make the helper text act as an error validation message.
         */
        MDCTextFieldHelperTextFoundation.prototype.setValidation = function (isValidation) {
            if (isValidation) {
                this.adapter_.addClass(cssClasses$d.HELPER_TEXT_VALIDATION_MSG);
            }
            else {
                this.adapter_.removeClass(cssClasses$d.HELPER_TEXT_VALIDATION_MSG);
            }
        };
        /**
         * Makes the helper text visible to the screen reader.
         */
        MDCTextFieldHelperTextFoundation.prototype.showToScreenReader = function () {
            this.adapter_.removeAttr(strings$g.ARIA_HIDDEN);
        };
        /**
         * Sets the validity of the helper text based on the input validity.
         */
        MDCTextFieldHelperTextFoundation.prototype.setValidity = function (inputIsValid) {
            var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$d.HELPER_TEXT_PERSISTENT);
            var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$d.HELPER_TEXT_VALIDATION_MSG);
            var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
            if (validationMsgNeedsDisplay) {
                this.adapter_.setAttr(strings$g.ROLE, 'alert');
            }
            else {
                this.adapter_.removeAttr(strings$g.ROLE);
            }
            if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
                this.hide_();
            }
        };
        /**
         * Hides the help text from screen readers.
         */
        MDCTextFieldHelperTextFoundation.prototype.hide_ = function () {
            this.adapter_.setAttr(strings$g.ARIA_HIDDEN, 'true');
        };
        return MDCTextFieldHelperTextFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldHelperText = /** @class */ (function (_super) {
        __extends(MDCTextFieldHelperText, _super);
        function MDCTextFieldHelperText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTextFieldHelperText.attachTo = function (root) {
            return new MDCTextFieldHelperText(root);
        };
        Object.defineProperty(MDCTextFieldHelperText.prototype, "foundation", {
            get: function () {
                return this.foundation_;
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldHelperText.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
                setContent: function (content) {
                    _this.root_.textContent = content;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTextFieldHelperTextFoundation(adapter);
        };
        return MDCTextFieldHelperText;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$f = {
        ICON_EVENT: 'MDCTextField:icon',
        ICON_ROLE: 'button',
    };
    var cssClasses$c = {
        ROOT: 'mdc-text-field__icon',
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var INTERACTION_EVENTS$1 = ['click', 'keydown'];
    var MDCTextFieldIconFoundation = /** @class */ (function (_super) {
        __extends(MDCTextFieldIconFoundation, _super);
        function MDCTextFieldIconFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCTextFieldIconFoundation.defaultAdapter, adapter)) || this;
            _this.savedTabIndex_ = null;
            _this.interactionHandler_ = function (evt) { return _this.handleInteraction(evt); };
            return _this;
        }
        Object.defineProperty(MDCTextFieldIconFoundation, "strings", {
            get: function () {
                return strings$f;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldIconFoundation, "cssClasses", {
            get: function () {
                return cssClasses$c;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldIconFoundation, "defaultAdapter", {
            /**
             * See {@link MDCTextFieldIconAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    getAttr: function () { return null; },
                    setAttr: function () { return undefined; },
                    removeAttr: function () { return undefined; },
                    setContent: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    notifyIconAction: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldIconFoundation.prototype.init = function () {
            var _this = this;
            this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
            INTERACTION_EVENTS$1.forEach(function (evtType) {
                _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
            });
        };
        MDCTextFieldIconFoundation.prototype.destroy = function () {
            var _this = this;
            INTERACTION_EVENTS$1.forEach(function (evtType) {
                _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
            });
        };
        MDCTextFieldIconFoundation.prototype.setDisabled = function (disabled) {
            if (!this.savedTabIndex_) {
                return;
            }
            if (disabled) {
                this.adapter_.setAttr('tabindex', '-1');
                this.adapter_.removeAttr('role');
            }
            else {
                this.adapter_.setAttr('tabindex', this.savedTabIndex_);
                this.adapter_.setAttr('role', strings$f.ICON_ROLE);
            }
        };
        MDCTextFieldIconFoundation.prototype.setAriaLabel = function (label) {
            this.adapter_.setAttr('aria-label', label);
        };
        MDCTextFieldIconFoundation.prototype.setContent = function (content) {
            this.adapter_.setContent(content);
        };
        MDCTextFieldIconFoundation.prototype.handleInteraction = function (evt) {
            var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
            if (evt.type === 'click' || isEnterKey) {
                this.adapter_.notifyIconAction();
            }
        };
        return MDCTextFieldIconFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldIcon = /** @class */ (function (_super) {
        __extends(MDCTextFieldIcon, _super);
        function MDCTextFieldIcon() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTextFieldIcon.attachTo = function (root) {
            return new MDCTextFieldIcon(root);
        };
        Object.defineProperty(MDCTextFieldIcon.prototype, "foundation", {
            get: function () {
                return this.foundation_;
            },
            enumerable: true,
            configurable: true
        });
        MDCTextFieldIcon.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                getAttr: function (attr) { return _this.root_.getAttribute(attr); },
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
                setContent: function (content) {
                    _this.root_.textContent = content;
                },
                registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
                deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
                notifyIconAction: function () { return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCTextFieldIconFoundation(adapter);
        };
        return MDCTextFieldIcon;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextField = /** @class */ (function (_super) {
        __extends(MDCTextField, _super);
        function MDCTextField() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCTextField.attachTo = function (root) {
            return new MDCTextField(root);
        };
        MDCTextField.prototype.initialize = function (rippleFactory, lineRippleFactory, helperTextFactory, characterCounterFactory, iconFactory, labelFactory, outlineFactory) {
            if (rippleFactory === void 0) { rippleFactory = function (el, foundation) { return new MDCRipple(el, foundation); }; }
            if (lineRippleFactory === void 0) { lineRippleFactory = function (el) { return new MDCLineRipple(el); }; }
            if (helperTextFactory === void 0) { helperTextFactory = function (el) { return new MDCTextFieldHelperText(el); }; }
            if (characterCounterFactory === void 0) { characterCounterFactory = function (el) { return new MDCTextFieldCharacterCounter(el); }; }
            if (iconFactory === void 0) { iconFactory = function (el) { return new MDCTextFieldIcon(el); }; }
            if (labelFactory === void 0) { labelFactory = function (el) { return new MDCFloatingLabel(el); }; }
            if (outlineFactory === void 0) { outlineFactory = function (el) { return new MDCNotchedOutline(el); }; }
            this.input_ = this.root_.querySelector(strings$h.INPUT_SELECTOR);
            var labelElement = this.root_.querySelector(strings$h.LABEL_SELECTOR);
            this.label_ = labelElement ? labelFactory(labelElement) : null;
            var lineRippleElement = this.root_.querySelector(strings$h.LINE_RIPPLE_SELECTOR);
            this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
            var outlineElement = this.root_.querySelector(strings$h.OUTLINE_SELECTOR);
            this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
            // Helper text
            var helperTextStrings = MDCTextFieldHelperTextFoundation.strings;
            var nextElementSibling = this.root_.nextElementSibling;
            var hasHelperLine = (nextElementSibling && nextElementSibling.classList.contains(cssClasses$e.HELPER_LINE));
            var helperTextEl = hasHelperLine && nextElementSibling && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);
            this.helperText_ = helperTextEl ? helperTextFactory(helperTextEl) : null;
            // Character counter
            var characterCounterStrings = MDCTextFieldCharacterCounterFoundation.strings;
            var characterCounterEl = this.root_.querySelector(characterCounterStrings.ROOT_SELECTOR);
            // If character counter is not found in root element search in sibling element.
            if (!characterCounterEl && hasHelperLine && nextElementSibling) {
                characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
            }
            this.characterCounter_ = characterCounterEl ? characterCounterFactory(characterCounterEl) : null;
            this.leadingIcon_ = null;
            this.trailingIcon_ = null;
            var iconElements = this.root_.querySelectorAll(strings$h.ICON_SELECTOR);
            if (iconElements.length > 0) {
                if (iconElements.length > 1) { // Has both icons.
                    this.leadingIcon_ = iconFactory(iconElements[0]);
                    this.trailingIcon_ = iconFactory(iconElements[1]);
                }
                else {
                    if (this.root_.classList.contains(cssClasses$e.WITH_LEADING_ICON)) {
                        this.leadingIcon_ = iconFactory(iconElements[0]);
                    }
                    else {
                        this.trailingIcon_ = iconFactory(iconElements[0]);
                    }
                }
            }
            this.ripple = this.createRipple_(rippleFactory);
        };
        MDCTextField.prototype.destroy = function () {
            if (this.ripple) {
                this.ripple.destroy();
            }
            if (this.lineRipple_) {
                this.lineRipple_.destroy();
            }
            if (this.helperText_) {
                this.helperText_.destroy();
            }
            if (this.characterCounter_) {
                this.characterCounter_.destroy();
            }
            if (this.leadingIcon_) {
                this.leadingIcon_.destroy();
            }
            if (this.trailingIcon_) {
                this.trailingIcon_.destroy();
            }
            if (this.label_) {
                this.label_.destroy();
            }
            if (this.outline_) {
                this.outline_.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        /**
         * Initializes the Text Field's internal state based on the environment's
         * state.
         */
        MDCTextField.prototype.initialSyncWithDOM = function () {
            this.disabled = this.input_.disabled;
        };
        Object.defineProperty(MDCTextField.prototype, "value", {
            get: function () {
                return this.foundation_.getValue();
            },
            /**
             * @param value The value to set on the input.
             */
            set: function (value) {
                this.foundation_.setValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "disabled", {
            get: function () {
                return this.foundation_.isDisabled();
            },
            /**
             * @param disabled Sets the Text Field disabled or enabled.
             */
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "valid", {
            get: function () {
                return this.foundation_.isValid();
            },
            /**
             * @param valid Sets the Text Field valid or invalid.
             */
            set: function (valid) {
                this.foundation_.setValid(valid);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "required", {
            get: function () {
                return this.input_.required;
            },
            /**
             * @param required Sets the Text Field to required.
             */
            set: function (required) {
                this.input_.required = required;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "pattern", {
            get: function () {
                return this.input_.pattern;
            },
            /**
             * @param pattern Sets the input element's validation pattern.
             */
            set: function (pattern) {
                this.input_.pattern = pattern;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "minLength", {
            get: function () {
                return this.input_.minLength;
            },
            /**
             * @param minLength Sets the input element's minLength.
             */
            set: function (minLength) {
                this.input_.minLength = minLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "maxLength", {
            get: function () {
                return this.input_.maxLength;
            },
            /**
             * @param maxLength Sets the input element's maxLength.
             */
            set: function (maxLength) {
                // Chrome throws exception if maxLength is set to a value less than zero
                if (maxLength < 0) {
                    this.input_.removeAttribute('maxLength');
                }
                else {
                    this.input_.maxLength = maxLength;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "min", {
            get: function () {
                return this.input_.min;
            },
            /**
             * @param min Sets the input element's min.
             */
            set: function (min) {
                this.input_.min = min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "max", {
            get: function () {
                return this.input_.max;
            },
            /**
             * @param max Sets the input element's max.
             */
            set: function (max) {
                this.input_.max = max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "step", {
            get: function () {
                return this.input_.step;
            },
            /**
             * @param step Sets the input element's step.
             */
            set: function (step) {
                this.input_.step = step;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "helperTextContent", {
            /**
             * Sets the helper text element content.
             */
            set: function (content) {
                this.foundation_.setHelperTextContent(content);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "leadingIconAriaLabel", {
            /**
             * Sets the aria label of the leading icon.
             */
            set: function (label) {
                this.foundation_.setLeadingIconAriaLabel(label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "leadingIconContent", {
            /**
             * Sets the text content of the leading icon.
             */
            set: function (content) {
                this.foundation_.setLeadingIconContent(content);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "trailingIconAriaLabel", {
            /**
             * Sets the aria label of the trailing icon.
             */
            set: function (label) {
                this.foundation_.setTrailingIconAriaLabel(label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "trailingIconContent", {
            /**
             * Sets the text content of the trailing icon.
             */
            set: function (content) {
                this.foundation_.setTrailingIconContent(content);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCTextField.prototype, "useNativeValidation", {
            /**
             * Enables or disables the use of native validation. Use this for custom validation.
             * @param useNativeValidation Set this to false to ignore native input validation.
             */
            set: function (useNativeValidation) {
                this.foundation_.setUseNativeValidation(useNativeValidation);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Focuses the input element.
         */
        MDCTextField.prototype.focus = function () {
            this.input_.focus();
        };
        /**
         * Recomputes the outline SVG path for the outline element.
         */
        MDCTextField.prototype.layout = function () {
            var openNotch = this.foundation_.shouldFloat;
            this.foundation_.notchOutline(openNotch);
        };
        MDCTextField.prototype.getDefaultFoundation = function () {
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = __assign({}, this.getRootAdapterMethods_(), this.getInputAdapterMethods_(), this.getLabelAdapterMethods_(), this.getLineRippleAdapterMethods_(), this.getOutlineAdapterMethods_());
            // tslint:enable:object-literal-sort-keys
            return new MDCTextFieldFoundation(adapter, this.getFoundationMap_());
        };
        MDCTextField.prototype.getRootAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                registerTextFieldInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
                deregisterTextFieldInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
                registerValidationAttributeChangeHandler: function (handler) {
                    var getAttributesList = function (mutationsList) {
                        return mutationsList
                            .map(function (mutation) { return mutation.attributeName; })
                            .filter(function (attributeName) { return attributeName; });
                    };
                    var observer = new MutationObserver(function (mutationsList) { return handler(getAttributesList(mutationsList)); });
                    var config = { attributes: true };
                    observer.observe(_this.input_, config);
                    return observer;
                },
                deregisterValidationAttributeChangeHandler: function (observer) { return observer.disconnect(); },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCTextField.prototype.getInputAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getNativeInput: function () { return _this.input_; },
                isFocused: function () { return document.activeElement === _this.input_; },
                registerInputInteractionHandler: function (evtType, handler) {
                    return _this.input_.addEventListener(evtType, handler, applyPassive());
                },
                deregisterInputInteractionHandler: function (evtType, handler) {
                    return _this.input_.removeEventListener(evtType, handler, applyPassive());
                },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCTextField.prototype.getLabelAdapterMethods_ = function () {
            var _this = this;
            return {
                floatLabel: function (shouldFloat) { return _this.label_ && _this.label_.float(shouldFloat); },
                getLabelWidth: function () { return _this.label_ ? _this.label_.getWidth() : 0; },
                hasLabel: function () { return Boolean(_this.label_); },
                shakeLabel: function (shouldShake) { return _this.label_ && _this.label_.shake(shouldShake); },
            };
        };
        MDCTextField.prototype.getLineRippleAdapterMethods_ = function () {
            var _this = this;
            return {
                activateLineRipple: function () {
                    if (_this.lineRipple_) {
                        _this.lineRipple_.activate();
                    }
                },
                deactivateLineRipple: function () {
                    if (_this.lineRipple_) {
                        _this.lineRipple_.deactivate();
                    }
                },
                setLineRippleTransformOrigin: function (normalizedX) {
                    if (_this.lineRipple_) {
                        _this.lineRipple_.setRippleCenter(normalizedX);
                    }
                },
            };
        };
        MDCTextField.prototype.getOutlineAdapterMethods_ = function () {
            var _this = this;
            return {
                closeOutline: function () { return _this.outline_ && _this.outline_.closeNotch(); },
                hasOutline: function () { return Boolean(_this.outline_); },
                notchOutline: function (labelWidth) { return _this.outline_ && _this.outline_.notch(labelWidth); },
            };
        };
        /**
         * @return A map of all subcomponents to subfoundations.
         */
        MDCTextField.prototype.getFoundationMap_ = function () {
            return {
                characterCounter: this.characterCounter_ ? this.characterCounter_.foundation : undefined,
                helperText: this.helperText_ ? this.helperText_.foundation : undefined,
                leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
                trailingIcon: this.trailingIcon_ ? this.trailingIcon_.foundation : undefined,
            };
        };
        MDCTextField.prototype.createRipple_ = function (rippleFactory) {
            var _this = this;
            var isTextArea = this.root_.classList.contains(cssClasses$e.TEXTAREA);
            var isOutlined = this.root_.classList.contains(cssClasses$e.OUTLINED);
            if (isTextArea || isOutlined) {
                return null;
            }
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { isSurfaceActive: function () { return matches$1(_this.input_, ':active'); }, registerInteractionHandler: function (evtType, handler) { return _this.input_.addEventListener(evtType, handler, applyPassive()); }, deregisterInteractionHandler: function (evtType, handler) {
                    return _this.input_.removeEventListener(evtType, handler, applyPassive());
                } });
            // tslint:enable:object-literal-sort-keys
            return rippleFactory(this.root_, new MDCRippleFoundation(adapter));
        };
        return MDCTextField;
    }(MDCComponent));

    /* node_modules\@smui\floating-label\FloatingLabel.svelte generated by Svelte v3.42.1 */
    const file$1d = "node_modules\\@smui\\floating-label\\FloatingLabel.svelte";

    // (9:0) {:else}
    function create_else_block$c(ctx) {
    	let label;
    	let label_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let label_levels = [
    		{
    			class: label_class_value = "mdc-floating-label " + /*className*/ ctx[1]
    		},
    		/*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
    		? {
    				'for': /*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
    			}
    		: {},
    		exclude(/*$$props*/ ctx[7], ['use', 'class', 'for', 'wrapped'])
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$1d, 9, 2, 225);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			/*label_binding*/ ctx[14](label);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, label))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				(!current || dirty & /*className*/ 2 && label_class_value !== (label_class_value = "mdc-floating-label " + /*className*/ ctx[1])) && { class: label_class_value },
    				dirty & /*forId*/ 4 && (/*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
    				? {
    						'for': /*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
    					}
    				: {}),
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ['use', 'class', 'for', 'wrapped'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    			/*label_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(9:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if wrapped}
    function create_if_block$B(ctx) {
    	let span;
    	let span_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let span_levels = [
    		{
    			class: span_class_value = "mdc-floating-label " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[7], ['use', 'class', 'wrapped'])
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$1d, 1, 2, 16);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[13](span);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, span))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = "mdc-floating-label " + /*className*/ ctx[1])) && { class: span_class_value },
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ['use', 'class', 'wrapped'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			/*span_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(1:0) {#if wrapped}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$B, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*wrapped*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FloatingLabel', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { for: forId = '' } = $$props;
    	let { wrapped = false } = $$props;
    	let element;
    	let floatingLabel;
    	let inputProps = getContext('SMUI:generic:input:props') || {};

    	onMount(() => {
    		floatingLabel = new MDCFloatingLabel(element);
    	});

    	onDestroy(() => {
    		floatingLabel && floatingLabel.destroy();
    	});

    	function shake(shouldShake, ...args) {
    		return floatingLabel.shake(shouldShake, ...args);
    	}

    	function float(shouldFloat, ...args) {
    		return floatingLabel.float(shouldFloat, ...args);
    	}

    	function getWidth(...args) {
    		return floatingLabel.getWidth(...args);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	function label_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('for' in $$new_props) $$invalidate(2, forId = $$new_props.for);
    		if ('wrapped' in $$new_props) $$invalidate(3, wrapped = $$new_props.wrapped);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCFloatingLabel,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		forId,
    		wrapped,
    		element,
    		floatingLabel,
    		inputProps,
    		shake,
    		float,
    		getWidth
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('forId' in $$props) $$invalidate(2, forId = $$new_props.forId);
    		if ('wrapped' in $$props) $$invalidate(3, wrapped = $$new_props.wrapped);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('floatingLabel' in $$props) floatingLabel = $$new_props.floatingLabel;
    		if ('inputProps' in $$props) $$invalidate(6, inputProps = $$new_props.inputProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		forId,
    		wrapped,
    		element,
    		forwardEvents,
    		inputProps,
    		$$props,
    		shake,
    		float,
    		getWidth,
    		$$scope,
    		slots,
    		span_binding,
    		label_binding
    	];
    }

    class FloatingLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1m, create_fragment$1m, safe_not_equal, {
    			use: 0,
    			class: 1,
    			for: 2,
    			wrapped: 3,
    			shake: 8,
    			float: 9,
    			getWidth: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FloatingLabel",
    			options,
    			id: create_fragment$1m.name
    		});
    	}

    	get use() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get for() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set for(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapped() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapped(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shake() {
    		return this.$$.ctx[8];
    	}

    	set shake(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get float() {
    		return this.$$.ctx[9];
    	}

    	set float(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getWidth() {
    		return this.$$.ctx[10];
    	}

    	set getWidth(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\line-ripple\LineRipple.svelte generated by Svelte v3.42.1 */
    const file$1c = "node_modules\\@smui\\line-ripple\\LineRipple.svelte";

    function create_fragment$1l(ctx) {
    	let div;
    	let div_class_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let div_levels = [
    		{
    			class: div_class_value = "\n    mdc-line-ripple\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? 'mdc-line-ripple--active' : '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[5], ['use', 'class', 'active'])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_attributes(div, div_data);
    			add_location(div, file$1c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[9](div);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[4].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*className, active*/ 6 && div_class_value !== (div_class_value = "\n    mdc-line-ripple\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? 'mdc-line-ripple--active' : '') + "\n  ") && { class: div_class_value },
    				dirty & /*$$props*/ 32 && exclude(/*$$props*/ ctx[5], ['use', 'class', 'active'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[9](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LineRipple', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let element;
    	let lineRipple;

    	onMount(() => {
    		lineRipple = new MDCLineRipple(element);
    	});

    	onDestroy(() => {
    		lineRipple && lineRipple.destroy();
    	});

    	function activate(...args) {
    		return lineRipple.activate(...args);
    	}

    	function deactivate(...args) {
    		return lineRipple.deactivate(...args);
    	}

    	function setRippleCenter(xCoordinate, ...args) {
    		return lineRipple.setRippleCenter(xCoordinate, ...args);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(3, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(2, active = $$new_props.active);
    	};

    	$$self.$capture_state = () => ({
    		MDCLineRipple,
    		onMount,
    		onDestroy,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		active,
    		element,
    		lineRipple,
    		activate,
    		deactivate,
    		setRippleCenter
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(2, active = $$new_props.active);
    		if ('element' in $$props) $$invalidate(3, element = $$new_props.element);
    		if ('lineRipple' in $$props) lineRipple = $$new_props.lineRipple;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		active,
    		element,
    		forwardEvents,
    		$$props,
    		activate,
    		deactivate,
    		setRippleCenter,
    		div_binding
    	];
    }

    class LineRipple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
    			use: 0,
    			class: 1,
    			active: 2,
    			activate: 6,
    			deactivate: 7,
    			setRippleCenter: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineRipple",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get use() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[6];
    	}

    	set activate(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[7];
    	}

    	set deactivate(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setRippleCenter() {
    		return this.$$.ctx[8];
    	}

    	set setRippleCenter(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\notched-outline\NotchedOutline.svelte generated by Svelte v3.42.1 */
    const file$1b = "node_modules\\@smui\\notched-outline\\NotchedOutline.svelte";

    // (14:2) {#if !noLabel}
    function create_if_block$A(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "mdc-notched-outline__notch");
    			add_location(div, file$1b, 14, 4, 367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(14:2) {#if !noLabel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let div2_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = !/*noLabel*/ ctx[3] && create_if_block$A(ctx);

    	let div2_levels = [
    		{
    			class: div2_class_value = "\n    mdc-notched-outline\n    " + /*className*/ ctx[1] + "\n    " + (/*notched*/ ctx[2] ? 'mdc-notched-outline--notched' : '') + "\n    " + (/*noLabel*/ ctx[3]
    			? 'mdc-notched-outline--no-label'
    			: '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[6], ['use', 'class', 'notched', 'noLabel'])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "mdc-notched-outline__leading");
    			add_location(div0, file$1b, 12, 2, 297);
    			attr_dev(div1, "class", "mdc-notched-outline__trailing");
    			add_location(div1, file$1b, 16, 2, 437);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$1b, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div2_binding*/ ctx[11](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div2, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, div2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*noLabel*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*noLabel*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty & /*className, notched, noLabel*/ 14 && div2_class_value !== (div2_class_value = "\n    mdc-notched-outline\n    " + /*className*/ ctx[1] + "\n    " + (/*notched*/ ctx[2] ? 'mdc-notched-outline--notched' : '') + "\n    " + (/*noLabel*/ ctx[3]
    				? 'mdc-notched-outline--no-label'
    				: '') + "\n  ")) && { class: div2_class_value },
    				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ['use', 'class', 'notched', 'noLabel'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NotchedOutline', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { notched = false } = $$props;
    	let { noLabel = false } = $$props;
    	let element;
    	let notchedOutline;

    	onMount(() => {
    		notchedOutline = new MDCNotchedOutline(element);
    	});

    	onDestroy(() => {
    		notchedOutline && notchedOutline.destroy();
    	});

    	function notch(notchWidth, ...args) {
    		return notchedOutline.notch(notchWidth, ...args);
    	}

    	function closeNotch(...args) {
    		return notchedOutline.closeNotch(...args);
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('notched' in $$new_props) $$invalidate(2, notched = $$new_props.notched);
    		if ('noLabel' in $$new_props) $$invalidate(3, noLabel = $$new_props.noLabel);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCNotchedOutline,
    		onMount,
    		onDestroy,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		notched,
    		noLabel,
    		element,
    		notchedOutline,
    		notch,
    		closeNotch
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('notched' in $$props) $$invalidate(2, notched = $$new_props.notched);
    		if ('noLabel' in $$props) $$invalidate(3, noLabel = $$new_props.noLabel);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('notchedOutline' in $$props) notchedOutline = $$new_props.notchedOutline;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		notched,
    		noLabel,
    		element,
    		forwardEvents,
    		$$props,
    		notch,
    		closeNotch,
    		$$scope,
    		slots,
    		div2_binding
    	];
    }

    class NotchedOutline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
    			use: 0,
    			class: 1,
    			notched: 2,
    			noLabel: 3,
    			notch: 7,
    			closeNotch: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotchedOutline",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get use() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notched() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notched(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notch() {
    		return this.$$.ctx[7];
    	}

    	set notch(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeNotch() {
    		return this.$$.ctx[8];
    	}

    	set closeNotch(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\textfield\Input.svelte generated by Svelte v3.42.1 */
    const file$1a = "node_modules\\@smui\\textfield\\Input.svelte";

    function create_fragment$1j(ctx) {
    	let input;
    	let input_class_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{
    			class: input_class_value = "mdc-text-field__input " + /*className*/ ctx[1]
    		},
    		{ type: /*type*/ ctx[2] },
    		/*valueProp*/ ctx[3],
    		exclude(/*$$props*/ ctx[8], [
    			'use',
    			'class',
    			'type',
    			'value',
    			'files',
    			'dirty',
    			'invalid',
    			'updateInvalid'
    		])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$1a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			/*input_binding*/ ctx[14](input);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, input)),
    					listen_dev(input, "change", /*change_handler*/ ctx[15], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[16], false, false, false),
    					listen_dev(input, "change", /*changeHandler*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty & /*className*/ 2 && input_class_value !== (input_class_value = "mdc-text-field__input " + /*className*/ ctx[1]) && { class: input_class_value },
    				dirty & /*type*/ 4 && { type: /*type*/ ctx[2] },
    				dirty & /*valueProp*/ 8 && /*valueProp*/ ctx[3],
    				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], [
    					'use',
    					'class',
    					'type',
    					'value',
    					'files',
    					'dirty',
    					'invalid',
    					'updateInvalid'
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function toNumber(value) {
    	if (value === '') {
    		const nan = new Number(Number.NaN);
    		nan.length = 0;
    		return nan;
    	}

    	return +value;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['change', 'input']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { type = 'text' } = $$props;
    	let { value = '' } = $$props;
    	let { files = undefined } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = false } = $$props;
    	let { updateInvalid = true } = $$props;
    	let element;
    	let valueProp = {};

    	onMount(() => {
    		if (updateInvalid) {
    			$$invalidate(12, invalid = element.matches(':invalid'));
    		}
    	});

    	function valueUpdater(e) {
    		switch (type) {
    			case 'number':
    			case 'range':
    				$$invalidate(9, value = toNumber(e.target.value));
    				break;
    			case 'file':
    				$$invalidate(10, files = e.target.files);
    			default:
    				$$invalidate(9, value = e.target.value);
    				break;
    		}
    	}

    	function changeHandler(e) {
    		$$invalidate(11, dirty = true);

    		if (updateInvalid) {
    			$$invalidate(12, invalid = element.matches(':invalid'));
    		}
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	const change_handler = e => (type === 'file' || type === 'range') && valueUpdater(e);
    	const input_handler = e => type !== 'file' && valueUpdater(e);

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('type' in $$new_props) $$invalidate(2, type = $$new_props.type);
    		if ('value' in $$new_props) $$invalidate(9, value = $$new_props.value);
    		if ('files' in $$new_props) $$invalidate(10, files = $$new_props.files);
    		if ('dirty' in $$new_props) $$invalidate(11, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(12, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(13, updateInvalid = $$new_props.updateInvalid);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		type,
    		value,
    		files,
    		dirty,
    		invalid,
    		updateInvalid,
    		element,
    		valueProp,
    		toNumber,
    		valueUpdater,
    		changeHandler
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('type' in $$props) $$invalidate(2, type = $$new_props.type);
    		if ('value' in $$props) $$invalidate(9, value = $$new_props.value);
    		if ('files' in $$props) $$invalidate(10, files = $$new_props.files);
    		if ('dirty' in $$props) $$invalidate(11, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(12, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(13, updateInvalid = $$new_props.updateInvalid);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('valueProp' in $$props) $$invalidate(3, valueProp = $$new_props.valueProp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type, valueProp, value*/ 524) {
    			if (type === 'file') {
    				delete valueProp.value;
    			} else {
    				$$invalidate(3, valueProp.value = value === undefined ? '' : value, valueProp);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		type,
    		valueProp,
    		element,
    		forwardEvents,
    		valueUpdater,
    		changeHandler,
    		$$props,
    		value,
    		files,
    		dirty,
    		invalid,
    		updateInvalid,
    		input_binding,
    		change_handler,
    		input_handler
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
    			use: 0,
    			class: 1,
    			type: 2,
    			value: 9,
    			files: 10,
    			dirty: 11,
    			invalid: 12,
    			updateInvalid: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$1j.name
    		});
    	}

    	get use() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\textfield\Textarea.svelte generated by Svelte v3.42.1 */
    const file$19 = "node_modules\\@smui\\textfield\\Textarea.svelte";

    function create_fragment$1i(ctx) {
    	let textarea;
    	let textarea_class_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let textarea_levels = [
    		{
    			class: textarea_class_value = "mdc-text-field__input " + /*className*/ ctx[2]
    		},
    		exclude(/*$$props*/ ctx[6], ['use', 'class', 'value', 'dirty', 'invalid', 'updateInvalid'])
    	];

    	let textarea_data = {};

    	for (let i = 0; i < textarea_levels.length; i += 1) {
    		textarea_data = assign(textarea_data, textarea_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			set_attributes(textarea, textarea_data);
    			add_location(textarea, file$19, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			if (textarea.autofocus) textarea.focus();
    			/*textarea_binding*/ ctx[10](textarea);
    			set_input_value(textarea, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, textarea, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[4].call(null, textarea)),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[11]),
    					listen_dev(textarea, "change", /*changeHandler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
    				dirty & /*className*/ 4 && textarea_class_value !== (textarea_class_value = "mdc-text-field__input " + /*className*/ ctx[2]) && { class: textarea_class_value },
    				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ['use', 'class', 'value', 'dirty', 'invalid', 'updateInvalid'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (dirty & /*value*/ 1) {
    				set_input_value(textarea, /*value*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding*/ ctx[10](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textarea', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['change', 'input']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { value = '' } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = false } = $$props;
    	let { updateInvalid = true } = $$props;
    	let element;

    	onMount(() => {
    		if (updateInvalid) {
    			$$invalidate(8, invalid = element.matches(':invalid'));
    		}
    	});

    	function changeHandler() {
    		$$invalidate(7, dirty = true);

    		if (updateInvalid) {
    			$$invalidate(8, invalid = element.matches(':invalid'));
    		}
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(3, element);
    		});
    	}

    	function textarea_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('dirty' in $$new_props) $$invalidate(7, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(8, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(9, updateInvalid = $$new_props.updateInvalid);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		value,
    		dirty,
    		invalid,
    		updateInvalid,
    		element,
    		changeHandler
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('dirty' in $$props) $$invalidate(7, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(8, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(9, updateInvalid = $$new_props.updateInvalid);
    		if ('element' in $$props) $$invalidate(3, element = $$new_props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		use,
    		className,
    		element,
    		forwardEvents,
    		changeHandler,
    		$$props,
    		dirty,
    		invalid,
    		updateInvalid,
    		textarea_binding,
    		textarea_input_handler
    	];
    }

    class Textarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
    			use: 1,
    			class: 2,
    			value: 0,
    			dirty: 7,
    			invalid: 8,
    			updateInvalid: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textarea",
    			options,
    			id: create_fragment$1i.name
    		});
    	}

    	get use() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\textfield\Textfield.svelte generated by Svelte v3.42.1 */
    const file$18 = "node_modules\\@smui\\textfield\\Textfield.svelte";
    const get_label_slot_changes_1$1 = dirty => ({});
    const get_label_slot_context_1$1 = ctx => ({});
    const get_label_slot_changes$2 = dirty => ({});
    const get_label_slot_context$2 = ctx => ({});

    // (65:0) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[41], null);

    	let div_levels = [
    		{
    			class: div_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? 'mdc-text-field--disabled' : '') + "\n      " + (/*fullwidth*/ ctx[8] ? 'mdc-text-field--fullwidth' : '') + "\n      " + (/*textarea*/ ctx[9] ? 'mdc-text-field--textarea' : '') + "\n      " + (/*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]
    			? 'mdc-text-field--outlined'
    			: '') + "\n      " + (/*variant*/ ctx[10] === 'standard' && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
    			? 'smui-text-field--standard'
    			: '') + "\n      " + (/*dense*/ ctx[11] ? 'mdc-text-field--dense' : '') + "\n      " + (/*noLabel*/ ctx[14] ? 'mdc-text-field--no-label' : '') + "\n      " + (/*withLeadingIcon*/ ctx[12]
    			? 'mdc-text-field--with-leading-icon'
    			: '') + "\n      " + (/*withTrailingIcon*/ ctx[13]
    			? 'mdc-text-field--with-trailing-icon'
    			: '') + "\n      " + (/*invalid*/ ctx[2] ? 'mdc-text-field--invalid' : '') + "\n    "
    		},
    		/*props*/ ctx[20]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$18, 65, 2, 2082);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[40](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[4])),
    					action_destroyer(/*forwardEvents*/ ctx[21].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[41], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*className, disabled, fullwidth, textarea, variant, dense, noLabel, withLeadingIcon, withTrailingIcon, invalid*/ 32676 && div_class_value !== (div_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? 'mdc-text-field--disabled' : '') + "\n      " + (/*fullwidth*/ ctx[8] ? 'mdc-text-field--fullwidth' : '') + "\n      " + (/*textarea*/ ctx[9] ? 'mdc-text-field--textarea' : '') + "\n      " + (/*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]
    				? 'mdc-text-field--outlined'
    				: '') + "\n      " + (/*variant*/ ctx[10] === 'standard' && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
    				? 'smui-text-field--standard'
    				: '') + "\n      " + (/*dense*/ ctx[11] ? 'mdc-text-field--dense' : '') + "\n      " + (/*noLabel*/ ctx[14] ? 'mdc-text-field--no-label' : '') + "\n      " + (/*withLeadingIcon*/ ctx[12]
    				? 'mdc-text-field--with-leading-icon'
    				: '') + "\n      " + (/*withTrailingIcon*/ ctx[13]
    				? 'mdc-text-field--with-trailing-icon'
    				: '') + "\n      " + (/*invalid*/ ctx[2] ? 'mdc-text-field--invalid' : '') + "\n    ")) && { class: div_class_value },
    				dirty[0] & /*props*/ 1048576 && /*props*/ ctx[20]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 16) useActions_action.update.call(null, /*use*/ ctx[4]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[40](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(65:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if valued}
    function create_if_block$z(ctx) {
    	let label_1;
    	let t0;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let t2;
    	let label_1_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[41], null);
    	const if_block_creators = [create_if_block_6$1, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*textarea*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = !/*textarea*/ ctx[9] && /*variant*/ ctx[10] !== 'outlined' && create_if_block_3$3(ctx);
    	let if_block2 = (/*textarea*/ ctx[9] || /*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]) && create_if_block_1$e(ctx);

    	let label_1_levels = [
    		{
    			class: label_1_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? 'mdc-text-field--disabled' : '') + "\n      " + (/*fullwidth*/ ctx[8] ? 'mdc-text-field--fullwidth' : '') + "\n      " + (/*textarea*/ ctx[9] ? 'mdc-text-field--textarea' : '') + "\n      " + (/*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]
    			? 'mdc-text-field--outlined'
    			: '') + "\n      " + (/*variant*/ ctx[10] === 'standard' && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
    			? 'smui-text-field--standard'
    			: '') + "\n      " + (/*dense*/ ctx[11] ? 'mdc-text-field--dense' : '') + "\n      " + (/*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
    			? 'mdc-text-field--no-label'
    			: '') + "\n      " + (/*withLeadingIcon*/ ctx[12]
    			? 'mdc-text-field--with-leading-icon'
    			: '') + "\n      " + (/*withTrailingIcon*/ ctx[13]
    			? 'mdc-text-field--with-trailing-icon'
    			: '') + "\n      " + (/*invalid*/ ctx[2] ? 'mdc-text-field--invalid' : '') + "\n    "
    		},
    		/*props*/ ctx[20]
    	];

    	let label_1_data = {};

    	for (let i = 0; i < label_1_levels.length; i += 1) {
    		label_1_data = assign(label_1_data, label_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			set_attributes(label_1, label_1_data);
    			add_location(label_1, file$18, 1, 2, 15);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);

    			if (default_slot) {
    				default_slot.m(label_1, null);
    			}

    			append_dev(label_1, t0);
    			if_blocks[current_block_type_index].m(label_1, null);
    			append_dev(label_1, t1);
    			if (if_block1) if_block1.m(label_1, null);
    			append_dev(label_1, t2);
    			if (if_block2) if_block2.m(label_1, null);
    			/*label_1_binding*/ ctx[39](label_1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, label_1, /*use*/ ctx[4])),
    					action_destroyer(/*forwardEvents*/ ctx[21].call(null, label_1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[41], dirty, null),
    						null
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(label_1, t1);
    			}

    			if (!/*textarea*/ ctx[9] && /*variant*/ ctx[10] !== 'outlined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*textarea, variant*/ 1536) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label_1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*textarea*/ ctx[9] || /*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*textarea, variant, fullwidth*/ 1792) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$e(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(label_1, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
    				(!current || dirty[0] & /*className, disabled, fullwidth, textarea, variant, dense, noLabel, label, withLeadingIcon, withTrailingIcon, invalid*/ 65444 && label_1_class_value !== (label_1_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? 'mdc-text-field--disabled' : '') + "\n      " + (/*fullwidth*/ ctx[8] ? 'mdc-text-field--fullwidth' : '') + "\n      " + (/*textarea*/ ctx[9] ? 'mdc-text-field--textarea' : '') + "\n      " + (/*variant*/ ctx[10] === 'outlined' && !/*fullwidth*/ ctx[8]
    				? 'mdc-text-field--outlined'
    				: '') + "\n      " + (/*variant*/ ctx[10] === 'standard' && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
    				? 'smui-text-field--standard'
    				: '') + "\n      " + (/*dense*/ ctx[11] ? 'mdc-text-field--dense' : '') + "\n      " + (/*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
    				? 'mdc-text-field--no-label'
    				: '') + "\n      " + (/*withLeadingIcon*/ ctx[12]
    				? 'mdc-text-field--with-leading-icon'
    				: '') + "\n      " + (/*withTrailingIcon*/ ctx[13]
    				? 'mdc-text-field--with-trailing-icon'
    				: '') + "\n      " + (/*invalid*/ ctx[2] ? 'mdc-text-field--invalid' : '') + "\n    ")) && { class: label_1_class_value },
    				dirty[0] & /*props*/ 1048576 && /*props*/ ctx[20]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 16) useActions_action.update.call(null, /*use*/ ctx[4]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (default_slot) default_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*label_1_binding*/ ctx[39](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(1:0) {#if valued}",
    		ctx
    	});

    	return block;
    }

    // (34:4) {:else}
    function create_else_block$b(ctx) {
    	let input;
    	let updating_value;
    	let updating_files;
    	let updating_dirty;
    	let updating_invalid;
    	let current;

    	const input_spread_levels = [
    		{ type: /*type*/ ctx[16] },
    		{ disabled: /*disabled*/ ctx[7] },
    		{ updateInvalid: /*updateInvalid*/ ctx[17] },
    		/*fullwidth*/ ctx[8] && /*label*/ ctx[15]
    		? { placeholder: /*label*/ ctx[15] }
    		: {},
    		prefixFilter(/*$$props*/ ctx[22], 'input$')
    	];

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[33](value);
    	}

    	function input_files_binding(value) {
    		/*input_files_binding*/ ctx[34](value);
    	}

    	function input_dirty_binding(value) {
    		/*input_dirty_binding*/ ctx[35](value);
    	}

    	function input_invalid_binding(value) {
    		/*input_invalid_binding*/ ctx[36](value);
    	}

    	let input_props = {};

    	for (let i = 0; i < input_spread_levels.length; i += 1) {
    		input_props = assign(input_props, input_spread_levels[i]);
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		input_props.value = /*value*/ ctx[0];
    	}

    	if (/*files*/ ctx[1] !== void 0) {
    		input_props.files = /*files*/ ctx[1];
    	}

    	if (/*dirty*/ ctx[3] !== void 0) {
    		input_props.dirty = /*dirty*/ ctx[3];
    	}

    	if (/*invalid*/ ctx[2] !== void 0) {
    		input_props.invalid = /*invalid*/ ctx[2];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding));
    	binding_callbacks.push(() => bind(input, 'files', input_files_binding));
    	binding_callbacks.push(() => bind(input, 'dirty', input_dirty_binding));
    	binding_callbacks.push(() => bind(input, 'invalid', input_invalid_binding));
    	input.$on("change", /*change_handler_1*/ ctx[37]);
    	input.$on("input", /*input_handler_1*/ ctx[38]);

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = (dirty[0] & /*type, disabled, updateInvalid, fullwidth, label, $$props*/ 4424064)
    			? get_spread_update(input_spread_levels, [
    					dirty[0] & /*type*/ 65536 && { type: /*type*/ ctx[16] },
    					dirty[0] & /*disabled*/ 128 && { disabled: /*disabled*/ ctx[7] },
    					dirty[0] & /*updateInvalid*/ 131072 && { updateInvalid: /*updateInvalid*/ ctx[17] },
    					dirty[0] & /*fullwidth, label*/ 33024 && get_spread_object(/*fullwidth*/ ctx[8] && /*label*/ ctx[15]
    					? { placeholder: /*label*/ ctx[15] }
    					: {}),
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'input$'))
    				])
    			: {};

    			if (!updating_value && dirty[0] & /*value*/ 1) {
    				updating_value = true;
    				input_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_files && dirty[0] & /*files*/ 2) {
    				updating_files = true;
    				input_changes.files = /*files*/ ctx[1];
    				add_flush_callback(() => updating_files = false);
    			}

    			if (!updating_dirty && dirty[0] & /*dirty*/ 8) {
    				updating_dirty = true;
    				input_changes.dirty = /*dirty*/ ctx[3];
    				add_flush_callback(() => updating_dirty = false);
    			}

    			if (!updating_invalid && dirty[0] & /*invalid*/ 4) {
    				updating_invalid = true;
    				input_changes.invalid = /*invalid*/ ctx[2];
    				add_flush_callback(() => updating_invalid = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(34:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if textarea}
    function create_if_block_6$1(ctx) {
    	let textarea_1;
    	let updating_value;
    	let updating_dirty;
    	let updating_invalid;
    	let current;

    	const textarea_1_spread_levels = [
    		{ disabled: /*disabled*/ ctx[7] },
    		{ updateInvalid: /*updateInvalid*/ ctx[17] },
    		prefixFilter(/*$$props*/ ctx[22], 'input$')
    	];

    	function textarea_1_value_binding(value) {
    		/*textarea_1_value_binding*/ ctx[28](value);
    	}

    	function textarea_1_dirty_binding(value) {
    		/*textarea_1_dirty_binding*/ ctx[29](value);
    	}

    	function textarea_1_invalid_binding(value) {
    		/*textarea_1_invalid_binding*/ ctx[30](value);
    	}

    	let textarea_1_props = {};

    	for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
    		textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		textarea_1_props.value = /*value*/ ctx[0];
    	}

    	if (/*dirty*/ ctx[3] !== void 0) {
    		textarea_1_props.dirty = /*dirty*/ ctx[3];
    	}

    	if (/*invalid*/ ctx[2] !== void 0) {
    		textarea_1_props.invalid = /*invalid*/ ctx[2];
    	}

    	textarea_1 = new Textarea({ props: textarea_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textarea_1, 'value', textarea_1_value_binding));
    	binding_callbacks.push(() => bind(textarea_1, 'dirty', textarea_1_dirty_binding));
    	binding_callbacks.push(() => bind(textarea_1, 'invalid', textarea_1_invalid_binding));
    	textarea_1.$on("change", /*change_handler*/ ctx[31]);
    	textarea_1.$on("input", /*input_handler*/ ctx[32]);

    	const block = {
    		c: function create() {
    			create_component(textarea_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textarea_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textarea_1_changes = (dirty[0] & /*disabled, updateInvalid, $$props*/ 4325504)
    			? get_spread_update(textarea_1_spread_levels, [
    					dirty[0] & /*disabled*/ 128 && { disabled: /*disabled*/ ctx[7] },
    					dirty[0] & /*updateInvalid*/ 131072 && { updateInvalid: /*updateInvalid*/ ctx[17] },
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'input$'))
    				])
    			: {};

    			if (!updating_value && dirty[0] & /*value*/ 1) {
    				updating_value = true;
    				textarea_1_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_dirty && dirty[0] & /*dirty*/ 8) {
    				updating_dirty = true;
    				textarea_1_changes.dirty = /*dirty*/ ctx[3];
    				add_flush_callback(() => updating_dirty = false);
    			}

    			if (!updating_invalid && dirty[0] & /*invalid*/ 4) {
    				updating_invalid = true;
    				textarea_1_changes.invalid = /*invalid*/ ctx[2];
    				add_flush_callback(() => updating_invalid = false);
    			}

    			textarea_1.$set(textarea_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textarea_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textarea_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textarea_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(23:4) {#if textarea}",
    		ctx
    	});

    	return block;
    }

    // (49:4) {#if !textarea && variant !== 'outlined'}
    function create_if_block_3$3(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = !/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && !/*fullwidth*/ ctx[8] && create_if_block_5$2(ctx);
    	let if_block1 = /*ripple*/ ctx[6] && create_if_block_4$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && !/*fullwidth*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label, fullwidth*/ 49408) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*ripple*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*ripple*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(49:4) {#if !textarea && variant !== 'outlined'}",
    		ctx
    	});

    	return block;
    }

    // (50:6) {#if !noLabel && label != null && !fullwidth}
    function create_if_block_5$2(ctx) {
    	let floatinglabel;
    	let current;
    	const floatinglabel_spread_levels = [{ wrapped: true }, prefixFilter(/*$$props*/ ctx[22], 'label$')];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_2$a] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*$$props*/ 4194304)
    			? get_spread_update(floatinglabel_spread_levels, [
    					floatinglabel_spread_levels[0],
    					get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'label$'))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 32768 | dirty[1] & /*$$scope*/ 1024) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(50:6) {#if !noLabel && label != null && !fullwidth}",
    		ctx
    	});

    	return block;
    }

    // (51:8) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>
    function create_default_slot_2$a(ctx) {
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[27].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[41], get_label_slot_context$2);

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[15]);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*label*/ 32768) set_data_dev(t, /*label*/ ctx[15]);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[41], dirty, get_label_slot_changes$2),
    						get_label_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(51:8) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>",
    		ctx
    	});

    	return block;
    }

    // (53:6) {#if ripple}
    function create_if_block_4$2(ctx) {
    	let lineripple;
    	let current;
    	const lineripple_spread_levels = [prefixFilter(/*$$props*/ ctx[22], 'ripple$')];
    	let lineripple_props = {};

    	for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    		lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
    	}

    	lineripple = new LineRipple({ props: lineripple_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(lineripple.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lineripple, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lineripple_changes = (dirty[0] & /*$$props*/ 4194304)
    			? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'ripple$'))])
    			: {};

    			lineripple.$set(lineripple_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lineripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lineripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lineripple, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(53:6) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    // (57:4) {#if textarea || (variant === 'outlined' && !fullwidth)}
    function create_if_block_1$e(ctx) {
    	let notchedoutline;
    	let current;

    	const notchedoutline_spread_levels = [
    		{
    			noLabel: /*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
    		},
    		prefixFilter(/*$$props*/ ctx[22], 'outline$')
    	];

    	let notchedoutline_props = {
    		$$slots: { default: [create_default_slot$r] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    		notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
    	}

    	notchedoutline = new NotchedOutline({
    			props: notchedoutline_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(notchedoutline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notchedoutline, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notchedoutline_changes = (dirty[0] & /*noLabel, label, $$props*/ 4243456)
    			? get_spread_update(notchedoutline_spread_levels, [
    					dirty[0] & /*noLabel, label*/ 49152 && {
    						noLabel: /*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
    					},
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'outline$'))
    				])
    			: {};

    			if (dirty[0] & /*$$props, label, noLabel*/ 4243456 | dirty[1] & /*$$scope*/ 1024) {
    				notchedoutline_changes.$$scope = { dirty, ctx };
    			}

    			notchedoutline.$set(notchedoutline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notchedoutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notchedoutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notchedoutline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(57:4) {#if textarea || (variant === 'outlined' && !fullwidth)}",
    		ctx
    	});

    	return block;
    }

    // (59:8) {#if !noLabel && label != null}
    function create_if_block_2$6(ctx) {
    	let floatinglabel;
    	let current;
    	const floatinglabel_spread_levels = [{ wrapped: true }, prefixFilter(/*$$props*/ ctx[22], 'label$')];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_1$e] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*$$props*/ 4194304)
    			? get_spread_update(floatinglabel_spread_levels, [
    					floatinglabel_spread_levels[0],
    					get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'label$'))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 32768 | dirty[1] & /*$$scope*/ 1024) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(59:8) {#if !noLabel && label != null}",
    		ctx
    	});

    	return block;
    }

    // (60:10) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>
    function create_default_slot_1$e(ctx) {
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[27].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[41], get_label_slot_context_1$1);

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[15]);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*label*/ 32768) set_data_dev(t, /*label*/ ctx[15]);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[1] & /*$$scope*/ 1024)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[41],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[41])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[41], dirty, get_label_slot_changes_1$1),
    						get_label_slot_context_1$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(60:10) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>",
    		ctx
    	});

    	return block;
    }

    // (58:6) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>
    function create_default_slot$r(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && create_if_block_2$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label*/ 49152) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(58:6) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$z, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*valued*/ ctx[19]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let props;
    	let valued;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textfield', slots, ['default','label']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { disabled = false } = $$props;
    	let { fullwidth = false } = $$props;
    	let { textarea = false } = $$props;
    	let { variant = 'standard' } = $$props;
    	let { dense = false } = $$props;
    	let { withLeadingIcon = false } = $$props;
    	let { withTrailingIcon = false } = $$props;
    	let { noLabel = false } = $$props;
    	let { label = null } = $$props;
    	let { type = 'text' } = $$props;
    	let { value = uninitializedValue } = $$props;
    	let { files = uninitializedValue } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = uninitializedValue } = $$props;
    	let { updateInvalid = invalid === uninitializedValue } = $$props;
    	let { useNativeValidation = updateInvalid } = $$props;
    	let element;
    	let textField;
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(() => {
    		$$invalidate(26, textField = new MDCTextField(element));

    		if (!ripple) {
    			textField.ripple && textField.ripple.destroy();
    		}
    	});

    	onDestroy(() => {
    		textField && textField.destroy();

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function focus(...args) {
    		return textField.focus(...args);
    	}

    	function layout(...args) {
    		return textField.layout(...args);
    	}

    	function textarea_1_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function textarea_1_dirty_binding(value) {
    		dirty = value;
    		$$invalidate(3, dirty);
    	}

    	function textarea_1_invalid_binding(value$1) {
    		invalid = value$1;
    		(((((($$invalidate(2, invalid), $$invalidate(26, textField)), $$invalidate(17, updateInvalid)), $$invalidate(0, value)), $$invalidate(43, uninitializedValue)), $$invalidate(7, disabled)), $$invalidate(23, useNativeValidation));
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function input_files_binding(value) {
    		files = value;
    		$$invalidate(1, files);
    	}

    	function input_dirty_binding(value) {
    		dirty = value;
    		$$invalidate(3, dirty);
    	}

    	function input_invalid_binding(value$1) {
    		invalid = value$1;
    		(((((($$invalidate(2, invalid), $$invalidate(26, textField)), $$invalidate(17, updateInvalid)), $$invalidate(0, value)), $$invalidate(43, uninitializedValue)), $$invalidate(7, disabled)), $$invalidate(23, useNativeValidation));
    	}

    	function change_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function label_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(18, element);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(18, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(4, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('ripple' in $$new_props) $$invalidate(6, ripple = $$new_props.ripple);
    		if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ('fullwidth' in $$new_props) $$invalidate(8, fullwidth = $$new_props.fullwidth);
    		if ('textarea' in $$new_props) $$invalidate(9, textarea = $$new_props.textarea);
    		if ('variant' in $$new_props) $$invalidate(10, variant = $$new_props.variant);
    		if ('dense' in $$new_props) $$invalidate(11, dense = $$new_props.dense);
    		if ('withLeadingIcon' in $$new_props) $$invalidate(12, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('withTrailingIcon' in $$new_props) $$invalidate(13, withTrailingIcon = $$new_props.withTrailingIcon);
    		if ('noLabel' in $$new_props) $$invalidate(14, noLabel = $$new_props.noLabel);
    		if ('label' in $$new_props) $$invalidate(15, label = $$new_props.label);
    		if ('type' in $$new_props) $$invalidate(16, type = $$new_props.type);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('files' in $$new_props) $$invalidate(1, files = $$new_props.files);
    		if ('dirty' in $$new_props) $$invalidate(3, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(2, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(17, updateInvalid = $$new_props.updateInvalid);
    		if ('useNativeValidation' in $$new_props) $$invalidate(23, useNativeValidation = $$new_props.useNativeValidation);
    		if ('$$scope' in $$new_props) $$invalidate(41, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTextField,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		FloatingLabel,
    		LineRipple,
    		NotchedOutline,
    		Input,
    		Textarea,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		ripple,
    		disabled,
    		fullwidth,
    		textarea,
    		variant,
    		dense,
    		withLeadingIcon,
    		withTrailingIcon,
    		noLabel,
    		label,
    		type,
    		value,
    		files,
    		dirty,
    		invalid,
    		updateInvalid,
    		useNativeValidation,
    		element,
    		textField,
    		addLayoutListener,
    		removeLayoutListener,
    		focus,
    		layout,
    		valued,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    		if ('uninitializedValue' in $$props) $$invalidate(43, uninitializedValue = $$new_props.uninitializedValue);
    		if ('use' in $$props) $$invalidate(4, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('ripple' in $$props) $$invalidate(6, ripple = $$new_props.ripple);
    		if ('disabled' in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ('fullwidth' in $$props) $$invalidate(8, fullwidth = $$new_props.fullwidth);
    		if ('textarea' in $$props) $$invalidate(9, textarea = $$new_props.textarea);
    		if ('variant' in $$props) $$invalidate(10, variant = $$new_props.variant);
    		if ('dense' in $$props) $$invalidate(11, dense = $$new_props.dense);
    		if ('withLeadingIcon' in $$props) $$invalidate(12, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('withTrailingIcon' in $$props) $$invalidate(13, withTrailingIcon = $$new_props.withTrailingIcon);
    		if ('noLabel' in $$props) $$invalidate(14, noLabel = $$new_props.noLabel);
    		if ('label' in $$props) $$invalidate(15, label = $$new_props.label);
    		if ('type' in $$props) $$invalidate(16, type = $$new_props.type);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('files' in $$props) $$invalidate(1, files = $$new_props.files);
    		if ('dirty' in $$props) $$invalidate(3, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(2, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(17, updateInvalid = $$new_props.updateInvalid);
    		if ('useNativeValidation' in $$props) $$invalidate(23, useNativeValidation = $$new_props.useNativeValidation);
    		if ('element' in $$props) $$invalidate(18, element = $$new_props.element);
    		if ('textField' in $$props) $$invalidate(26, textField = $$new_props.textField);
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ('valued' in $$props) $$invalidate(19, valued = $$new_props.valued);
    		if ('props' in $$props) $$invalidate(20, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(20, props = exclude($$props, [
    			'use',
    			'class',
    			'ripple',
    			'disabled',
    			'fullwidth',
    			'textarea',
    			'variant',
    			'dense',
    			'withLeadingIcon',
    			'withTrailingIcon',
    			'noLabel',
    			'label',
    			'type',
    			'value',
    			'dirty',
    			'invalid',
    			'updateInvalid',
    			'useNativeValidation',
    			'input$',
    			'label$',
    			'ripple$',
    			'outline$'
    		]));

    		if ($$self.$$.dirty[0] & /*value, files*/ 3) {
    			$$invalidate(19, valued = value !== uninitializedValue || files !== uninitializedValue);
    		}

    		if ($$self.$$.dirty[0] & /*textField, value*/ 67108865) {
    			if (textField && value !== uninitializedValue && textField.value !== value) {
    				$$invalidate(26, textField.value = value, textField);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*textField, disabled*/ 67108992) {
    			if (textField && textField.disabled !== disabled) {
    				$$invalidate(26, textField.disabled = disabled, textField);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*textField, invalid, updateInvalid*/ 67239940) {
    			if (textField && textField.valid !== !invalid) {
    				if (updateInvalid) {
    					$$invalidate(2, invalid = !textField.valid);
    				} else {
    					$$invalidate(26, textField.valid = !invalid, textField);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*textField, useNativeValidation*/ 75497472) {
    			if (textField && textField.useNativeValidation !== useNativeValidation) {
    				$$invalidate(26, textField.useNativeValidation = useNativeValidation, textField);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		files,
    		invalid,
    		dirty,
    		use,
    		className,
    		ripple,
    		disabled,
    		fullwidth,
    		textarea,
    		variant,
    		dense,
    		withLeadingIcon,
    		withTrailingIcon,
    		noLabel,
    		label,
    		type,
    		updateInvalid,
    		element,
    		valued,
    		props,
    		forwardEvents,
    		$$props,
    		useNativeValidation,
    		focus,
    		layout,
    		textField,
    		slots,
    		textarea_1_value_binding,
    		textarea_1_dirty_binding,
    		textarea_1_invalid_binding,
    		change_handler,
    		input_handler,
    		input_value_binding,
    		input_files_binding,
    		input_dirty_binding,
    		input_invalid_binding,
    		change_handler_1,
    		input_handler_1,
    		label_1_binding,
    		div_binding,
    		$$scope
    	];
    }

    class Textfield extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$1h,
    			create_fragment$1h,
    			safe_not_equal,
    			{
    				use: 4,
    				class: 5,
    				ripple: 6,
    				disabled: 7,
    				fullwidth: 8,
    				textarea: 9,
    				variant: 10,
    				dense: 11,
    				withLeadingIcon: 12,
    				withTrailingIcon: 13,
    				noLabel: 14,
    				label: 15,
    				type: 16,
    				value: 0,
    				files: 1,
    				dirty: 3,
    				invalid: 2,
    				updateInvalid: 17,
    				useNativeValidation: 23,
    				focus: 24,
    				layout: 25
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textfield",
    			options,
    			id: create_fragment$1h.name
    		});
    	}

    	get use() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullwidth() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullwidth(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textarea() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textarea(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withLeadingIcon() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withLeadingIcon(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withTrailingIcon() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withTrailingIcon(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useNativeValidation() {
    		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useNativeValidation(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[24];
    	}

    	set focus(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[25];
    	}

    	set layout(value) {
    		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\textfield\helper-text\HelperText.svelte generated by Svelte v3.42.1 */
    const file$17 = "node_modules\\@smui\\textfield\\helper-text\\HelperText.svelte";
    const get_character_counter_slot_changes = dirty => ({});
    const get_character_counter_slot_context = ctx => ({});

    function create_fragment$1g(ctx) {
    	let div1;
    	let div0;
    	let div0_class_value;
    	let useActions_action;
    	let t;
    	let div1_class_value;
    	let useActions_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	let div0_levels = [
    		{
    			class: div0_class_value = "\n      mdc-text-field-helper-text\n      " + /*className*/ ctx[1] + "\n      " + (/*persistent*/ ctx[2]
    			? 'mdc-text-field-helper-text--persistent'
    			: '') + "\n      " + (/*validationMsg*/ ctx[3]
    			? 'mdc-text-field-helper-text--validation-msg'
    			: '') + "\n    "
    		},
    		{ "aria-hidden": "true" },
    		exclude(/*$$props*/ ctx[8], ['use', 'class', 'persistent', 'validationMsg'])
    	];

    	let div0_data = {};

    	for (let i = 0; i < div0_levels.length; i += 1) {
    		div0_data = assign(div0_data, div0_levels[i]);
    	}

    	const character_counter_slot_template = /*#slots*/ ctx[10]["character-counter"];
    	const character_counter_slot = create_slot(character_counter_slot_template, ctx, /*$$scope*/ ctx[9], get_character_counter_slot_context);

    	let div1_levels = [
    		{
    			class: div1_class_value = "mdc-text-field-helper-line " + /*line$class*/ ctx[5]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[8], 'line$'), ['use', 'class'])
    	];

    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			if (character_counter_slot) character_counter_slot.c();
    			set_attributes(div0, div0_data);
    			add_location(div0, file$17, 5, 2, 152);
    			set_attributes(div1, div1_data);
    			add_location(div1, file$17, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[11](div0);
    			append_dev(div1, t);

    			if (character_counter_slot) {
    				character_counter_slot.m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div0, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, div0)),
    					action_destroyer(useActions_action_1 = useActions.call(null, div1, /*line$use*/ ctx[4]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div0, div0_data = get_spread_update(div0_levels, [
    				(!current || dirty & /*className, persistent, validationMsg*/ 14 && div0_class_value !== (div0_class_value = "\n      mdc-text-field-helper-text\n      " + /*className*/ ctx[1] + "\n      " + (/*persistent*/ ctx[2]
    				? 'mdc-text-field-helper-text--persistent'
    				: '') + "\n      " + (/*validationMsg*/ ctx[3]
    				? 'mdc-text-field-helper-text--validation-msg'
    				: '') + "\n    ")) && { class: div0_class_value },
    				{ "aria-hidden": "true" },
    				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ['use', 'class', 'persistent', 'validationMsg'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);

    			if (character_counter_slot) {
    				if (character_counter_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						character_counter_slot,
    						character_counter_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(character_counter_slot_template, /*$$scope*/ ctx[9], dirty, get_character_counter_slot_changes),
    						get_character_counter_slot_context
    					);
    				}
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty & /*line$class*/ 32 && div1_class_value !== (div1_class_value = "mdc-text-field-helper-line " + /*line$class*/ ctx[5])) && { class: div1_class_value },
    				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], 'line$'), ['use', 'class'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*line$use*/ 16) useActions_action_1.update.call(null, /*line$use*/ ctx[4]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(character_counter_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(character_counter_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			/*div0_binding*/ ctx[11](null);
    			if (character_counter_slot) character_counter_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HelperText', slots, ['default','character-counter']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { persistent = false } = $$props;
    	let { validationMsg = false } = $$props;
    	let { line$use = [] } = $$props;
    	let { line$class = '' } = $$props;
    	let element;
    	let helperText;

    	onMount(() => {
    		helperText = new MDCTextFieldHelperText(element);
    	});

    	onDestroy(() => {
    		helperText && helperText.destroy();
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(6, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('persistent' in $$new_props) $$invalidate(2, persistent = $$new_props.persistent);
    		if ('validationMsg' in $$new_props) $$invalidate(3, validationMsg = $$new_props.validationMsg);
    		if ('line$use' in $$new_props) $$invalidate(4, line$use = $$new_props.line$use);
    		if ('line$class' in $$new_props) $$invalidate(5, line$class = $$new_props.line$class);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTextFieldHelperText,
    		onMount,
    		onDestroy,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		persistent,
    		validationMsg,
    		line$use,
    		line$class,
    		element,
    		helperText
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('persistent' in $$props) $$invalidate(2, persistent = $$new_props.persistent);
    		if ('validationMsg' in $$props) $$invalidate(3, validationMsg = $$new_props.validationMsg);
    		if ('line$use' in $$props) $$invalidate(4, line$use = $$new_props.line$use);
    		if ('line$class' in $$props) $$invalidate(5, line$class = $$new_props.line$class);
    		if ('element' in $$props) $$invalidate(6, element = $$new_props.element);
    		if ('helperText' in $$props) helperText = $$new_props.helperText;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		persistent,
    		validationMsg,
    		line$use,
    		line$class,
    		element,
    		forwardEvents,
    		$$props,
    		$$scope,
    		slots,
    		div0_binding
    	];
    }

    class HelperText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1g, create_fragment$1g, safe_not_equal, {
    			use: 0,
    			class: 1,
    			persistent: 2,
    			validationMsg: 3,
    			line$use: 4,
    			line$class: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HelperText",
    			options,
    			id: create_fragment$1g.name
    		});
    	}

    	get use() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get persistent() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set persistent(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validationMsg() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validationMsg(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line$use() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line$use(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line$class() {
    		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line$class(value) {
    		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var jsEventTypeMap = {
        animationend: {
            cssProperty: 'animation',
            prefixed: 'webkitAnimationEnd',
            standard: 'animationend',
        },
        animationiteration: {
            cssProperty: 'animation',
            prefixed: 'webkitAnimationIteration',
            standard: 'animationiteration',
        },
        animationstart: {
            cssProperty: 'animation',
            prefixed: 'webkitAnimationStart',
            standard: 'animationstart',
        },
        transitionend: {
            cssProperty: 'transition',
            prefixed: 'webkitTransitionEnd',
            standard: 'transitionend',
        },
    };
    function isWindow(windowObj) {
        return Boolean(windowObj.document) && typeof windowObj.document.createElement === 'function';
    }
    function getCorrectEventName(windowObj, eventType) {
        if (isWindow(windowObj) && eventType in jsEventTypeMap) {
            var el = windowObj.document.createElement('div');
            var _a = jsEventTypeMap[eventType], standard = _a.standard, prefixed = _a.prefixed, cssProperty = _a.cssProperty;
            var isStandard = cssProperty in el.style;
            return isStandard ? standard : prefixed;
        }
        return eventType;
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$b = {
        ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
        ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
        ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
        ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked',
        ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
        ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
        BACKGROUND: 'mdc-checkbox__background',
        CHECKED: 'mdc-checkbox--checked',
        CHECKMARK: 'mdc-checkbox__checkmark',
        CHECKMARK_PATH: 'mdc-checkbox__checkmark-path',
        DISABLED: 'mdc-checkbox--disabled',
        INDETERMINATE: 'mdc-checkbox--indeterminate',
        MIXEDMARK: 'mdc-checkbox__mixedmark',
        NATIVE_CONTROL: 'mdc-checkbox__native-control',
        ROOT: 'mdc-checkbox',
        SELECTED: 'mdc-checkbox--selected',
        UPGRADED: 'mdc-checkbox--upgraded',
    };
    var strings$e = {
        ARIA_CHECKED_ATTR: 'aria-checked',
        ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed',
        NATIVE_CONTROL_SELECTOR: '.mdc-checkbox__native-control',
        TRANSITION_STATE_CHECKED: 'checked',
        TRANSITION_STATE_INDETERMINATE: 'indeterminate',
        TRANSITION_STATE_INIT: 'init',
        TRANSITION_STATE_UNCHECKED: 'unchecked',
    };
    var numbers$5 = {
        ANIM_END_LATCH_MS: 250,
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCCheckboxFoundation = /** @class */ (function (_super) {
        __extends(MDCCheckboxFoundation, _super);
        function MDCCheckboxFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCCheckboxFoundation.defaultAdapter, adapter)) || this;
            _this.currentCheckState_ = strings$e.TRANSITION_STATE_INIT;
            _this.currentAnimationClass_ = '';
            _this.animEndLatchTimer_ = 0;
            _this.enableAnimationEndHandler_ = false;
            return _this;
        }
        Object.defineProperty(MDCCheckboxFoundation, "cssClasses", {
            get: function () {
                return cssClasses$b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckboxFoundation, "strings", {
            get: function () {
                return strings$e;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckboxFoundation, "numbers", {
            get: function () {
                return numbers$5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckboxFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    forceLayout: function () { return undefined; },
                    hasNativeControl: function () { return false; },
                    isAttachedToDOM: function () { return false; },
                    isChecked: function () { return false; },
                    isIndeterminate: function () { return false; },
                    removeClass: function () { return undefined; },
                    removeNativeControlAttr: function () { return undefined; },
                    setNativeControlAttr: function () { return undefined; },
                    setNativeControlDisabled: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCCheckboxFoundation.prototype.init = function () {
            this.currentCheckState_ = this.determineCheckState_();
            this.updateAriaChecked_();
            this.adapter_.addClass(cssClasses$b.UPGRADED);
        };
        MDCCheckboxFoundation.prototype.destroy = function () {
            clearTimeout(this.animEndLatchTimer_);
        };
        MDCCheckboxFoundation.prototype.setDisabled = function (disabled) {
            this.adapter_.setNativeControlDisabled(disabled);
            if (disabled) {
                this.adapter_.addClass(cssClasses$b.DISABLED);
            }
            else {
                this.adapter_.removeClass(cssClasses$b.DISABLED);
            }
        };
        /**
         * Handles the animationend event for the checkbox
         */
        MDCCheckboxFoundation.prototype.handleAnimationEnd = function () {
            var _this = this;
            if (!this.enableAnimationEndHandler_) {
                return;
            }
            clearTimeout(this.animEndLatchTimer_);
            this.animEndLatchTimer_ = setTimeout(function () {
                _this.adapter_.removeClass(_this.currentAnimationClass_);
                _this.enableAnimationEndHandler_ = false;
            }, numbers$5.ANIM_END_LATCH_MS);
        };
        /**
         * Handles the change event for the checkbox
         */
        MDCCheckboxFoundation.prototype.handleChange = function () {
            this.transitionCheckState_();
        };
        MDCCheckboxFoundation.prototype.transitionCheckState_ = function () {
            if (!this.adapter_.hasNativeControl()) {
                return;
            }
            var oldState = this.currentCheckState_;
            var newState = this.determineCheckState_();
            if (oldState === newState) {
                return;
            }
            this.updateAriaChecked_();
            var TRANSITION_STATE_UNCHECKED = strings$e.TRANSITION_STATE_UNCHECKED;
            var SELECTED = cssClasses$b.SELECTED;
            if (newState === TRANSITION_STATE_UNCHECKED) {
                this.adapter_.removeClass(SELECTED);
            }
            else {
                this.adapter_.addClass(SELECTED);
            }
            // Check to ensure that there isn't a previously existing animation class, in case for example
            // the user interacted with the checkbox before the animation was finished.
            if (this.currentAnimationClass_.length > 0) {
                clearTimeout(this.animEndLatchTimer_);
                this.adapter_.forceLayout();
                this.adapter_.removeClass(this.currentAnimationClass_);
            }
            this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
            this.currentCheckState_ = newState;
            // Check for parentNode so that animations are only run when the element is attached
            // to the DOM.
            if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
                this.adapter_.addClass(this.currentAnimationClass_);
                this.enableAnimationEndHandler_ = true;
            }
        };
        MDCCheckboxFoundation.prototype.determineCheckState_ = function () {
            var TRANSITION_STATE_INDETERMINATE = strings$e.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings$e.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings$e.TRANSITION_STATE_UNCHECKED;
            if (this.adapter_.isIndeterminate()) {
                return TRANSITION_STATE_INDETERMINATE;
            }
            return this.adapter_.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
        };
        MDCCheckboxFoundation.prototype.getTransitionAnimationClass_ = function (oldState, newState) {
            var TRANSITION_STATE_INIT = strings$e.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings$e.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings$e.TRANSITION_STATE_UNCHECKED;
            var _a = MDCCheckboxFoundation.cssClasses, ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
            switch (oldState) {
                case TRANSITION_STATE_INIT:
                    if (newState === TRANSITION_STATE_UNCHECKED) {
                        return '';
                    }
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
                case TRANSITION_STATE_UNCHECKED:
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
                case TRANSITION_STATE_CHECKED:
                    return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
                default: // TRANSITION_STATE_INDETERMINATE
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
            }
        };
        MDCCheckboxFoundation.prototype.updateAriaChecked_ = function () {
            // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
            if (this.adapter_.isIndeterminate()) {
                this.adapter_.setNativeControlAttr(strings$e.ARIA_CHECKED_ATTR, strings$e.ARIA_CHECKED_INDETERMINATE_VALUE);
            }
            else {
                // The on/off state does not need to keep track of aria-checked, since
                // the screenreader uses the checked property on the checkbox element.
                this.adapter_.removeNativeControlAttr(strings$e.ARIA_CHECKED_ATTR);
            }
        };
        return MDCCheckboxFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var CB_PROTO_PROPS = ['checked', 'indeterminate'];
    var MDCCheckbox = /** @class */ (function (_super) {
        __extends(MDCCheckbox, _super);
        function MDCCheckbox() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ripple_ = _this.createRipple_();
            return _this;
        }
        MDCCheckbox.attachTo = function (root) {
            return new MDCCheckbox(root);
        };
        Object.defineProperty(MDCCheckbox.prototype, "ripple", {
            get: function () {
                return this.ripple_;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckbox.prototype, "checked", {
            get: function () {
                return this.nativeControl_.checked;
            },
            set: function (checked) {
                this.nativeControl_.checked = checked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckbox.prototype, "indeterminate", {
            get: function () {
                return this.nativeControl_.indeterminate;
            },
            set: function (indeterminate) {
                this.nativeControl_.indeterminate = indeterminate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckbox.prototype, "disabled", {
            get: function () {
                return this.nativeControl_.disabled;
            },
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCCheckbox.prototype, "value", {
            get: function () {
                return this.nativeControl_.value;
            },
            set: function (value) {
                this.nativeControl_.value = value;
            },
            enumerable: true,
            configurable: true
        });
        MDCCheckbox.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleChange_ = function () { return _this.foundation_.handleChange(); };
            this.handleAnimationEnd_ = function () { return _this.foundation_.handleAnimationEnd(); };
            this.nativeControl_.addEventListener('change', this.handleChange_);
            this.listen(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
            this.installPropertyChangeHooks_();
        };
        MDCCheckbox.prototype.destroy = function () {
            this.ripple_.destroy();
            this.nativeControl_.removeEventListener('change', this.handleChange_);
            this.unlisten(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
            this.uninstallPropertyChangeHooks_();
            _super.prototype.destroy.call(this);
        };
        MDCCheckbox.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                forceLayout: function () { return _this.root_.offsetWidth; },
                hasNativeControl: function () { return !!_this.nativeControl_; },
                isAttachedToDOM: function () { return Boolean(_this.root_.parentNode); },
                isChecked: function () { return _this.checked; },
                isIndeterminate: function () { return _this.indeterminate; },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                removeNativeControlAttr: function (attr) { return _this.nativeControl_.removeAttribute(attr); },
                setNativeControlAttr: function (attr, value) { return _this.nativeControl_.setAttribute(attr, value); },
                setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
            };
            return new MDCCheckboxFoundation(adapter);
        };
        MDCCheckbox.prototype.createRipple_ = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { deregisterInteractionHandler: function (evtType, handler) { return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive()); }, isSurfaceActive: function () { return matches$1(_this.nativeControl_, ':active'); }, isUnbounded: function () { return true; }, registerInteractionHandler: function (evtType, handler) { return _this.nativeControl_.addEventListener(evtType, handler, applyPassive()); } });
            return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
        };
        MDCCheckbox.prototype.installPropertyChangeHooks_ = function () {
            var _this = this;
            var nativeCb = this.nativeControl_;
            var cbProto = Object.getPrototypeOf(nativeCb);
            CB_PROTO_PROPS.forEach(function (controlState) {
                var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
                // We have to check for this descriptor, since some browsers (Safari) don't support its return.
                // See: https://bugs.webkit.org/show_bug.cgi?id=49739
                if (!validDescriptor(desc)) {
                    return;
                }
                // Type cast is needed for compatibility with Closure Compiler.
                var nativeGetter = desc.get;
                var nativeCbDesc = {
                    configurable: desc.configurable,
                    enumerable: desc.enumerable,
                    get: nativeGetter,
                    set: function (state) {
                        desc.set.call(nativeCb, state);
                        _this.foundation_.handleChange();
                    },
                };
                Object.defineProperty(nativeCb, controlState, nativeCbDesc);
            });
        };
        MDCCheckbox.prototype.uninstallPropertyChangeHooks_ = function () {
            var nativeCb = this.nativeControl_;
            var cbProto = Object.getPrototypeOf(nativeCb);
            CB_PROTO_PROPS.forEach(function (controlState) {
                var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
                if (!validDescriptor(desc)) {
                    return;
                }
                Object.defineProperty(nativeCb, controlState, desc);
            });
        };
        Object.defineProperty(MDCCheckbox.prototype, "nativeControl_", {
            get: function () {
                var NATIVE_CONTROL_SELECTOR = MDCCheckboxFoundation.strings.NATIVE_CONTROL_SELECTOR;
                var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
                if (!el) {
                    throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
                }
                return el;
            },
            enumerable: true,
            configurable: true
        });
        return MDCCheckbox;
    }(MDCComponent));
    function validDescriptor(inputPropDesc) {
        return !!inputPropDesc && typeof inputPropDesc.set === 'function';
    }

    /* node_modules\@smui\checkbox\Checkbox.svelte generated by Svelte v3.42.1 */
    const file$16 = "node_modules\\@smui\\checkbox\\Checkbox.svelte";

    function create_fragment$1f(ctx) {
    	let div2;
    	let input;
    	let input_class_value;
    	let input_value_value;
    	let useActions_action;
    	let t0;
    	let div1;
    	let svg;
    	let path;
    	let t1;
    	let div0;
    	let div2_class_value;
    	let useActions_action_1;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{
    			class: input_class_value = "mdc-checkbox__native-control " + /*input$class*/ ctx[6]
    		},
    		{ type: "checkbox" },
    		/*inputProps*/ ctx[11],
    		{ disabled: /*disabled*/ ctx[2] },
    		{
    			__value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    			? /*value*/ ctx[3]
    			: /*valueKey*/ ctx[4]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[15], 'input$'), ['use', 'class'])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	let div2_levels = [
    		{
    			class: div2_class_value = "\n    mdc-checkbox\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-checkbox--disabled' : '') + "\n    " + (/*context*/ ctx[12] === 'data-table' && /*dataTableHeader*/ ctx[13]
    			? 'mdc-data-table__header-row-checkbox'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'data-table' && !/*dataTableHeader*/ ctx[13]
    			? 'mdc-data-table__row-checkbox'
    			: '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[15], [
    			'use',
    			'class',
    			'disabled',
    			'indeterminate',
    			'group',
    			'checked',
    			'value',
    			'valueKey',
    			'input$'
    		])
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			input = element("input");
    			t0 = space();
    			div1 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t1 = space();
    			div0 = element("div");
    			set_attributes(input, input_data);
    			add_location(input, file$16, 13, 2, 478);
    			attr_dev(path, "class", "mdc-checkbox__checkmark-path");
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
    			add_location(path, file$16, 28, 6, 984);
    			attr_dev(svg, "class", "mdc-checkbox__checkmark");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$16, 27, 4, 920);
    			attr_dev(div0, "class", "mdc-checkbox__mixedmark");
    			add_location(div0, file$16, 30, 4, 1094);
    			attr_dev(div1, "class", "mdc-checkbox__background");
    			add_location(div1, file$16, 26, 2, 877);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$16, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, input);
    			if (input.autofocus) input.focus();
    			input.checked = /*nativeChecked*/ ctx[7];
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			/*div2_binding*/ ctx[25](div2);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[24]),
    					listen_dev(input, "change", /*handleChange*/ ctx[14], false, false, false),
    					listen_dev(input, "input", /*handleChange*/ ctx[14], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[22], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[23], false, false, false),
    					action_destroyer(useActions_action_1 = useActions.call(null, div2, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[9].call(null, div2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-checkbox__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
    				{ type: "checkbox" },
    				/*inputProps*/ ctx[11],
    				dirty[0] & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
    				dirty[0] & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    				? /*value*/ ctx[3]
    				: /*valueKey*/ ctx[4]) && { __value: input_value_value },
    				dirty[0] & /*$$props*/ 32768 && exclude(prefixFilter(/*$$props*/ ctx[15], 'input$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

    			if (dirty[0] & /*nativeChecked*/ 128) {
    				input.checked = /*nativeChecked*/ ctx[7];
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				dirty[0] & /*className, disabled*/ 6 && div2_class_value !== (div2_class_value = "\n    mdc-checkbox\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-checkbox--disabled' : '') + "\n    " + (/*context*/ ctx[12] === 'data-table' && /*dataTableHeader*/ ctx[13]
    				? 'mdc-data-table__header-row-checkbox'
    				: '') + "\n    " + (/*context*/ ctx[12] === 'data-table' && !/*dataTableHeader*/ ctx[13]
    				? 'mdc-data-table__row-checkbox'
    				: '') + "\n  ") && { class: div2_class_value },
    				dirty[0] & /*$$props*/ 32768 && exclude(/*$$props*/ ctx[15], [
    					'use',
    					'class',
    					'disabled',
    					'indeterminate',
    					'group',
    					'checked',
    					'value',
    					'valueKey',
    					'input$'
    				])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			/*div2_binding*/ ctx[25](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { indeterminate = uninitializedValue } = $$props;
    	let { group = uninitializedValue } = $$props;
    	let { checked = uninitializedValue } = $$props;
    	let { value = null } = $$props;
    	let { valueKey = uninitializedValue } = $$props;
    	let { input$use = [] } = $$props;
    	let { input$class = '' } = $$props;
    	let element;
    	let checkbox;
    	let formField = getContext('SMUI:form-field');
    	let inputProps = getContext('SMUI:generic:input:props') || {};
    	let setChecked = getContext('SMUI:generic:input:setChecked');
    	let addChangeHandler = getContext('SMUI:generic:input:addChangeHandler');

    	let nativeChecked = group === uninitializedValue
    	? checked === uninitializedValue ? false : checked
    	: group.indexOf(value) !== -1;

    	let context = getContext('SMUI:checkbox:context');
    	let dataTableHeader = getContext('SMUI:data-table:row:header');
    	let getDataTableRowIndex = getContext('SMUI:data-table:row:getIndex');
    	let instantiate = getContext('SMUI:checkbox:instantiate');
    	let getInstance = getContext('SMUI:checkbox:getInstance');
    	let previousChecked = checked;

    	if (addChangeHandler) {
    		addChangeHandler(handleChange);
    	}

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(20, checkbox = new MDCCheckbox(element));
    		} else {
    			if (context === 'data-table') {
    				if (dataTableHeader) {
    					$$invalidate(20, checkbox = await getInstance(true));
    				} else {
    					$$invalidate(20, checkbox = (await getInstance(false))[getDataTableRowIndex()]);
    				}
    			} else {
    				$$invalidate(20, checkbox = await getInstance());
    			}
    		}

    		if (formField && formField()) {
    			formField().input = checkbox;
    		}
    	});

    	onDestroy(() => {
    		if (instantiate !== false) {
    			checkbox && checkbox.destroy();
    		}
    	});

    	function handleChange() {
    		if (group !== uninitializedValue) {
    			const idx = group.indexOf(value);

    			if (checkbox.checked && idx === -1) {
    				group.push(value);
    				$$invalidate(16, group);
    			} else if (!checkbox.checked && idx !== -1) {
    				group.splice(idx, 1);
    				$$invalidate(16, group);
    			}
    		}
    	}

    	function getId() {
    		return inputProps && inputProps.id;
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_handler() {
    		nativeChecked = this.checked;
    		((($$invalidate(7, nativeChecked), $$invalidate(17, checked)), $$invalidate(10, uninitializedValue)), $$invalidate(21, previousChecked));
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(8, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('indeterminate' in $$new_props) $$invalidate(18, indeterminate = $$new_props.indeterminate);
    		if ('group' in $$new_props) $$invalidate(16, group = $$new_props.group);
    		if ('checked' in $$new_props) $$invalidate(17, checked = $$new_props.checked);
    		if ('value' in $$new_props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
    	};

    	$$self.$capture_state = () => ({
    		MDCCheckbox,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		disabled,
    		indeterminate,
    		group,
    		checked,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		element,
    		checkbox,
    		formField,
    		inputProps,
    		setChecked,
    		addChangeHandler,
    		nativeChecked,
    		context,
    		dataTableHeader,
    		getDataTableRowIndex,
    		instantiate,
    		getInstance,
    		previousChecked,
    		handleChange,
    		getId
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    		if ('uninitializedValue' in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('indeterminate' in $$props) $$invalidate(18, indeterminate = $$new_props.indeterminate);
    		if ('group' in $$props) $$invalidate(16, group = $$new_props.group);
    		if ('checked' in $$props) $$invalidate(17, checked = $$new_props.checked);
    		if ('value' in $$props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$props) $$invalidate(6, input$class = $$new_props.input$class);
    		if ('element' in $$props) $$invalidate(8, element = $$new_props.element);
    		if ('checkbox' in $$props) $$invalidate(20, checkbox = $$new_props.checkbox);
    		if ('formField' in $$props) formField = $$new_props.formField;
    		if ('inputProps' in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
    		if ('setChecked' in $$props) $$invalidate(27, setChecked = $$new_props.setChecked);
    		if ('addChangeHandler' in $$props) addChangeHandler = $$new_props.addChangeHandler;
    		if ('nativeChecked' in $$props) $$invalidate(7, nativeChecked = $$new_props.nativeChecked);
    		if ('context' in $$props) $$invalidate(12, context = $$new_props.context);
    		if ('dataTableHeader' in $$props) $$invalidate(13, dataTableHeader = $$new_props.dataTableHeader);
    		if ('getDataTableRowIndex' in $$props) getDataTableRowIndex = $$new_props.getDataTableRowIndex;
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    		if ('previousChecked' in $$props) $$invalidate(21, previousChecked = $$new_props.previousChecked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*checked, previousChecked, nativeChecked*/ 2228352) {
    			if (checked !== uninitializedValue) {
    				if (checked === previousChecked) {
    					$$invalidate(17, checked = nativeChecked);
    				} else if (nativeChecked !== checked) {
    					$$invalidate(7, nativeChecked = checked);
    				}

    				$$invalidate(21, previousChecked = checked);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*nativeChecked*/ 128) {
    			if (setChecked) {
    				setChecked(nativeChecked);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*checkbox, indeterminate*/ 1310720) {
    			if (checkbox && indeterminate !== uninitializedValue && checkbox.indeterminate !== indeterminate) {
    				$$invalidate(20, checkbox.indeterminate = indeterminate, checkbox);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*checkbox, group, value, checked*/ 1245192) {
    			if (checkbox) {
    				if (group !== uninitializedValue) {
    					const isChecked = group.indexOf(value) !== -1;

    					if (checkbox.checked !== isChecked) {
    						$$invalidate(20, checkbox.checked = isChecked, checkbox);
    					}
    				} else if (checked !== uninitializedValue && checkbox.checked !== checked) {
    					$$invalidate(20, checkbox.checked = checked, checkbox);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*checkbox, disabled*/ 1048580) {
    			if (checkbox && checkbox.disabled !== disabled) {
    				$$invalidate(20, checkbox.disabled = disabled, checkbox);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*checkbox, valueKey, value*/ 1048600) {
    			if (checkbox && valueKey === uninitializedValue && checkbox.value !== value) {
    				$$invalidate(20, checkbox.value = value, checkbox);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*checkbox, valueKey*/ 1048592) {
    			if (checkbox && valueKey !== uninitializedValue && checkbox.value !== valueKey) {
    				$$invalidate(20, checkbox.value = valueKey, checkbox);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		disabled,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		nativeChecked,
    		element,
    		forwardEvents,
    		uninitializedValue,
    		inputProps,
    		context,
    		dataTableHeader,
    		handleChange,
    		$$props,
    		group,
    		checked,
    		indeterminate,
    		getId,
    		checkbox,
    		previousChecked,
    		change_handler,
    		input_handler,
    		input_change_handler,
    		div2_binding
    	];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$1f,
    			create_fragment$1f,
    			safe_not_equal,
    			{
    				use: 0,
    				class: 1,
    				disabled: 2,
    				indeterminate: 18,
    				group: 16,
    				checked: 17,
    				value: 3,
    				valueKey: 4,
    				input$use: 5,
    				input$class: 6,
    				getId: 19
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get use() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indeterminate() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indeterminate(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueKey() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueKey(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$use() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$use(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$class() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$class(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getId() {
    		return this.$$.ctx[19];
    	}

    	set getId(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$a = {
        ROOT: 'mdc-form-field',
    };
    var strings$d = {
        LABEL_SELECTOR: '.mdc-form-field > label',
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFormFieldFoundation = /** @class */ (function (_super) {
        __extends(MDCFormFieldFoundation, _super);
        function MDCFormFieldFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCFormFieldFoundation.defaultAdapter, adapter)) || this;
            _this.clickHandler_ = function () { return _this.handleClick_(); };
            return _this;
        }
        Object.defineProperty(MDCFormFieldFoundation, "cssClasses", {
            get: function () {
                return cssClasses$a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFormFieldFoundation, "strings", {
            get: function () {
                return strings$d;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFormFieldFoundation, "defaultAdapter", {
            get: function () {
                return {
                    activateInputRipple: function () { return undefined; },
                    deactivateInputRipple: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCFormFieldFoundation.prototype.init = function () {
            this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        };
        MDCFormFieldFoundation.prototype.destroy = function () {
            this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        };
        MDCFormFieldFoundation.prototype.handleClick_ = function () {
            var _this = this;
            this.adapter_.activateInputRipple();
            requestAnimationFrame(function () { return _this.adapter_.deactivateInputRipple(); });
        };
        return MDCFormFieldFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFormField = /** @class */ (function (_super) {
        __extends(MDCFormField, _super);
        function MDCFormField() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCFormField.attachTo = function (root) {
            return new MDCFormField(root);
        };
        Object.defineProperty(MDCFormField.prototype, "input", {
            get: function () {
                return this.input_;
            },
            set: function (input) {
                this.input_ = input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCFormField.prototype, "label_", {
            get: function () {
                var LABEL_SELECTOR = MDCFormFieldFoundation.strings.LABEL_SELECTOR;
                return this.root_.querySelector(LABEL_SELECTOR);
            },
            enumerable: true,
            configurable: true
        });
        MDCFormField.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                activateInputRipple: function () {
                    if (_this.input_ && _this.input_.ripple) {
                        _this.input_.ripple.activate();
                    }
                },
                deactivateInputRipple: function () {
                    if (_this.input_ && _this.input_.ripple) {
                        _this.input_.ripple.deactivate();
                    }
                },
                deregisterInteractionHandler: function (evtType, handler) {
                    if (_this.label_) {
                        _this.label_.removeEventListener(evtType, handler);
                    }
                },
                registerInteractionHandler: function (evtType, handler) {
                    if (_this.label_) {
                        _this.label_.addEventListener(evtType, handler);
                    }
                },
            };
            return new MDCFormFieldFoundation(adapter);
        };
        return MDCFormField;
    }(MDCComponent));

    /* node_modules\@smui\form-field\FormField.svelte generated by Svelte v3.42.1 */
    const file$15 = "node_modules\\@smui\\form-field\\FormField.svelte";
    const get_label_slot_changes$1 = dirty => ({});
    const get_label_slot_context$1 = ctx => ({});

    function create_fragment$1e(ctx) {
    	let div;
    	let t;
    	let label;
    	let useActions_action;
    	let div_class_value;
    	let useActions_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	const label_slot_template = /*#slots*/ ctx[9].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[8], get_label_slot_context$1);

    	let label_levels = [
    		{ for: /*inputId*/ ctx[3] },
    		exclude(prefixFilter(/*$$props*/ ctx[7], 'label$'), ['use'])
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	let div_levels = [
    		{
    			class: div_class_value = "\n    mdc-form-field\n    " + /*className*/ ctx[1] + "\n    " + (/*align*/ ctx[2] === 'end'
    			? 'mdc-form-field--align-end'
    			: '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[7], ['use', 'class', 'alignEnd', 'inputId', 'label$'])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			label = element("label");
    			if (label_slot) label_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$15, 12, 2, 271);
    			set_attributes(div, div_data);
    			add_location(div, file$15, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			append_dev(div, label);

    			if (label_slot) {
    				label_slot.m(label, null);
    			}

    			/*div_binding*/ ctx[10](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, label, /*label$use*/ ctx[4])),
    					action_destroyer(useActions_action_1 = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[6].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[8], dirty, get_label_slot_changes$1),
    						get_label_slot_context$1
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				(!current || dirty & /*inputId*/ 8) && { for: /*inputId*/ ctx[3] },
    				dirty & /*$$props*/ 128 && exclude(prefixFilter(/*$$props*/ ctx[7], 'label$'), ['use'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*label$use*/ 16) useActions_action.update.call(null, /*label$use*/ ctx[4]);

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className, align*/ 6 && div_class_value !== (div_class_value = "\n    mdc-form-field\n    " + /*className*/ ctx[1] + "\n    " + (/*align*/ ctx[2] === 'end'
    				? 'mdc-form-field--align-end'
    				: '') + "\n  ")) && { class: div_class_value },
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ['use', 'class', 'alignEnd', 'inputId', 'label$'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (label_slot) label_slot.d(detaching);
    			/*div_binding*/ ctx[10](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let counter$2 = 0;

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormField', slots, ['default','label']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { align = 'start' } = $$props;
    	let { inputId = 'SMUI-form-field-' + counter$2++ } = $$props;
    	let { label$use = [] } = $$props;
    	let element;
    	let formField;
    	setContext('SMUI:form-field', () => formField);
    	setContext('SMUI:generic:input:props', { id: inputId });

    	onMount(() => {
    		formField = new MDCFormField(element);
    	});

    	onDestroy(() => {
    		formField && formField.destroy();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(5, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('align' in $$new_props) $$invalidate(2, align = $$new_props.align);
    		if ('inputId' in $$new_props) $$invalidate(3, inputId = $$new_props.inputId);
    		if ('label$use' in $$new_props) $$invalidate(4, label$use = $$new_props.label$use);
    		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		counter: counter$2,
    		MDCFormField,
    		onMount,
    		onDestroy,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		align,
    		inputId,
    		label$use,
    		element,
    		formField
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('align' in $$props) $$invalidate(2, align = $$new_props.align);
    		if ('inputId' in $$props) $$invalidate(3, inputId = $$new_props.inputId);
    		if ('label$use' in $$props) $$invalidate(4, label$use = $$new_props.label$use);
    		if ('element' in $$props) $$invalidate(5, element = $$new_props.element);
    		if ('formField' in $$props) formField = $$new_props.formField;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		align,
    		inputId,
    		label$use,
    		element,
    		forwardEvents,
    		$$props,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class FormField extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
    			use: 0,
    			class: 1,
    			align: 2,
    			inputId: 3,
    			label$use: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormField",
    			options,
    			id: create_fragment$1e.name
    		});
    	}

    	get use() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label$use() {
    		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label$use(value) {
    		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$9 = {
        ICON_BUTTON_ON: 'mdc-icon-button--on',
        ROOT: 'mdc-icon-button',
    };
    var strings$c = {
        ARIA_PRESSED: 'aria-pressed',
        CHANGE_EVENT: 'MDCIconButtonToggle:change',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCIconButtonToggleFoundation = /** @class */ (function (_super) {
        __extends(MDCIconButtonToggleFoundation, _super);
        function MDCIconButtonToggleFoundation(adapter) {
            return _super.call(this, __assign({}, MDCIconButtonToggleFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCIconButtonToggleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$9;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCIconButtonToggleFoundation, "strings", {
            get: function () {
                return strings$c;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCIconButtonToggleFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    notifyChange: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setAttr: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCIconButtonToggleFoundation.prototype.init = function () {
            this.adapter_.setAttr(strings$c.ARIA_PRESSED, "" + this.isOn());
        };
        MDCIconButtonToggleFoundation.prototype.handleClick = function () {
            this.toggle();
            this.adapter_.notifyChange({ isOn: this.isOn() });
        };
        MDCIconButtonToggleFoundation.prototype.isOn = function () {
            return this.adapter_.hasClass(cssClasses$9.ICON_BUTTON_ON);
        };
        MDCIconButtonToggleFoundation.prototype.toggle = function (isOn) {
            if (isOn === void 0) { isOn = !this.isOn(); }
            if (isOn) {
                this.adapter_.addClass(cssClasses$9.ICON_BUTTON_ON);
            }
            else {
                this.adapter_.removeClass(cssClasses$9.ICON_BUTTON_ON);
            }
            this.adapter_.setAttr(strings$c.ARIA_PRESSED, "" + isOn);
        };
        return MDCIconButtonToggleFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$b = MDCIconButtonToggleFoundation.strings;
    var MDCIconButtonToggle = /** @class */ (function (_super) {
        __extends(MDCIconButtonToggle, _super);
        function MDCIconButtonToggle() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ripple_ = _this.createRipple_();
            return _this;
        }
        MDCIconButtonToggle.attachTo = function (root) {
            return new MDCIconButtonToggle(root);
        };
        MDCIconButtonToggle.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleClick_ = function () { return _this.foundation_.handleClick(); };
            this.listen('click', this.handleClick_);
        };
        MDCIconButtonToggle.prototype.destroy = function () {
            this.unlisten('click', this.handleClick_);
            this.ripple_.destroy();
            _super.prototype.destroy.call(this);
        };
        MDCIconButtonToggle.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                notifyChange: function (evtData) { return _this.emit(strings$b.CHANGE_EVENT, evtData); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                setAttr: function (attrName, attrValue) { return _this.root_.setAttribute(attrName, attrValue); },
            };
            return new MDCIconButtonToggleFoundation(adapter);
        };
        Object.defineProperty(MDCIconButtonToggle.prototype, "ripple", {
            get: function () {
                return this.ripple_;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCIconButtonToggle.prototype, "on", {
            get: function () {
                return this.foundation_.isOn();
            },
            set: function (isOn) {
                this.foundation_.toggle(isOn);
            },
            enumerable: true,
            configurable: true
        });
        MDCIconButtonToggle.prototype.createRipple_ = function () {
            var ripple = new MDCRipple(this.root_);
            ripple.unbounded = true;
            return ripple;
        };
        return MDCIconButtonToggle;
    }(MDCComponent));

    function Ripple(node, props = {ripple: false, unbounded: false, color: null, classForward: () => {}}) {
      let instance = null;
      let addLayoutListener = getContext('SMUI:addLayoutListener');
      let removeLayoutListener;
      let classList = [];

      function addClass(className) {
        const idx = classList.indexOf(className);
        if (idx === -1) {
          node.classList.add(className);
          classList.push(className);
          if (props.classForward) {
            props.classForward(classList);
          }
        }
      }

      function removeClass(className) {
        const idx = classList.indexOf(className);
        if (idx !== -1) {
          node.classList.remove(className);
          classList.splice(idx, 1);
          if (props.classForward) {
            props.classForward(classList);
          }
        }
      }

      function handleProps() {
        if (props.ripple && !instance) {
          // Override the Ripple component's adapter, so that we can forward classes
          // to Svelte components that overwrite Ripple's classes.
          const _createAdapter = MDCRipple.createAdapter;
          MDCRipple.createAdapter = function(...args) {
            const adapter = _createAdapter.apply(this, args);
            adapter.addClass = function(className) {
              return addClass(className);
            };
            adapter.removeClass = function(className) {
              return removeClass(className);
            };
            return adapter;
          };
          instance = new MDCRipple(node);
          MDCRipple.createAdapter = _createAdapter;
        } else if (instance && !props.ripple) {
          instance.destroy();
          instance = null;
        }
        if (props.ripple) {
          instance.unbounded = !!props.unbounded;
          switch (props.color) {
            case 'surface':
              addClass('mdc-ripple-surface');
              removeClass('mdc-ripple-surface--primary');
              removeClass('mdc-ripple-surface--accent');
              return;
            case 'primary':
              addClass('mdc-ripple-surface');
              addClass('mdc-ripple-surface--primary');
              removeClass('mdc-ripple-surface--accent');
              return;
            case 'secondary':
              addClass('mdc-ripple-surface');
              removeClass('mdc-ripple-surface--primary');
              addClass('mdc-ripple-surface--accent');
              return;
          }
        }
        removeClass('mdc-ripple-surface');
        removeClass('mdc-ripple-surface--primary');
        removeClass('mdc-ripple-surface--accent');
      }

      handleProps();

      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }

      function layout() {
        if (instance) {
          instance.layout();
        }
      }

      return {
        update(newProps = {ripple: false, unbounded: false, color: null, classForward: []}) {
          props = newProps;
          handleProps();
        },

        destroy() {
          if (instance) {
            instance.destroy();
            instance = null;
            removeClass('mdc-ripple-surface');
            removeClass('mdc-ripple-surface--primary');
            removeClass('mdc-ripple-surface--accent');
          }

          if (removeLayoutListener) {
            removeLayoutListener();
          }
        }
      }
    }

    /* node_modules\@smui\icon-button\IconButton.svelte generated by Svelte v3.42.1 */
    const file$14 = "node_modules\\@smui\\icon-button\\IconButton.svelte";

    // (23:0) {:else}
    function create_else_block$a(ctx) {
    	let button;
    	let button_class_value;
    	let useActions_action;
    	let Ripple_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	let button_levels = [
    		{
    			class: button_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? 'mdc-icon-button--on' : '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    			? 'mdc-card__action'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    			? 'mdc-card__action--icon'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:navigation'
    			? 'mdc-top-app-bar__navigation-icon'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:action'
    			? 'mdc-top-app-bar__action-item'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'snackbar'
    			? 'mdc-snackbar__dismiss'
    			: '') + "\n    "
    		},
    		{ "aria-hidden": "true" },
    		{ "aria-pressed": /*pressed*/ ctx[0] },
    		/*props*/ ctx[8]
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$14, 23, 2, 769);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[17](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[9].call(null, button)),
    					action_destroyer(Ripple_action = Ripple.call(null, button, {
    						ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
    						unbounded: true,
    						color: /*color*/ ctx[4]
    					})),
    					listen_dev(button, "MDCIconButtonToggle:change", /*handleChange*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				(!current || dirty & /*className, pressed*/ 5 && button_class_value !== (button_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? 'mdc-icon-button--on' : '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    				? 'mdc-card__action'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    				? 'mdc-card__action--icon'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:navigation'
    				? 'mdc-top-app-bar__navigation-icon'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:action'
    				? 'mdc-top-app-bar__action-item'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'snackbar'
    				? 'mdc-snackbar__dismiss'
    				: '') + "\n    ")) && { class: button_class_value },
    				{ "aria-hidden": "true" },
    				(!current || dirty & /*pressed*/ 1) && { "aria-pressed": /*pressed*/ ctx[0] },
    				dirty & /*props*/ 256 && /*props*/ ctx[8]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, toggle, color*/ 56) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
    				unbounded: true,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[17](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(23:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if href}
    function create_if_block$y(ctx) {
    	let a;
    	let a_class_value;
    	let useActions_action;
    	let Ripple_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	let a_levels = [
    		{
    			class: a_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? 'mdc-icon-button--on' : '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    			? 'mdc-card__action'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    			? 'mdc-card__action--icon'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:navigation'
    			? 'mdc-top-app-bar__navigation-icon'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:action'
    			? 'mdc-top-app-bar__action-item'
    			: '') + "\n      " + (/*context*/ ctx[10] === 'snackbar'
    			? 'mdc-snackbar__dismiss'
    			: '') + "\n    "
    		},
    		{ "aria-hidden": "true" },
    		{ "aria-pressed": /*pressed*/ ctx[0] },
    		{ href: /*href*/ ctx[6] },
    		/*props*/ ctx[8]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$14, 1, 2, 13);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[16](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[9].call(null, a)),
    					action_destroyer(Ripple_action = Ripple.call(null, a, {
    						ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
    						unbounded: true,
    						color: /*color*/ ctx[4]
    					})),
    					listen_dev(a, "MDCIconButtonToggle:change", /*handleChange*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*className, pressed*/ 5 && a_class_value !== (a_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? 'mdc-icon-button--on' : '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    				? 'mdc-card__action'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'card:action'
    				? 'mdc-card__action--icon'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:navigation'
    				? 'mdc-top-app-bar__navigation-icon'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'top-app-bar:action'
    				? 'mdc-top-app-bar__action-item'
    				: '') + "\n      " + (/*context*/ ctx[10] === 'snackbar'
    				? 'mdc-snackbar__dismiss'
    				: '') + "\n    ")) && { class: a_class_value },
    				{ "aria-hidden": "true" },
    				(!current || dirty & /*pressed*/ 1) && { "aria-pressed": /*pressed*/ ctx[0] },
    				(!current || dirty & /*href*/ 64) && { href: /*href*/ ctx[6] },
    				dirty & /*props*/ 256 && /*props*/ ctx[8]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, toggle, color*/ 56) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
    				unbounded: true,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[16](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(1:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$y, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let props;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconButton', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCIconButtonToggle:change']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { color = null } = $$props;
    	let { toggle = false } = $$props;
    	let { pressed = false } = $$props;
    	let { href = null } = $$props;
    	let element;
    	let toggleButton;
    	let context = getContext('SMUI:icon-button:context');
    	setContext('SMUI:icon:context', 'icon-button');
    	let oldToggle = null;

    	onDestroy(() => {
    		toggleButton && toggleButton.destroy();
    	});

    	function handleChange(e) {
    		$$invalidate(0, pressed = e.detail.isOn);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('ripple' in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('toggle' in $$new_props) $$invalidate(5, toggle = $$new_props.toggle);
    		if ('pressed' in $$new_props) $$invalidate(0, pressed = $$new_props.pressed);
    		if ('href' in $$new_props) $$invalidate(6, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCIconButtonToggle,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		Ripple,
    		forwardEvents,
    		use,
    		className,
    		ripple,
    		color,
    		toggle,
    		pressed,
    		href,
    		element,
    		toggleButton,
    		context,
    		oldToggle,
    		handleChange,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('ripple' in $$props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('toggle' in $$props) $$invalidate(5, toggle = $$new_props.toggle);
    		if ('pressed' in $$props) $$invalidate(0, pressed = $$new_props.pressed);
    		if ('href' in $$props) $$invalidate(6, href = $$new_props.href);
    		if ('element' in $$props) $$invalidate(7, element = $$new_props.element);
    		if ('toggleButton' in $$props) $$invalidate(12, toggleButton = $$new_props.toggleButton);
    		if ('context' in $$props) $$invalidate(10, context = $$new_props.context);
    		if ('oldToggle' in $$props) $$invalidate(13, oldToggle = $$new_props.oldToggle);
    		if ('props' in $$props) $$invalidate(8, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(8, props = exclude($$props, ['use', 'class', 'ripple', 'color', 'toggle', 'pressed', 'href']));

    		if ($$self.$$.dirty & /*element, toggle, oldToggle, ripple, toggleButton, pressed*/ 12457) {
    			if (element && toggle !== oldToggle) {
    				if (toggle) {
    					$$invalidate(12, toggleButton = new MDCIconButtonToggle(element));

    					if (!ripple) {
    						toggleButton.ripple.destroy();
    					}

    					$$invalidate(12, toggleButton.on = pressed, toggleButton);
    				} else if (oldToggle) {
    					toggleButton && toggleButton.destroy();
    					$$invalidate(12, toggleButton = null);
    				}

    				$$invalidate(13, oldToggle = toggle);
    			}
    		}

    		if ($$self.$$.dirty & /*toggleButton, pressed*/ 4097) {
    			if (toggleButton && toggleButton.on !== pressed) {
    				$$invalidate(12, toggleButton.on = pressed, toggleButton);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		pressed,
    		use,
    		className,
    		ripple,
    		color,
    		toggle,
    		href,
    		element,
    		props,
    		forwardEvents,
    		context,
    		handleChange,
    		toggleButton,
    		oldToggle,
    		$$scope,
    		slots,
    		a_binding,
    		button_binding
    	];
    }

    class IconButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
    			use: 1,
    			class: 2,
    			ripple: 3,
    			color: 4,
    			toggle: 5,
    			pressed: 0,
    			href: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconButton",
    			options,
    			id: create_fragment$1d.name
    		});
    	}

    	get use() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pressed() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pressed(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /** CSS classes used by the switch. */
    var cssClasses$8 = {
        /** Class used for a switch that is in the "checked" (on) position. */
        CHECKED: 'mdc-switch--checked',
        /** Class used for a switch that is disabled. */
        DISABLED: 'mdc-switch--disabled',
    };
    /** String constants used by the switch. */
    var strings$a = {
        /** A CSS selector used to locate the native HTML control for the switch.  */
        NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
        /** A CSS selector used to locate the ripple surface element for the switch. */
        RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSwitchFoundation = /** @class */ (function (_super) {
        __extends(MDCSwitchFoundation, _super);
        function MDCSwitchFoundation(adapter) {
            return _super.call(this, __assign({}, MDCSwitchFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCSwitchFoundation, "strings", {
            /** The string constants used by the switch. */
            get: function () {
                return strings$a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSwitchFoundation, "cssClasses", {
            /** The CSS classes used by the switch. */
            get: function () {
                return cssClasses$8;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSwitchFoundation, "defaultAdapter", {
            /** The default Adapter for the switch. */
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setNativeControlChecked: function () { return undefined; },
                    setNativeControlDisabled: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        /** Sets the checked state of the switch. */
        MDCSwitchFoundation.prototype.setChecked = function (checked) {
            this.adapter_.setNativeControlChecked(checked);
            this.updateCheckedStyling_(checked);
        };
        /** Sets the disabled state of the switch. */
        MDCSwitchFoundation.prototype.setDisabled = function (disabled) {
            this.adapter_.setNativeControlDisabled(disabled);
            if (disabled) {
                this.adapter_.addClass(cssClasses$8.DISABLED);
            }
            else {
                this.adapter_.removeClass(cssClasses$8.DISABLED);
            }
        };
        /** Handles the change event for the switch native control. */
        MDCSwitchFoundation.prototype.handleChange = function (evt) {
            var nativeControl = evt.target;
            this.updateCheckedStyling_(nativeControl.checked);
        };
        /** Updates the styling of the switch based on its checked state. */
        MDCSwitchFoundation.prototype.updateCheckedStyling_ = function (checked) {
            if (checked) {
                this.adapter_.addClass(cssClasses$8.CHECKED);
            }
            else {
                this.adapter_.removeClass(cssClasses$8.CHECKED);
            }
        };
        return MDCSwitchFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSwitch = /** @class */ (function (_super) {
        __extends(MDCSwitch, _super);
        function MDCSwitch() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ripple_ = _this.createRipple_();
            return _this;
        }
        MDCSwitch.attachTo = function (root) {
            return new MDCSwitch(root);
        };
        MDCSwitch.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.ripple_.destroy();
            this.nativeControl_.removeEventListener('change', this.changeHandler_);
        };
        MDCSwitch.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.changeHandler_ = function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return (_a = _this.foundation_).handleChange.apply(_a, __spread(args));
            };
            this.nativeControl_.addEventListener('change', this.changeHandler_);
            // Sometimes the checked state of the input element is saved in the history.
            // The switch styling should match the checked state of the input element.
            // Do an initial sync between the native control and the foundation.
            this.checked = this.checked;
        };
        MDCSwitch.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                setNativeControlChecked: function (checked) { return _this.nativeControl_.checked = checked; },
                setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
            };
            return new MDCSwitchFoundation(adapter);
        };
        Object.defineProperty(MDCSwitch.prototype, "ripple", {
            get: function () {
                return this.ripple_;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSwitch.prototype, "checked", {
            get: function () {
                return this.nativeControl_.checked;
            },
            set: function (checked) {
                this.foundation_.setChecked(checked);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSwitch.prototype, "disabled", {
            get: function () {
                return this.nativeControl_.disabled;
            },
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        MDCSwitch.prototype.createRipple_ = function () {
            var _this = this;
            var RIPPLE_SURFACE_SELECTOR = MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
            var rippleSurface = this.root_.querySelector(RIPPLE_SURFACE_SELECTOR);
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { addClass: function (className) { return rippleSurface.classList.add(className); }, computeBoundingRect: function () { return rippleSurface.getBoundingClientRect(); }, deregisterInteractionHandler: function (evtType, handler) {
                    _this.nativeControl_.removeEventListener(evtType, handler, applyPassive());
                }, isSurfaceActive: function () { return matches$1(_this.nativeControl_, ':active'); }, isUnbounded: function () { return true; }, registerInteractionHandler: function (evtType, handler) {
                    _this.nativeControl_.addEventListener(evtType, handler, applyPassive());
                }, removeClass: function (className) { return rippleSurface.classList.remove(className); }, updateCssVariable: function (varName, value) {
                    rippleSurface.style.setProperty(varName, value);
                } });
            return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
        };
        Object.defineProperty(MDCSwitch.prototype, "nativeControl_", {
            get: function () {
                var NATIVE_CONTROL_SELECTOR = MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
                return this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
            },
            enumerable: true,
            configurable: true
        });
        return MDCSwitch;
    }(MDCComponent));

    /* node_modules\@smui\switch\Switch.svelte generated by Svelte v3.42.1 */
    const file$13 = "node_modules\\@smui\\switch\\Switch.svelte";

    function create_fragment$1c(ctx) {
    	let div3;
    	let div0;
    	let t;
    	let div2;
    	let div1;
    	let input;
    	let input_class_value;
    	let input_value_value;
    	let useActions_action;
    	let div3_class_value;
    	let useActions_action_1;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{
    			class: input_class_value = "mdc-switch__native-control " + /*input$class*/ ctx[6]
    		},
    		{ type: "checkbox" },
    		{ role: "switch" },
    		/*inputProps*/ ctx[11],
    		{ disabled: /*disabled*/ ctx[2] },
    		{
    			__value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    			? /*value*/ ctx[3]
    			: /*valueKey*/ ctx[4]
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[13], 'input$'), ['use', 'class'])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	let div3_levels = [
    		{
    			class: div3_class_value = "\n    mdc-switch\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-switch--disabled' : '') + "\n    " + (/*nativeChecked*/ ctx[7] ? 'mdc-switch--checked' : '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[13], ['use', 'class', 'disabled', 'group', 'checked', 'value', 'input$'])
    	];

    	let div3_data = {};

    	for (let i = 0; i < div3_levels.length; i += 1) {
    		div3_data = assign(div3_data, div3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t = space();
    			div2 = element("div");
    			div1 = element("div");
    			input = element("input");
    			attr_dev(div0, "class", "mdc-switch__track");
    			add_location(div0, file$13, 12, 2, 306);
    			set_attributes(input, input_data);
    			add_location(input, file$13, 15, 6, 429);
    			attr_dev(div1, "class", "mdc-switch__thumb");
    			add_location(div1, file$13, 14, 4, 391);
    			attr_dev(div2, "class", "mdc-switch__thumb-underlay");
    			add_location(div2, file$13, 13, 2, 346);
    			set_attributes(div3, div3_data);
    			add_location(div3, file$13, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			if (input.autofocus) input.focus();
    			input.checked = /*nativeChecked*/ ctx[7];
    			/*div3_binding*/ ctx[22](div3);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[21]),
    					listen_dev(input, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[19], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[20], false, false, false),
    					action_destroyer(useActions_action_1 = useActions.call(null, div3, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[9].call(null, div3))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-switch__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
    				{ type: "checkbox" },
    				{ role: "switch" },
    				/*inputProps*/ ctx[11],
    				dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
    				dirty & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    				? /*value*/ ctx[3]
    				: /*valueKey*/ ctx[4]) && { __value: input_value_value },
    				dirty & /*$$props*/ 8192 && exclude(prefixFilter(/*$$props*/ ctx[13], 'input$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

    			if (dirty & /*nativeChecked*/ 128) {
    				input.checked = /*nativeChecked*/ ctx[7];
    			}

    			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
    				dirty & /*className, disabled, nativeChecked*/ 134 && div3_class_value !== (div3_class_value = "\n    mdc-switch\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-switch--disabled' : '') + "\n    " + (/*nativeChecked*/ ctx[7] ? 'mdc-switch--checked' : '') + "\n  ") && { class: div3_class_value },
    				dirty & /*$$props*/ 8192 && exclude(/*$$props*/ ctx[13], ['use', 'class', 'disabled', 'group', 'checked', 'value', 'input$'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*div3_binding*/ ctx[22](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Switch', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { group = uninitializedValue } = $$props;
    	let { checked = uninitializedValue } = $$props;
    	let { value = null } = $$props;
    	let { valueKey = uninitializedValue } = $$props;
    	let { input$use = [] } = $$props;
    	let { input$class = '' } = $$props;
    	let element;
    	let switchControl;
    	let formField = getContext('SMUI:form-field');
    	let inputProps = getContext('SMUI:generic:input:props') || {};
    	let setChecked = getContext('SMUI:generic:input:setChecked');

    	let nativeChecked = group === uninitializedValue
    	? checked === uninitializedValue ? false : checked
    	: group.indexOf(value) !== -1;

    	let previousChecked = checked;

    	onMount(() => {
    		$$invalidate(17, switchControl = new MDCSwitch(element));

    		if (formField && formField()) {
    			formField().input = switchControl;
    		}
    	});

    	onDestroy(() => {
    		switchControl && switchControl.destroy();
    	});

    	function handleChange(e) {
    		if (group !== uninitializedValue) {
    			const idx = group.indexOf(value);

    			if (switchControl.checked && idx === -1) {
    				group.push(value);
    				$$invalidate(14, group);
    			} else if (!switchControl.checked && idx !== -1) {
    				group.splice(idx, 1);
    				$$invalidate(14, group);
    			}
    		}
    	}

    	function getId() {
    		return inputProps && inputProps.id;
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_handler() {
    		nativeChecked = this.checked;
    		((($$invalidate(7, nativeChecked), $$invalidate(15, checked)), $$invalidate(10, uninitializedValue)), $$invalidate(18, previousChecked));
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(8, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('group' in $$new_props) $$invalidate(14, group = $$new_props.group);
    		if ('checked' in $$new_props) $$invalidate(15, checked = $$new_props.checked);
    		if ('value' in $$new_props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
    	};

    	$$self.$capture_state = () => ({
    		MDCSwitch,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		disabled,
    		group,
    		checked,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		element,
    		switchControl,
    		formField,
    		inputProps,
    		setChecked,
    		nativeChecked,
    		previousChecked,
    		handleChange,
    		getId
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ('uninitializedValue' in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('group' in $$props) $$invalidate(14, group = $$new_props.group);
    		if ('checked' in $$props) $$invalidate(15, checked = $$new_props.checked);
    		if ('value' in $$props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$props) $$invalidate(6, input$class = $$new_props.input$class);
    		if ('element' in $$props) $$invalidate(8, element = $$new_props.element);
    		if ('switchControl' in $$props) $$invalidate(17, switchControl = $$new_props.switchControl);
    		if ('formField' in $$props) formField = $$new_props.formField;
    		if ('inputProps' in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
    		if ('setChecked' in $$props) $$invalidate(24, setChecked = $$new_props.setChecked);
    		if ('nativeChecked' in $$props) $$invalidate(7, nativeChecked = $$new_props.nativeChecked);
    		if ('previousChecked' in $$props) $$invalidate(18, previousChecked = $$new_props.previousChecked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checked, previousChecked, nativeChecked*/ 295040) {
    			if (checked !== uninitializedValue) {
    				if (checked === previousChecked) {
    					$$invalidate(15, checked = nativeChecked);
    				} else if (nativeChecked !== checked) {
    					$$invalidate(7, nativeChecked = checked);
    				}

    				$$invalidate(18, previousChecked = checked);
    			}
    		}

    		if ($$self.$$.dirty & /*nativeChecked*/ 128) {
    			if (setChecked) {
    				setChecked(nativeChecked);
    			}
    		}

    		if ($$self.$$.dirty & /*switchControl, group, value, checked*/ 180232) {
    			if (switchControl) {
    				if (group !== uninitializedValue) {
    					const isChecked = group.indexOf(value) !== -1;

    					if (switchControl.checked !== isChecked) {
    						$$invalidate(17, switchControl.checked = isChecked, switchControl);
    					}
    				} else if (checked !== uninitializedValue && switchControl.checked !== checked) {
    					$$invalidate(17, switchControl.checked = checked, switchControl);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*switchControl, disabled*/ 131076) {
    			if (switchControl && switchControl.disabled !== disabled) {
    				$$invalidate(17, switchControl.disabled = disabled, switchControl);
    			}
    		}

    		if ($$self.$$.dirty & /*switchControl, valueKey, value*/ 131096) {
    			if (switchControl && valueKey === uninitializedValue && switchControl.value !== value) {
    				$$invalidate(17, switchControl.value = value, switchControl);
    			}
    		}

    		if ($$self.$$.dirty & /*switchControl, valueKey*/ 131088) {
    			if (switchControl && valueKey !== uninitializedValue && switchControl.value !== valueKey) {
    				$$invalidate(17, switchControl.value = valueKey, switchControl);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		disabled,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		nativeChecked,
    		element,
    		forwardEvents,
    		uninitializedValue,
    		inputProps,
    		handleChange,
    		$$props,
    		group,
    		checked,
    		getId,
    		switchControl,
    		previousChecked,
    		change_handler,
    		input_handler,
    		input_change_handler,
    		div3_binding
    	];
    }

    class Switch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
    			use: 0,
    			class: 1,
    			disabled: 2,
    			group: 14,
    			checked: 15,
    			value: 3,
    			valueKey: 4,
    			input$use: 5,
    			input$class: 6,
    			getId: 16
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Switch",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get use() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueKey() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueKey(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$use() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$use(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$class() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$class(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getId() {
    		return this.$$.ctx[16];
    	}

    	set getId(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomIconSwitch.svelte generated by Svelte v3.42.1 */

    // (9:4) <Icon class="material-icons" on>
    function create_default_slot_2$9(ctx) {
    	let t_value = /*icons*/ ctx[1][0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(9:4) <Icon class=\\\"material-icons\\\" on>",
    		ctx
    	});

    	return block;
    }

    // (11:4) <Icon class="material-icons">
    function create_default_slot_1$d(ctx) {
    	let t_value = /*icons*/ ctx[1][1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(11:4) <Icon class=\\\"material-icons\\\">",
    		ctx
    	});

    	return block;
    }

    // (7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>
    function create_default_slot$q(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon({
    			props: {
    				class: "material-icons",
    				on: true,
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon0_changes = {};

    			if (dirty & /*$$scope, icons*/ 34) {
    				icon0_changes.$$scope = { dirty, ctx };
    			}

    			icon0.$set(icon0_changes);
    			const icon1_changes = {};

    			if (dirty & /*$$scope, icons*/ 34) {
    				icon1_changes.$$scope = { dirty, ctx };
    			}

    			icon1.$set(icon1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let iconbutton;
    	let updating_pressed;
    	let current;

    	function iconbutton_pressed_binding(value) {
    		/*iconbutton_pressed_binding*/ ctx[3](value);
    	}

    	let iconbutton_props = {
    		style: /*style*/ ctx[2],
    		toggle: true,
    		$$slots: { default: [create_default_slot$q] },
    		$$scope: { ctx }
    	};

    	if (/*toggler*/ ctx[0] !== void 0) {
    		iconbutton_props.pressed = /*toggler*/ ctx[0];
    	}

    	iconbutton = new IconButton({ props: iconbutton_props, $$inline: true });
    	binding_callbacks.push(() => bind(iconbutton, 'pressed', iconbutton_pressed_binding));
    	iconbutton.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(iconbutton.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbutton_changes = {};
    			if (dirty & /*style*/ 4) iconbutton_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, icons*/ 34) {
    				iconbutton_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_pressed && dirty & /*toggler*/ 1) {
    				updating_pressed = true;
    				iconbutton_changes.pressed = /*toggler*/ ctx[0];
    				add_flush_callback(() => updating_pressed = false);
    			}

    			iconbutton.$set(iconbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomIconSwitch', slots, []);
    	let { icons = [], toggler = "", style = "" } = $$props;
    	const writable_props = ['icons', 'toggler', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomIconSwitch> was created with unknown prop '${key}'`);
    	});

    	function iconbutton_pressed_binding(value) {
    		toggler = value;
    		$$invalidate(0, toggler);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('icons' in $$props) $$invalidate(1, icons = $$props.icons);
    		if ('toggler' in $$props) $$invalidate(0, toggler = $$props.toggler);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ IconButton, Icon, icons, toggler, style });

    	$$self.$inject_state = $$props => {
    		if ('icons' in $$props) $$invalidate(1, icons = $$props.icons);
    		if ('toggler' in $$props) $$invalidate(0, toggler = $$props.toggler);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [toggler, icons, style, iconbutton_pressed_binding, click_handler];
    }

    class CustomIconSwitch$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1b, create_fragment$1b, safe_not_equal, { icons: 1, toggler: 0, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomIconSwitch",
    			options,
    			id: create_fragment$1b.name
    		});
    	}

    	get icons() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icons(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggler() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggler(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$7 = {
        LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
        LIST_ITEM_CLASS: 'mdc-list-item',
        LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
        LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
        ROOT: 'mdc-list',
    };
    var strings$9 = {
        ACTION_EVENT: 'MDCList:action',
        ARIA_CHECKED: 'aria-checked',
        ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
        ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
        ARIA_CURRENT: 'aria-current',
        ARIA_DISABLED: 'aria-disabled',
        ARIA_ORIENTATION: 'aria-orientation',
        ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
        ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
        ARIA_SELECTED: 'aria-selected',
        CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
        CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
        CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$7.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$7.LIST_ITEM_CLASS + " a\n  ",
        FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$7.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$7.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$7.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses$7.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled)\n  ",
        RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
    };
    var numbers$4 = {
        UNSET_INDEX: -1,
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
    function isNumberArray(selectedIndex) {
        return selectedIndex instanceof Array;
    }
    var MDCListFoundation = /** @class */ (function (_super) {
        __extends(MDCListFoundation, _super);
        function MDCListFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCListFoundation.defaultAdapter, adapter)) || this;
            _this.wrapFocus_ = false;
            _this.isVertical_ = true;
            _this.isSingleSelectionList_ = false;
            _this.selectedIndex_ = numbers$4.UNSET_INDEX;
            _this.focusedItemIndex_ = numbers$4.UNSET_INDEX;
            _this.useActivatedClass_ = false;
            _this.ariaCurrentAttrValue_ = null;
            _this.isCheckboxList_ = false;
            _this.isRadioList_ = false;
            return _this;
        }
        Object.defineProperty(MDCListFoundation, "strings", {
            get: function () {
                return strings$9;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "cssClasses", {
            get: function () {
                return cssClasses$7;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "numbers", {
            get: function () {
                return numbers$4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCListFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClassForElementIndex: function () { return undefined; },
                    focusItemAtIndex: function () { return undefined; },
                    getAttributeForElementIndex: function () { return null; },
                    getFocusedElementIndex: function () { return 0; },
                    getListItemCount: function () { return 0; },
                    hasCheckboxAtIndex: function () { return false; },
                    hasRadioAtIndex: function () { return false; },
                    isCheckboxCheckedAtIndex: function () { return false; },
                    isFocusInsideList: function () { return false; },
                    isRootFocused: function () { return false; },
                    notifyAction: function () { return undefined; },
                    removeClassForElementIndex: function () { return undefined; },
                    setAttributeForElementIndex: function () { return undefined; },
                    setCheckedCheckboxOrRadioAtIndex: function () { return undefined; },
                    setTabIndexForListItemChildren: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCListFoundation.prototype.layout = function () {
            if (this.adapter_.getListItemCount() === 0) {
                return;
            }
            if (this.adapter_.hasCheckboxAtIndex(0)) {
                this.isCheckboxList_ = true;
            }
            else if (this.adapter_.hasRadioAtIndex(0)) {
                this.isRadioList_ = true;
            }
        };
        /**
         * Sets the private wrapFocus_ variable.
         */
        MDCListFoundation.prototype.setWrapFocus = function (value) {
            this.wrapFocus_ = value;
        };
        /**
         * Sets the isVertical_ private variable.
         */
        MDCListFoundation.prototype.setVerticalOrientation = function (value) {
            this.isVertical_ = value;
        };
        /**
         * Sets the isSingleSelectionList_ private variable.
         */
        MDCListFoundation.prototype.setSingleSelection = function (value) {
            this.isSingleSelectionList_ = value;
        };
        /**
         * Sets the useActivatedClass_ private variable.
         */
        MDCListFoundation.prototype.setUseActivatedClass = function (useActivated) {
            this.useActivatedClass_ = useActivated;
        };
        MDCListFoundation.prototype.getSelectedIndex = function () {
            return this.selectedIndex_;
        };
        MDCListFoundation.prototype.setSelectedIndex = function (index) {
            if (!this.isIndexValid_(index)) {
                return;
            }
            if (this.isCheckboxList_) {
                this.setCheckboxAtIndex_(index);
            }
            else if (this.isRadioList_) {
                this.setRadioAtIndex_(index);
            }
            else {
                this.setSingleSelectionAtIndex_(index);
            }
        };
        /**
         * Focus in handler for the list items.
         */
        MDCListFoundation.prototype.handleFocusIn = function (_, listItemIndex) {
            if (listItemIndex >= 0) {
                this.adapter_.setTabIndexForListItemChildren(listItemIndex, '0');
            }
        };
        /**
         * Focus out handler for the list items.
         */
        MDCListFoundation.prototype.handleFocusOut = function (_, listItemIndex) {
            var _this = this;
            if (listItemIndex >= 0) {
                this.adapter_.setTabIndexForListItemChildren(listItemIndex, '-1');
            }
            /**
             * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
             * is moved to next element.
             */
            setTimeout(function () {
                if (!_this.adapter_.isFocusInsideList()) {
                    _this.setTabindexToFirstSelectedItem_();
                }
            }, 0);
        };
        /**
         * Key handler for the list.
         */
        MDCListFoundation.prototype.handleKeydown = function (evt, isRootListItem, listItemIndex) {
            var isArrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
            var isArrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
            var isArrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
            var isArrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
            var isHome = evt.key === 'Home' || evt.keyCode === 36;
            var isEnd = evt.key === 'End' || evt.keyCode === 35;
            var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
            var isSpace = evt.key === 'Space' || evt.keyCode === 32;
            if (this.adapter_.isRootFocused()) {
                if (isArrowUp || isEnd) {
                    evt.preventDefault();
                    this.focusLastElement();
                }
                else if (isArrowDown || isHome) {
                    evt.preventDefault();
                    this.focusFirstElement();
                }
                return;
            }
            var currentIndex = this.adapter_.getFocusedElementIndex();
            if (currentIndex === -1) {
                currentIndex = listItemIndex;
                if (currentIndex < 0) {
                    // If this event doesn't have a mdc-list-item ancestor from the
                    // current list (not from a sublist), return early.
                    return;
                }
            }
            var nextIndex;
            if ((this.isVertical_ && isArrowDown) || (!this.isVertical_ && isArrowRight)) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusNextElement(currentIndex);
            }
            else if ((this.isVertical_ && isArrowUp) || (!this.isVertical_ && isArrowLeft)) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusPrevElement(currentIndex);
            }
            else if (isHome) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusFirstElement();
            }
            else if (isEnd) {
                this.preventDefaultEvent_(evt);
                nextIndex = this.focusLastElement();
            }
            else if (isEnter || isSpace) {
                if (isRootListItem) {
                    // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
                    var target = evt.target;
                    if (target && target.tagName === 'A' && isEnter) {
                        return;
                    }
                    this.preventDefaultEvent_(evt);
                    if (this.isSelectableList_()) {
                        this.setSelectedIndexOnAction_(currentIndex);
                    }
                    this.adapter_.notifyAction(currentIndex);
                }
            }
            this.focusedItemIndex_ = currentIndex;
            if (nextIndex !== undefined) {
                this.setTabindexAtIndex_(nextIndex);
                this.focusedItemIndex_ = nextIndex;
            }
        };
        /**
         * Click handler for the list.
         */
        MDCListFoundation.prototype.handleClick = function (index, toggleCheckbox) {
            if (index === numbers$4.UNSET_INDEX) {
                return;
            }
            if (this.isSelectableList_()) {
                this.setSelectedIndexOnAction_(index, toggleCheckbox);
            }
            this.adapter_.notifyAction(index);
            this.setTabindexAtIndex_(index);
            this.focusedItemIndex_ = index;
        };
        /**
         * Focuses the next element on the list.
         */
        MDCListFoundation.prototype.focusNextElement = function (index) {
            var count = this.adapter_.getListItemCount();
            var nextIndex = index + 1;
            if (nextIndex >= count) {
                if (this.wrapFocus_) {
                    nextIndex = 0;
                }
                else {
                    // Return early because last item is already focused.
                    return index;
                }
            }
            this.adapter_.focusItemAtIndex(nextIndex);
            return nextIndex;
        };
        /**
         * Focuses the previous element on the list.
         */
        MDCListFoundation.prototype.focusPrevElement = function (index) {
            var prevIndex = index - 1;
            if (prevIndex < 0) {
                if (this.wrapFocus_) {
                    prevIndex = this.adapter_.getListItemCount() - 1;
                }
                else {
                    // Return early because first item is already focused.
                    return index;
                }
            }
            this.adapter_.focusItemAtIndex(prevIndex);
            return prevIndex;
        };
        MDCListFoundation.prototype.focusFirstElement = function () {
            this.adapter_.focusItemAtIndex(0);
            return 0;
        };
        MDCListFoundation.prototype.focusLastElement = function () {
            var lastIndex = this.adapter_.getListItemCount() - 1;
            this.adapter_.focusItemAtIndex(lastIndex);
            return lastIndex;
        };
        /**
         * @param itemIndex Index of the list item
         * @param isEnabled Sets the list item to enabled or disabled.
         */
        MDCListFoundation.prototype.setEnabled = function (itemIndex, isEnabled) {
            if (!this.isIndexValid_(itemIndex)) {
                return;
            }
            if (isEnabled) {
                this.adapter_.removeClassForElementIndex(itemIndex, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.setAttributeForElementIndex(itemIndex, strings$9.ARIA_DISABLED, 'false');
            }
            else {
                this.adapter_.addClassForElementIndex(itemIndex, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.setAttributeForElementIndex(itemIndex, strings$9.ARIA_DISABLED, 'true');
            }
        };
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         */
        MDCListFoundation.prototype.preventDefaultEvent_ = function (evt) {
            var target = evt.target;
            var tagName = ("" + target.tagName).toLowerCase();
            if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
                evt.preventDefault();
            }
        };
        MDCListFoundation.prototype.setSingleSelectionAtIndex_ = function (index) {
            if (this.selectedIndex_ === index) {
                return;
            }
            var selectedClassName = cssClasses$7.LIST_ITEM_SELECTED_CLASS;
            if (this.useActivatedClass_) {
                selectedClassName = cssClasses$7.LIST_ITEM_ACTIVATED_CLASS;
            }
            if (this.selectedIndex_ !== numbers$4.UNSET_INDEX) {
                this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
            }
            this.adapter_.addClassForElementIndex(index, selectedClassName);
            this.setAriaForSingleSelectionAtIndex_(index);
            this.selectedIndex_ = index;
        };
        /**
         * Sets aria attribute for single selection at given index.
         */
        MDCListFoundation.prototype.setAriaForSingleSelectionAtIndex_ = function (index) {
            // Detect the presence of aria-current and get the value only during list initialization when it is in unset state.
            if (this.selectedIndex_ === numbers$4.UNSET_INDEX) {
                this.ariaCurrentAttrValue_ =
                    this.adapter_.getAttributeForElementIndex(index, strings$9.ARIA_CURRENT);
            }
            var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
            var ariaAttribute = isAriaCurrent ? strings$9.ARIA_CURRENT : strings$9.ARIA_SELECTED;
            if (this.selectedIndex_ !== numbers$4.UNSET_INDEX) {
                this.adapter_.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
            }
            var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
            this.adapter_.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
        };
        /**
         * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
         */
        MDCListFoundation.prototype.setRadioAtIndex_ = function (index) {
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);
            if (this.selectedIndex_ !== numbers$4.UNSET_INDEX) {
                this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$9.ARIA_CHECKED, 'false');
            }
            this.adapter_.setAttributeForElementIndex(index, strings$9.ARIA_CHECKED, 'true');
            this.selectedIndex_ = index;
        };
        MDCListFoundation.prototype.setCheckboxAtIndex_ = function (index) {
            for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
                var isChecked = false;
                if (index.indexOf(i) >= 0) {
                    isChecked = true;
                }
                this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
                this.adapter_.setAttributeForElementIndex(i, strings$9.ARIA_CHECKED, isChecked ? 'true' : 'false');
            }
            this.selectedIndex_ = index;
        };
        MDCListFoundation.prototype.setTabindexAtIndex_ = function (index) {
            if (this.focusedItemIndex_ === numbers$4.UNSET_INDEX && index !== 0) {
                // If no list item was selected set first list item's tabindex to -1.
                // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
                this.adapter_.setAttributeForElementIndex(0, 'tabindex', '-1');
            }
            else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
                this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', '-1');
            }
            this.adapter_.setAttributeForElementIndex(index, 'tabindex', '0');
        };
        /**
         * @return Return true if it is single selectin list, checkbox list or radio list.
         */
        MDCListFoundation.prototype.isSelectableList_ = function () {
            return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
        };
        MDCListFoundation.prototype.setTabindexToFirstSelectedItem_ = function () {
            var targetIndex = 0;
            if (this.isSelectableList_()) {
                if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== numbers$4.UNSET_INDEX) {
                    targetIndex = this.selectedIndex_;
                }
                else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
                    targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) { return Math.min(currentIndex, minIndex); });
                }
            }
            this.setTabindexAtIndex_(targetIndex);
        };
        MDCListFoundation.prototype.isIndexValid_ = function (index) {
            var _this = this;
            if (index instanceof Array) {
                if (!this.isCheckboxList_) {
                    throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
                }
                if (index.length === 0) {
                    return true;
                }
                else {
                    return index.some(function (i) { return _this.isIndexInRange_(i); });
                }
            }
            else if (typeof index === 'number') {
                if (this.isCheckboxList_) {
                    throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
                }
                return this.isIndexInRange_(index);
            }
            else {
                return false;
            }
        };
        MDCListFoundation.prototype.isIndexInRange_ = function (index) {
            var listSize = this.adapter_.getListItemCount();
            return index >= 0 && index < listSize;
        };
        MDCListFoundation.prototype.setSelectedIndexOnAction_ = function (index, toggleCheckbox) {
            if (toggleCheckbox === void 0) { toggleCheckbox = true; }
            if (this.isCheckboxList_) {
                this.toggleCheckboxAtIndex_(index, toggleCheckbox);
            }
            else {
                this.setSelectedIndex(index);
            }
        };
        MDCListFoundation.prototype.toggleCheckboxAtIndex_ = function (index, toggleCheckbox) {
            var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);
            if (toggleCheckbox) {
                isChecked = !isChecked;
                this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
            }
            this.adapter_.setAttributeForElementIndex(index, strings$9.ARIA_CHECKED, isChecked ? 'true' : 'false');
            // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.
            var selectedIndexes = this.selectedIndex_ === numbers$4.UNSET_INDEX ? [] : this.selectedIndex_.slice();
            if (isChecked) {
                selectedIndexes.push(index);
            }
            else {
                selectedIndexes = selectedIndexes.filter(function (i) { return i !== index; });
            }
            this.selectedIndex_ = selectedIndexes;
        };
        return MDCListFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCList = /** @class */ (function (_super) {
        __extends(MDCList, _super);
        function MDCList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MDCList.prototype, "vertical", {
            set: function (value) {
                this.foundation_.setVerticalOrientation(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "listElements", {
            get: function () {
                return [].slice.call(this.root_.querySelectorAll("." + cssClasses$7.LIST_ITEM_CLASS));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "wrapFocus", {
            set: function (value) {
                this.foundation_.setWrapFocus(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "singleSelection", {
            set: function (isSingleSelectionList) {
                this.foundation_.setSingleSelection(isSingleSelectionList);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCList.prototype, "selectedIndex", {
            get: function () {
                return this.foundation_.getSelectedIndex();
            },
            set: function (index) {
                this.foundation_.setSelectedIndex(index);
            },
            enumerable: true,
            configurable: true
        });
        MDCList.attachTo = function (root) {
            return new MDCList(root);
        };
        MDCList.prototype.initialSyncWithDOM = function () {
            this.handleClick_ = this.handleClickEvent_.bind(this);
            this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
            this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
            this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
            this.listen('keydown', this.handleKeydown_);
            this.listen('click', this.handleClick_);
            this.listen('focusin', this.focusInEventListener_);
            this.listen('focusout', this.focusOutEventListener_);
            this.layout();
            this.initializeListType();
        };
        MDCList.prototype.destroy = function () {
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten('click', this.handleClick_);
            this.unlisten('focusin', this.focusInEventListener_);
            this.unlisten('focusout', this.focusOutEventListener_);
        };
        MDCList.prototype.layout = function () {
            var direction = this.root_.getAttribute(strings$9.ARIA_ORIENTATION);
            this.vertical = direction !== strings$9.ARIA_ORIENTATION_HORIZONTAL;
            // List items need to have at least tabindex=-1 to be focusable.
            [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])'))
                .forEach(function (el) {
                el.setAttribute('tabindex', '-1');
            });
            // Child button/a elements are not tabbable until the list item is focused.
            [].slice.call(this.root_.querySelectorAll(strings$9.FOCUSABLE_CHILD_ELEMENTS))
                .forEach(function (el) { return el.setAttribute('tabindex', '-1'); });
            this.foundation_.layout();
        };
        /**
         * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
         */
        MDCList.prototype.initializeListType = function () {
            var _this = this;
            var checkboxListItems = this.root_.querySelectorAll(strings$9.ARIA_ROLE_CHECKBOX_SELECTOR);
            var singleSelectedListItem = this.root_.querySelector("\n      ." + cssClasses$7.LIST_ITEM_ACTIVATED_CLASS + ",\n      ." + cssClasses$7.LIST_ITEM_SELECTED_CLASS + "\n    ");
            var radioSelectedListItem = this.root_.querySelector(strings$9.ARIA_CHECKED_RADIO_SELECTOR);
            if (checkboxListItems.length) {
                var preselectedItems = this.root_.querySelectorAll(strings$9.ARIA_CHECKED_CHECKBOX_SELECTOR);
                this.selectedIndex =
                    [].map.call(preselectedItems, function (listItem) { return _this.listElements.indexOf(listItem); });
            }
            else if (singleSelectedListItem) {
                if (singleSelectedListItem.classList.contains(cssClasses$7.LIST_ITEM_ACTIVATED_CLASS)) {
                    this.foundation_.setUseActivatedClass(true);
                }
                this.singleSelection = true;
                this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
            }
            else if (radioSelectedListItem) {
                this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
            }
        };
        /**
         * Updates the list item at itemIndex to the desired isEnabled state.
         * @param itemIndex Index of the list item
         * @param isEnabled Sets the list item to enabled or disabled.
         */
        MDCList.prototype.setEnabled = function (itemIndex, isEnabled) {
            this.foundation_.setEnabled(itemIndex, isEnabled);
        };
        MDCList.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClassForElementIndex: function (index, className) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.classList.add(className);
                    }
                },
                focusItemAtIndex: function (index) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.focus();
                    }
                },
                getAttributeForElementIndex: function (index, attr) { return _this.listElements[index].getAttribute(attr); },
                getFocusedElementIndex: function () { return _this.listElements.indexOf(document.activeElement); },
                getListItemCount: function () { return _this.listElements.length; },
                hasCheckboxAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    return !!listItem.querySelector(strings$9.CHECKBOX_SELECTOR);
                },
                hasRadioAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    return !!listItem.querySelector(strings$9.RADIO_SELECTOR);
                },
                isCheckboxCheckedAtIndex: function (index) {
                    var listItem = _this.listElements[index];
                    var toggleEl = listItem.querySelector(strings$9.CHECKBOX_SELECTOR);
                    return toggleEl.checked;
                },
                isFocusInsideList: function () {
                    return _this.root_.contains(document.activeElement);
                },
                isRootFocused: function () { return document.activeElement === _this.root_; },
                notifyAction: function (index) {
                    _this.emit(strings$9.ACTION_EVENT, { index: index }, /** shouldBubble */ true);
                },
                removeClassForElementIndex: function (index, className) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.classList.remove(className);
                    }
                },
                setAttributeForElementIndex: function (index, attr, value) {
                    var element = _this.listElements[index];
                    if (element) {
                        element.setAttribute(attr, value);
                    }
                },
                setCheckedCheckboxOrRadioAtIndex: function (index, isChecked) {
                    var listItem = _this.listElements[index];
                    var toggleEl = listItem.querySelector(strings$9.CHECKBOX_RADIO_SELECTOR);
                    toggleEl.checked = isChecked;
                    var event = document.createEvent('Event');
                    event.initEvent('change', true, true);
                    toggleEl.dispatchEvent(event);
                },
                setTabIndexForListItemChildren: function (listItemIndex, tabIndexValue) {
                    var element = _this.listElements[listItemIndex];
                    var listItemChildren = [].slice.call(element.querySelectorAll(strings$9.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                    listItemChildren.forEach(function (el) { return el.setAttribute('tabindex', tabIndexValue); });
                },
            };
            return new MDCListFoundation(adapter);
        };
        /**
         * Used to figure out which list item this event is targetting. Or returns -1 if
         * there is no list item
         */
        MDCList.prototype.getListItemIndex_ = function (evt) {
            var eventTarget = evt.target;
            var nearestParent = closest(eventTarget, "." + cssClasses$7.LIST_ITEM_CLASS + ", ." + cssClasses$7.ROOT);
            // Get the index of the element if it is a list item.
            if (nearestParent && matches$1(nearestParent, "." + cssClasses$7.LIST_ITEM_CLASS)) {
                return this.listElements.indexOf(nearestParent);
            }
            return -1;
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleFocusInEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            this.foundation_.handleFocusIn(evt, index);
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleFocusOutEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            this.foundation_.handleFocusOut(evt, index);
        };
        /**
         * Used to figure out which element was focused when keydown event occurred before sending the event to the
         * foundation.
         */
        MDCList.prototype.handleKeydownEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            var target = evt.target;
            this.foundation_.handleKeydown(evt, target.classList.contains(cssClasses$7.LIST_ITEM_CLASS), index);
        };
        /**
         * Used to figure out which element was clicked before sending the event to the foundation.
         */
        MDCList.prototype.handleClickEvent_ = function (evt) {
            var index = this.getListItemIndex_(evt);
            var target = evt.target;
            // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
            var toggleCheckbox = !matches$1(target, strings$9.CHECKBOX_RADIO_SELECTOR);
            this.foundation_.handleClick(index, toggleCheckbox);
        };
        return MDCList;
    }(MDCComponent));

    /* node_modules\@smui\list\List.svelte generated by Svelte v3.42.1 */
    const file$12 = "node_modules\\@smui\\list\\List.svelte";

    // (18:0) {:else}
    function create_else_block$9(ctx) {
    	let ul;
    	let ul_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	let ul_levels = [
    		{
    			class: ul_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    			? 'mdc-list--non-interactive'
    			: '') + "\n      " + (/*dense*/ ctx[3] ? 'mdc-list--dense' : '') + "\n      " + (/*avatarList*/ ctx[4] ? 'mdc-list--avatar-list' : '') + "\n      " + (/*twoLine*/ ctx[5] ? 'mdc-list--two-line' : '') + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    			? 'smui-list--three-line'
    			: '') + "\n    "
    		},
    		{ role: /*role*/ ctx[8] },
    		/*props*/ ctx[9]
    	];

    	let ul_data = {};

    	for (let i = 0; i < ul_levels.length; i += 1) {
    		ul_data = assign(ul_data, ul_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			set_attributes(ul, ul_data);
    			add_location(ul, file$12, 18, 2, 478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			/*ul_binding*/ ctx[26](ul);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, ul, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[10].call(null, ul)),
    					listen_dev(ul, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
    				(!current || dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && ul_class_value !== (ul_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    				? 'mdc-list--non-interactive'
    				: '') + "\n      " + (/*dense*/ ctx[3] ? 'mdc-list--dense' : '') + "\n      " + (/*avatarList*/ ctx[4] ? 'mdc-list--avatar-list' : '') + "\n      " + (/*twoLine*/ ctx[5] ? 'mdc-list--two-line' : '') + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    				? 'smui-list--three-line'
    				: '') + "\n    ")) && { class: ul_class_value },
    				(!current || dirty[0] & /*role*/ 256) && { role: /*role*/ ctx[8] },
    				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    			/*ul_binding*/ ctx[26](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(18:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if nav}
    function create_if_block$x(ctx) {
    	let nav_1;
    	let nav_1_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

    	let nav_1_levels = [
    		{
    			class: nav_1_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    			? 'mdc-list--non-interactive'
    			: '') + "\n      " + (/*dense*/ ctx[3] ? 'mdc-list--dense' : '') + "\n      " + (/*avatarList*/ ctx[4] ? 'mdc-list--avatar-list' : '') + "\n      " + (/*twoLine*/ ctx[5] ? 'mdc-list--two-line' : '') + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    			? 'smui-list--three-line'
    			: '') + "\n    "
    		},
    		/*props*/ ctx[9]
    	];

    	let nav_1_data = {};

    	for (let i = 0; i < nav_1_levels.length; i += 1) {
    		nav_1_data = assign(nav_1_data, nav_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav_1 = element("nav");
    			if (default_slot) default_slot.c();
    			set_attributes(nav_1, nav_1_data);
    			add_location(nav_1, file$12, 1, 2, 12);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav_1, anchor);

    			if (default_slot) {
    				default_slot.m(nav_1, null);
    			}

    			/*nav_1_binding*/ ctx[25](nav_1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, nav_1, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[10].call(null, nav_1)),
    					listen_dev(nav_1, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[23],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(nav_1, nav_1_data = get_spread_update(nav_1_levels, [
    				(!current || dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && nav_1_class_value !== (nav_1_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
    				? 'mdc-list--non-interactive'
    				: '') + "\n      " + (/*dense*/ ctx[3] ? 'mdc-list--dense' : '') + "\n      " + (/*avatarList*/ ctx[4] ? 'mdc-list--avatar-list' : '') + "\n      " + (/*twoLine*/ ctx[5] ? 'mdc-list--two-line' : '') + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
    				? 'smui-list--three-line'
    				: '') + "\n    ")) && { class: nav_1_class_value },
    				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav_1);
    			if (default_slot) default_slot.d(detaching);
    			/*nav_1_binding*/ ctx[25](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(1:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$x, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[11]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let props;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCList:action']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { nonInteractive = false } = $$props;
    	let { dense = false } = $$props;
    	let { avatarList = false } = $$props;
    	let { twoLine = false } = $$props;
    	let { threeLine = false } = $$props;
    	let { vertical = true } = $$props;
    	let { wrapFocus = false } = $$props;
    	let { singleSelection = false } = $$props;
    	let { selectedIndex = null } = $$props;
    	let { radiolist = false } = $$props;
    	let { checklist = false } = $$props;
    	let element;
    	let list;
    	let role = getContext('SMUI:list:role');
    	let nav = getContext('SMUI:list:nav');
    	let instantiate = getContext('SMUI:list:instantiate');
    	let getInstance = getContext('SMUI:list:getInstance');
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;
    	setContext('SMUI:list:nonInteractive', nonInteractive);

    	if (!role) {
    		if (singleSelection) {
    			role = 'listbox';
    			setContext('SMUI:list:item:role', 'option');
    		} else if (radiolist) {
    			role = 'radiogroup';
    			setContext('SMUI:list:item:role', 'radio');
    		} else if (checklist) {
    			role = 'group';
    			setContext('SMUI:list:item:role', 'checkbox');
    		} else {
    			role = 'list';
    			setContext('SMUI:list:item:role', undefined);
    		}
    	}

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(22, list = new MDCList(element));
    		} else {
    			$$invalidate(22, list = await getInstance());
    		}

    		if (singleSelection) {
    			list.initializeListType();
    			$$invalidate(13, selectedIndex = list.selectedIndex);
    		}
    	});

    	onDestroy(() => {
    		if (instantiate !== false) {
    			list && list.destroy();
    		}

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function handleAction(e) {
    		if (list && list.listElements[e.detail.index].classList.contains('mdc-list-item--disabled')) {
    			e.preventDefault();
    			$$invalidate(22, list.selectedIndex = selectedIndex, list);
    		} else if (list && list.selectedIndex === e.detail.index) {
    			$$invalidate(13, selectedIndex = e.detail.index);
    		}
    	}

    	function layout(...args) {
    		return list.layout(...args);
    	}

    	function setEnabled(...args) {
    		return list.setEnabled(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return list.getDefaultFoundation(...args);
    	}

    	function nav_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	function ul_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('nonInteractive' in $$new_props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    		if ('dense' in $$new_props) $$invalidate(3, dense = $$new_props.dense);
    		if ('avatarList' in $$new_props) $$invalidate(4, avatarList = $$new_props.avatarList);
    		if ('twoLine' in $$new_props) $$invalidate(5, twoLine = $$new_props.twoLine);
    		if ('threeLine' in $$new_props) $$invalidate(6, threeLine = $$new_props.threeLine);
    		if ('vertical' in $$new_props) $$invalidate(14, vertical = $$new_props.vertical);
    		if ('wrapFocus' in $$new_props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
    		if ('singleSelection' in $$new_props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
    		if ('selectedIndex' in $$new_props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
    		if ('radiolist' in $$new_props) $$invalidate(17, radiolist = $$new_props.radiolist);
    		if ('checklist' in $$new_props) $$invalidate(18, checklist = $$new_props.checklist);
    		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCList,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		nonInteractive,
    		dense,
    		avatarList,
    		twoLine,
    		threeLine,
    		vertical,
    		wrapFocus,
    		singleSelection,
    		selectedIndex,
    		radiolist,
    		checklist,
    		element,
    		list,
    		role,
    		nav,
    		instantiate,
    		getInstance,
    		addLayoutListener,
    		removeLayoutListener,
    		handleAction,
    		layout,
    		setEnabled,
    		getDefaultFoundation,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('nonInteractive' in $$props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    		if ('dense' in $$props) $$invalidate(3, dense = $$new_props.dense);
    		if ('avatarList' in $$props) $$invalidate(4, avatarList = $$new_props.avatarList);
    		if ('twoLine' in $$props) $$invalidate(5, twoLine = $$new_props.twoLine);
    		if ('threeLine' in $$props) $$invalidate(6, threeLine = $$new_props.threeLine);
    		if ('vertical' in $$props) $$invalidate(14, vertical = $$new_props.vertical);
    		if ('wrapFocus' in $$props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
    		if ('singleSelection' in $$props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
    		if ('selectedIndex' in $$props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
    		if ('radiolist' in $$props) $$invalidate(17, radiolist = $$new_props.radiolist);
    		if ('checklist' in $$props) $$invalidate(18, checklist = $$new_props.checklist);
    		if ('element' in $$props) $$invalidate(7, element = $$new_props.element);
    		if ('list' in $$props) $$invalidate(22, list = $$new_props.list);
    		if ('role' in $$props) $$invalidate(8, role = $$new_props.role);
    		if ('nav' in $$props) $$invalidate(11, nav = $$new_props.nav);
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ('props' in $$props) $$invalidate(9, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(9, props = exclude($$props, [
    			'use',
    			'class',
    			'nonInteractive',
    			'dense',
    			'avatarList',
    			'twoLine',
    			'threeLine',
    			'vertical',
    			'wrapFocus',
    			'singleSelection',
    			'selectedIndex',
    			'radiolist',
    			'checklist'
    		]));

    		if ($$self.$$.dirty[0] & /*list, vertical*/ 4210688) {
    			if (list && list.vertical !== vertical) {
    				$$invalidate(22, list.vertical = vertical, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, wrapFocus*/ 4227072) {
    			if (list && list.wrapFocus !== wrapFocus) {
    				$$invalidate(22, list.wrapFocus = wrapFocus, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, singleSelection*/ 4259840) {
    			if (list && list.singleSelection !== singleSelection) {
    				$$invalidate(22, list.singleSelection = singleSelection, list);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*list, singleSelection, selectedIndex*/ 4268032) {
    			if (list && singleSelection && list.selectedIndex !== selectedIndex) {
    				$$invalidate(22, list.selectedIndex = selectedIndex, list);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		nonInteractive,
    		dense,
    		avatarList,
    		twoLine,
    		threeLine,
    		element,
    		role,
    		props,
    		forwardEvents,
    		nav,
    		handleAction,
    		selectedIndex,
    		vertical,
    		wrapFocus,
    		singleSelection,
    		radiolist,
    		checklist,
    		layout,
    		setEnabled,
    		getDefaultFoundation,
    		list,
    		$$scope,
    		slots,
    		nav_1_binding,
    		ul_binding
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$1a,
    			create_fragment$1a,
    			safe_not_equal,
    			{
    				use: 0,
    				class: 1,
    				nonInteractive: 2,
    				dense: 3,
    				avatarList: 4,
    				twoLine: 5,
    				threeLine: 6,
    				vertical: 14,
    				wrapFocus: 15,
    				singleSelection: 16,
    				selectedIndex: 13,
    				radiolist: 17,
    				checklist: 18,
    				layout: 19,
    				setEnabled: 20,
    				getDefaultFoundation: 21
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$1a.name
    		});
    	}

    	get use() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nonInteractive() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nonInteractive(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get avatarList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set avatarList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get twoLine() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set twoLine(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get threeLine() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threeLine(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapFocus() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapFocus(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get singleSelection() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set singleSelection(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get radiolist() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set radiolist(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checklist() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checklist(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[19];
    	}

    	set layout(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setEnabled() {
    		return this.$$.ctx[20];
    	}

    	set setEnabled(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[21];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\list\Item.svelte generated by Svelte v3.42.1 */
    const file$11 = "node_modules\\@smui\\list\\Item.svelte";

    // (40:0) {:else}
    function create_else_block$8(ctx) {
    	let li;
    	let li_class_value;
    	let useActions_action;
    	let Ripple_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	let li_levels = [
    		{
    			class: li_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n      " + (/*role*/ ctx[6] === 'menuitem' && /*selected*/ ctx[7]
    			? 'mdc-menu-item--selected'
    			: '') + "\n    "
    		},
    		{ role: /*role*/ ctx[6] },
    		/*role*/ ctx[6] === 'option'
    		? {
    				'aria-selected': /*selected*/ ctx[7] ? 'true' : 'false'
    			}
    		: {},
    		/*role*/ ctx[6] === 'radio' || /*role*/ ctx[6] === 'checkbox'
    		? {
    				'aria-checked': /*checked*/ ctx[10] ? 'true' : 'false'
    			}
    		: {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$11, 40, 2, 1053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[23](li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, li, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[13].call(null, li)),
    					action_destroyer(Ripple_action = Ripple.call(null, li, {
    						ripple: /*ripple*/ ctx[3],
    						unbounded: false,
    						color: /*color*/ ctx[4]
    					})),
    					listen_dev(li, "click", /*action*/ ctx[15], false, false, false),
    					listen_dev(li, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty & /*className, activated, selected, disabled, role*/ 484 && li_class_value !== (li_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n      " + (/*role*/ ctx[6] === 'menuitem' && /*selected*/ ctx[7]
    				? 'mdc-menu-item--selected'
    				: '') + "\n    ")) && { class: li_class_value },
    				(!current || dirty & /*role*/ 64) && { role: /*role*/ ctx[6] },
    				dirty & /*role, selected*/ 192 && (/*role*/ ctx[6] === 'option'
    				? {
    						'aria-selected': /*selected*/ ctx[7] ? 'true' : 'false'
    					}
    				: {}),
    				dirty & /*role, checked*/ 1088 && (/*role*/ ctx[6] === 'radio' || /*role*/ ctx[6] === 'checkbox'
    				? {
    						'aria-checked': /*checked*/ ctx[10] ? 'true' : 'false'
    					}
    				: {}),
    				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[23](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(40:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:23) 
    function create_if_block_1$d(ctx) {
    	let span;
    	let span_class_value;
    	let useActions_action;
    	let Ripple_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	let span_levels = [
    		{
    			class: span_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n    "
    		},
    		/*activated*/ ctx[5] ? { 'aria-current': 'page' } : {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$11, 21, 2, 547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[22](span);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[13].call(null, span)),
    					action_destroyer(Ripple_action = Ripple.call(null, span, {
    						ripple: /*ripple*/ ctx[3],
    						unbounded: false,
    						color: /*color*/ ctx[4]
    					})),
    					listen_dev(span, "click", /*action*/ ctx[15], false, false, false),
    					listen_dev(span, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*className, activated, selected, disabled*/ 420 && span_class_value !== (span_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n    ")) && { class: span_class_value },
    				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { 'aria-current': 'page' } : {}),
    				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			/*span_binding*/ ctx[22](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(21:23) ",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if nav && href}
    function create_if_block$w(ctx) {
    	let a;
    	let a_class_value;
    	let useActions_action;
    	let Ripple_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	let a_levels = [
    		{
    			class: a_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n    "
    		},
    		{ href: /*href*/ ctx[9] },
    		/*activated*/ ctx[5] ? { 'aria-current': 'page' } : {},
    		{ tabindex: /*tabindex*/ ctx[0] },
    		/*props*/ ctx[12]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$11, 1, 2, 20);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[21](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[13].call(null, a)),
    					action_destroyer(Ripple_action = Ripple.call(null, a, {
    						ripple: /*ripple*/ ctx[3],
    						unbounded: false,
    						color: /*color*/ ctx[4]
    					})),
    					listen_dev(a, "click", /*action*/ ctx[15], false, false, false),
    					listen_dev(a, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*className, activated, selected, disabled*/ 420 && a_class_value !== (a_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? 'mdc-list-item--activated' : '') + "\n      " + (/*selected*/ ctx[7] ? 'mdc-list-item--selected' : '') + "\n      " + (/*disabled*/ ctx[8] ? 'mdc-list-item--disabled' : '') + "\n    ")) && { class: a_class_value },
    				(!current || dirty & /*href*/ 512) && { href: /*href*/ ctx[9] },
    				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { 'aria-current': 'page' } : {}),
    				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] },
    				dirty & /*props*/ 4096 && /*props*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[3],
    				unbounded: false,
    				color: /*color*/ ctx[4]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[21](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(1:0) {#if nav && href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$w, create_if_block_1$d, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[14] && /*href*/ ctx[9]) return 0;
    		if (/*nav*/ ctx[14] && !/*href*/ ctx[9]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let counter$1 = 0;

    function instance$19($$self, $$props, $$invalidate) {
    	let props;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Item', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let checked = false;
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { color = null } = $$props;
    	let { nonInteractive = getContext('SMUI:list:nonInteractive') } = $$props;
    	let { activated = false } = $$props;
    	let { role = getContext('SMUI:list:item:role') } = $$props;
    	let { selected = false } = $$props;
    	let { disabled = false } = $$props;
    	let { tabindex = !nonInteractive && !disabled && (selected || checked) && '0' || '-1' } = $$props;
    	let { href = false } = $$props;
    	let { inputId = 'SMUI-form-field-list-' + counter$1++ } = $$props;
    	let element;
    	let addTabindexIfNoItemsSelectedRaf;
    	let nav = getContext('SMUI:list:item:nav');
    	setContext('SMUI:generic:input:props', { id: inputId });
    	setContext('SMUI:generic:input:setChecked', setChecked);

    	onMount(() => {
    		// Tabindex needs to be '0' if this is the first non-disabled list item, and
    		// no other item is selected.
    		if (!selected && !nonInteractive) {
    			let first = true;
    			let el = element;

    			while (el.previousSibling) {
    				el = el.previousSibling;

    				if (el.nodeType === 1 && el.classList.contains('mdc-list-item') && !el.classList.contains('mdc-list-item--disabled')) {
    					first = false;
    					break;
    				}
    			}

    			if (first) {
    				// This is first, so now set up a check that no other items are
    				// selected.
    				addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
    			}
    		}
    	});

    	onDestroy(() => {
    		if (addTabindexIfNoItemsSelectedRaf) {
    			window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    		}
    	});

    	function addTabindexIfNoItemsSelected() {
    		// Look through next siblings to see if none of them are selected.
    		let noneSelected = true;

    		let el = element;

    		while (el.nextSibling) {
    			el = el.nextSibling;

    			if (el.nodeType === 1 && el.classList.contains('mdc-list-item') && el.attributes['tabindex'] && el.attributes['tabindex'].value === '0') {
    				noneSelected = false;
    				break;
    			}
    		}

    		if (noneSelected) {
    			// This is the first element, and no other element is selected, so the
    			// tabindex should be '0'.
    			$$invalidate(0, tabindex = '0');
    		}
    	}

    	function action(e) {
    		if (disabled) {
    			e.preventDefault();
    		} else {
    			dispatch('SMUI:action', e);
    		}
    	}

    	function handleKeydown(e) {
    		const isEnter = e.key === 'Enter' || e.keyCode === 13;
    		const isSpace = e.key === 'Space' || e.keyCode === 32;

    		if (isEnter || isSpace) {
    			action(e);
    		}
    	}

    	function setChecked(isChecked) {
    		$$invalidate(10, checked = isChecked);
    		$$invalidate(0, tabindex = !nonInteractive && !disabled && (selected || checked) && '0' || '-1');
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(11, element);
    		});
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(11, element);
    		});
    	}

    	function li_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(11, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('ripple' in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('nonInteractive' in $$new_props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
    		if ('activated' in $$new_props) $$invalidate(5, activated = $$new_props.activated);
    		if ('role' in $$new_props) $$invalidate(6, role = $$new_props.role);
    		if ('selected' in $$new_props) $$invalidate(7, selected = $$new_props.selected);
    		if ('disabled' in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('tabindex' in $$new_props) $$invalidate(0, tabindex = $$new_props.tabindex);
    		if ('href' in $$new_props) $$invalidate(9, href = $$new_props.href);
    		if ('inputId' in $$new_props) $$invalidate(18, inputId = $$new_props.inputId);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		counter: counter$1,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		createEventDispatcher,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		Ripple,
    		dispatch,
    		forwardEvents,
    		checked,
    		use,
    		className,
    		ripple,
    		color,
    		nonInteractive,
    		activated,
    		role,
    		selected,
    		disabled,
    		tabindex,
    		href,
    		inputId,
    		element,
    		addTabindexIfNoItemsSelectedRaf,
    		nav,
    		addTabindexIfNoItemsSelected,
    		action,
    		handleKeydown,
    		setChecked,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    		if ('checked' in $$props) $$invalidate(10, checked = $$new_props.checked);
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('ripple' in $$props) $$invalidate(3, ripple = $$new_props.ripple);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('nonInteractive' in $$props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
    		if ('activated' in $$props) $$invalidate(5, activated = $$new_props.activated);
    		if ('role' in $$props) $$invalidate(6, role = $$new_props.role);
    		if ('selected' in $$props) $$invalidate(7, selected = $$new_props.selected);
    		if ('disabled' in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('tabindex' in $$props) $$invalidate(0, tabindex = $$new_props.tabindex);
    		if ('href' in $$props) $$invalidate(9, href = $$new_props.href);
    		if ('inputId' in $$props) $$invalidate(18, inputId = $$new_props.inputId);
    		if ('element' in $$props) $$invalidate(11, element = $$new_props.element);
    		if ('addTabindexIfNoItemsSelectedRaf' in $$props) addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
    		if ('nav' in $$props) $$invalidate(14, nav = $$new_props.nav);
    		if ('props' in $$props) $$invalidate(12, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(12, props = exclude($$props, [
    			'use',
    			'class',
    			'ripple',
    			'color',
    			'nonInteractive',
    			'activated',
    			'selected',
    			'disabled',
    			'tabindex',
    			'href',
    			'inputId'
    		]));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		tabindex,
    		use,
    		className,
    		ripple,
    		color,
    		activated,
    		role,
    		selected,
    		disabled,
    		href,
    		checked,
    		element,
    		props,
    		forwardEvents,
    		nav,
    		action,
    		handleKeydown,
    		nonInteractive,
    		inputId,
    		$$scope,
    		slots,
    		a_binding,
    		span_binding,
    		li_binding
    	];
    }

    class Item$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$19, create_fragment$19, safe_not_equal, {
    			use: 1,
    			class: 2,
    			ripple: 3,
    			color: 4,
    			nonInteractive: 17,
    			activated: 5,
    			role: 6,
    			selected: 7,
    			disabled: 8,
    			tabindex: 0,
    			href: 9,
    			inputId: 18
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$19.name
    		});
    	}

    	get use() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nonInteractive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nonInteractive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activated() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activated(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\ClassAdder.svelte generated by Svelte v3.42.1 */

    // (1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class="{smuiClass} {className}"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >
    function create_default_slot$p(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class=\\\"{smuiClass} {className}\\\"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
    		},
    		{
    			class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
    		},
    		exclude(/*$$props*/ ctx[5], ['use', 'class', 'component', 'forwardEvents'])
    	];

    	var switch_value = /*component*/ ctx[2];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$p] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*forwardEvents, use, smuiClass, className, exclude, $$props*/ 59)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*forwardEvents, use*/ 17 && {
    						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
    					},
    					dirty & /*smuiClass, className*/ 10 && {
    						class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
    					},
    					dirty & /*exclude, $$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ['use', 'class', 'component', 'forwardEvents']))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 256) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const internals = {
    	component: null,
    	smuiClass: null,
    	contexts: {}
    };

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClassAdder', slots, ['default']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { component = internals.component } = $$props;
    	let { forwardEvents: smuiForwardEvents = [] } = $$props;
    	const smuiClass = internals.class;
    	const contexts = internals.contexts;
    	const forwardEvents = forwardEventsBuilder(get_current_component(), smuiForwardEvents);

    	for (let context in contexts) {
    		if (contexts.hasOwnProperty(context)) {
    			setContext(context, contexts[context]);
    		}
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('component' in $$new_props) $$invalidate(2, component = $$new_props.component);
    		if ('forwardEvents' in $$new_props) $$invalidate(6, smuiForwardEvents = $$new_props.forwardEvents);
    		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		internals,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		use,
    		className,
    		component,
    		smuiForwardEvents,
    		smuiClass,
    		contexts,
    		forwardEvents
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('component' in $$props) $$invalidate(2, component = $$new_props.component);
    		if ('smuiForwardEvents' in $$props) $$invalidate(6, smuiForwardEvents = $$new_props.smuiForwardEvents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		component,
    		smuiClass,
    		forwardEvents,
    		$$props,
    		smuiForwardEvents,
    		slots,
    		$$scope
    	];
    }

    class ClassAdder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$18, create_fragment$18, safe_not_equal, {
    			use: 0,
    			class: 1,
    			component: 2,
    			forwardEvents: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClassAdder",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get use() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get forwardEvents() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set forwardEvents(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function classAdderBuilder(props) {
      function Component(...args) {
        Object.assign(internals, props);
        return new ClassAdder(...args);
      }

      Component.prototype = ClassAdder;

      // SSR support
      if (ClassAdder.$$render) {
        Component.$$render = (...args) => Object.assign(internals, props) && ClassAdder.$$render(...args);
      }
      if (ClassAdder.render) {
        Component.render = (...args) => Object.assign(internals, props) && ClassAdder.render(...args);
      }

      return Component;
    }

    /* node_modules\@smui\common\Span.svelte generated by Svelte v3.42.1 */
    const file$10 = "node_modules\\@smui\\common\\Span.svelte";

    function create_fragment$17(ctx) {
    	let span;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let span_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$10, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, span))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Span', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class Span extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$17, create_fragment$17, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Span",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get use() {
    		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    classAdderBuilder({
      class: 'mdc-list-item__text',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__primary-text',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__secondary-text',
      component: Span,
      contexts: {}
    });

    classAdderBuilder({
      class: 'mdc-list-item__graphic',
      component: Span,
      contexts: {}
    });

    var Meta = classAdderBuilder({
      class: 'mdc-list-item__meta',
      component: Span,
      contexts: {}
    });

    /* node_modules\@smui\list\Label.svelte generated by Svelte v3.42.1 */
    const file$$ = "node_modules\\@smui\\list\\Label.svelte";

    function create_fragment$16(ctx) {
    	let label;
    	let label_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	let label_levels = [
    		{
    			class: label_class_value = "mdc-list-item__text " + /*className*/ ctx[1]
    		},
    		/*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
    		? {
    				'for': /*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
    			}
    		: {},
    		exclude(/*$$props*/ ctx[4], ['use', 'class'])
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$$, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, label))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				(!current || dirty & /*className*/ 2 && label_class_value !== (label_class_value = "mdc-list-item__text " + /*className*/ ctx[1])) && { class: label_class_value },
    				/*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
    				? {
    						'for': /*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
    					}
    				: {},
    				dirty & /*$$props*/ 16 && exclude(/*$$props*/ ctx[4], ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let inputProps = getContext('SMUI:generic:input:props') || {};

    	$$self.$$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		inputProps
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('inputProps' in $$props) $$invalidate(3, inputProps = $$new_props.inputProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, className, forwardEvents, inputProps, $$props, $$scope, slots];
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$16, create_fragment$16, safe_not_equal, { use: 0, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$16.name
    		});
    	}

    	get use() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Div.svelte generated by Svelte v3.42.1 */
    const file$_ = "node_modules\\@smui\\common\\Div.svelte";

    function create_fragment$15(ctx) {
    	let div;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$_, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Div', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class Div extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$15, create_fragment$15, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Div",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get use() {
    		throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    classAdderBuilder({
      class: 'mdc-list-group',
      component: Div,
      contexts: {}
    });

    /* node_modules\@smui\common\H3.svelte generated by Svelte v3.42.1 */
    const file$Z = "node_modules\\@smui\\common\\H3.svelte";

    function create_fragment$14(ctx) {
    	let h3;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let h3_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let h3_data = {};

    	for (let i = 0; i < h3_levels.length; i += 1) {
    		h3_data = assign(h3_data, h3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			if (default_slot) default_slot.c();
    			set_attributes(h3, h3_data);
    			add_location(h3, file$Z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);

    			if (default_slot) {
    				default_slot.m(h3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, h3, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, h3))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('H3', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class H3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$14, create_fragment$14, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "H3",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get use() {
    		throw new Error("<H3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    classAdderBuilder({
      class: 'mdc-list-group__subheader',
      component: H3,
      contexts: {}
    });

    /* node_modules\@sveltejs\svelte-virtual-list\VirtualList.svelte generated by Svelte v3.42.1 */
    const file$Y = "node_modules\\@sveltejs\\svelte-virtual-list\\VirtualList.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ item: dirty & /*visible*/ 16 });
    const get_default_slot_context = ctx => ({ item: /*row*/ ctx[23].data });

    // (166:26) Missing template
    function fallback_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Missing template");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(166:26) Missing template",
    		ctx
    	});

    	return block;
    }

    // (164:2) {#each visible as row (row.index)}
    function create_each_block$g(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-1tqh76q");
    			add_location(svelte_virtual_list_row, file$Y, 164, 3, 3469);
    			this.first = svelte_virtual_list_row;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append_dev(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, visible*/ 8208)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(164:2) {#each visible as row (row.index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[4];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[23].index;
    	validate_each_keys(ctx, each_value, get_each_context$g, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$g(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[5] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[6] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-1tqh76q");
    			add_location(svelte_virtual_list_contents, file$Y, 159, 1, 3313);
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-1tqh76q");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[17].call(svelte_virtual_list_viewport));
    			add_location(svelte_virtual_list_viewport, file$Y, 153, 0, 3167);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_viewport, anchor);
    			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[15](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[16](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[17].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible*/ 8208) {
    				each_value = /*visible*/ ctx[4];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$g, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$g, null, get_each_context$g);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 32) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[5] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[15](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[16](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VirtualList', slots, ['default']);
    	let { items } = $$props;
    	let { height = '100%' } = $$props;
    	let { itemHeight = undefined } = $$props;
    	let foo;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;

    	// local state
    	let height_map = [];

    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick(); // wait until the DOM is up to date
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(9, end = i + 1);
    				await tick(); // render the newly visible row
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(9, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(6, bottom = remaining * average_height);
    		height_map.length = items.length;
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(8, start = i);
    				$$invalidate(5, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(9, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(6, bottom = remaining * average_height);

    		// prevent jumping if we scrolled up into unknown territory
    		if (start < old_start) {
    			await tick();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	} // TODO if we overestimated the space these
    	// rows would occupy we may need to add some

    	// more. maybe we can just call handle_scroll again?
    	// trigger initial refresh
    	onMount(() => {
    		rows = contents.getElementsByTagName('svelte-virtual-list-row');
    		$$invalidate(12, mounted = true);
    	});

    	const writable_props = ['items', 'height', 'itemHeight', 'start', 'end'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualList> was created with unknown prop '${key}'`);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contents = $$value;
    			$$invalidate(3, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			viewport = $$value;
    			$$invalidate(2, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(1, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(10, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
    		if ('start' in $$props) $$invalidate(8, start = $$props.start);
    		if ('end' in $$props) $$invalidate(9, end = $$props.end);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		items,
    		height,
    		itemHeight,
    		foo,
    		start,
    		end,
    		height_map,
    		rows,
    		viewport,
    		contents,
    		viewport_height,
    		visible,
    		mounted,
    		top,
    		bottom,
    		average_height,
    		refresh,
    		handle_scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(10, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
    		if ('foo' in $$props) foo = $$props.foo;
    		if ('start' in $$props) $$invalidate(8, start = $$props.start);
    		if ('end' in $$props) $$invalidate(9, end = $$props.end);
    		if ('height_map' in $$props) height_map = $$props.height_map;
    		if ('rows' in $$props) rows = $$props.rows;
    		if ('viewport' in $$props) $$invalidate(2, viewport = $$props.viewport);
    		if ('contents' in $$props) $$invalidate(3, contents = $$props.contents);
    		if ('viewport_height' in $$props) $$invalidate(1, viewport_height = $$props.viewport_height);
    		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
    		if ('mounted' in $$props) $$invalidate(12, mounted = $$props.mounted);
    		if ('top' in $$props) $$invalidate(5, top = $$props.top);
    		if ('bottom' in $$props) $$invalidate(6, bottom = $$props.bottom);
    		if ('average_height' in $$props) average_height = $$props.average_height;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 1792) {
    			$$invalidate(4, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 7170) {
    			// whenever `items` changes, invalidate the current heightmap
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$13, create_fragment$13, safe_not_equal, {
    			items: 10,
    			height: 0,
    			itemHeight: 11,
    			start: 8,
    			end: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualList",
    			options,
    			id: create_fragment$13.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*items*/ ctx[10] === undefined && !('items' in props)) {
    			console.warn("<VirtualList> was created without expected prop 'items'");
    		}
    	}

    	get items() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\VirtualCheckList.svelte generated by Svelte v3.42.1 */
    const file$X = "src\\components\\VirtualCheckList.svelte";

    // (33:20) {#if markedFile == item.name}
    function create_if_block$v(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "b";
    			attr_dev(span, "class", "tag is-warning svelte-skfrad");
    			add_location(span, file$X, 33, 24, 617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(33:20) {#if markedFile == item.name}",
    		ctx
    	});

    	return block;
    }

    // (28:16) <Label >
    function create_default_slot_4$4(ctx) {
    	let t0;
    	let t1_value = /*item*/ ctx[7].name + "";
    	let t1;
    	let if_block = /*markedFile*/ ctx[4] == /*item*/ ctx[7].name && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*markedFile*/ ctx[4] == /*item*/ ctx[7].name) {
    				if (if_block) ; else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*item*/ 128 && t1_value !== (t1_value = /*item*/ ctx[7].name + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(28:16) <Label >",
    		ctx
    	});

    	return block;
    }

    // (38:16) <Meta>
    function create_default_slot_3$5(ctx) {
    	let checkbox;
    	let updating_group;
    	let current;

    	function checkbox_group_binding(value) {
    		/*checkbox_group_binding*/ ctx[5](value);
    	}

    	let checkbox_props = { value: /*item*/ ctx[7].name };

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		checkbox_props.group = /*fileChecked*/ ctx[0];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'group', checkbox_group_binding));
    	checkbox.$on("click", /*click_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};
    			if (dirty & /*item*/ 128) checkbox_changes.value = /*item*/ ctx[7].name;

    			if (!updating_group && dirty & /*fileChecked*/ 1) {
    				updating_group = true;
    				checkbox_changes.group = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_group = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(38:16) <Meta>",
    		ctx
    	});

    	return block;
    }

    // (27:12) <Item style="height:2.5em;">
    function create_default_slot_2$8(ctx) {
    	let label;
    	let t;
    	let meta;
    	let current;

    	label = new Label({
    			props: {
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	meta = new Meta({
    			props: {
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    			t = space();
    			create_component(meta.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(meta, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, item, markedFile*/ 400) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    			const meta_changes = {};

    			if (dirty & /*$$scope, item, fileChecked*/ 385) {
    				meta_changes.$$scope = { dirty, ctx };
    			}

    			meta.$set(meta_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			transition_in(meta.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			transition_out(meta.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(meta, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(27:12) <Item style=\\\"height:2.5em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:8) <List checklist>
    function create_default_slot_1$c(ctx) {
    	let item;
    	let current;

    	item = new Item$1({
    			props: {
    				style: "height:2.5em;",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(item.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(item, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item_changes = {};

    			if (dirty & /*$$scope, item, fileChecked, markedFile*/ 401) {
    				item_changes.$$scope = { dirty, ctx };
    			}

    			item.$set(item_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(item, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(26:8) <List checklist>",
    		ctx
    	});

    	return block;
    }

    // (24:4) <VirtualList {items} let:item {height}>
    function create_default_slot$o(ctx) {
    	let list;
    	let current;

    	list = new List({
    			props: {
    				checklist: true,
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const list_changes = {};

    			if (dirty & /*$$scope, item, fileChecked, markedFile*/ 401) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(24:4) <VirtualList {items} let:item {height}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let div;
    	let virtuallist;
    	let current;

    	virtuallist = new VirtualList({
    			props: {
    				items: /*items*/ ctx[1],
    				height: /*height*/ ctx[2],
    				$$slots: {
    					default: [
    						create_default_slot$o,
    						({ item }) => ({ 7: item }),
    						({ item }) => item ? 128 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(virtuallist.$$.fragment);
    			attr_dev(div, "style", /*style*/ ctx[3]);
    			add_location(div, file$X, 22, 0, 378);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(virtuallist, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const virtuallist_changes = {};
    			if (dirty & /*items*/ 2) virtuallist_changes.items = /*items*/ ctx[1];
    			if (dirty & /*height*/ 4) virtuallist_changes.height = /*height*/ ctx[2];

    			if (dirty & /*$$scope, item, fileChecked, markedFile*/ 401) {
    				virtuallist_changes.$$scope = { dirty, ctx };
    			}

    			virtuallist.$set(virtuallist_changes);

    			if (!current || dirty & /*style*/ 8) {
    				attr_dev(div, "style", /*style*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(virtuallist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(virtuallist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(virtuallist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VirtualCheckList', slots, []);
    	let { items = [], fileChecked = [], height = "500px", style = "", markedFile = "" } = $$props;
    	const writable_props = ['items', 'fileChecked', 'height', 'style', 'markedFile'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualCheckList> was created with unknown prop '${key}'`);
    	});

    	function checkbox_group_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('markedFile' in $$props) $$invalidate(4, markedFile = $$props.markedFile);
    	};

    	$$self.$capture_state = () => ({
    		List,
    		Item: Item$1,
    		Meta,
    		Label,
    		Checkbox,
    		VirtualList,
    		items,
    		fileChecked,
    		height,
    		style,
    		markedFile
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('style' in $$props) $$invalidate(3, style = $$props.style);
    		if ('markedFile' in $$props) $$invalidate(4, markedFile = $$props.markedFile);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		fileChecked,
    		items,
    		height,
    		style,
    		markedFile,
    		checkbox_group_binding,
    		click_handler
    	];
    }

    class VirtualCheckList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$12, create_fragment$12, safe_not_equal, {
    			items: 1,
    			fileChecked: 0,
    			height: 2,
    			style: 3,
    			markedFile: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualCheckList",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get items() {
    		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get markedFile() {
    		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set markedFile(value) {
    		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\FileBrowser.svelte generated by Svelte v3.42.1 */

    const { console: console_1$j } = globals;
    const file_1 = "src\\components\\FileBrowser.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    // (125:4) <Icon class="material-icons" on:click="{()=>changeDirectory("..")}">
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("arrow_back");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(125:4) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=>changeDirectory(\\\"..\\\")}\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:4) <Icon class="material-icons" on:click="{()=>{getfiles(true, true)}}">
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("refresh");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(126:4) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=>{getfiles(true, true)}}\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:4) <FormField>
    function create_default_slot_4$3(ctx) {
    	let switch_1;
    	let updating_checked;
    	let current;

    	function switch_1_checked_binding(value) {
    		/*switch_1_checked_binding*/ ctx[23](value);
    	}

    	let switch_1_props = {};

    	if (/*selectAll*/ ctx[7] !== void 0) {
    		switch_1_props.checked = /*selectAll*/ ctx[7];
    	}

    	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));
    	switch_1.$on("change", /*change_handler*/ ctx[24]);

    	const block = {
    		c: function create() {
    			create_component(switch_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(switch_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_1_changes = {};

    			if (!updating_checked && dirty[0] & /*selectAll*/ 128) {
    				updating_checked = true;
    				switch_1_changes.checked = /*selectAll*/ ctx[7];
    				add_flush_callback(() => updating_checked = false);
    			}

    			switch_1.$set(switch_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(switch_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(switch_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(switch_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(133:4) <FormField>",
    		ctx
    	});

    	return block;
    }

    // (136:8) 
    function create_label_slot$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Select All";
    			attr_dev(span, "slot", "label");
    			add_location(span, file_1, 135, 8, 5068);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$6.name,
    		type: "slot",
    		source: "(136:8) ",
    		ctx
    	});

    	return block;
    }

    // (144:12) <Icon class="material-icons" on>
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("keyboard_arrow_down");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(144:12) <Icon class=\\\"material-icons\\\" on>",
    		ctx
    	});

    	return block;
    }

    // (145:12) <Icon class="material-icons" >
    function create_default_slot_2$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("keyboard_arrow_right");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(145:12) <Icon class=\\\"material-icons\\\" >",
    		ctx
    	});

    	return block;
    }

    // (143:8) <IconButton  toggle bind:pressed={showfiles}>
    function create_default_slot_1$b(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon({
    			props: {
    				class: "material-icons",
    				on: true,
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon0_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				icon0_changes.$$scope = { dirty, ctx };
    			}

    			icon0.$set(icon0_changes);
    			const icon1_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				icon1_changes.$$scope = { dirty, ctx };
    			}

    			icon1.$set(icon1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(143:8) <IconButton  toggle bind:pressed={showfiles}>",
    		ctx
    	});

    	return block;
    }

    // (174:4) {:else}
    function create_else_block$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "...loading";
    			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-ujy50h");
    			add_location(div, file_1, 174, 8, 6801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(174:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (172:30) 
    function create_if_block_3$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Location doesn't exist: Browse files again";
    			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-ujy50h");
    			add_location(div, file_1, 172, 8, 6678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(172:30) ",
    		ctx
    	});

    	return block;
    }

    // (150:4) {#if files_loaded && locationStatus}
    function create_if_block$u(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	const if_block_creators = [create_if_block_1$c, create_if_block_2$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*showfiles*/ ctx[8] && /*fullfiles*/ ctx[3].length) return 0;
    		if (/*fullfiles*/ ctx[3].length <= 0) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let each_value = /*otherfolders*/ ctx[6];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*folder*/ ctx[34].id;
    	validate_each_keys(ctx, each_value, get_each_context$f, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$f(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "otherFolderlist");
    			set_style(div, "cursor", "pointer");
    			add_location(div, file_1, 162, 8, 6201);
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				} else {
    					if_block = null;
    				}
    			}

    			if (dirty[0] & /*changeDirectory, otherfolders*/ 32832) {
    				each_value = /*otherfolders*/ ctx[6];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$f, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(150:4) {#if files_loaded && locationStatus}",
    		ctx
    	});

    	return block;
    }

    // (159:40) 
    function create_if_block_2$5(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("No ");
    			t1 = text(/*filetype*/ ctx[2]);
    			t2 = text(" here!");
    			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-ujy50h");
    			add_location(div, file_1, 159, 12, 6081);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filetype*/ 4) set_data_dev(t1, /*filetype*/ ctx[2]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(159:40) ",
    		ctx
    	});

    	return block;
    }

    // (151:8) {#if showfiles && fullfiles.length }
    function create_if_block_1$c(ctx) {
    	let div;
    	let virtualchecklist;
    	let updating_fileChecked;
    	let updating_items;
    	let current;
    	let mounted;
    	let dispose;

    	function virtualchecklist_fileChecked_binding(value) {
    		/*virtualchecklist_fileChecked_binding*/ ctx[26](value);
    	}

    	function virtualchecklist_items_binding(value) {
    		/*virtualchecklist_items_binding*/ ctx[27](value);
    	}

    	let virtualchecklist_props = { markedFile: /*markedFile*/ ctx[1] };

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		virtualchecklist_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	if (/*fullfiles*/ ctx[3] !== void 0) {
    		virtualchecklist_props.items = /*fullfiles*/ ctx[3];
    	}

    	virtualchecklist = new VirtualCheckList({
    			props: virtualchecklist_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(virtualchecklist, 'fileChecked', virtualchecklist_fileChecked_binding));
    	binding_callbacks.push(() => bind(virtualchecklist, 'items', virtualchecklist_items_binding));
    	virtualchecklist.$on("click", /*click_handler_2*/ ctx[28]);
    	virtualchecklist.$on("select", /*select_handler*/ ctx[29]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(virtualchecklist.$$.fragment);
    			add_location(div, file_1, 151, 12, 5636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(virtualchecklist, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*selectRange*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const virtualchecklist_changes = {};
    			if (dirty[0] & /*markedFile*/ 2) virtualchecklist_changes.markedFile = /*markedFile*/ ctx[1];

    			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				virtualchecklist_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			if (!updating_items && dirty[0] & /*fullfiles*/ 8) {
    				updating_items = true;
    				virtualchecklist_changes.items = /*fullfiles*/ ctx[3];
    				add_flush_callback(() => updating_items = false);
    			}

    			virtualchecklist.$set(virtualchecklist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(virtualchecklist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(virtualchecklist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(virtualchecklist);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(151:8) {#if showfiles && fullfiles.length }",
    		ctx
    	});

    	return block;
    }

    // (166:20) <Icon class="material-icons">
    function create_default_slot$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("keyboard_arrow_right");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(166:20) <Icon class=\\\"material-icons\\\">",
    		ctx
    	});

    	return block;
    }

    // (164:12) {#each otherfolders as folder (folder.id)}
    function create_each_block$f(key_1, ctx) {
    	let div1;
    	let icon;
    	let t0;
    	let div0;
    	let t1_value = /*folder*/ ctx[34].name + "";
    	let t1;
    	let t2;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[30](/*folder*/ ctx[34]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div1 = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(div0, "class", "mdc-typography--subtitle1");
    			add_location(div0, file_1, 166, 20, 6515);
    			attr_dev(div1, "class", "align svelte-ujy50h");
    			add_location(div1, file_1, 164, 16, 6327);
    			this.first = div1;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(icon, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div1, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_3, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const icon_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    			if ((!current || dirty[0] & /*otherfolders*/ 64) && t1_value !== (t1_value = /*folder*/ ctx[34].name + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, true);
    					div1_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);

    			if (local) {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, false);
    				div1_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(164:12) {#each otherfolders as folder (folder.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let div0;
    	let icon0;
    	let t0;
    	let icon1;
    	let t1;
    	let customiconswitch;
    	let updating_toggler;
    	let t2;
    	let textfield;
    	let updating_value;
    	let t3;
    	let div1;
    	let formfield;
    	let t4;
    	let div4;
    	let div3;
    	let iconbutton;
    	let updating_pressed;
    	let t5;
    	let div2;
    	let t6;
    	let t7;
    	let current_block_type_index;
    	let if_block;
    	let div4_id_value;
    	let current;

    	icon0 = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon0.$on("click", /*click_handler*/ ctx[19]);

    	icon1 = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon1.$on("click", /*click_handler_1*/ ctx[20]);

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[21](value);
    	}

    	let customiconswitch_props = { icons: ["trending_up", "trending_down"] };

    	if (/*sortFile*/ ctx[4] !== void 0) {
    		customiconswitch_props.toggler = /*sortFile*/ ctx[4];
    	}

    	customiconswitch = new CustomIconSwitch$1({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[22](value);
    	}

    	let textfield_props = {
    		style: "margin-bottom:1em; width:100%; ",
    		label: "Seach"
    	};

    	if (/*searchKey*/ ctx[9] !== void 0) {
    		textfield_props.value = /*searchKey*/ ctx[9];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
    	textfield.$on("keyup", /*searchfile*/ ctx[13]);

    	formfield = new FormField({
    			props: {
    				$$slots: {
    					label: [create_label_slot$6],
    					default: [create_default_slot_4$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function iconbutton_pressed_binding(value) {
    		/*iconbutton_pressed_binding*/ ctx[25](value);
    	}

    	let iconbutton_props = {
    		toggle: true,
    		$$slots: { default: [create_default_slot_1$b] },
    		$$scope: { ctx }
    	};

    	if (/*showfiles*/ ctx[8] !== void 0) {
    		iconbutton_props.pressed = /*showfiles*/ ctx[8];
    	}

    	iconbutton = new IconButton({ props: iconbutton_props, $$inline: true });
    	binding_callbacks.push(() => bind(iconbutton, 'pressed', iconbutton_pressed_binding));
    	const if_block_creators = [create_if_block$u, create_if_block_3$2, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*files_loaded*/ ctx[10] && /*locationStatus*/ ctx[5]) return 0;
    		if (!/*locationStatus*/ ctx[5]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(icon0.$$.fragment);
    			t0 = space();
    			create_component(icon1.$$.fragment);
    			t1 = space();
    			create_component(customiconswitch.$$.fragment);
    			t2 = space();
    			create_component(textfield.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(formfield.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			div3 = element("div");
    			create_component(iconbutton.$$.fragment);
    			t5 = space();
    			div2 = element("div");
    			t6 = text(/*parentFolder*/ ctx[11]);
    			t7 = space();
    			if_block.c();
    			attr_dev(div0, "class", "align center browseIcons svelte-ujy50h");
    			add_location(div0, file_1, 123, 0, 4430);
    			attr_dev(div1, "class", "align center svelte-ujy50h");
    			add_location(div1, file_1, 131, 0, 4866);
    			attr_dev(div2, "class", "mdc-typography--subtitle1");
    			add_location(div2, file_1, 146, 8, 5461);
    			attr_dev(div3, "class", "align folderlist svelte-ujy50h");
    			add_location(div3, file_1, 141, 4, 5199);
    			attr_dev(div4, "class", "folderfile-list svelte-ujy50h");
    			attr_dev(div4, "id", div4_id_value = "" + (/*filetype*/ ctx[2] + "_filebrowser"));
    			add_location(div4, file_1, 140, 0, 5136);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(icon0, div0, null);
    			append_dev(div0, t0);
    			mount_component(icon1, div0, null);
    			append_dev(div0, t1);
    			mount_component(customiconswitch, div0, null);
    			insert_dev(target, t2, anchor);
    			mount_component(textfield, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(formfield, div1, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			mount_component(iconbutton, div3, null);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, t6);
    			append_dev(div4, t7);
    			if_blocks[current_block_type_index].m(div4, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon0_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				icon0_changes.$$scope = { dirty, ctx };
    			}

    			icon0.$set(icon0_changes);
    			const icon1_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				icon1_changes.$$scope = { dirty, ctx };
    			}

    			icon1.$set(icon1_changes);
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty[0] & /*sortFile*/ 16) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*sortFile*/ ctx[4];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*searchKey*/ 512) {
    				updating_value = true;
    				textfield_changes.value = /*searchKey*/ ctx[9];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const formfield_changes = {};

    			if (dirty[0] & /*selectAll, fileChecked, fullfiles*/ 137 | dirty[1] & /*$$scope*/ 64) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    			const iconbutton_changes = {};

    			if (dirty[1] & /*$$scope*/ 64) {
    				iconbutton_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_pressed && dirty[0] & /*showfiles*/ 256) {
    				updating_pressed = true;
    				iconbutton_changes.pressed = /*showfiles*/ ctx[8];
    				add_flush_callback(() => updating_pressed = false);
    			}

    			iconbutton.$set(iconbutton_changes);
    			if (!current || dirty[0] & /*parentFolder*/ 2048) set_data_dev(t6, /*parentFolder*/ ctx[11]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div4, null);
    			}

    			if (!current || dirty[0] & /*filetype*/ 4 && div4_id_value !== (div4_id_value = "" + (/*filetype*/ ctx[2] + "_filebrowser"))) {
    				attr_dev(div4, "id", div4_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(customiconswitch.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(formfield.$$.fragment, local);
    			transition_in(iconbutton.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(customiconswitch.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(formfield.$$.fragment, local);
    			transition_out(iconbutton.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(customiconswitch);
    			if (detaching) detach_dev(t2);
    			destroy_component(textfield, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(formfield);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div4);
    			destroy_component(iconbutton);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let locationStatus;
    	let parentFolder;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FileBrowser', slots, []);
    	let { fileChecked = [], currentLocation = "", filetype = "*.*", fullfileslist = [], markedFile = "" } = $$props;
    	const dispatch = createEventDispatcher();
    	let fullfiles = [];

    	// $: fullfileslist
    	function dispatch_chdir_event() {
    		dispatch('chdir', {
    			action: "chdir",
    			filetype,
    			currentLocation
    		});
    	}

    	let original_location = currentLocation;
    	let otherfolders = [], selectAll = false, showfiles = true, original_files = [];
    	let searchKey = "";

    	const searchfile = () => {
    		console.log(searchKey);

    		if (!searchKey) {
    			$$invalidate(3, fullfiles = original_files);
    		} else {
    			$$invalidate(3, fullfiles = original_files.filter(file => file.name.includes(searchKey)));
    		}
    	};

    	let files_loaded = false;

    	function getfiles(toast = false, keepfiles = false) {
    		if (!locationStatus) {
    			return window.createToast("Location undefined", "danger");
    		}

    		original_files = $$invalidate(6, otherfolders = $$invalidate(3, fullfiles = []));

    		if (!keepfiles) {
    			$$invalidate(0, fileChecked = []);
    		}

    		$$invalidate(7, selectAll = $$invalidate(10, files_loaded = false));

    		try {
    			console.log("Current location: ", currentLocation);
    			let folderfile = fs.readdirSync(currentLocation);
    			const fileIncludePattern = new RegExp(`.+\\.[^fr]?${filetype}`); // f or r keyword is to avoid getting fscan and rscan files
    			original_files = $$invalidate(3, fullfiles = folderfile.filter(file => fileIncludePattern.test(file) && fs.lstatSync(pathJoin(currentLocation, file)).isFile()).map(file => file = { name: file, id: getID() }).sort((a, b) => a.name < b.name ? 1 : -1));
    			$$invalidate(18, fullfileslist = fullfiles.map(file => file = file.name));
    			$$invalidate(6, otherfolders = folderfile.filter(file => fs.lstatSync(pathJoin(currentLocation, file)).isDirectory()).map(file => file = { name: file, id: getID() }).sort((a, b) => a.name > b.name ? 1 : -1));
    			original_location = currentLocation;
    			$$invalidate(10, files_loaded = true);
    			console.log("Folder updated");
    			dispatch_chdir_event();

    			if (filetype.length > 2) {
    				db.set(`${filetype}_location`, currentLocation);
    			}

    			if (toast) {
    				window.createToast("Files updated");
    			}
    		} catch(error) {
    			console.log(error);
    			window.handleError(error);
    			return;
    		}
    	}

    	let sortFile = false;

    	const changeDirectory = goto => {
    		$$invalidate(17, currentLocation = pathResolve(currentLocation, goto));
    		getfiles();
    	};

    	onMount(() => {
    		if (locationStatus) {
    			getfiles();
    			console.log("onMount Updating location for ", filetype);
    		}
    	});

    	afterUpdate(() => {
    		if (original_location !== currentLocation && locationStatus) {
    			getfiles(true);
    			console.log("Updating location for ", filetype);
    		}
    	});

    	async function selectRange(event) {
    		await tick();

    		if (event.shiftKey && fileChecked.length) {
    			const _from = fullfileslist.indexOf(fileChecked.at(0));
    			const _to = fullfileslist.indexOf(fileChecked.at(-1));

    			if (_from < _to) {
    				$$invalidate(0, fileChecked = fullfileslist.slice(_from, _to + 1));
    			} else {
    				$$invalidate(0, fileChecked = fullfileslist.slice(_to, _from + 1));
    			}
    		}
    	}

    	const writable_props = ['fileChecked', 'currentLocation', 'filetype', 'fullfileslist', 'markedFile'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$j.warn(`<FileBrowser> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => changeDirectory("..");

    	const click_handler_1 = () => {
    		getfiles(true, true);
    	};

    	function customiconswitch_toggler_binding(value) {
    		sortFile = value;
    		$$invalidate(4, sortFile);
    	}

    	function textfield_value_binding(value) {
    		searchKey = value;
    		$$invalidate(9, searchKey);
    	}

    	function switch_1_checked_binding(value) {
    		selectAll = value;
    		$$invalidate(7, selectAll);
    	}

    	const change_handler = () => selectAll
    	? $$invalidate(0, fileChecked = fullfiles.map(file => file = file.name))
    	: $$invalidate(0, fileChecked = []);

    	function iconbutton_pressed_binding(value) {
    		showfiles = value;
    		$$invalidate(8, showfiles);
    	}

    	function virtualchecklist_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	function virtualchecklist_items_binding(value) {
    		fullfiles = value;
    		($$invalidate(3, fullfiles), $$invalidate(4, sortFile));
    	}

    	const click_handler_2 = e => {
    		$$invalidate(7, selectAll = false);

    		if (e.ctrlKey && filetype.includes("felix")) {
    			$$invalidate(1, markedFile = e.target.value);
    			dispatch('markedFile', { markedFile });
    		}
    	};

    	const select_handler = e => console.log(e);
    	const click_handler_3 = folder => changeDirectory(folder.name);

    	$$self.$$set = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(17, currentLocation = $$props.currentLocation);
    		if ('filetype' in $$props) $$invalidate(2, filetype = $$props.filetype);
    		if ('fullfileslist' in $$props) $$invalidate(18, fullfileslist = $$props.fullfileslist);
    		if ('markedFile' in $$props) $$invalidate(1, markedFile = $$props.markedFile);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		IconButton,
    		Icon,
    		slide,
    		FormField,
    		Switch,
    		Textfield,
    		tick,
    		onMount,
    		afterUpdate,
    		CustomIconSwitch: CustomIconSwitch$1,
    		VirtualCheckList,
    		createEventDispatcher,
    		fileChecked,
    		currentLocation,
    		filetype,
    		fullfileslist,
    		markedFile,
    		dispatch,
    		fullfiles,
    		dispatch_chdir_event,
    		original_location,
    		otherfolders,
    		selectAll,
    		showfiles,
    		original_files,
    		searchKey,
    		searchfile,
    		files_loaded,
    		getfiles,
    		sortFile,
    		changeDirectory,
    		selectRange,
    		locationStatus,
    		parentFolder
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(17, currentLocation = $$props.currentLocation);
    		if ('filetype' in $$props) $$invalidate(2, filetype = $$props.filetype);
    		if ('fullfileslist' in $$props) $$invalidate(18, fullfileslist = $$props.fullfileslist);
    		if ('markedFile' in $$props) $$invalidate(1, markedFile = $$props.markedFile);
    		if ('fullfiles' in $$props) $$invalidate(3, fullfiles = $$props.fullfiles);
    		if ('original_location' in $$props) original_location = $$props.original_location;
    		if ('otherfolders' in $$props) $$invalidate(6, otherfolders = $$props.otherfolders);
    		if ('selectAll' in $$props) $$invalidate(7, selectAll = $$props.selectAll);
    		if ('showfiles' in $$props) $$invalidate(8, showfiles = $$props.showfiles);
    		if ('original_files' in $$props) original_files = $$props.original_files;
    		if ('searchKey' in $$props) $$invalidate(9, searchKey = $$props.searchKey);
    		if ('files_loaded' in $$props) $$invalidate(10, files_loaded = $$props.files_loaded);
    		if ('sortFile' in $$props) $$invalidate(4, sortFile = $$props.sortFile);
    		if ('locationStatus' in $$props) $$invalidate(5, locationStatus = $$props.locationStatus);
    		if ('parentFolder' in $$props) $$invalidate(11, parentFolder = $$props.parentFolder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*currentLocation*/ 131072) {
    			$$invalidate(5, locationStatus = fs.existsSync(currentLocation));
    		}

    		if ($$self.$$.dirty[0] & /*locationStatus, currentLocation*/ 131104) {
    			$$invalidate(11, parentFolder = locationStatus ? basename(currentLocation) : "Undefined");
    		}

    		if ($$self.$$.dirty[0] & /*sortFile, fullfiles*/ 24) {
    			sortFile
    			? $$invalidate(3, fullfiles = fullfiles.sort((a, b) => a.name > b.name ? 1 : -1))
    			: $$invalidate(3, fullfiles = fullfiles.sort((a, b) => a.name < b.name ? 1 : -1));
    		}
    	};

    	return [
    		fileChecked,
    		markedFile,
    		filetype,
    		fullfiles,
    		sortFile,
    		locationStatus,
    		otherfolders,
    		selectAll,
    		showfiles,
    		searchKey,
    		files_loaded,
    		parentFolder,
    		dispatch,
    		searchfile,
    		getfiles,
    		changeDirectory,
    		selectRange,
    		currentLocation,
    		fullfileslist,
    		click_handler,
    		click_handler_1,
    		customiconswitch_toggler_binding,
    		textfield_value_binding,
    		switch_1_checked_binding,
    		change_handler,
    		iconbutton_pressed_binding,
    		virtualchecklist_fileChecked_binding,
    		virtualchecklist_items_binding,
    		click_handler_2,
    		select_handler,
    		click_handler_3
    	];
    }

    class FileBrowser extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$11,
    			create_fragment$11,
    			safe_not_equal,
    			{
    				fileChecked: 0,
    				currentLocation: 17,
    				filetype: 2,
    				fullfileslist: 18,
    				markedFile: 1
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FileBrowser",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get fileChecked() {
    		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentLocation() {
    		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filetype() {
    		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filetype(value) {
    		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullfileslist() {
    		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullfileslist(value) {
    		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get markedFile() {
    		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set markedFile(value) {
    		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Modal.svelte generated by Svelte v3.42.1 */

    const { window: window_1$1 } = globals;
    const file$W = "src\\components\\Modal.svelte";
    const get_footerbtn_slot_changes$1 = dirty => ({});
    const get_footerbtn_slot_context$1 = ctx => ({});
    const get_content_slot_changes$1 = dirty => ({});
    const get_content_slot_context$1 = ctx => ({ style: "white-space: pre-wrap;" });

    // (34:4) {#if $$slots.footerbtn}
    function create_if_block$t(ctx) {
    	let footer;
    	let div;
    	let current;
    	const footerbtn_slot_template = /*#slots*/ ctx[10].footerbtn;
    	const footerbtn_slot = create_slot(footerbtn_slot_template, ctx, /*$$scope*/ ctx[9], get_footerbtn_slot_context$1);

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			div = element("div");
    			if (footerbtn_slot) footerbtn_slot.c();
    			set_style(div, "margin-left", "auto");
    			set_style(div, "display", "flex");
    			add_location(div, file$W, 36, 8, 1336);
    			attr_dev(footer, "class", "modal-card-foot");
    			add_location(footer, file$W, 35, 4, 1294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			append_dev(footer, div);

    			if (footerbtn_slot) {
    				footerbtn_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footerbtn_slot) {
    				if (footerbtn_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						footerbtn_slot,
    						footerbtn_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(footerbtn_slot_template, /*$$scope*/ ctx[9], dirty, get_footerbtn_slot_changes$1),
    						get_footerbtn_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footerbtn_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footerbtn_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if (footerbtn_slot) footerbtn_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(34:4) {#if $$slots.footerbtn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let header;
    	let p;
    	let t1;
    	let t2;
    	let span;
    	let t3;
    	let section;
    	let section_style_value;
    	let section_id_value;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;
    	const content_slot_template = /*#slots*/ ctx[10].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[9], get_content_slot_context$1);
    	let if_block = /*$$slots*/ ctx[8].footerbtn && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			t1 = text(/*title*/ ctx[1]);
    			t2 = space();
    			span = element("span");
    			t3 = space();
    			section = element("section");
    			if (content_slot) content_slot.c();
    			t4 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "modal-background");
    			add_location(div0, file$W, 22, 2, 708);
    			attr_dev(p, "class", "modal-card-title svelte-eip82y");
    			add_location(p, file$W, 27, 6, 899);
    			attr_dev(span, "class", "delete is-pulled-right svelte-eip82y");
    			add_location(span, file$W, 28, 6, 946);
    			attr_dev(header, "class", "modal-card-head");
    			set_style(header, "background-color", /*headerBackground*/ ctx[6]);
    			add_location(header, file$W, 26, 4, 813);
    			attr_dev(section, "class", "modal-card-body svelte-eip82y");
    			attr_dev(section, "style", section_style_value = "background: " + /*bodyBackground*/ ctx[3] + "; " + /*bodyStyle*/ ctx[4]);
    			attr_dev(section, "id", section_id_value = /*contentID*/ ctx[5] || window.getID());
    			add_location(section, file$W, 31, 4, 1076);
    			attr_dev(div1, "class", "modal-card animated fadeIn faster");
    			attr_dev(div1, "style", /*style*/ ctx[2]);
    			add_location(div1, file$W, 23, 2, 748);
    			attr_dev(div2, "class", "modal");
    			toggle_class(div2, "is-active", /*active*/ ctx[0]);
    			add_location(div2, file$W, 21, 0, 660);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, header);
    			append_dev(header, p);
    			append_dev(p, t1);
    			append_dev(header, t2);
    			append_dev(header, span);
    			append_dev(div1, t3);
    			append_dev(div1, section);

    			if (content_slot) {
    				content_slot.m(section, null);
    			}

    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1$1, "keydown", /*keydown_handler*/ ctx[11], false, false, false),
    					listen_dev(span, "click", /*click_handler*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);

    			if (!current || dirty & /*headerBackground*/ 64) {
    				set_style(header, "background-color", /*headerBackground*/ ctx[6]);
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[9], dirty, get_content_slot_changes$1),
    						get_content_slot_context$1
    					);
    				}
    			}

    			if (!current || dirty & /*bodyBackground, bodyStyle*/ 24 && section_style_value !== (section_style_value = "background: " + /*bodyBackground*/ ctx[3] + "; " + /*bodyStyle*/ ctx[4])) {
    				attr_dev(section, "style", section_style_value);
    			}

    			if (!current || dirty & /*contentID*/ 32 && section_id_value !== (section_id_value = /*contentID*/ ctx[5] || window.getID())) {
    				attr_dev(section, "id", section_id_value);
    			}

    			if (/*$$slots*/ ctx[8].footerbtn) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div1, "style", /*style*/ ctx[2]);
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div2, "is-active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (content_slot) content_slot.d(detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['content','footerbtn']);
    	const $$slots = compute_slots(slots);
    	let { active = false, title = "Title", style = "width:60vw", bodyBackground = "#634e96", bodyStyle = "max-height: 30em; height: 30em", contentID = "" } = $$props;
    	let { headerBackground = "#836ac05c" } = $$props;
    	const dispatch = createEventDispatcher();

    	const writable_props = [
    		'active',
    		'title',
    		'style',
    		'bodyBackground',
    		'bodyStyle',
    		'contentID',
    		'headerBackground'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	const keydown_handler = e => {
    		if (e.keyCode === 27) $$invalidate(0, active = false);
    	};

    	const click_handler = () => {
    		$$invalidate(0, active = false);
    		dispatch('closed', { active });
    	};

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('bodyBackground' in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
    		if ('bodyStyle' in $$props) $$invalidate(4, bodyStyle = $$props.bodyStyle);
    		if ('contentID' in $$props) $$invalidate(5, contentID = $$props.contentID);
    		if ('headerBackground' in $$props) $$invalidate(6, headerBackground = $$props.headerBackground);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		active,
    		title,
    		style,
    		bodyBackground,
    		bodyStyle,
    		contentID,
    		headerBackground,
    		dispatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('bodyBackground' in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
    		if ('bodyStyle' in $$props) $$invalidate(4, bodyStyle = $$props.bodyStyle);
    		if ('contentID' in $$props) $$invalidate(5, contentID = $$props.contentID);
    		if ('headerBackground' in $$props) $$invalidate(6, headerBackground = $$props.headerBackground);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		title,
    		style,
    		bodyBackground,
    		bodyStyle,
    		contentID,
    		headerBackground,
    		dispatch,
    		$$slots,
    		$$scope,
    		slots,
    		keydown_handler,
    		click_handler
    	];
    }

    class Modal$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$10, create_fragment$10, safe_not_equal, {
    			active: 0,
    			title: 1,
    			style: 2,
    			bodyBackground: 3,
    			bodyStyle: 4,
    			contentID: 5,
    			headerBackground: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get active() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bodyBackground() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bodyBackground(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bodyStyle() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bodyStyle(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentID() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentID(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerBackground() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerBackground(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Layout.svelte generated by Svelte v3.42.1 */

    const { console: console_1$i } = globals;
    const file$V = "src\\components\\Layout.svelte";
    const get_config_slot_changes = dirty => ({});
    const get_config_slot_context = ctx => ({});
    const get_plotContainer_reports_slot_changes = dirty => ({});
    const get_plotContainer_reports_slot_context = ctx => ({});
    const get_plotContainer_functions_slot_changes = dirty => ({});
    const get_plotContainer_functions_slot_context = ctx => ({});
    const get_plotContainer_slot_changes = dirty => ({});
    const get_plotContainer_slot_context = ctx => ({ lookForGraph: /*lookForGraph*/ ctx[12] });
    const get_buttonContainer_slot_changes = dirty => ({});
    const get_buttonContainer_slot_context = ctx => ({});

    // (132:16) <IconButton class="material-icons" on:click={() => activateConfigModal=true} >
    function create_default_slot$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("build");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(132:16) <IconButton class=\\\"material-icons\\\" on:click={() => activateConfigModal=true} >",
    		ctx
    	});

    	return block;
    }

    // (138:16) {#if graphPlotted}
    function create_if_block_2$4(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Graph:Open separately";
    			attr_dev(button, "class", "button is-warning animated fadeIn");
    			add_location(button, file$V, 138, 20, 4659);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*openGraph*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(138:16) {#if graphPlotted}",
    		ctx
    	});

    	return block;
    }

    // (148:16) {#if graphPlotted}
    function create_if_block_1$b(ctx) {
    	let t;
    	let current;
    	const plotContainer_functions_slot_template = /*#slots*/ ctx[16].plotContainer_functions;
    	const plotContainer_functions_slot = create_slot(plotContainer_functions_slot_template, ctx, /*$$scope*/ ctx[30], get_plotContainer_functions_slot_context);
    	const plotContainer_reports_slot_template = /*#slots*/ ctx[16].plotContainer_reports;
    	const plotContainer_reports_slot = create_slot(plotContainer_reports_slot_template, ctx, /*$$scope*/ ctx[30], get_plotContainer_reports_slot_context);

    	const block = {
    		c: function create() {
    			if (plotContainer_functions_slot) plotContainer_functions_slot.c();
    			t = space();
    			if (plotContainer_reports_slot) plotContainer_reports_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (plotContainer_functions_slot) {
    				plotContainer_functions_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (plotContainer_reports_slot) {
    				plotContainer_reports_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (plotContainer_functions_slot) {
    				if (plotContainer_functions_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						plotContainer_functions_slot,
    						plotContainer_functions_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(plotContainer_functions_slot_template, /*$$scope*/ ctx[30], dirty, get_plotContainer_functions_slot_changes),
    						get_plotContainer_functions_slot_context
    					);
    				}
    			}

    			if (plotContainer_reports_slot) {
    				if (plotContainer_reports_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						plotContainer_reports_slot,
    						plotContainer_reports_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(plotContainer_reports_slot_template, /*$$scope*/ ctx[30], dirty, get_plotContainer_reports_slot_changes),
    						get_plotContainer_reports_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(plotContainer_functions_slot, local);
    			transition_in(plotContainer_reports_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(plotContainer_functions_slot, local);
    			transition_out(plotContainer_reports_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (plotContainer_functions_slot) plotContainer_functions_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (plotContainer_reports_slot) plotContainer_reports_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(148:16) {#if graphPlotted}",
    		ctx
    	});

    	return block;
    }

    // (156:8) {#if activateConfigModal}
    function create_if_block$s(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[29](value);
    	}

    	let modal_props = {
    		title: "" + (/*filetype*/ ctx[5].toUpperCase() + " Settings"),
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$6],
    			content: [create_content_slot$8]
    		},
    		$$scope: { ctx }
    	};

    	if (/*activateConfigModal*/ ctx[3] !== void 0) {
    		modal_props.active = /*activateConfigModal*/ ctx[3];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};
    			if (dirty[0] & /*filetype*/ 32) modal_changes.title = "" + (/*filetype*/ ctx[5].toUpperCase() + " Settings");

    			if (dirty[0] & /*$$scope, filetype*/ 1073741856) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty[0] & /*activateConfigModal*/ 8) {
    				updating_active = true;
    				modal_changes.active = /*activateConfigModal*/ ctx[3];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(156:8) {#if activateConfigModal}",
    		ctx
    	});

    	return block;
    }

    // (158:16) <svelte:fragment slot="content">
    function create_content_slot$8(ctx) {
    	let current;
    	const config_slot_template = /*#slots*/ ctx[16].config;
    	const config_slot = create_slot(config_slot_template, ctx, /*$$scope*/ ctx[30], get_config_slot_context);

    	const block = {
    		c: function create() {
    			if (config_slot) config_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (config_slot) {
    				config_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (config_slot) {
    				if (config_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						config_slot,
    						config_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(config_slot_template, /*$$scope*/ ctx[30], dirty, get_config_slot_changes),
    						get_config_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(config_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(config_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (config_slot) config_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$8.name,
    		type: "slot",
    		source: "(158:16) <svelte:fragment slot=\\\"content\\\">",
    		ctx
    	});

    	return block;
    }

    // (161:16) <svelte:fragment slot="footerbtn">
    function create_footerbtn_slot$6(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Save";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$V, 161, 20, 5591);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[28], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$6.name,
    		type: "slot",
    		source: "(161:16) <svelte:fragment slot=\\\"footerbtn\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let section;
    	let div5;
    	let div0;
    	let filebrowser;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let updating_fullfileslist;
    	let div0_transition;
    	let t0;
    	let div4;
    	let div1;
    	let button;
    	let t1;
    	let button_id_value;
    	let t2;
    	let textfield;
    	let updating_value;
    	let t3;
    	let iconbutton;
    	let t4;
    	let div2;
    	let t5;
    	let div2_id_value;
    	let t6;
    	let div3;
    	let t7;
    	let div3_id_value;
    	let div3_resize_listener;
    	let div3_transition;
    	let div4_id_value;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;

    	function filebrowser_currentLocation_binding(value) {
    		/*filebrowser_currentLocation_binding*/ ctx[17](value);
    	}

    	function filebrowser_fileChecked_binding(value) {
    		/*filebrowser_fileChecked_binding*/ ctx[18](value);
    	}

    	function filebrowser_fullfileslist_binding(value) {
    		/*filebrowser_fullfileslist_binding*/ ctx[19](value);
    	}

    	let filebrowser_props = { filetype: /*filetype*/ ctx[5] };

    	if (/*currentLocation*/ ctx[2] !== void 0) {
    		filebrowser_props.currentLocation = /*currentLocation*/ ctx[2];
    	}

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		filebrowser_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	if (/*fullfileslist*/ ctx[1] !== void 0) {
    		filebrowser_props.fullfileslist = /*fullfileslist*/ ctx[1];
    	}

    	filebrowser = new FileBrowser({ props: filebrowser_props, $$inline: true });
    	binding_callbacks.push(() => bind(filebrowser, 'currentLocation', filebrowser_currentLocation_binding));
    	binding_callbacks.push(() => bind(filebrowser, 'fileChecked', filebrowser_fileChecked_binding));
    	binding_callbacks.push(() => bind(filebrowser, 'fullfileslist', filebrowser_fullfileslist_binding));
    	filebrowser.$on("chdir", /*chdir_handler*/ ctx[20]);
    	filebrowser.$on("markedFile", /*markedFile_handler*/ ctx[21]);

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[24](value);
    	}

    	let textfield_props = {
    		label: "Current location",
    		style: "width:100%; "
    	};

    	if (/*currentLocation*/ ctx[2] !== void 0) {
    		textfield_props.value = /*currentLocation*/ ctx[2];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	iconbutton = new IconButton({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	iconbutton.$on("click", /*click_handler*/ ctx[25]);
    	const buttonContainer_slot_template = /*#slots*/ ctx[16].buttonContainer;
    	const buttonContainer_slot = create_slot(buttonContainer_slot_template, ctx, /*$$scope*/ ctx[30], get_buttonContainer_slot_context);
    	let if_block0 = /*graphPlotted*/ ctx[6] && create_if_block_2$4(ctx);
    	const plotContainer_slot_template = /*#slots*/ ctx[16].plotContainer;
    	const plotContainer_slot = create_slot(plotContainer_slot_template, ctx, /*$$scope*/ ctx[30], get_plotContainer_slot_context);
    	let if_block1 = /*graphPlotted*/ ctx[6] && create_if_block_1$b(ctx);
    	let if_block2 = /*activateConfigModal*/ ctx[3] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div5 = element("div");
    			div0 = element("div");
    			create_component(filebrowser.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			div1 = element("div");
    			button = element("button");
    			t1 = text("Browse");
    			t2 = space();
    			create_component(textfield.$$.fragment);
    			t3 = space();
    			create_component(iconbutton.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			if (buttonContainer_slot) buttonContainer_slot.c();
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			div3 = element("div");
    			if (plotContainer_slot) plotContainer_slot.c();
    			t7 = space();
    			if (if_block1) if_block1.c();
    			t8 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div0, "class", "interact left_container__div box  svelte-ds15ez");
    			add_location(div0, file$V, 120, 8, 3670);
    			attr_dev(button, "class", "button is-link");
    			attr_dev(button, "id", button_id_value = "" + (/*filetype*/ ctx[5] + "_filebrowser_btn"));
    			add_location(button, file$V, 128, 16, 4126);
    			attr_dev(div1, "class", "location__div svelte-ds15ez");
    			add_location(div1, file$V, 127, 12, 4080);
    			attr_dev(div2, "class", "button__div align");
    			attr_dev(div2, "id", div2_id_value = "" + (/*filetype*/ ctx[5] + "-buttonContainer"));
    			add_location(div2, file$V, 134, 12, 4486);
    			attr_dev(div3, "class", "plot__div svelte-ds15ez");
    			attr_dev(div3, "id", div3_id_value = "" + (/*filetype*/ ctx[5] + "-plotContainer"));
    			add_render_callback(() => /*div3_elementresize_handler*/ ctx[26].call(div3));
    			add_location(div3, file$V, 144, 12, 4823);
    			attr_dev(div4, "class", "right_container__div box  svelte-ds15ez");
    			attr_dev(div4, "id", div4_id_value = "" + (/*filetype*/ ctx[5] + "__mainContainer__div"));
    			add_location(div4, file$V, 125, 8, 3988);
    			attr_dev(div5, "class", "main__layout__div svelte-ds15ez");
    			add_location(div5, file$V, 119, 4, 3629);
    			attr_dev(section, "id", /*id*/ ctx[4]);
    			set_style(section, "display", "none");
    			attr_dev(section, "class", "animated fadeIn");
    			add_location(section, file$V, 117, 0, 3562);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div5);
    			append_dev(div5, div0);
    			mount_component(filebrowser, div0, null);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, button);
    			append_dev(button, t1);
    			append_dev(div1, t2);
    			mount_component(textfield, div1, null);
    			append_dev(div1, t3);
    			mount_component(iconbutton, div1, null);
    			append_dev(div4, t4);
    			append_dev(div4, div2);

    			if (buttonContainer_slot) {
    				buttonContainer_slot.m(div2, null);
    			}

    			append_dev(div2, t5);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div4, t6);
    			append_dev(div4, div3);

    			if (plotContainer_slot) {
    				plotContainer_slot.m(div3, null);
    			}

    			append_dev(div3, t7);
    			if (if_block1) if_block1.m(div3, null);
    			div3_resize_listener = add_resize_listener(div3, /*div3_elementresize_handler*/ ctx[26].bind(div3));
    			/*div3_binding*/ ctx[27](div3);
    			append_dev(div5, t8);
    			if (if_block2) if_block2.m(div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "mouseup", /*mouseup_handler*/ ctx[22], false, false, false),
    					listen_dev(div0, "mousedown", /*mousedown_handler*/ ctx[23], false, false, false),
    					listen_dev(button, "click", /*browse_folder*/ ctx[11], false, false, false),
    					action_destroyer(/*lookForGraph*/ ctx[12].call(null, div3))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const filebrowser_changes = {};
    			if (dirty[0] & /*filetype*/ 32) filebrowser_changes.filetype = /*filetype*/ ctx[5];

    			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 4) {
    				updating_currentLocation = true;
    				filebrowser_changes.currentLocation = /*currentLocation*/ ctx[2];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				filebrowser_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			if (!updating_fullfileslist && dirty[0] & /*fullfileslist*/ 2) {
    				updating_fullfileslist = true;
    				filebrowser_changes.fullfileslist = /*fullfileslist*/ ctx[1];
    				add_flush_callback(() => updating_fullfileslist = false);
    			}

    			filebrowser.$set(filebrowser_changes);

    			if (!current || dirty[0] & /*filetype*/ 32 && button_id_value !== (button_id_value = "" + (/*filetype*/ ctx[5] + "_filebrowser_btn"))) {
    				attr_dev(button, "id", button_id_value);
    			}

    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*currentLocation*/ 4) {
    				updating_value = true;
    				textfield_changes.value = /*currentLocation*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const iconbutton_changes = {};

    			if (dirty[0] & /*$$scope*/ 1073741824) {
    				iconbutton_changes.$$scope = { dirty, ctx };
    			}

    			iconbutton.$set(iconbutton_changes);

    			if (buttonContainer_slot) {
    				if (buttonContainer_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						buttonContainer_slot,
    						buttonContainer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(buttonContainer_slot_template, /*$$scope*/ ctx[30], dirty, get_buttonContainer_slot_changes),
    						get_buttonContainer_slot_context
    					);
    				}
    			}

    			if (/*graphPlotted*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					if_block0.m(div2, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*filetype*/ 32 && div2_id_value !== (div2_id_value = "" + (/*filetype*/ ctx[5] + "-buttonContainer"))) {
    				attr_dev(div2, "id", div2_id_value);
    			}

    			if (plotContainer_slot) {
    				if (plotContainer_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						plotContainer_slot,
    						plotContainer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(plotContainer_slot_template, /*$$scope*/ ctx[30], dirty, get_plotContainer_slot_changes),
    						get_plotContainer_slot_context
    					);
    				}
    			}

    			if (/*graphPlotted*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*graphPlotted*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*filetype*/ 32 && div3_id_value !== (div3_id_value = "" + (/*filetype*/ ctx[5] + "-plotContainer"))) {
    				attr_dev(div3, "id", div3_id_value);
    			}

    			if (!current || dirty[0] & /*filetype*/ 32 && div4_id_value !== (div4_id_value = "" + (/*filetype*/ ctx[5] + "__mainContainer__div"))) {
    				attr_dev(div4, "id", div4_id_value);
    			}

    			if (/*activateConfigModal*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*activateConfigModal*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$s(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div5, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*id*/ 16) {
    				attr_dev(section, "id", /*id*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filebrowser.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fly, { x: -100, duration: 500 }, true);
    				div0_transition.run(1);
    			});

    			transition_in(textfield.$$.fragment, local);
    			transition_in(iconbutton.$$.fragment, local);
    			transition_in(buttonContainer_slot, local);
    			transition_in(plotContainer_slot, local);
    			transition_in(if_block1);

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, true);
    				div3_transition.run(1);
    			});

    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filebrowser.$$.fragment, local);
    			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fly, { x: -100, duration: 500 }, false);
    			div0_transition.run(0);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(iconbutton.$$.fragment, local);
    			transition_out(buttonContainer_slot, local);
    			transition_out(plotContainer_slot, local);
    			transition_out(if_block1);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, false);
    			div3_transition.run(0);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(filebrowser);
    			if (detaching && div0_transition) div0_transition.end();
    			destroy_component(textfield);
    			destroy_component(iconbutton);
    			if (buttonContainer_slot) buttonContainer_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (plotContainer_slot) plotContainer_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			div3_resize_listener();
    			/*div3_binding*/ ctx[27](null);
    			if (detaching && div3_transition) div3_transition.end();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function browse({ filetype = "", dir = true, multiple = true } = {}) {
    	let type;
    	dir ? type = "openDirectory" : type = "openFile";

    	const options = {
    		filters: [
    			{
    				name: filetype,
    				extensions: [`*${filetype}`]
    			},
    			{ name: 'All Files', extensions: ['*'] }
    		],
    		properties: [type, multiple ? "multiSelections" : ""]
    	};

    	const { showOpenDialogSync } = dialogs;
    	const result = await showOpenDialogSync(options);
    	return result;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('Layout', slots, [
    		'buttonContainer','plotContainer','plotContainer_functions','plotContainer_reports','config'
    	]);

    	let { id, fileChecked = [], filetype = "felix", toggleBrowser = false, fullfileslist = [] } = $$props;
    	let { currentLocation = db.get(`${filetype}_location`) || "", graphPlotted = false } = $$props;
    	let { graphWindowClasses = ["no-full"] } = $$props;
    	let { activateConfigModal = false } = $$props;
    	const dispatch = createEventDispatcher();

    	async function browse_folder() {
    		const result = await browse({ dir: true });

    		if (result) {
    			$$invalidate(2, currentLocation = result[0]);
    			db.set(`${filetype}_location`, currentLocation);
    			console.log(result, currentLocation);
    		}
    	}

    	let graphDivs = [];

    	onMount(() => {
    		$$invalidate(14, toggleBrowser = true);
    	});

    	let graphContainer;

    	const lookForGraph = () => {
    		try {
    			graphDivs = Array.from(document.querySelectorAll(`#${filetype}-plotContainer .graph__div`));
    		} catch(error) {
    			console.log(error);
    		}
    	};

    	function openGraph() {
    		const mount = document.getElementById(`${filetype}-plotContainer`);

    		const graphWindow = new WinBox({
    				class: graphWindowClasses,
    				root: document.getElementById("pageContainer"),
    				mount,
    				title: `Modal: ${filetype}`,
    				x: "center",
    				y: "center",
    				width: "70%",
    				height: "70%",
    				background: "#634e96",
    				top: 50,
    				bottom: 50
    			});

    		graphWindow.maximize(true);
    	}

    	let plotWidth;

    	const changeGraphDivWidth = async () => {
    		await tick();

    		graphDivs.forEach(id => {
    			if (id.data) {
    				Plotly.relayout(id, { width: id.clientWidth });
    			}
    		});
    	};

    	
    	let mouseReleased = true;

    	const writable_props = [
    		'id',
    		'fileChecked',
    		'filetype',
    		'toggleBrowser',
    		'fullfileslist',
    		'currentLocation',
    		'graphPlotted',
    		'graphWindowClasses',
    		'activateConfigModal'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$i.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	function filebrowser_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(2, currentLocation);
    	}

    	function filebrowser_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	function filebrowser_fullfileslist_binding(value) {
    		fullfileslist = value;
    		$$invalidate(1, fullfileslist);
    	}

    	function chdir_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function markedFile_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const mouseup_handler = () => $$invalidate(8, mouseReleased = true);
    	const mousedown_handler = () => $$invalidate(8, mouseReleased = false);

    	function textfield_value_binding(value) {
    		currentLocation = value;
    		$$invalidate(2, currentLocation);
    	}

    	const click_handler = () => $$invalidate(3, activateConfigModal = true);

    	function div3_elementresize_handler() {
    		plotWidth = this.clientWidth;
    		$$invalidate(7, plotWidth);
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			graphContainer = $$value;
    			$$invalidate(9, graphContainer);
    		});
    	}

    	const click_handler_1 = () => {
    		dispatch('configSave', { filetype });
    	};

    	function modal_active_binding(value) {
    		activateConfigModal = value;
    		$$invalidate(3, activateConfigModal);
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(4, id = $$props.id);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('filetype' in $$props) $$invalidate(5, filetype = $$props.filetype);
    		if ('toggleBrowser' in $$props) $$invalidate(14, toggleBrowser = $$props.toggleBrowser);
    		if ('fullfileslist' in $$props) $$invalidate(1, fullfileslist = $$props.fullfileslist);
    		if ('currentLocation' in $$props) $$invalidate(2, currentLocation = $$props.currentLocation);
    		if ('graphPlotted' in $$props) $$invalidate(6, graphPlotted = $$props.graphPlotted);
    		if ('graphWindowClasses' in $$props) $$invalidate(15, graphWindowClasses = $$props.graphWindowClasses);
    		if ('activateConfigModal' in $$props) $$invalidate(3, activateConfigModal = $$props.activateConfigModal);
    		if ('$$scope' in $$props) $$invalidate(30, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		browse,
    		fly,
    		fade,
    		Textfield,
    		onMount,
    		tick,
    		FileBrowser,
    		Modal: Modal$1,
    		createEventDispatcher,
    		IconButton,
    		id,
    		fileChecked,
    		filetype,
    		toggleBrowser,
    		fullfileslist,
    		currentLocation,
    		graphPlotted,
    		graphWindowClasses,
    		activateConfigModal,
    		dispatch,
    		browse_folder,
    		graphDivs,
    		graphContainer,
    		lookForGraph,
    		openGraph,
    		plotWidth,
    		changeGraphDivWidth,
    		mouseReleased
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(4, id = $$props.id);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('filetype' in $$props) $$invalidate(5, filetype = $$props.filetype);
    		if ('toggleBrowser' in $$props) $$invalidate(14, toggleBrowser = $$props.toggleBrowser);
    		if ('fullfileslist' in $$props) $$invalidate(1, fullfileslist = $$props.fullfileslist);
    		if ('currentLocation' in $$props) $$invalidate(2, currentLocation = $$props.currentLocation);
    		if ('graphPlotted' in $$props) $$invalidate(6, graphPlotted = $$props.graphPlotted);
    		if ('graphWindowClasses' in $$props) $$invalidate(15, graphWindowClasses = $$props.graphWindowClasses);
    		if ('activateConfigModal' in $$props) $$invalidate(3, activateConfigModal = $$props.activateConfigModal);
    		if ('graphDivs' in $$props) graphDivs = $$props.graphDivs;
    		if ('graphContainer' in $$props) $$invalidate(9, graphContainer = $$props.graphContainer);
    		if ('plotWidth' in $$props) $$invalidate(7, plotWidth = $$props.plotWidth);
    		if ('mouseReleased' in $$props) $$invalidate(8, mouseReleased = $$props.mouseReleased);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*plotWidth, mouseReleased*/ 384) {
    			if (plotWidth && mouseReleased) {
    				changeGraphDivWidth();
    			}
    		}
    	};

    	return [
    		fileChecked,
    		fullfileslist,
    		currentLocation,
    		activateConfigModal,
    		id,
    		filetype,
    		graphPlotted,
    		plotWidth,
    		mouseReleased,
    		graphContainer,
    		dispatch,
    		browse_folder,
    		lookForGraph,
    		openGraph,
    		toggleBrowser,
    		graphWindowClasses,
    		slots,
    		filebrowser_currentLocation_binding,
    		filebrowser_fileChecked_binding,
    		filebrowser_fullfileslist_binding,
    		chdir_handler,
    		markedFile_handler,
    		mouseup_handler,
    		mousedown_handler,
    		textfield_value_binding,
    		click_handler,
    		div3_elementresize_handler,
    		div3_binding,
    		click_handler_1,
    		modal_active_binding,
    		$$scope
    	];
    }

    class Layout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$$,
    			create_fragment$$,
    			safe_not_equal,
    			{
    				id: 4,
    				fileChecked: 0,
    				filetype: 5,
    				toggleBrowser: 14,
    				fullfileslist: 1,
    				currentLocation: 2,
    				graphPlotted: 6,
    				graphWindowClasses: 15,
    				activateConfigModal: 3
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[4] === undefined && !('id' in props)) {
    			console_1$i.warn("<Layout> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filetype() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filetype(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleBrowser() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleBrowser(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullfileslist() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullfileslist(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentLocation() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graphPlotted() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graphPlotted(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graphWindowClasses() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graphWindowClasses(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activateConfigModal() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activateConfigModal(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var candidateSelectors = [
      'input',
      'select',
      'textarea',
      'a[href]',
      'button',
      '[tabindex]',
      'audio[controls]',
      'video[controls]',
      '[contenteditable]:not([contenteditable="false"])',
    ];
    var candidateSelector = candidateSelectors.join(',');

    var matches = typeof Element === 'undefined'
      ? function () {}
      : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    function tabbable$1(el, options) {
      options = options || {};

      var regularTabbables = [];
      var orderedTabbables = [];

      var candidates = el.querySelectorAll(candidateSelector);

      if (options.includeContainer) {
        if (matches.call(el, candidateSelector)) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }

      var i, candidate, candidateTabindex;
      for (i = 0; i < candidates.length; i++) {
        candidate = candidates[i];

        if (!isNodeMatchingSelectorTabbable(candidate)) continue;

        candidateTabindex = getTabindex(candidate);
        if (candidateTabindex === 0) {
          regularTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            node: candidate,
          });
        }
      }

      var tabbableNodes = orderedTabbables
        .sort(sortOrderedTabbables)
        .map(function(a) { return a.node })
        .concat(regularTabbables);

      return tabbableNodes;
    }

    tabbable$1.isTabbable = isTabbable;
    tabbable$1.isFocusable = isFocusable;

    function isNodeMatchingSelectorTabbable(node) {
      if (
        !isNodeMatchingSelectorFocusable(node)
        || isNonTabbableRadio(node)
        || getTabindex(node) < 0
      ) {
        return false;
      }
      return true;
    }

    function isTabbable(node) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, candidateSelector) === false) return false;
      return isNodeMatchingSelectorTabbable(node);
    }

    function isNodeMatchingSelectorFocusable(node) {
      if (
        node.disabled
        || isHiddenInput(node)
        || isHidden(node)
      ) {
        return false;
      }
      return true;
    }

    var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
    function isFocusable(node) {
      if (!node) throw new Error('No node provided');
      if (matches.call(node, focusableCandidateSelector) === false) return false;
      return isNodeMatchingSelectorFocusable(node);
    }

    function getTabindex(node) {
      var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
      if (!isNaN(tabindexAttr)) return tabindexAttr;
      // Browsers do not return `tabIndex` correctly for contentEditable nodes;
      // so if they don't have a tabindex attribute specifically set, assume it's 0.
      if (isContentEditable(node)) return 0;
      return node.tabIndex;
    }

    function sortOrderedTabbables(a, b) {
      return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
    }

    function isContentEditable(node) {
      return node.contentEditable === 'true';
    }

    function isInput(node) {
      return node.tagName === 'INPUT';
    }

    function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    }

    function isRadio(node) {
      return isInput(node) && node.type === 'radio';
    }

    function isNonTabbableRadio(node) {
      return isRadio(node) && !isTabbableRadio(node);
    }

    function getCheckedRadio(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked) {
          return nodes[i];
        }
      }
    }

    function isTabbableRadio(node) {
      if (!node.name) return true;
      // This won't account for the edge case where you have radio groups with the same
      // in separate forms on the same page.
      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
      var checked = getCheckedRadio(radioSet);
      return !checked || checked === node;
    }

    function isHidden(node) {
      // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
      // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
      return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
    }

    var tabbable_1 = tabbable$1;

    var immutable = extend;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var tabbable = tabbable_1;
    var xtend = immutable;

    var activeFocusDelay;

    var activeFocusTraps = (function() {
      var trapQueue = [];
      return {
        activateTrap: function(trap) {
          if (trapQueue.length > 0) {
            var activeTrap = trapQueue[trapQueue.length - 1];
            if (activeTrap !== trap) {
              activeTrap.pause();
            }
          }

          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex === -1) {
            trapQueue.push(trap);
          } else {
            // move this existing trap to the front of the queue
            trapQueue.splice(trapIndex, 1);
            trapQueue.push(trap);
          }
        },

        deactivateTrap: function(trap) {
          var trapIndex = trapQueue.indexOf(trap);
          if (trapIndex !== -1) {
            trapQueue.splice(trapIndex, 1);
          }

          if (trapQueue.length > 0) {
            trapQueue[trapQueue.length - 1].unpause();
          }
        }
      };
    })();

    function focusTrap(element, userOptions) {
      var doc = document;
      var container =
        typeof element === 'string' ? doc.querySelector(element) : element;

      var config = xtend(
        {
          returnFocusOnDeactivate: true,
          escapeDeactivates: true
        },
        userOptions
      );

      var state = {
        firstTabbableNode: null,
        lastTabbableNode: null,
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false
      };

      var trap = {
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        unpause: unpause
      };

      return trap;

      function activate(activateOptions) {
        if (state.active) return;

        updateTabbableNodes();

        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;

        var onActivate =
          activateOptions && activateOptions.onActivate
            ? activateOptions.onActivate
            : config.onActivate;
        if (onActivate) {
          onActivate();
        }

        addListeners();
        return trap;
      }

      function deactivate(deactivateOptions) {
        if (!state.active) return;

        clearTimeout(activeFocusDelay);

        removeListeners();
        state.active = false;
        state.paused = false;

        activeFocusTraps.deactivateTrap(trap);

        var onDeactivate =
          deactivateOptions && deactivateOptions.onDeactivate !== undefined
            ? deactivateOptions.onDeactivate
            : config.onDeactivate;
        if (onDeactivate) {
          onDeactivate();
        }

        var returnFocus =
          deactivateOptions && deactivateOptions.returnFocus !== undefined
            ? deactivateOptions.returnFocus
            : config.returnFocusOnDeactivate;
        if (returnFocus) {
          delay(function() {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          });
        }

        return trap;
      }

      function pause() {
        if (state.paused || !state.active) return;
        state.paused = true;
        removeListeners();
      }

      function unpause() {
        if (!state.paused || !state.active) return;
        state.paused = false;
        updateTabbableNodes();
        addListeners();
      }

      function addListeners() {
        if (!state.active) return;

        // There can be only one listening focus trap at a time
        activeFocusTraps.activateTrap(trap);

        // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.
        activeFocusDelay = delay(function() {
          tryFocus(getInitialFocusNode());
        });

        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener('touchstart', checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener('click', checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener('keydown', checkKey, {
          capture: true,
          passive: false
        });

        return trap;
      }

      function removeListeners() {
        if (!state.active) return;

        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);

        return trap;
      }

      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;
        if (!optionValue) {
          return null;
        }
        if (typeof optionValue === 'string') {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error('`' + optionName + '` refers to no known node');
          }
        }
        if (typeof optionValue === 'function') {
          node = optionValue();
          if (!node) {
            throw new Error('`' + optionName + '` did not return a node');
          }
        }
        return node;
      }

      function getInitialFocusNode() {
        var node;
        if (getNodeForOption('initialFocus') !== null) {
          node = getNodeForOption('initialFocus');
        } else if (container.contains(doc.activeElement)) {
          node = doc.activeElement;
        } else {
          node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
        }

        if (!node) {
          throw new Error(
            'Your focus-trap needs to have at least one focusable element'
          );
        }

        return node;
      }

      function getReturnFocusNode(previousActiveElement) {
        var node = getNodeForOption('setReturnFocus');
        return node ? node : previousActiveElement;
      }

      // This needs to be done on mousedown and touchstart instead of click
      // so that it precedes the focus event.
      function checkPointerDown(e) {
        if (container.contains(e.target)) return;
        if (config.clickOutsideDeactivates) {
          deactivate({
            returnFocus: !tabbable.isFocusable(e.target)
          });
          return;
        }
        // This is needed for mobile devices.
        // (If we'll only let `click` events through,
        // then on mobile they will be blocked anyways if `touchstart` is blocked.)
        if (config.allowOutsideClick && config.allowOutsideClick(e)) {
          return;
        }
        e.preventDefault();
      }

      // In case focus escapes the trap for some strange reason, pull it back in.
      function checkFocusIn(e) {
        // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (container.contains(e.target) || e.target instanceof Document) {
          return;
        }
        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }

      function checkKey(e) {
        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
          e.preventDefault();
          deactivate();
          return;
        }
        if (isTabEvent(e)) {
          checkTab(e);
          return;
        }
      }

      // Hijack Tab events on the first and last focusable nodes of the trap,
      // in order to prevent focus from escaping. If it escapes for even a
      // moment it can end up scrolling the page and causing confusion so we
      // kind of need to capture the action at the keydown phase.
      function checkTab(e) {
        updateTabbableNodes();
        if (e.shiftKey && e.target === state.firstTabbableNode) {
          e.preventDefault();
          tryFocus(state.lastTabbableNode);
          return;
        }
        if (!e.shiftKey && e.target === state.lastTabbableNode) {
          e.preventDefault();
          tryFocus(state.firstTabbableNode);
          return;
        }
      }

      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        if (config.allowOutsideClick && config.allowOutsideClick(e)) {
          return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
      }

      function updateTabbableNodes() {
        var tabbableNodes = tabbable(container);
        state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
        state.lastTabbableNode =
          tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
      }

      function tryFocus(node) {
        if (node === doc.activeElement) return;
        if (!node || !node.focus) {
          tryFocus(getInitialFocusNode());
          return;
        }
        node.focus();
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      }
    }

    function isSelectableInput(node) {
      return (
        node.tagName &&
        node.tagName.toLowerCase() === 'input' &&
        typeof node.select === 'function'
      );
    }

    function isEscapeEvent(e) {
      return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
    }

    function isTabEvent(e) {
      return e.key === 'Tab' || e.keyCode === 9;
    }

    function delay(fn) {
      return setTimeout(fn, 0);
    }

    var focusTrap_1 = focusTrap;

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
        if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1; }
        return focusTrapFactory(surfaceEl, {
            clickOutsideDeactivates: true,
            escapeDeactivates: false,
            initialFocus: initialFocusEl,
        });
    }
    function isScrollable(el) {
        return el ? el.scrollHeight > el.offsetHeight : false;
    }
    function areTopsMisaligned(els) {
        var tops = new Set();
        [].forEach.call(els, function (el) { return tops.add(el.offsetTop); });
        return tops.size > 1;
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$6 = {
        CLOSING: 'mdc-dialog--closing',
        OPEN: 'mdc-dialog--open',
        OPENING: 'mdc-dialog--opening',
        SCROLLABLE: 'mdc-dialog--scrollable',
        SCROLL_LOCK: 'mdc-dialog-scroll-lock',
        STACKED: 'mdc-dialog--stacked',
    };
    var strings$8 = {
        ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
        BUTTON_DEFAULT_ATTRIBUTE: 'data-mdc-dialog-button-default',
        BUTTON_SELECTOR: '.mdc-dialog__button',
        CLOSED_EVENT: 'MDCDialog:closed',
        CLOSE_ACTION: 'close',
        CLOSING_EVENT: 'MDCDialog:closing',
        CONTAINER_SELECTOR: '.mdc-dialog__container',
        CONTENT_SELECTOR: '.mdc-dialog__content',
        DESTROY_ACTION: 'destroy',
        INITIAL_FOCUS_ATTRIBUTE: 'data-mdc-dialog-initial-focus',
        OPENED_EVENT: 'MDCDialog:opened',
        OPENING_EVENT: 'MDCDialog:opening',
        SCRIM_SELECTOR: '.mdc-dialog__scrim',
        SUPPRESS_DEFAULT_PRESS_SELECTOR: [
            'textarea',
            '.mdc-menu .mdc-list-item',
        ].join(', '),
        SURFACE_SELECTOR: '.mdc-dialog__surface',
    };
    var numbers$3 = {
        DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
        DIALOG_ANIMATION_OPEN_TIME_MS: 150,
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCDialogFoundation = /** @class */ (function (_super) {
        __extends(MDCDialogFoundation, _super);
        function MDCDialogFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCDialogFoundation.defaultAdapter, adapter)) || this;
            _this.isOpen_ = false;
            _this.animationFrame_ = 0;
            _this.animationTimer_ = 0;
            _this.layoutFrame_ = 0;
            _this.escapeKeyAction_ = strings$8.CLOSE_ACTION;
            _this.scrimClickAction_ = strings$8.CLOSE_ACTION;
            _this.autoStackButtons_ = true;
            _this.areButtonsStacked_ = false;
            return _this;
        }
        Object.defineProperty(MDCDialogFoundation, "cssClasses", {
            get: function () {
                return cssClasses$6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "strings", {
            get: function () {
                return strings$8;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "numbers", {
            get: function () {
                return numbers$3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addBodyClass: function () { return undefined; },
                    addClass: function () { return undefined; },
                    areButtonsStacked: function () { return false; },
                    clickDefaultButton: function () { return undefined; },
                    eventTargetMatches: function () { return false; },
                    getActionFromEvent: function () { return ''; },
                    getInitialFocusEl: function () { return null; },
                    hasClass: function () { return false; },
                    isContentScrollable: function () { return false; },
                    notifyClosed: function () { return undefined; },
                    notifyClosing: function () { return undefined; },
                    notifyOpened: function () { return undefined; },
                    notifyOpening: function () { return undefined; },
                    releaseFocus: function () { return undefined; },
                    removeBodyClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    reverseButtons: function () { return undefined; },
                    trapFocus: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCDialogFoundation.prototype.init = function () {
            if (this.adapter_.hasClass(cssClasses$6.STACKED)) {
                this.setAutoStackButtons(false);
            }
        };
        MDCDialogFoundation.prototype.destroy = function () {
            if (this.isOpen_) {
                this.close(strings$8.DESTROY_ACTION);
            }
            if (this.animationTimer_) {
                clearTimeout(this.animationTimer_);
                this.handleAnimationTimerEnd_();
            }
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
                this.layoutFrame_ = 0;
            }
        };
        MDCDialogFoundation.prototype.open = function () {
            var _this = this;
            this.isOpen_ = true;
            this.adapter_.notifyOpening();
            this.adapter_.addClass(cssClasses$6.OPENING);
            // Wait a frame once display is no longer "none", to establish basis for animation
            this.runNextAnimationFrame_(function () {
                _this.adapter_.addClass(cssClasses$6.OPEN);
                _this.adapter_.addBodyClass(cssClasses$6.SCROLL_LOCK);
                _this.layout();
                _this.animationTimer_ = setTimeout(function () {
                    _this.handleAnimationTimerEnd_();
                    _this.adapter_.trapFocus(_this.adapter_.getInitialFocusEl());
                    _this.adapter_.notifyOpened();
                }, numbers$3.DIALOG_ANIMATION_OPEN_TIME_MS);
            });
        };
        MDCDialogFoundation.prototype.close = function (action) {
            var _this = this;
            if (action === void 0) { action = ''; }
            if (!this.isOpen_) {
                // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
                return;
            }
            this.isOpen_ = false;
            this.adapter_.notifyClosing(action);
            this.adapter_.addClass(cssClasses$6.CLOSING);
            this.adapter_.removeClass(cssClasses$6.OPEN);
            this.adapter_.removeBodyClass(cssClasses$6.SCROLL_LOCK);
            cancelAnimationFrame(this.animationFrame_);
            this.animationFrame_ = 0;
            clearTimeout(this.animationTimer_);
            this.animationTimer_ = setTimeout(function () {
                _this.adapter_.releaseFocus();
                _this.handleAnimationTimerEnd_();
                _this.adapter_.notifyClosed(action);
            }, numbers$3.DIALOG_ANIMATION_CLOSE_TIME_MS);
        };
        MDCDialogFoundation.prototype.isOpen = function () {
            return this.isOpen_;
        };
        MDCDialogFoundation.prototype.getEscapeKeyAction = function () {
            return this.escapeKeyAction_;
        };
        MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {
            this.escapeKeyAction_ = action;
        };
        MDCDialogFoundation.prototype.getScrimClickAction = function () {
            return this.scrimClickAction_;
        };
        MDCDialogFoundation.prototype.setScrimClickAction = function (action) {
            this.scrimClickAction_ = action;
        };
        MDCDialogFoundation.prototype.getAutoStackButtons = function () {
            return this.autoStackButtons_;
        };
        MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {
            this.autoStackButtons_ = autoStack;
        };
        MDCDialogFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame_) {
                cancelAnimationFrame(this.layoutFrame_);
            }
            this.layoutFrame_ = requestAnimationFrame(function () {
                _this.layoutInternal_();
                _this.layoutFrame_ = 0;
            });
        };
        /** Handles click on the dialog root element. */
        MDCDialogFoundation.prototype.handleClick = function (evt) {
            var isScrim = this.adapter_.eventTargetMatches(evt.target, strings$8.SCRIM_SELECTOR);
            // Check for scrim click first since it doesn't require querying ancestors.
            if (isScrim && this.scrimClickAction_ !== '') {
                this.close(this.scrimClickAction_);
            }
            else {
                var action = this.adapter_.getActionFromEvent(evt);
                if (action) {
                    this.close(action);
                }
            }
        };
        /** Handles keydown on the dialog root element. */
        MDCDialogFoundation.prototype.handleKeydown = function (evt) {
            var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
            if (!isEnter) {
                return;
            }
            var action = this.adapter_.getActionFromEvent(evt);
            if (action) {
                // Action button callback is handled in `handleClick`,
                // since space/enter keydowns on buttons trigger click events.
                return;
            }
            var isDefault = !this.adapter_.eventTargetMatches(evt.target, strings$8.SUPPRESS_DEFAULT_PRESS_SELECTOR);
            if (isEnter && isDefault) {
                this.adapter_.clickDefaultButton();
            }
        };
        /** Handles keydown on the document. */
        MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {
            var isEscape = evt.key === 'Escape' || evt.keyCode === 27;
            if (isEscape && this.escapeKeyAction_ !== '') {
                this.close(this.escapeKeyAction_);
            }
        };
        MDCDialogFoundation.prototype.layoutInternal_ = function () {
            if (this.autoStackButtons_) {
                this.detectStackedButtons_();
            }
            this.detectScrollableContent_();
        };
        MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function () {
            this.animationTimer_ = 0;
            this.adapter_.removeClass(cssClasses$6.OPENING);
            this.adapter_.removeClass(cssClasses$6.CLOSING);
        };
        /**
         * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
         */
        MDCDialogFoundation.prototype.runNextAnimationFrame_ = function (callback) {
            var _this = this;
            cancelAnimationFrame(this.animationFrame_);
            this.animationFrame_ = requestAnimationFrame(function () {
                _this.animationFrame_ = 0;
                clearTimeout(_this.animationTimer_);
                _this.animationTimer_ = setTimeout(callback, 0);
            });
        };
        MDCDialogFoundation.prototype.detectStackedButtons_ = function () {
            // Remove the class first to let us measure the buttons' natural positions.
            this.adapter_.removeClass(cssClasses$6.STACKED);
            var areButtonsStacked = this.adapter_.areButtonsStacked();
            if (areButtonsStacked) {
                this.adapter_.addClass(cssClasses$6.STACKED);
            }
            if (areButtonsStacked !== this.areButtonsStacked_) {
                this.adapter_.reverseButtons();
                this.areButtonsStacked_ = areButtonsStacked;
            }
        };
        MDCDialogFoundation.prototype.detectScrollableContent_ = function () {
            // Remove the class first to let us measure the natural height of the content.
            this.adapter_.removeClass(cssClasses$6.SCROLLABLE);
            if (this.adapter_.isContentScrollable()) {
                this.adapter_.addClass(cssClasses$6.SCROLLABLE);
            }
        };
        return MDCDialogFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$7 = MDCDialogFoundation.strings;
    var MDCDialog = /** @class */ (function (_super) {
        __extends(MDCDialog, _super);
        function MDCDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MDCDialog.prototype, "isOpen", {
            get: function () {
                return this.foundation_.isOpen();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "escapeKeyAction", {
            get: function () {
                return this.foundation_.getEscapeKeyAction();
            },
            set: function (action) {
                this.foundation_.setEscapeKeyAction(action);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "scrimClickAction", {
            get: function () {
                return this.foundation_.getScrimClickAction();
            },
            set: function (action) {
                this.foundation_.setScrimClickAction(action);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCDialog.prototype, "autoStackButtons", {
            get: function () {
                return this.foundation_.getAutoStackButtons();
            },
            set: function (autoStack) {
                this.foundation_.setAutoStackButtons(autoStack);
            },
            enumerable: true,
            configurable: true
        });
        MDCDialog.attachTo = function (root) {
            return new MDCDialog(root);
        };
        MDCDialog.prototype.initialize = function (focusTrapFactory) {
            var e_1, _a;
            var container = this.root_.querySelector(strings$7.CONTAINER_SELECTOR);
            if (!container) {
                throw new Error("Dialog component requires a " + strings$7.CONTAINER_SELECTOR + " container element");
            }
            this.container_ = container;
            this.content_ = this.root_.querySelector(strings$7.CONTENT_SELECTOR);
            this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings$7.BUTTON_SELECTOR));
            this.defaultButton_ = this.root_.querySelector("[" + strings$7.BUTTON_DEFAULT_ATTRIBUTE + "]");
            this.focusTrapFactory_ = focusTrapFactory;
            this.buttonRipples_ = [];
            try {
                for (var _b = __values(this.buttons_), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var buttonEl = _c.value;
                    this.buttonRipples_.push(new MDCRipple(buttonEl));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        MDCDialog.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.getInitialFocusEl_() || undefined);
            this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
            this.handleKeydown_ = this.foundation_.handleKeydown.bind(this.foundation_);
            this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
            this.handleLayout_ = this.layout.bind(this);
            var LAYOUT_EVENTS = ['resize', 'orientationchange'];
            this.handleOpening_ = function () {
                LAYOUT_EVENTS.forEach(function (evtType) { return window.addEventListener(evtType, _this.handleLayout_); });
                document.addEventListener('keydown', _this.handleDocumentKeydown_);
            };
            this.handleClosing_ = function () {
                LAYOUT_EVENTS.forEach(function (evtType) { return window.removeEventListener(evtType, _this.handleLayout_); });
                document.removeEventListener('keydown', _this.handleDocumentKeydown_);
            };
            this.listen('click', this.handleClick_);
            this.listen('keydown', this.handleKeydown_);
            this.listen(strings$7.OPENING_EVENT, this.handleOpening_);
            this.listen(strings$7.CLOSING_EVENT, this.handleClosing_);
        };
        MDCDialog.prototype.destroy = function () {
            this.unlisten('click', this.handleClick_);
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(strings$7.OPENING_EVENT, this.handleOpening_);
            this.unlisten(strings$7.CLOSING_EVENT, this.handleClosing_);
            this.handleClosing_();
            this.buttonRipples_.forEach(function (ripple) { return ripple.destroy(); });
            _super.prototype.destroy.call(this);
        };
        MDCDialog.prototype.layout = function () {
            this.foundation_.layout();
        };
        MDCDialog.prototype.open = function () {
            this.foundation_.open();
        };
        MDCDialog.prototype.close = function (action) {
            if (action === void 0) { action = ''; }
            this.foundation_.close(action);
        };
        MDCDialog.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addBodyClass: function (className) { return document.body.classList.add(className); },
                addClass: function (className) { return _this.root_.classList.add(className); },
                areButtonsStacked: function () { return areTopsMisaligned(_this.buttons_); },
                clickDefaultButton: function () { return _this.defaultButton_ && _this.defaultButton_.click(); },
                eventTargetMatches: function (target, selector) { return target ? matches$1(target, selector) : false; },
                getActionFromEvent: function (evt) {
                    if (!evt.target) {
                        return '';
                    }
                    var element = closest(evt.target, "[" + strings$7.ACTION_ATTRIBUTE + "]");
                    return element && element.getAttribute(strings$7.ACTION_ATTRIBUTE);
                },
                getInitialFocusEl: function () { return _this.getInitialFocusEl_(); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                isContentScrollable: function () { return isScrollable(_this.content_); },
                notifyClosed: function (action) { return _this.emit(strings$7.CLOSED_EVENT, action ? { action: action } : {}); },
                notifyClosing: function (action) { return _this.emit(strings$7.CLOSING_EVENT, action ? { action: action } : {}); },
                notifyOpened: function () { return _this.emit(strings$7.OPENED_EVENT, {}); },
                notifyOpening: function () { return _this.emit(strings$7.OPENING_EVENT, {}); },
                releaseFocus: function () { return _this.focusTrap_.deactivate(); },
                removeBodyClass: function (className) { return document.body.classList.remove(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                reverseButtons: function () {
                    _this.buttons_.reverse();
                    _this.buttons_.forEach(function (button) {
                        button.parentElement.appendChild(button);
                    });
                },
                trapFocus: function () { return _this.focusTrap_.activate(); },
            };
            return new MDCDialogFoundation(adapter);
        };
        MDCDialog.prototype.getInitialFocusEl_ = function () {
            return document.querySelector("[" + strings$7.INITIAL_FOCUS_ATTRIBUTE + "]");
        };
        return MDCDialog;
    }(MDCComponent));

    /* node_modules\@smui\dialog\Dialog.svelte generated by Svelte v3.42.1 */
    const file$U = "node_modules\\@smui\\dialog\\Dialog.svelte";

    function create_fragment$_(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let t;
    	let div2;
    	let div3_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	let div3_levels = [
    		{
    			class: div3_class_value = "mdc-dialog " + /*className*/ ctx[1]
    		},
    		{ role: "alertdialog" },
    		{ "aria-modal": "true" },
    		exclude(/*$$props*/ ctx[5], ['use', 'class'])
    	];

    	let div3_data = {};

    	for (let i = 0; i < div3_levels.length; i += 1) {
    		div3_data = assign(div3_data, div3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			div2 = element("div");
    			attr_dev(div0, "class", "mdc-dialog__surface");
    			add_location(div0, file$U, 11, 4, 273);
    			attr_dev(div1, "class", "mdc-dialog__container");
    			add_location(div1, file$U, 10, 2, 233);
    			attr_dev(div2, "class", "mdc-dialog__scrim");
    			add_location(div2, file$U, 15, 2, 349);
    			set_attributes(div3, div3_data);
    			add_location(div3, file$U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div3, t);
    			append_dev(div3, div2);
    			/*div3_binding*/ ctx[16](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div3, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[3].call(null, div3)),
    					listen_dev(div3, "MDCDialog:opened", /*handleDialogOpened*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
    				(!current || dirty & /*className*/ 2 && div3_class_value !== (div3_class_value = "mdc-dialog " + /*className*/ ctx[1])) && { class: div3_class_value },
    				{ role: "alertdialog" },
    				{ "aria-modal": "true" },
    				dirty & /*$$props*/ 32 && exclude(/*$$props*/ ctx[5], ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    			/*div3_binding*/ ctx[16](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dialog', slots, ['default']);

    	const forwardEvents = forwardEventsBuilder(get_current_component(), [
    		'MDCDialog:opening',
    		'MDCDialog:opened',
    		'MDCDialog:closing',
    		'MDCDialog:closed'
    	]);

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { escapeKeyAction = 'close' } = $$props;
    	let { scrimClickAction = 'close' } = $$props;
    	let { autoStackButtons = true } = $$props;
    	let element;
    	let dialog;
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;
    	let layoutListeners = [];

    	let addLayoutListenerFn = listener => {
    		layoutListeners.push(listener);

    		return () => {
    			const idx = layoutListeners.indexOf(listener);

    			if (idx >= 0) {
    				layoutListeners.splice(idx, 1);
    			}
    		};
    	};

    	setContext('SMUI:addLayoutListener', addLayoutListenerFn);

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(() => {
    		$$invalidate(13, dialog = new MDCDialog(element));
    	});

    	onDestroy(() => {
    		dialog && dialog.destroy();

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function handleDialogOpened() {
    		layoutListeners.forEach(listener => listener());
    	}

    	function open(...args) {
    		return dialog.open(...args);
    	}

    	function close(...args) {
    		return dialog.close(...args);
    	}

    	function isOpen() {
    		return dialog.isOpen;
    	}

    	function layout(...args) {
    		return dialog.layout(...args);
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(2, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('escapeKeyAction' in $$new_props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
    		if ('scrimClickAction' in $$new_props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
    		if ('autoStackButtons' in $$new_props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
    		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCDialog,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		escapeKeyAction,
    		scrimClickAction,
    		autoStackButtons,
    		element,
    		dialog,
    		addLayoutListener,
    		removeLayoutListener,
    		layoutListeners,
    		addLayoutListenerFn,
    		handleDialogOpened,
    		open,
    		close,
    		isOpen,
    		layout
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('escapeKeyAction' in $$props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
    		if ('scrimClickAction' in $$props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
    		if ('autoStackButtons' in $$props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
    		if ('element' in $$props) $$invalidate(2, element = $$new_props.element);
    		if ('dialog' in $$props) $$invalidate(13, dialog = $$new_props.dialog);
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ('layoutListeners' in $$props) layoutListeners = $$new_props.layoutListeners;
    		if ('addLayoutListenerFn' in $$props) addLayoutListenerFn = $$new_props.addLayoutListenerFn;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dialog, escapeKeyAction*/ 8256) {
    			dialog && $$invalidate(13, dialog.escapeKeyAction = escapeKeyAction, dialog);
    		}

    		if ($$self.$$.dirty & /*dialog, scrimClickAction*/ 8320) {
    			dialog && $$invalidate(13, dialog.scrimClickAction = scrimClickAction, dialog);
    		}

    		if ($$self.$$.dirty & /*dialog, autoStackButtons*/ 8448) {
    			dialog && $$invalidate(13, dialog.autoStackButtons = autoStackButtons, dialog);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		element,
    		forwardEvents,
    		handleDialogOpened,
    		$$props,
    		escapeKeyAction,
    		scrimClickAction,
    		autoStackButtons,
    		open,
    		close,
    		isOpen,
    		layout,
    		dialog,
    		$$scope,
    		slots,
    		div3_binding
    	];
    }

    class Dialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$_, create_fragment$_, safe_not_equal, {
    			use: 0,
    			class: 1,
    			escapeKeyAction: 6,
    			scrimClickAction: 7,
    			autoStackButtons: 8,
    			open: 9,
    			close: 10,
    			isOpen: 11,
    			layout: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get use() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get escapeKeyAction() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set escapeKeyAction(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrimClickAction() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrimClickAction(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoStackButtons() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoStackButtons(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		return this.$$.ctx[9];
    	}

    	set open(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		return this.$$.ctx[10];
    	}

    	set close(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		return this.$$.ctx[11];
    	}

    	set isOpen(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[12];
    	}

    	set layout(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\H2.svelte generated by Svelte v3.42.1 */
    const file$T = "node_modules\\@smui\\common\\H2.svelte";

    function create_fragment$Z(ctx) {
    	let h2;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let h2_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let h2_data = {};

    	for (let i = 0; i < h2_levels.length; i += 1) {
    		h2_data = assign(h2_data, h2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			if (default_slot) default_slot.c();
    			set_attributes(h2, h2_data);
    			add_location(h2, file$T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);

    			if (default_slot) {
    				default_slot.m(h2, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, h2, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, h2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(h2, h2_data = get_spread_update(h2_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('H2', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class H2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$Z, create_fragment$Z, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "H2",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get use() {
    		throw new Error("<H2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<H2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Title = classAdderBuilder({
      class: 'mdc-dialog__title',
      component: H2,
      contexts: {}
    });

    var Content = classAdderBuilder({
      class: 'mdc-dialog__content',
      component: Div,
      contexts: {}
    });

    /* node_modules\@smui\common\Footer.svelte generated by Svelte v3.42.1 */
    const file$S = "node_modules\\@smui\\common\\Footer.svelte";

    function create_fragment$Y(ctx) {
    	let footer;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let footer_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let footer_data = {};

    	for (let i = 0; i < footer_levels.length; i += 1) {
    		footer_data = assign(footer_data, footer_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			if (default_slot) default_slot.c();
    			set_attributes(footer, footer_data);
    			add_location(footer, file$S, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);

    			if (default_slot) {
    				default_slot.m(footer, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, footer, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, footer))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(footer, footer_data = get_spread_update(footer_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$Y, create_fragment$Y, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get use() {
    		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Actions = classAdderBuilder({
      class: 'mdc-dialog__actions',
      component: Footer,
      contexts: {
        'SMUI:button:context': 'dialog:action'
      }
    });

    function InitialFocus(node) {
      node.setAttribute('data-mdc-dialog-initial-focus', '');

      return {
        destroy() {
          node.removeAttribute('data-mdc-dialog-initial-focus');
        }
      }
    }

    /* node_modules\@smui\common\A.svelte generated by Svelte v3.42.1 */
    const file$R = "node_modules\\@smui\\common\\A.svelte";

    function create_fragment$X(ctx) {
    	let a;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let a_levels = [{ href: /*href*/ ctx[1] }, exclude(/*$$props*/ ctx[3], ['use', 'href'])];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$R, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, a))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
    				dirty & /*$$props*/ 8 && exclude(/*$$props*/ ctx[3], ['use', 'href'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('A', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { href = 'javascript:void(0);' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('href' in $$new_props) $$invalidate(1, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		href
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('href' in $$props) $$invalidate(1, href = $$new_props.href);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, href, forwardEvents, $$props, $$scope, slots];
    }

    class A extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$X, create_fragment$X, safe_not_equal, { use: 0, href: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "A",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get use() {
    		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\common\Button.svelte generated by Svelte v3.42.1 */
    const file$Q = "node_modules\\@smui\\common\\Button.svelte";

    function create_fragment$W(ctx) {
    	let button;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let button_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$Q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, button))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$W, create_fragment$W, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get use() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\button\Button.svelte generated by Svelte v3.42.1 */

    // (1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class="     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   "   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >
    function create_default_slot$l(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class=\\\"     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   \\\"   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [
    				[
    					Ripple,
    					{
    						ripple: /*ripple*/ ctx[2],
    						unbounded: false,
    						classForward: /*func*/ ctx[18]
    					}
    				],
    				/*forwardEvents*/ ctx[11],
    				.../*use*/ ctx[0]
    			]
    		},
    		{
    			class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(' ') + "\n    " + (/*variant*/ ctx[4] === 'raised'
    			? 'mdc-button--raised'
    			: '') + "\n    " + (/*variant*/ ctx[4] === 'unelevated'
    			? 'mdc-button--unelevated'
    			: '') + "\n    " + (/*variant*/ ctx[4] === 'outlined'
    			? 'mdc-button--outlined'
    			: '') + "\n    " + (/*dense*/ ctx[5] ? 'mdc-button--dense' : '') + "\n    " + (/*color*/ ctx[3] === 'secondary'
    			? 'smui-button--color-secondary'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'card:action'
    			? 'mdc-card__action'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'card:action'
    			? 'mdc-card__action--button'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'dialog:action'
    			? 'mdc-dialog__button'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'top-app-bar:navigation'
    			? 'mdc-top-app-bar__navigation-icon'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'top-app-bar:action'
    			? 'mdc-top-app-bar__action-item'
    			: '') + "\n    " + (/*context*/ ctx[12] === 'snackbar'
    			? 'mdc-snackbar__action'
    			: '') + "\n  "
    		},
    		/*actionProp*/ ctx[9],
    		/*defaultProp*/ ctx[8],
    		exclude(/*$$props*/ ctx[13], [
    			'use',
    			'class',
    			'ripple',
    			'color',
    			'variant',
    			'dense',
    			.../*dialogExcludes*/ ctx[10]
    		])
    	];

    	var switch_value = /*component*/ ctx[6];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$l] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use, className, variant, dense, color, context, actionProp, defaultProp, exclude, $$props, dialogExcludes*/ 16319)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use*/ 2181 && {
    						use: [
    							[
    								Ripple,
    								{
    									ripple: /*ripple*/ ctx[2],
    									unbounded: false,
    									classForward: /*func*/ ctx[18]
    								}
    							],
    							/*forwardEvents*/ ctx[11],
    							.../*use*/ ctx[0]
    						]
    					},
    					dirty & /*className, rippleClasses, variant, dense, color, context*/ 4282 && {
    						class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(' ') + "\n    " + (/*variant*/ ctx[4] === 'raised'
    						? 'mdc-button--raised'
    						: '') + "\n    " + (/*variant*/ ctx[4] === 'unelevated'
    						? 'mdc-button--unelevated'
    						: '') + "\n    " + (/*variant*/ ctx[4] === 'outlined'
    						? 'mdc-button--outlined'
    						: '') + "\n    " + (/*dense*/ ctx[5] ? 'mdc-button--dense' : '') + "\n    " + (/*color*/ ctx[3] === 'secondary'
    						? 'smui-button--color-secondary'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'card:action'
    						? 'mdc-card__action'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'card:action'
    						? 'mdc-card__action--button'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'dialog:action'
    						? 'mdc-dialog__button'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'top-app-bar:navigation'
    						? 'mdc-top-app-bar__navigation-icon'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'top-app-bar:action'
    						? 'mdc-top-app-bar__action-item'
    						: '') + "\n    " + (/*context*/ ctx[12] === 'snackbar'
    						? 'mdc-snackbar__action'
    						: '') + "\n  "
    					},
    					dirty & /*actionProp*/ 512 && get_spread_object(/*actionProp*/ ctx[9]),
    					dirty & /*defaultProp*/ 256 && get_spread_object(/*defaultProp*/ ctx[8]),
    					dirty & /*exclude, $$props, dialogExcludes*/ 9216 && get_spread_object(exclude(/*$$props*/ ctx[13], [
    						'use',
    						'class',
    						'ripple',
    						'color',
    						'variant',
    						'dense',
    						.../*dialogExcludes*/ ctx[10]
    					]))
    				])
    			: {};

    			if (dirty & /*$$scope*/ 524288) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[6])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let dialogExcludes;
    	let actionProp;
    	let defaultProp;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { color = 'primary' } = $$props;
    	let { variant = 'text' } = $$props;
    	let { dense = false } = $$props;
    	let { href = null } = $$props;
    	let { action = 'close' } = $$props;
    	let { default: defaultAction = false } = $$props;
    	let { component = href == null ? Button : A } = $$props;
    	let context = getContext('SMUI:button:context');
    	let rippleClasses = [];
    	setContext('SMUI:label:context', 'button');
    	setContext('SMUI:icon:context', 'button');
    	const func = classes => $$invalidate(7, rippleClasses = classes);

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('ripple' in $$new_props) $$invalidate(2, ripple = $$new_props.ripple);
    		if ('color' in $$new_props) $$invalidate(3, color = $$new_props.color);
    		if ('variant' in $$new_props) $$invalidate(4, variant = $$new_props.variant);
    		if ('dense' in $$new_props) $$invalidate(5, dense = $$new_props.dense);
    		if ('href' in $$new_props) $$invalidate(14, href = $$new_props.href);
    		if ('action' in $$new_props) $$invalidate(15, action = $$new_props.action);
    		if ('default' in $$new_props) $$invalidate(16, defaultAction = $$new_props.default);
    		if ('component' in $$new_props) $$invalidate(6, component = $$new_props.component);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		A,
    		Button,
    		Ripple,
    		forwardEvents,
    		use,
    		className,
    		ripple,
    		color,
    		variant,
    		dense,
    		href,
    		action,
    		defaultAction,
    		component,
    		context,
    		rippleClasses,
    		defaultProp,
    		actionProp,
    		dialogExcludes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('ripple' in $$props) $$invalidate(2, ripple = $$new_props.ripple);
    		if ('color' in $$props) $$invalidate(3, color = $$new_props.color);
    		if ('variant' in $$props) $$invalidate(4, variant = $$new_props.variant);
    		if ('dense' in $$props) $$invalidate(5, dense = $$new_props.dense);
    		if ('href' in $$props) $$invalidate(14, href = $$new_props.href);
    		if ('action' in $$props) $$invalidate(15, action = $$new_props.action);
    		if ('defaultAction' in $$props) $$invalidate(16, defaultAction = $$new_props.defaultAction);
    		if ('component' in $$props) $$invalidate(6, component = $$new_props.component);
    		if ('context' in $$props) $$invalidate(12, context = $$new_props.context);
    		if ('rippleClasses' in $$props) $$invalidate(7, rippleClasses = $$new_props.rippleClasses);
    		if ('defaultProp' in $$props) $$invalidate(8, defaultProp = $$new_props.defaultProp);
    		if ('actionProp' in $$props) $$invalidate(9, actionProp = $$new_props.actionProp);
    		if ('dialogExcludes' in $$props) $$invalidate(10, dialogExcludes = $$new_props.dialogExcludes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*action*/ 32768) {
    			$$invalidate(9, actionProp = context === 'dialog:action' && action !== null
    			? { 'data-mdc-dialog-action': action }
    			: {});
    		}

    		if ($$self.$$.dirty & /*defaultAction*/ 65536) {
    			$$invalidate(8, defaultProp = context === 'dialog:action' && defaultAction
    			? { 'data-mdc-dialog-button-default': '' }
    			: {});
    		}
    	};

    	$$invalidate(10, dialogExcludes = context === 'dialog:action' ? ['action', 'default'] : []);
    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		ripple,
    		color,
    		variant,
    		dense,
    		component,
    		rippleClasses,
    		defaultProp,
    		actionProp,
    		dialogExcludes,
    		forwardEvents,
    		context,
    		$$props,
    		href,
    		action,
    		defaultAction,
    		slots,
    		func,
    		$$scope
    	];
    }

    class Button_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$V, create_fragment$V, safe_not_equal, {
    			use: 0,
    			class: 1,
    			ripple: 2,
    			color: 3,
    			variant: 4,
    			dense: 5,
    			href: 14,
    			action: 15,
    			default: 16,
    			component: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_1",
    			options,
    			id: create_fragment$V.name
    		});
    	}

    	get use() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dense() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dense(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get action() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set action(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get default() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set default(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomDialog.svelte generated by Svelte v3.42.1 */

    // (18:2) <Title id="{id}-title">
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 16) set_data_dev(t, /*title*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(18:2) <Title id=\\\"{id}-title\\\">",
    		ctx
    	});

    	return block;
    }

    // (19:2) <Content id="{id}-content">
    function create_default_slot_6$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*content*/ ctx[5]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 32) set_data_dev(t, /*content*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(19:2) <Content id=\\\"{id}-content\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:29) <Label>
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label1*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label1*/ 4) set_data_dev(t, /*label1*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(21:29) <Label>",
    		ctx
    	});

    	return block;
    }

    // (21:4) <Button action={label1}>
    function create_default_slot_4$2(ctx) {
    	let label;
    	let current;

    	label = new Label$1({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, label1*/ 516) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(21:4) <Button action={label1}>",
    		ctx
    	});

    	return block;
    }

    // (22:58) <Label>
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label2*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label2*/ 8) set_data_dev(t, /*label2*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(22:58) <Label>",
    		ctx
    	});

    	return block;
    }

    // (22:4) <Button action={label2} default use={[InitialFocus]}>
    function create_default_slot_2$6(ctx) {
    	let label;
    	let current;

    	label = new Label$1({
    			props: {
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, label2*/ 520) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(22:4) <Button action={label2} default use={[InitialFocus]}>",
    		ctx
    	});

    	return block;
    }

    // (20:2) <Actions>
    function create_default_slot_1$a(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button_1({
    			props: {
    				action: /*label1*/ ctx[2],
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button_1({
    			props: {
    				action: /*label2*/ ctx[3],
    				default: true,
    				use: [InitialFocus],
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};
    			if (dirty & /*label1*/ 4) button0_changes.action = /*label1*/ ctx[2];

    			if (dirty & /*$$scope, label1*/ 516) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*label2*/ 8) button1_changes.action = /*label2*/ ctx[3];

    			if (dirty & /*$$scope, label2*/ 520) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(20:2) <Actions>",
    		ctx
    	});

    	return block;
    }

    // (11:0) <Dialog    bind:this={dialog}      aria-labelledby="{id}-title"    aria-describedby="{id}-content"    on:MDCDialog:closed={sendAction} >
    function create_default_slot$k(ctx) {
    	let title_1;
    	let t0;
    	let content_1;
    	let t1;
    	let actions;
    	let current;

    	title_1 = new Title({
    			props: {
    				id: "" + (/*id*/ ctx[1] + "-title"),
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	content_1 = new Content({
    			props: {
    				id: "" + (/*id*/ ctx[1] + "-content"),
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	actions = new Actions({
    			props: {
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(title_1.$$.fragment);
    			t0 = space();
    			create_component(content_1.$$.fragment);
    			t1 = space();
    			create_component(actions.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(title_1, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(content_1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(actions, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const title_1_changes = {};
    			if (dirty & /*id*/ 2) title_1_changes.id = "" + (/*id*/ ctx[1] + "-title");

    			if (dirty & /*$$scope, title*/ 528) {
    				title_1_changes.$$scope = { dirty, ctx };
    			}

    			title_1.$set(title_1_changes);
    			const content_1_changes = {};
    			if (dirty & /*id*/ 2) content_1_changes.id = "" + (/*id*/ ctx[1] + "-content");

    			if (dirty & /*$$scope, content*/ 544) {
    				content_1_changes.$$scope = { dirty, ctx };
    			}

    			content_1.$set(content_1_changes);
    			const actions_changes = {};

    			if (dirty & /*$$scope, label2, label1*/ 524) {
    				actions_changes.$$scope = { dirty, ctx };
    			}

    			actions.$set(actions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_1.$$.fragment, local);
    			transition_in(content_1.$$.fragment, local);
    			transition_in(actions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_1.$$.fragment, local);
    			transition_out(content_1.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(title_1, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(content_1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(actions, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(11:0) <Dialog    bind:this={dialog}      aria-labelledby=\\\"{id}-title\\\"    aria-describedby=\\\"{id}-content\\\"    on:MDCDialog:closed={sendAction} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let dialog_1;
    	let current;

    	let dialog_1_props = {
    		"aria-labelledby": "" + (/*id*/ ctx[1] + "-title"),
    		"aria-describedby": "" + (/*id*/ ctx[1] + "-content"),
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};

    	dialog_1 = new Dialog({ props: dialog_1_props, $$inline: true });
    	/*dialog_1_binding*/ ctx[7](dialog_1);
    	dialog_1.$on("MDCDialog:closed", /*sendAction*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(dialog_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_1_changes = {};
    			if (dirty & /*id*/ 2) dialog_1_changes["aria-labelledby"] = "" + (/*id*/ ctx[1] + "-title");
    			if (dirty & /*id*/ 2) dialog_1_changes["aria-describedby"] = "" + (/*id*/ ctx[1] + "-content");

    			if (dirty & /*$$scope, label2, label1, id, content, title*/ 574) {
    				dialog_1_changes.$$scope = { dirty, ctx };
    			}

    			dialog_1.$set(dialog_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*dialog_1_binding*/ ctx[7](null);
    			destroy_component(dialog_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomDialog', slots, []);
    	let { dialog = "", id = "dialog", label1 = "Yes", label2 = "Cancel", title = "", content = "" } = $$props;
    	const dispatch = createEventDispatcher();

    	function sendAction(e) {
    		dispatch('response', { action: e.detail.action });
    	}

    	const writable_props = ['dialog', 'id', 'label1', 'label2', 'title', 'content'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomDialog> was created with unknown prop '${key}'`);
    	});

    	function dialog_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			dialog = $$value;
    			$$invalidate(0, dialog);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('dialog' in $$props) $$invalidate(0, dialog = $$props.dialog);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('label1' in $$props) $$invalidate(2, label1 = $$props.label1);
    		if ('label2' in $$props) $$invalidate(3, label2 = $$props.label2);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    		if ('content' in $$props) $$invalidate(5, content = $$props.content);
    	};

    	$$self.$capture_state = () => ({
    		Dialog,
    		Title,
    		Content,
    		Actions,
    		InitialFocus,
    		Button: Button_1,
    		Label: Label$1,
    		createEventDispatcher,
    		dialog,
    		id,
    		label1,
    		label2,
    		title,
    		content,
    		dispatch,
    		sendAction
    	});

    	$$self.$inject_state = $$props => {
    		if ('dialog' in $$props) $$invalidate(0, dialog = $$props.dialog);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('label1' in $$props) $$invalidate(2, label1 = $$props.label1);
    		if ('label2' in $$props) $$invalidate(3, label2 = $$props.label2);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    		if ('content' in $$props) $$invalidate(5, content = $$props.content);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dialog, id, label1, label2, title, content, sendAction, dialog_1_binding];
    }

    class CustomDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$U, create_fragment$U, safe_not_equal, {
    			dialog: 0,
    			id: 1,
    			label1: 2,
    			label2: 3,
    			title: 4,
    			content: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomDialog",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get dialog() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dialog(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label1() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label1(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label2() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label2(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Powerfile.svelte generated by Svelte v3.42.1 */

    const { console: console_1$h } = globals;
    const file$P = "src\\Pages\\Powerfile.svelte";

    // (128:12) <FormField>
    function create_default_slot_1$9(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[17](value);
    	}

    	let checkbox_props = {
    		indeterminate: /*convert*/ ctx[2] === null
    	};

    	if (/*convert*/ ctx[2] !== void 0) {
    		checkbox_props.checked = /*convert*/ ctx[2];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};
    			if (dirty & /*convert*/ 4) checkbox_changes.indeterminate = /*convert*/ ctx[2] === null;

    			if (!updating_checked && dirty & /*convert*/ 4) {
    				updating_checked = true;
    				checkbox_changes.checked = /*convert*/ ctx[2];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(128:12) <FormField>",
    		ctx
    	});

    	return block;
    }

    // (131:16) 
    function create_label_slot$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Convert to µm";
    			attr_dev(span, "slot", "label");
    			add_location(span, file$P, 130, 16, 4194);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$5.name,
    		type: "slot",
    		source: "(131:16) ",
    		ctx
    	});

    	return block;
    }

    // (140:12) <HelperText id="powercontent_help">
    function create_default_slot$j(ctx) {
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("Enter powerfile measured for ");
    			t1 = text(/*filename*/ ctx[4]);
    			t2 = text(".felix file (wavenumber power-in mJ)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filename*/ 16) set_data_dev(t1, /*filename*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(140:12) <HelperText id=\\\"powercontent_help\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let customdialog;
    	let updating_dialog;
    	let t0;
    	let section;
    	let div3;
    	let div0;
    	let button0;
    	let t2;
    	let textfield0;
    	let updating_value;
    	let t3;
    	let div1;
    	let textfield1;
    	let updating_value_1;
    	let t4;
    	let textfield2;
    	let updating_value_2;
    	let t5;
    	let textfield3;
    	let updating_value_3;
    	let t6;
    	let formfield;
    	let t7;
    	let div2;
    	let textfield4;
    	let updating_value_4;
    	let t8;
    	let helpertext;
    	let t9;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	function customdialog_dialog_binding(value) {
    		/*customdialog_dialog_binding*/ ctx[11](value);
    	}

    	let customdialog_props = {
    		id: "powerfile-overwrite",
    		title: "Overwrite?",
    		content: `${/*filename*/ ctx[4]} already exists. Do you want to overwrite it?`
    	};

    	if (/*overwrite_dialog*/ ctx[6] !== void 0) {
    		customdialog_props.dialog = /*overwrite_dialog*/ ctx[6];
    	}

    	customdialog = new CustomDialog({
    			props: customdialog_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customdialog, 'dialog', customdialog_dialog_binding));
    	customdialog.$on("response", /*handleOverwrite*/ ctx[9]);

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[12](value);
    	}

    	let textfield0_props = {
    		label: "Current Location",
    		style: "flex-grow:1;"
    	};

    	if (/*location*/ ctx[3] !== void 0) {
    		textfield0_props.value = /*location*/ ctx[3];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[13](value);
    	}

    	let textfield1_props = { label: "Filename" };

    	if (/*filename*/ ctx[4] !== void 0) {
    		textfield1_props.value = /*filename*/ ctx[4];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[14](value);
    	}

    	let textfield2_props = { label: "FELIX Shots" };

    	if (/*felixShots*/ ctx[1] !== void 0) {
    		textfield2_props.value = /*felixShots*/ ctx[1];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));
    	textfield2.$on("change", /*change_handler*/ ctx[15]);

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[16](value);
    	}

    	let textfield3_props = { label: "FELIX Hz" };

    	if (/*felixHz*/ ctx[0] !== void 0) {
    		textfield3_props.value = /*felixHz*/ ctx[0];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	formfield = new FormField({
    			props: {
    				$$slots: {
    					label: [create_label_slot$5],
    					default: [create_default_slot_1$9]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[18](value);
    	}

    	let textfield4_props = {
    		textarea: true,
    		label: "Powerfile contents",
    		"input$aria-controls": "powercontent_help",
    		"input$aria-describedby": "powercontent_help"
    	};

    	if (/*powerfileContent*/ ctx[5] !== void 0) {
    		textfield4_props.value = /*powerfileContent*/ ctx[5];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	helpertext = new HelperText({
    			props: {
    				id: "powercontent_help",
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(customdialog.$$.fragment);
    			t0 = space();
    			section = element("section");
    			div3 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Browse";
    			t2 = space();
    			create_component(textfield0.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(textfield1.$$.fragment);
    			t4 = space();
    			create_component(textfield2.$$.fragment);
    			t5 = space();
    			create_component(textfield3.$$.fragment);
    			t6 = space();
    			create_component(formfield.$$.fragment);
    			t7 = space();
    			div2 = element("div");
    			create_component(textfield4.$$.fragment);
    			t8 = space();
    			create_component(helpertext.$$.fragment);
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Save";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$P, 114, 12, 3552);
    			attr_dev(div0, "class", "location__bar svelte-kzx37e");
    			add_location(div0, file$P, 113, 8, 3511);
    			attr_dev(div1, "class", "grid_column__container file__details__bar svelte-kzx37e");
    			add_location(div1, file$P, 120, 8, 3755);
    			attr_dev(button1, "class", "button is-success");
    			set_style(button1, "width", "12em");
    			set_style(button1, "margin-left", "auto");
    			add_location(button1, file$P, 140, 12, 4661);
    			attr_dev(div2, "class", "power_value__container svelte-kzx37e");
    			add_location(div2, file$P, 136, 8, 4297);
    			attr_dev(div3, "class", "box main__container svelte-kzx37e");
    			attr_dev(div3, "id", "powfileContainer");
    			add_location(div3, file$P, 111, 4, 3444);
    			attr_dev(section, "class", "section svelte-kzx37e");
    			attr_dev(section, "id", "Powerfile");
    			set_style(section, "display", "none");
    			add_location(section, file$P, 110, 0, 3377);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(customdialog, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section, anchor);
    			append_dev(section, div3);
    			append_dev(div3, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t2);
    			mount_component(textfield0, div0, null);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t4);
    			mount_component(textfield2, div1, null);
    			append_dev(div1, t5);
    			mount_component(textfield3, div1, null);
    			append_dev(div1, t6);
    			mount_component(formfield, div1, null);
    			append_dev(div3, t7);
    			append_dev(div3, div2);
    			mount_component(textfield4, div2, null);
    			append_dev(div2, t8);
    			mount_component(helpertext, div2, null);
    			append_dev(div2, t9);
    			append_dev(div2, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*openFolder*/ ctx[8], false, false, false),
    					listen_dev(button1, "click", /*savefile*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const customdialog_changes = {};
    			if (dirty & /*filename*/ 16) customdialog_changes.content = `${/*filename*/ ctx[4]} already exists. Do you want to overwrite it?`;

    			if (!updating_dialog && dirty & /*overwrite_dialog*/ 64) {
    				updating_dialog = true;
    				customdialog_changes.dialog = /*overwrite_dialog*/ ctx[6];
    				add_flush_callback(() => updating_dialog = false);
    			}

    			customdialog.$set(customdialog_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*location*/ 8) {
    				updating_value = true;
    				textfield0_changes.value = /*location*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*filename*/ 16) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*filename*/ ctx[4];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty & /*felixShots*/ 2) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*felixShots*/ ctx[1];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty & /*felixHz*/ 1) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*felixHz*/ ctx[0];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const formfield_changes = {};

    			if (dirty & /*$$scope, convert*/ 67108868) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty & /*powerfileContent*/ 32) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*powerfileContent*/ ctx[5];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const helpertext_changes = {};

    			if (dirty & /*$$scope, filename*/ 67108880) {
    				helpertext_changes.$$scope = { dirty, ctx };
    			}

    			helpertext.$set(helpertext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customdialog.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(formfield.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(helpertext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customdialog.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(formfield.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(helpertext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(customdialog, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(formfield);
    			destroy_component(textfield4);
    			destroy_component(helpertext);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let powfile;
    	let conversion;
    	let initContent;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Powerfile', slots, []);

    	const writePowfile = () => {
    		let contents = `${initContent}\n${powerfileContent}`;

    		fs.writeFile(powfile, contents, function (err) {
    			if (err) {
    				return window.createToast("Power file couldn't be saved.", "danger");
    			}

    			window.createToast("Power file saved", "success");
    		});
    	};

    	async function savefile() {
    		if (location.length == 0) {
    			return openFolder({ save: true });
    		}

    		const overwrite = await fs.existsSync(powfile);
    		overwrite ? overwrite_dialog.open() : writePowfile();
    	}

    	function openFolder({ save = false } = {}) {
    		browse({ dir: true }).then(result => {
    			if (result) {
    				$$invalidate(3, location = result[0]);
    				db.set("powerfile_location", location);
    				window.createToast("Location updated", "success");
    				if (save) savefile();
    			}
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	let powerfileContent = '', felixHz = 10, felixShots = 16, convert = null;
    	let location = db.get("powerfile_location") || "";
    	let overwrite_dialog;
    	let today = new Date();
    	const dd = String(today.getDate()).padStart(2, '0');
    	const mm = String(today.getMonth() + 1).padStart(2, '0');
    	const yy = today.getFullYear().toString().substr(2);
    	let filename = `${dd}_${mm}_${yy}-#`;

    	const handleOverwrite = e => {
    		let action = e.detail.action;
    		if (action === "Cancel" || action === "close") window.createToast("Powerfile saving cancelled", "warning");
    		if (action === "Yes") writePowfile();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$h.warn(`<Powerfile> was created with unknown prop '${key}'`);
    	});

    	function customdialog_dialog_binding(value) {
    		overwrite_dialog = value;
    		$$invalidate(6, overwrite_dialog);
    	}

    	function textfield0_value_binding(value) {
    		location = value;
    		$$invalidate(3, location);
    	}

    	function textfield1_value_binding(value) {
    		filename = value;
    		$$invalidate(4, filename);
    	}

    	function textfield2_value_binding(value) {
    		felixShots = value;
    		$$invalidate(1, felixShots);
    	}

    	const change_handler = () => {
    		console.log(felixShots);
    	};

    	function textfield3_value_binding(value) {
    		felixHz = value;
    		$$invalidate(0, felixHz);
    	}

    	function checkbox_checked_binding(value) {
    		convert = value;
    		$$invalidate(2, convert);
    	}

    	function textfield4_value_binding(value) {
    		powerfileContent = value;
    		$$invalidate(5, powerfileContent);
    	}

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Textfield,
    		HelperText,
    		Checkbox,
    		FormField,
    		browse,
    		CustomDialog,
    		writePowfile,
    		savefile,
    		openFolder,
    		powerfileContent,
    		felixHz,
    		felixShots,
    		convert,
    		location,
    		overwrite_dialog,
    		today,
    		dd,
    		mm,
    		yy,
    		filename,
    		handleOverwrite,
    		conversion,
    		initContent,
    		powfile
    	});

    	$$self.$inject_state = $$props => {
    		if ('powerfileContent' in $$props) $$invalidate(5, powerfileContent = $$props.powerfileContent);
    		if ('felixHz' in $$props) $$invalidate(0, felixHz = $$props.felixHz);
    		if ('felixShots' in $$props) $$invalidate(1, felixShots = $$props.felixShots);
    		if ('convert' in $$props) $$invalidate(2, convert = $$props.convert);
    		if ('location' in $$props) $$invalidate(3, location = $$props.location);
    		if ('overwrite_dialog' in $$props) $$invalidate(6, overwrite_dialog = $$props.overwrite_dialog);
    		if ('today' in $$props) today = $$props.today;
    		if ('filename' in $$props) $$invalidate(4, filename = $$props.filename);
    		if ('conversion' in $$props) $$invalidate(10, conversion = $$props.conversion);
    		if ('initContent' in $$props) initContent = $$props.initContent;
    		if ('powfile' in $$props) powfile = $$props.powfile;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*location, filename*/ 24) {
    			powfile = pathResolve(location, `${filename}.pow`);
    		}

    		if ($$self.$$.dirty & /*convert*/ 4) {
    			convert
    			? $$invalidate(10, conversion = "_")
    			: $$invalidate(10, conversion = "_no_");
    		}

    		if ($$self.$$.dirty & /*felixHz, felixShots, conversion*/ 1027) {
    			initContent = `#POWER file\n` + `# ${felixHz} Hz FELIX\n` + `#SHOTS=${felixShots}\n` + `#INTERP=linear\n` + `#    IN${conversion}UM (if one deletes the no the firs number will be in \mu m\n` + `# wavelength/cm-1      energy/pulse/mJ\n`;
    		}
    	};

    	$$invalidate(10, conversion = "_no_");

    	return [
    		felixHz,
    		felixShots,
    		convert,
    		location,
    		filename,
    		powerfileContent,
    		overwrite_dialog,
    		savefile,
    		openFolder,
    		handleOverwrite,
    		conversion,
    		customdialog_dialog_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		change_handler,
    		textfield3_value_binding,
    		checkbox_checked_binding,
    		textfield4_value_binding
    	];
    }

    class Powerfile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Powerfile",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    const felixIndex = writable([]);
    const felixPeakTable = writable([]);

    const felixOutputName = writable("");
    const opoMode = writable(false);
    const Ngauss_sigma = writable(5);
    const dataTable = writable([]);

    const dataTable_avg = writable([]);

    const opoData = writable({});

    const felixData = writable({});

    const normMethodDatas = derived([opoMode, felixData, opoData], ([$opoMode, $felixData, $opoData]) => { return $opoMode ? $opoData : $felixData });
    const felixopoLocation = writable("");
    const baselineFile = writable("");

    const filedetails = writable([]);
    const felixPlotAnnotations = writable([]);
    const plotlyEventCreatedFELIX = writable(false);
    const plotlyEventCreatedOPO = writable(false);
    const toggleRow = writable(false);
    const graphDiv = derived(opoMode, $opoMode => { return $opoMode ? "opoRelPlot" : "avgplot" });

    derived(opoMode, $opoMode => { return $opoMode ? "opoplot" : "bplot" });

    const expfittedLines = writable([]);
    const expfittedLinesCollectedData = writable([]);
    const collectData = writable(false);
    const avgfittedLineCount = writable(0);
    const fittedTraceCount = writable(0);
    const felixAnnotationColor = writable("black");
    const normMethod = writable("Relative");

    const felixPlotCheckboxes = writable([]);
    const felixConfigDB = writable(JSONdb(pathResolve(appInfo.userData, "config/normline.json")));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$6 = {
        NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control',
    };
    var cssClasses$5 = {
        DISABLED: 'mdc-radio--disabled',
        ROOT: 'mdc-radio',
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRadioFoundation = /** @class */ (function (_super) {
        __extends(MDCRadioFoundation, _super);
        function MDCRadioFoundation(adapter) {
            return _super.call(this, __assign({}, MDCRadioFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCRadioFoundation, "cssClasses", {
            get: function () {
                return cssClasses$5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadioFoundation, "strings", {
            get: function () {
                return strings$6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadioFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setNativeControlDisabled: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        MDCRadioFoundation.prototype.setDisabled = function (disabled) {
            var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
            this.adapter_.setNativeControlDisabled(disabled);
            if (disabled) {
                this.adapter_.addClass(DISABLED);
            }
            else {
                this.adapter_.removeClass(DISABLED);
            }
        };
        return MDCRadioFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCRadio = /** @class */ (function (_super) {
        __extends(MDCRadio, _super);
        function MDCRadio() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ripple_ = _this.createRipple_();
            return _this;
        }
        MDCRadio.attachTo = function (root) {
            return new MDCRadio(root);
        };
        Object.defineProperty(MDCRadio.prototype, "checked", {
            get: function () {
                return this.nativeControl_.checked;
            },
            set: function (checked) {
                this.nativeControl_.checked = checked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "disabled", {
            get: function () {
                return this.nativeControl_.disabled;
            },
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "value", {
            get: function () {
                return this.nativeControl_.value;
            },
            set: function (value) {
                this.nativeControl_.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCRadio.prototype, "ripple", {
            get: function () {
                return this.ripple_;
            },
            enumerable: true,
            configurable: true
        });
        MDCRadio.prototype.destroy = function () {
            this.ripple_.destroy();
            _super.prototype.destroy.call(this);
        };
        MDCRadio.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
            };
            return new MDCRadioFoundation(adapter);
        };
        MDCRadio.prototype.createRipple_ = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { registerInteractionHandler: function (evtType, handler) { return _this.nativeControl_.addEventListener(evtType, handler, applyPassive()); }, deregisterInteractionHandler: function (evtType, handler) { return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive()); }, 
                // Radio buttons technically go "active" whenever there is *any* keyboard interaction.
                // This is not the UI we desire.
                isSurfaceActive: function () { return false; }, isUnbounded: function () { return true; } });
            // tslint:enable:object-literal-sort-keys
            return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
        };
        Object.defineProperty(MDCRadio.prototype, "nativeControl_", {
            get: function () {
                var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
                var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
                if (!el) {
                    throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
                }
                return el;
            },
            enumerable: true,
            configurable: true
        });
        return MDCRadio;
    }(MDCComponent));

    /* node_modules\@smui\radio\Radio.svelte generated by Svelte v3.42.1 */
    const file$O = "node_modules\\@smui\\radio\\Radio.svelte";

    function create_fragment$S(ctx) {
    	let div3;
    	let input;
    	let input_class_value;
    	let input_value_value;
    	let useActions_action;
    	let t0;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let div3_class_value;
    	let useActions_action_1;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{
    			class: input_class_value = "mdc-radio__native-control " + /*input$class*/ ctx[6]
    		},
    		{ type: "radio" },
    		/*inputProps*/ ctx[11],
    		{ disabled: /*disabled*/ ctx[2] },
    		{
    			value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    			? /*value*/ ctx[3]
    			: /*valueKey*/ ctx[4]
    		},
    		{ checked: /*checked*/ ctx[7] },
    		exclude(prefixFilter(/*$$props*/ ctx[13], 'input$'), ['use', 'class'])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	let div3_levels = [
    		{
    			class: div3_class_value = "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-radio--disabled' : '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[13], ['use', 'class', 'disabled', 'group', 'value', 'valueKey', 'input$'])
    	];

    	let div3_data = {};

    	for (let i = 0; i < div3_levels.length; i += 1) {
    		div3_data = assign(div3_data, div3_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			input = element("input");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");
    			set_attributes(input, input_data);
    			add_location(input, file$O, 11, 2, 256);
    			attr_dev(div0, "class", "mdc-radio__outer-circle");
    			add_location(div0, file$O, 24, 4, 642);
    			attr_dev(div1, "class", "mdc-radio__inner-circle");
    			add_location(div1, file$O, 25, 4, 690);
    			attr_dev(div2, "class", "mdc-radio__background");
    			add_location(div2, file$O, 23, 2, 602);
    			set_attributes(div3, div3_data);
    			add_location(div3, file$O, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, input);
    			if (input.autofocus) input.focus();
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div3_binding*/ ctx[19](div3);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
    					listen_dev(input, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[17], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[18], false, false, false),
    					action_destroyer(useActions_action_1 = useActions.call(null, div3, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[9].call(null, div3))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-radio__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
    				{ type: "radio" },
    				/*inputProps*/ ctx[11],
    				dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
    				dirty & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
    				? /*value*/ ctx[3]
    				: /*valueKey*/ ctx[4]) && { value: input_value_value },
    				dirty & /*checked*/ 128 && { checked: /*checked*/ ctx[7] },
    				dirty & /*$$props*/ 8192 && exclude(prefixFilter(/*$$props*/ ctx[13], 'input$'), ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

    			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
    				dirty & /*className, disabled*/ 6 && div3_class_value !== (div3_class_value = "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? 'mdc-radio--disabled' : '') + "\n  ") && { class: div3_class_value },
    				dirty & /*$$props*/ 8192 && exclude(/*$$props*/ ctx[13], ['use', 'class', 'disabled', 'group', 'value', 'valueKey', 'input$'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*div3_binding*/ ctx[19](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let checked;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Radio', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { group = null } = $$props;
    	let { value = null } = $$props;
    	let { valueKey = uninitializedValue } = $$props;
    	let { input$use = [] } = $$props;
    	let { input$class = '' } = $$props;
    	let element;
    	let radio;
    	let formField = getContext('SMUI:form-field');
    	let inputProps = getContext('SMUI:generic:input:props') || {};
    	let setChecked = getContext('SMUI:generic:input:setChecked');

    	onMount(() => {
    		$$invalidate(16, radio = new MDCRadio(element));

    		if (formField && formField()) {
    			formField().input = radio;
    		}
    	});

    	onDestroy(() => {
    		radio && radio.destroy();
    	});

    	function handleChange(e) {
    		if (radio.checked) {
    			$$invalidate(14, group = value);
    		}
    	}

    	function getId() {
    		return inputProps && inputProps.id;
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(8, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('group' in $$new_props) $$invalidate(14, group = $$new_props.group);
    		if ('value' in $$new_props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
    	};

    	$$self.$capture_state = () => ({
    		MDCRadio,
    		onMount,
    		onDestroy,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		disabled,
    		group,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		element,
    		radio,
    		formField,
    		inputProps,
    		setChecked,
    		handleChange,
    		getId,
    		checked
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ('uninitializedValue' in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('group' in $$props) $$invalidate(14, group = $$new_props.group);
    		if ('value' in $$props) $$invalidate(3, value = $$new_props.value);
    		if ('valueKey' in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
    		if ('input$use' in $$props) $$invalidate(5, input$use = $$new_props.input$use);
    		if ('input$class' in $$props) $$invalidate(6, input$class = $$new_props.input$class);
    		if ('element' in $$props) $$invalidate(8, element = $$new_props.element);
    		if ('radio' in $$props) $$invalidate(16, radio = $$new_props.radio);
    		if ('formField' in $$props) formField = $$new_props.formField;
    		if ('inputProps' in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
    		if ('setChecked' in $$props) $$invalidate(21, setChecked = $$new_props.setChecked);
    		if ('checked' in $$props) $$invalidate(7, checked = $$new_props.checked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*group, value*/ 16392) {
    			$$invalidate(7, checked = group === value);
    		}

    		if ($$self.$$.dirty & /*checked*/ 128) {
    			if (setChecked) {
    				setChecked(checked);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, checked*/ 65664) {
    			if (radio && radio.checked !== checked) {
    				$$invalidate(16, radio.checked = checked, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, disabled*/ 65540) {
    			if (radio && radio.disabled !== disabled) {
    				$$invalidate(16, radio.disabled = disabled, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, valueKey, value*/ 65560) {
    			if (radio && valueKey === uninitializedValue && radio.value !== value) {
    				$$invalidate(16, radio.value = value, radio);
    			}
    		}

    		if ($$self.$$.dirty & /*radio, valueKey*/ 65552) {
    			if (radio && valueKey !== uninitializedValue && radio.value !== valueKey) {
    				$$invalidate(16, radio.value = valueKey, radio);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		disabled,
    		value,
    		valueKey,
    		input$use,
    		input$class,
    		checked,
    		element,
    		forwardEvents,
    		uninitializedValue,
    		inputProps,
    		handleChange,
    		$$props,
    		group,
    		getId,
    		radio,
    		change_handler,
    		input_handler,
    		div3_binding
    	];
    }

    class Radio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$S, create_fragment$S, safe_not_equal, {
    			use: 0,
    			class: 1,
    			disabled: 2,
    			group: 14,
    			value: 3,
    			valueKey: 4,
    			input$use: 5,
    			input$class: 6,
    			getId: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Radio",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get use() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueKey() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueKey(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$use() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$use(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$class() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$class(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getId() {
    		return this.$$.ctx[15];
    	}

    	set getId(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomRadio.svelte generated by Svelte v3.42.1 */
    const file$N = "src\\components\\CustomRadio.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (10:4) <FormField {style}>
    function create_default_slot$i(ctx) {
    	let radio;
    	let updating_group;
    	let t;
    	let current;

    	function radio_group_binding(value) {
    		/*radio_group_binding*/ ctx[3](value);
    	}

    	let radio_props = { value: /*option*/ ctx[5] };

    	if (/*selected*/ ctx[0] !== void 0) {
    		radio_props.group = /*selected*/ ctx[0];
    	}

    	radio = new Radio({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, 'group', radio_group_binding));
    	radio.$on("change", /*change_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(radio.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(radio, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radio_changes = {};
    			if (dirty & /*options*/ 2) radio_changes.value = /*option*/ ctx[5];

    			if (!updating_group && dirty & /*selected*/ 1) {
    				updating_group = true;
    				radio_changes.group = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_group = false);
    			}

    			radio.$set(radio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(radio, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(10:4) <FormField {style}>",
    		ctx
    	});

    	return block;
    }

    // (12:8) 
    function create_label_slot$4(ctx) {
    	let span;
    	let t_value = /*option*/ ctx[5] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "slot", "label");
    			add_location(span, file$N, 11, 8, 295);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[5] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$4.name,
    		type: "slot",
    		source: "(12:8) ",
    		ctx
    	});

    	return block;
    }

    // (9:0) {#each options as option}
    function create_each_block$e(ctx) {
    	let formfield;
    	let current;

    	formfield = new FormField({
    			props: {
    				style: /*style*/ ctx[2],
    				$$slots: {
    					label: [create_label_slot$4],
    					default: [create_default_slot$i]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formfield_changes = {};
    			if (dirty & /*style*/ 4) formfield_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, options, selected*/ 259) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(9:0) {#each options as option}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style, options, selected*/ 7) {
    				each_value = /*options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomRadio', slots, []);
    	let { options = [], selected = "", style = "" } = $$props;
    	const writable_props = ['options', 'selected', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomRadio> was created with unknown prop '${key}'`);
    	});

    	function radio_group_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		Radio,
    		FormField,
    		options,
    		selected,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, options, style, radio_group_binding, change_handler];
    }

    class CustomRadio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$R, create_fragment$R, safe_not_equal, { options: 1, selected: 0, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomRadio",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get options() {
    		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\modals\AddFilesToPlot.svelte generated by Svelte v3.42.1 */
    const file$M = "src\\Pages\\normline\\modals\\AddFilesToPlot.svelte";

    // (42:0) {#if active}
    function create_if_block$r(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[12](value);
    	}

    	let modal_props = {
    		title: "Add file to plot",
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$5],
    			content: [create_content_slot$7]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, addedFileScale, addedFileCol*/ 16390) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(42:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (46:8) 
    function create_content_slot$7(ctx) {
    	let div;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[10](value);
    	}

    	let textfield0_props = {
    		style: "width:7em; margin:0 0.5em;",
    		label: "Columns"
    	};

    	if (/*addedFileCol*/ ctx[1] !== void 0) {
    		textfield0_props.value = /*addedFileCol*/ ctx[1];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[11](value);
    	}

    	let textfield1_props = {
    		style: "width:7em; margin:0 0.5em;",
    		label: "ScaleY"
    	};

    	if (/*addedFileScale*/ ctx[2] !== void 0) {
    		textfield1_props.value = /*addedFileScale*/ ctx[2];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			button = element("button");
    			button.textContent = "Browse";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$M, 48, 12, 1632);
    			attr_dev(div, "slot", "content");
    			add_location(div, file$M, 45, 8, 1390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t0);
    			mount_component(textfield1, div, null);
    			append_dev(div, t1);
    			append_dev(div, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*addFileSelection*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*addedFileCol*/ 2) {
    				updating_value = true;
    				textfield0_changes.value = /*addedFileCol*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*addedFileScale*/ 4) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*addedFileScale*/ ctx[2];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$7.name,
    		type: "slot",
    		source: "(46:8) ",
    		ctx
    	});

    	return block;
    }

    // (52:8) 
    function create_footerbtn_slot$5(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Add";
    			attr_dev(button, "slot", "footerbtn");
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$M, 51, 8, 1734);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$5.name,
    		type: "slot",
    		source: "(52:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $graphDiv;
    	validate_store(graphDiv, 'graphDiv');
    	component_subscribe($$self, graphDiv, $$value => $$invalidate(13, $graphDiv = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AddFilesToPlot', slots, []);
    	let { active = false, fileChecked = [], addedFileCol = 1, addedFileScale = 1000, addedfiles = [], addedFile = {}, extrafileAdded = 0 } = $$props;

    	function addFileSelection() {
    		browse({ dir: false }).then(result => {
    			if (result) {
    				$$invalidate(5, addedfiles = $$invalidate(6, addedFile["files"] = result, addedFile));
    			}
    		});
    	}

    	function plotData({ e = null } = {}) {
    		let pyfile = "addTrace.py", args;
    		if (addedFile.files < 1) return window.createToast("No files selected", "danger");
    		($$invalidate(6, addedFile["col"] = addedFileCol, addedFile), $$invalidate(6, addedFile["N"] = fileChecked.length + extrafileAdded, addedFile));
    		$$invalidate(6, addedFile["scale"] = addedFileScale, addedFile);
    		args = [JSON.stringify(addedFile)];

    		computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			Plotly.addTraces($graphDiv, dataFromPython);
    			$$invalidate(7, extrafileAdded += addedfiles.length);
    			window.createToast("Graph Plotted", "success");
    			$$invalidate(0, active = false);
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	const writable_props = [
    		'active',
    		'fileChecked',
    		'addedFileCol',
    		'addedFileScale',
    		'addedfiles',
    		'addedFile',
    		'extrafileAdded'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddFilesToPlot> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => plotData({ e });

    	function textfield0_value_binding(value) {
    		addedFileCol = value;
    		$$invalidate(1, addedFileCol);
    	}

    	function textfield1_value_binding(value) {
    		addedFileScale = value;
    		$$invalidate(2, addedFileScale);
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('fileChecked' in $$props) $$invalidate(8, fileChecked = $$props.fileChecked);
    		if ('addedFileCol' in $$props) $$invalidate(1, addedFileCol = $$props.addedFileCol);
    		if ('addedFileScale' in $$props) $$invalidate(2, addedFileScale = $$props.addedFileScale);
    		if ('addedfiles' in $$props) $$invalidate(5, addedfiles = $$props.addedfiles);
    		if ('addedFile' in $$props) $$invalidate(6, addedFile = $$props.addedFile);
    		if ('extrafileAdded' in $$props) $$invalidate(7, extrafileAdded = $$props.extrafileAdded);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		graphDiv,
    		Modal: Modal$1,
    		Textfield,
    		browse,
    		active,
    		fileChecked,
    		addedFileCol,
    		addedFileScale,
    		addedfiles,
    		addedFile,
    		extrafileAdded,
    		addFileSelection,
    		plotData,
    		$graphDiv
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('fileChecked' in $$props) $$invalidate(8, fileChecked = $$props.fileChecked);
    		if ('addedFileCol' in $$props) $$invalidate(1, addedFileCol = $$props.addedFileCol);
    		if ('addedFileScale' in $$props) $$invalidate(2, addedFileScale = $$props.addedFileScale);
    		if ('addedfiles' in $$props) $$invalidate(5, addedfiles = $$props.addedfiles);
    		if ('addedFile' in $$props) $$invalidate(6, addedFile = $$props.addedFile);
    		if ('extrafileAdded' in $$props) $$invalidate(7, extrafileAdded = $$props.extrafileAdded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		addedFileCol,
    		addedFileScale,
    		addFileSelection,
    		plotData,
    		addedfiles,
    		addedFile,
    		extrafileAdded,
    		fileChecked,
    		click_handler,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		modal_active_binding
    	];
    }

    class AddFilesToPlot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
    			active: 0,
    			fileChecked: 8,
    			addedFileCol: 1,
    			addedFileScale: 2,
    			addedfiles: 5,
    			addedFile: 6,
    			extrafileAdded: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddFilesToPlot",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get active() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addedFileCol() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedFileCol(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addedFileScale() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedFileScale(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addedfiles() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedfiles(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addedFile() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedFile(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extrafileAdded() {
    		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extrafileAdded(value) {
    		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$4 = {
        CELL: 'mdc-data-table__cell',
        CELL_NUMERIC: 'mdc-data-table__cell--numeric',
        CONTENT: 'mdc-data-table__content',
        HEADER_ROW: 'mdc-data-table__header-row',
        HEADER_ROW_CHECKBOX: 'mdc-data-table__header-row-checkbox',
        ROOT: 'mdc-data-table',
        ROW: 'mdc-data-table__row',
        ROW_CHECKBOX: 'mdc-data-table__row-checkbox',
        ROW_SELECTED: 'mdc-data-table__row--selected',
    };
    var strings$5 = {
        ARIA_SELECTED: 'aria-selected',
        DATA_ROW_ID_ATTR: 'data-row-id',
        HEADER_ROW_CHECKBOX_SELECTOR: "." + cssClasses$4.HEADER_ROW_CHECKBOX,
        ROW_CHECKBOX_SELECTOR: "." + cssClasses$4.ROW_CHECKBOX,
        ROW_SELECTED_SELECTOR: "." + cssClasses$4.ROW_SELECTED,
        ROW_SELECTOR: "." + cssClasses$4.ROW,
    };
    var events = {
        ROW_SELECTION_CHANGED: 'MDCDataTable:rowSelectionChanged',
        SELECTED_ALL: 'MDCDataTable:selectedAll',
        UNSELECTED_ALL: 'MDCDataTable:unselectedAll',
    };

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCDataTableFoundation = /** @class */ (function (_super) {
        __extends(MDCDataTableFoundation, _super);
        function MDCDataTableFoundation(adapter) {
            return _super.call(this, __assign({}, MDCDataTableFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCDataTableFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClassAtRowIndex: function () { return undefined; },
                    getRowCount: function () { return 0; },
                    getRowElements: function () { return []; },
                    getRowIdAtIndex: function () { return ''; },
                    getRowIndexByChildElement: function () { return 0; },
                    getSelectedRowCount: function () { return 0; },
                    isCheckboxAtRowIndexChecked: function () { return false; },
                    isHeaderRowCheckboxChecked: function () { return false; },
                    isRowsSelectable: function () { return false; },
                    notifyRowSelectionChanged: function () { return undefined; },
                    notifySelectedAll: function () { return undefined; },
                    notifyUnselectedAll: function () { return undefined; },
                    registerHeaderRowCheckbox: function () { return undefined; },
                    registerRowCheckboxes: function () { return undefined; },
                    removeClassAtRowIndex: function () { return undefined; },
                    setAttributeAtRowIndex: function () { return undefined; },
                    setHeaderRowCheckboxChecked: function () { return undefined; },
                    setHeaderRowCheckboxIndeterminate: function () { return undefined; },
                    setRowCheckboxCheckedAtIndex: function () { return undefined; },
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
         * Use this if registering checkbox is synchronous.
         */
        MDCDataTableFoundation.prototype.layout = function () {
            if (this.adapter_.isRowsSelectable()) {
                this.adapter_.registerHeaderRowCheckbox();
                this.adapter_.registerRowCheckboxes();
                this.setHeaderRowCheckboxState_();
            }
        };
        /**
         * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
         * Use this if registering checkbox is asynchronous.
         */
        MDCDataTableFoundation.prototype.layoutAsync = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.adapter_.isRowsSelectable()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.adapter_.registerHeaderRowCheckbox()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.adapter_.registerRowCheckboxes()];
                        case 2:
                            _a.sent();
                            this.setHeaderRowCheckboxState_();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @return Returns array of row elements.
         */
        MDCDataTableFoundation.prototype.getRows = function () {
            return this.adapter_.getRowElements();
        };
        /**
         * Sets selected row ids. Overwrites previously selected rows.
         * @param rowIds Array of row ids that needs to be selected.
         */
        MDCDataTableFoundation.prototype.setSelectedRowIds = function (rowIds) {
            for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
                var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
                var isSelected = false;
                if (rowId && rowIds.indexOf(rowId) >= 0) {
                    isSelected = true;
                }
                this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
                this.selectRowAtIndex_(rowIndex, isSelected);
            }
            this.setHeaderRowCheckboxState_();
        };
        /**
         * @return Returns array of selected row ids.
         */
        MDCDataTableFoundation.prototype.getSelectedRowIds = function () {
            var selectedRowIds = [];
            for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
                if (this.adapter_.isCheckboxAtRowIndexChecked(rowIndex)) {
                    selectedRowIds.push(this.adapter_.getRowIdAtIndex(rowIndex));
                }
            }
            return selectedRowIds;
        };
        /**
         * Handles header row checkbox change event.
         */
        MDCDataTableFoundation.prototype.handleHeaderRowCheckboxChange = function () {
            var isHeaderChecked = this.adapter_.isHeaderRowCheckboxChecked();
            for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
                this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
                this.selectRowAtIndex_(rowIndex, isHeaderChecked);
            }
            if (isHeaderChecked) {
                this.adapter_.notifySelectedAll();
            }
            else {
                this.adapter_.notifyUnselectedAll();
            }
        };
        /**
         * Handles change event originated from row checkboxes.
         */
        MDCDataTableFoundation.prototype.handleRowCheckboxChange = function (event) {
            var rowIndex = this.adapter_.getRowIndexByChildElement(event.target);
            if (rowIndex === -1) {
                return;
            }
            var selected = this.adapter_.isCheckboxAtRowIndexChecked(rowIndex);
            this.selectRowAtIndex_(rowIndex, selected);
            this.setHeaderRowCheckboxState_();
            var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
            this.adapter_.notifyRowSelectionChanged({ rowId: rowId, rowIndex: rowIndex, selected: selected });
        };
        /**
         * Updates header row checkbox state based on number of rows selected.
         */
        MDCDataTableFoundation.prototype.setHeaderRowCheckboxState_ = function () {
            if (this.adapter_.getSelectedRowCount() === this.adapter_.getRowCount()) {
                this.adapter_.setHeaderRowCheckboxChecked(true);
                this.adapter_.setHeaderRowCheckboxIndeterminate(false);
            }
            else if (this.adapter_.getSelectedRowCount() === 0) {
                this.adapter_.setHeaderRowCheckboxIndeterminate(false);
                this.adapter_.setHeaderRowCheckboxChecked(false);
            }
            else {
                this.adapter_.setHeaderRowCheckboxIndeterminate(true);
                this.adapter_.setHeaderRowCheckboxChecked(false);
            }
        };
        /**
         * Sets the attributes of row element based on selection state.
         */
        MDCDataTableFoundation.prototype.selectRowAtIndex_ = function (rowIndex, selected) {
            if (selected) {
                this.adapter_.addClassAtRowIndex(rowIndex, cssClasses$4.ROW_SELECTED);
                this.adapter_.setAttributeAtRowIndex(rowIndex, strings$5.ARIA_SELECTED, 'true');
            }
            else {
                this.adapter_.removeClassAtRowIndex(rowIndex, cssClasses$4.ROW_SELECTED);
                this.adapter_.setAttributeAtRowIndex(rowIndex, strings$5.ARIA_SELECTED, 'false');
            }
        };
        return MDCDataTableFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCDataTable = /** @class */ (function (_super) {
        __extends(MDCDataTable, _super);
        function MDCDataTable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCDataTable.attachTo = function (root) {
            return new MDCDataTable(root);
        };
        MDCDataTable.prototype.initialize = function (checkboxFactory) {
            if (checkboxFactory === void 0) { checkboxFactory = function (el) { return new MDCCheckbox(el); }; }
            this.checkboxFactory_ = checkboxFactory;
        };
        MDCDataTable.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.headerRow_ = this.root_.querySelector("." + cssClasses$4.HEADER_ROW);
            this.handleHeaderRowCheckboxChange_ = function () { return _this.foundation_.handleHeaderRowCheckboxChange(); };
            this.headerRow_.addEventListener('change', this.handleHeaderRowCheckboxChange_);
            this.content_ = this.root_.querySelector("." + cssClasses$4.CONTENT);
            this.handleRowCheckboxChange_ = function (event) { return _this.foundation_.handleRowCheckboxChange(event); };
            this.content_.addEventListener('change', this.handleRowCheckboxChange_);
            this.layout();
        };
        /**
         * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
         */
        MDCDataTable.prototype.layout = function () {
            this.foundation_.layout();
        };
        /**
         * @return Returns array of row elements.
         */
        MDCDataTable.prototype.getRows = function () {
            return this.foundation_.getRows();
        };
        /**
         * @return Returns array of selected row ids.
         */
        MDCDataTable.prototype.getSelectedRowIds = function () {
            return this.foundation_.getSelectedRowIds();
        };
        /**
         * Sets selected row ids. Overwrites previously selected rows.
         * @param rowIds Array of row ids that needs to be selected.
         */
        MDCDataTable.prototype.setSelectedRowIds = function (rowIds) {
            this.foundation_.setSelectedRowIds(rowIds);
        };
        MDCDataTable.prototype.destroy = function () {
            this.headerRow_.removeEventListener('change', this.handleHeaderRowCheckboxChange_);
            this.content_.removeEventListener('change', this.handleRowCheckboxChange_);
            this.headerRowCheckbox_.destroy();
            this.rowCheckboxList_.forEach(function (checkbox) { return checkbox.destroy(); });
        };
        MDCDataTable.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClassAtRowIndex: function (rowIndex, className) { return _this.getRows()[rowIndex].classList.add(className); },
                getRowCount: function () { return _this.getRows().length; },
                getRowElements: function () { return [].slice.call(_this.root_.querySelectorAll(strings$5.ROW_SELECTOR)); },
                getRowIdAtIndex: function (rowIndex) { return _this.getRows()[rowIndex].getAttribute(strings$5.DATA_ROW_ID_ATTR); },
                getRowIndexByChildElement: function (el) {
                    return _this.getRows().indexOf(closest(el, strings$5.ROW_SELECTOR));
                },
                getSelectedRowCount: function () { return _this.root_.querySelectorAll(strings$5.ROW_SELECTED_SELECTOR).length; },
                isCheckboxAtRowIndexChecked: function (rowIndex) { return _this.rowCheckboxList_[rowIndex].checked; },
                isHeaderRowCheckboxChecked: function () { return _this.headerRowCheckbox_.checked; },
                isRowsSelectable: function () { return !!_this.root_.querySelector(strings$5.ROW_CHECKBOX_SELECTOR); },
                notifyRowSelectionChanged: function (data) {
                    _this.emit(events.ROW_SELECTION_CHANGED, {
                        row: _this.getRowByIndex_(data.rowIndex),
                        rowId: _this.getRowIdByIndex_(data.rowIndex),
                        rowIndex: data.rowIndex,
                        selected: data.selected,
                    }, 
                    /** shouldBubble */ true);
                },
                notifySelectedAll: function () { return _this.emit(events.SELECTED_ALL, {}, /** shouldBubble */ true); },
                notifyUnselectedAll: function () { return _this.emit(events.UNSELECTED_ALL, {}, /** shouldBubble */ true); },
                registerHeaderRowCheckbox: function () {
                    if (_this.headerRowCheckbox_) {
                        _this.headerRowCheckbox_.destroy();
                    }
                    var checkboxEl = _this.root_.querySelector(strings$5.HEADER_ROW_CHECKBOX_SELECTOR);
                    _this.headerRowCheckbox_ = _this.checkboxFactory_(checkboxEl);
                },
                registerRowCheckboxes: function () {
                    if (_this.rowCheckboxList_) {
                        _this.rowCheckboxList_.forEach(function (checkbox) { return checkbox.destroy(); });
                    }
                    _this.rowCheckboxList_ = [];
                    _this.getRows().forEach(function (rowEl) {
                        var checkbox = _this.checkboxFactory_(rowEl.querySelector(strings$5.ROW_CHECKBOX_SELECTOR));
                        _this.rowCheckboxList_.push(checkbox);
                    });
                },
                removeClassAtRowIndex: function (rowIndex, className) {
                    _this.getRows()[rowIndex].classList.remove(className);
                },
                setAttributeAtRowIndex: function (rowIndex, attr, value) {
                    _this.getRows()[rowIndex].setAttribute(attr, value);
                },
                setHeaderRowCheckboxChecked: function (checked) {
                    _this.headerRowCheckbox_.checked = checked;
                },
                setHeaderRowCheckboxIndeterminate: function (indeterminate) {
                    _this.headerRowCheckbox_.indeterminate = indeterminate;
                },
                setRowCheckboxCheckedAtIndex: function (rowIndex, checked) {
                    _this.rowCheckboxList_[rowIndex].checked = checked;
                },
            };
            return new MDCDataTableFoundation(adapter);
        };
        MDCDataTable.prototype.getRowByIndex_ = function (index) {
            return this.getRows()[index];
        };
        MDCDataTable.prototype.getRowIdByIndex_ = function (index) {
            return this.getRowByIndex_(index).getAttribute(strings$5.DATA_ROW_ID_ATTR);
        };
        return MDCDataTable;
    }(MDCComponent));

    /* node_modules\@smui\data-table\DataTable.svelte generated by Svelte v3.42.1 */

    const { Error: Error_1 } = globals;
    const file$L = "node_modules\\@smui\\data-table\\DataTable.svelte";

    function create_fragment$P(ctx) {
    	let div;
    	let table;
    	let table_class_value;
    	let useActions_action;
    	let div_class_value;
    	let useActions_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	let table_levels = [
    		{
    			class: table_class_value = "mdc-data-table__table " + /*table$class*/ ctx[3]
    		},
    		prefixFilter(/*$$props*/ ctx[7], 'table$')
    	];

    	let table_data = {};

    	for (let i = 0; i < table_levels.length; i += 1) {
    		table_data = assign(table_data, table_levels[i]);
    	}

    	let div_levels = [
    		{
    			class: div_class_value = "mdc-data-table " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[7], ['use', 'class', 'table$'])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			if (default_slot) default_slot.c();
    			set_attributes(table, table_data);
    			add_location(table, file$L, 10, 2, 308);
    			set_attributes(div, div_data);
    			add_location(div, file$L, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);

    			if (default_slot) {
    				default_slot.m(table, null);
    			}

    			/*div_binding*/ ctx[14](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, table, /*table$use*/ ctx[2])),
    					action_destroyer(useActions_action_1 = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, div)),
    					listen_dev(div, "MDCDataTable:rowSelectionChanged", /*handleChange*/ ctx[6], false, false, false),
    					listen_dev(div, "MDCDataTable:selectedAll", /*handleChange*/ ctx[6], false, false, false),
    					listen_dev(div, "MDCDataTable:unselectedAll", /*handleChange*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(table, table_data = get_spread_update(table_levels, [
    				(!current || dirty & /*table$class*/ 8 && table_class_value !== (table_class_value = "mdc-data-table__table " + /*table$class*/ ctx[3])) && { class: table_class_value },
    				dirty & /*$$props*/ 128 && prefixFilter(/*$$props*/ ctx[7], 'table$')
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*table$use*/ 4) useActions_action.update.call(null, /*table$use*/ ctx[2]);

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "mdc-data-table " + /*className*/ ctx[1])) && { class: div_class_value },
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ['use', 'class', 'table$'])
    			]));

    			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DataTable', slots, ['default']);

    	if (events.ROW_SELECTION_CHANGED !== 'MDCDataTable:rowSelectionChanged' || events.SELECTED_ALL !== 'MDCDataTable:selectedAll' || events.UNSELECTED_ALL !== 'MDCDataTable:unselectedAll') {
    		throw new Error('MDC API has changed!');
    	}

    	const forwardEvents = forwardEventsBuilder(get_current_component(), [
    		'MDCDataTable:rowSelectionChanged',
    		'MDCDataTable:selectedAll',
    		'MDCDataTable:unselectedAll'
    	]);

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { table$use = [] } = $$props;
    	let { table$class = '' } = $$props;
    	let element;
    	let dataTable;
    	let changeHandlers = [];
    	let checkBoxHeaderPromiseResolve;
    	let checkBoxHeaderPromise = new Promise(resolve => checkBoxHeaderPromiseResolve = resolve);
    	let checkBoxListPromiseResolve;
    	let checkBoxListPromise = new Promise(resolve => checkBoxListPromiseResolve = resolve);
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;
    	setContext('SMUI:generic:input:addChangeHandler', addChangeHandler);
    	setContext('SMUI:checkbox:context', 'data-table');
    	setContext('SMUI:checkbox:instantiate', false);
    	setContext('SMUI:checkbox:getInstance', getCheckboxInstancePromise);

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(async () => {
    		dataTable = new MDCDataTable(element);
    		checkBoxHeaderPromiseResolve(dataTable.headerRowCheckbox_);
    		checkBoxListPromiseResolve(dataTable.rowCheckboxList_);

    		// Workaround for a bug in MDC DataTable where a table with no checkboxes
    		// calls destroy on them anyway.
    		if (!dataTable.headerRowCheckbox_) {
    			dataTable.headerRowCheckbox_ = {
    				destroy() {
    					
    				}
    			};
    		}

    		if (!dataTable.rowCheckboxList_) {
    			dataTable.rowCheckboxList_ = [];
    		}
    	});

    	onDestroy(() => {
    		dataTable && dataTable.destroy();

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function getCheckboxInstancePromise(header) {
    		return header ? checkBoxHeaderPromise : checkBoxListPromise;
    	}

    	function handleChange() {
    		for (let i = 0; i < changeHandlers.length; i++) {
    			changeHandlers[i]();
    		}
    	}

    	function addChangeHandler(handler) {
    		changeHandlers.push(handler);
    	}

    	function layout(...args) {
    		return dataTable.layout(...args);
    	}

    	function getRows(...args) {
    		return dataTable.getRows(...args);
    	}

    	function getSelectedRowIds(...args) {
    		return dataTable.getSelectedRowIds(...args);
    	}

    	function setSelectedRowIds(...args) {
    		return dataTable.setSelectedRowIds(...args);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('table$use' in $$new_props) $$invalidate(2, table$use = $$new_props.table$use);
    		if ('table$class' in $$new_props) $$invalidate(3, table$class = $$new_props.table$class);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCDataTable,
    		events,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		table$use,
    		table$class,
    		element,
    		dataTable,
    		changeHandlers,
    		checkBoxHeaderPromiseResolve,
    		checkBoxHeaderPromise,
    		checkBoxListPromiseResolve,
    		checkBoxListPromise,
    		addLayoutListener,
    		removeLayoutListener,
    		getCheckboxInstancePromise,
    		handleChange,
    		addChangeHandler,
    		layout,
    		getRows,
    		getSelectedRowIds,
    		setSelectedRowIds
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('table$use' in $$props) $$invalidate(2, table$use = $$new_props.table$use);
    		if ('table$class' in $$props) $$invalidate(3, table$class = $$new_props.table$class);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('dataTable' in $$props) dataTable = $$new_props.dataTable;
    		if ('changeHandlers' in $$props) changeHandlers = $$new_props.changeHandlers;
    		if ('checkBoxHeaderPromiseResolve' in $$props) checkBoxHeaderPromiseResolve = $$new_props.checkBoxHeaderPromiseResolve;
    		if ('checkBoxHeaderPromise' in $$props) checkBoxHeaderPromise = $$new_props.checkBoxHeaderPromise;
    		if ('checkBoxListPromiseResolve' in $$props) checkBoxListPromiseResolve = $$new_props.checkBoxListPromiseResolve;
    		if ('checkBoxListPromise' in $$props) checkBoxListPromise = $$new_props.checkBoxListPromise;
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		table$use,
    		table$class,
    		element,
    		forwardEvents,
    		handleChange,
    		$$props,
    		layout,
    		getRows,
    		getSelectedRowIds,
    		setSelectedRowIds,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class DataTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$P, create_fragment$P, safe_not_equal, {
    			use: 0,
    			class: 1,
    			table$use: 2,
    			table$class: 3,
    			layout: 8,
    			getRows: 9,
    			getSelectedRowIds: 10,
    			setSelectedRowIds: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DataTable",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get use() {
    		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get table$use() {
    		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set table$use(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get table$class() {
    		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set table$class(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[8];
    	}

    	set layout(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getRows() {
    		return this.$$.ctx[9];
    	}

    	set getRows(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectedRowIds() {
    		return this.$$.ctx[10];
    	}

    	set getSelectedRowIds(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setSelectedRowIds() {
    		return this.$$.ctx[11];
    	}

    	set setSelectedRowIds(value) {
    		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\data-table\Head.svelte generated by Svelte v3.42.1 */
    const file$K = "node_modules\\@smui\\data-table\\Head.svelte";

    function create_fragment$O(ctx) {
    	let thead;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let thead_levels = [exclude(/*$$props*/ ctx[2], ['use'])];
    	let thead_data = {};

    	for (let i = 0; i < thead_levels.length; i += 1) {
    		thead_data = assign(thead_data, thead_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			if (default_slot) default_slot.c();
    			set_attributes(thead, thead_data);
    			add_location(thead, file$K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);

    			if (default_slot) {
    				default_slot.m(thead, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, thead, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[1].call(null, thead))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ['use'])]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Head', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	setContext('SMUI:data-table:row:header', true);

    	$$self.$$set = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, forwardEvents, $$props, $$scope, slots];
    }

    class Head extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$O, create_fragment$O, safe_not_equal, { use: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Head",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get use() {
    		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\data-table\Body.svelte generated by Svelte v3.42.1 */
    const file$J = "node_modules\\@smui\\data-table\\Body.svelte";

    function create_fragment$N(ctx) {
    	let tbody;
    	let tbody_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	let tbody_levels = [
    		{
    			class: tbody_class_value = "mdc-data-table__content " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[3], ['use', 'class'])
    	];

    	let tbody_data = {};

    	for (let i = 0; i < tbody_levels.length; i += 1) {
    		tbody_data = assign(tbody_data, tbody_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			tbody = element("tbody");
    			if (default_slot) default_slot.c();
    			set_attributes(tbody, tbody_data);
    			add_location(tbody, file$J, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tbody, anchor);

    			if (default_slot) {
    				default_slot.m(tbody, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, tbody, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, tbody))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
    				(!current || dirty & /*className*/ 2 && tbody_class_value !== (tbody_class_value = "mdc-data-table__content " + /*className*/ ctx[1])) && { class: tbody_class_value },
    				dirty & /*$$props*/ 8 && exclude(/*$$props*/ ctx[3], ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tbody);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Body', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	setContext('SMUI:data-table:row:header', false);

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [use, className, forwardEvents, $$props, $$scope, slots];
    }

    class Body extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$N, create_fragment$N, safe_not_equal, { use: 0, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Body",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get use() {
    		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\data-table\Row.svelte generated by Svelte v3.42.1 */
    const file$I = "node_modules\\@smui\\data-table\\Row.svelte";

    function create_fragment$M(ctx) {
    	let tr;
    	let tr_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let tr_levels = [
    		{
    			class: tr_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*header*/ ctx[5] ? 'mdc-data-table__header-row' : '') + "\n    " + (!/*header*/ ctx[5] ? 'mdc-data-table__row' : '') + "\n    " + (!/*header*/ ctx[5] && /*selected*/ ctx[3]
    			? 'mdc-data-table__row--selected'
    			: '') + "\n  "
    		},
    		/*selected*/ ctx[3] !== undefined
    		? {
    				'aria-selected': /*selected*/ ctx[3] ? 'true' : 'false'
    			}
    		: {},
    		exclude(/*$$props*/ ctx[6], ['use', 'class'])
    	];

    	let tr_data = {};

    	for (let i = 0; i < tr_levels.length; i += 1) {
    		tr_data = assign(tr_data, tr_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			if (default_slot) default_slot.c();
    			set_attributes(tr, tr_data);
    			add_location(tr, file$I, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			/*tr_binding*/ ctx[9](tr);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, tr, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[4].call(null, tr))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(tr, tr_data = get_spread_update(tr_levels, [
    				(!current || dirty & /*className, selected*/ 10 && tr_class_value !== (tr_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*header*/ ctx[5] ? 'mdc-data-table__header-row' : '') + "\n    " + (!/*header*/ ctx[5] ? 'mdc-data-table__row' : '') + "\n    " + (!/*header*/ ctx[5] && /*selected*/ ctx[3]
    				? 'mdc-data-table__row--selected'
    				: '') + "\n  ")) && { class: tr_class_value },
    				dirty & /*selected*/ 8 && (/*selected*/ ctx[3] !== undefined
    				? {
    						'aria-selected': /*selected*/ ctx[3] ? 'true' : 'false'
    					}
    				: {}),
    				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ['use', 'class'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (default_slot) default_slot.d(detaching);
    			/*tr_binding*/ ctx[9](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Row', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let element;
    	let header = getContext('SMUI:data-table:row:header');
    	let selected = undefined;
    	setContext('SMUI:data-table:row:getIndex', getIndex);
    	setContext('SMUI:generic:input:setChecked', setChecked);

    	function setChecked(checked) {
    		$$invalidate(3, selected = checked);
    	}

    	function getIndex() {
    		let i = 0;

    		if (element) {
    			let el = element;

    			while (el.previousSibling) {
    				el = el.previousSibling;

    				if (el.nodeType === 1) {
    					i++;
    				}
    			}
    		}

    		return i;
    	}

    	function tr_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(2, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		element,
    		header,
    		selected,
    		setChecked,
    		getIndex
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('element' in $$props) $$invalidate(2, element = $$new_props.element);
    		if ('header' in $$props) $$invalidate(5, header = $$new_props.header);
    		if ('selected' in $$props) $$invalidate(3, selected = $$new_props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		element,
    		selected,
    		forwardEvents,
    		header,
    		$$props,
    		$$scope,
    		slots,
    		tr_binding
    	];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$M, create_fragment$M, safe_not_equal, { use: 0, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get use() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\data-table\Cell.svelte generated by Svelte v3.42.1 */
    const file$H = "node_modules\\@smui\\data-table\\Cell.svelte";

    // (14:0) {:else}
    function create_else_block$6(ctx) {
    	let td;
    	let td_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let td_levels = [
    		{
    			class: td_class_value = "\n      mdc-data-table__cell\n      " + /*className*/ ctx[1] + "\n      " + (/*numeric*/ ctx[2]
    			? 'mdc-data-table__cell--numeric'
    			: '') + "\n      " + (/*checkbox*/ ctx[3]
    			? 'mdc-data-table__cell--checkbox'
    			: '') + "\n    "
    		},
    		/*roleProp*/ ctx[5],
    		/*scopeProp*/ ctx[4],
    		/*props*/ ctx[6]
    	];

    	let td_data = {};

    	for (let i = 0; i < td_levels.length; i += 1) {
    		td_data = assign(td_data, td_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			set_attributes(td, td_data);
    			add_location(td, file$H, 14, 2, 284);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, td, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, td))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(td, td_data = get_spread_update(td_levels, [
    				(!current || dirty & /*className, numeric, checkbox*/ 14 && td_class_value !== (td_class_value = "\n      mdc-data-table__cell\n      " + /*className*/ ctx[1] + "\n      " + (/*numeric*/ ctx[2]
    				? 'mdc-data-table__cell--numeric'
    				: '') + "\n      " + (/*checkbox*/ ctx[3]
    				? 'mdc-data-table__cell--checkbox'
    				: '') + "\n    ")) && { class: td_class_value },
    				dirty & /*roleProp*/ 32 && /*roleProp*/ ctx[5],
    				dirty & /*scopeProp*/ 16 && /*scopeProp*/ ctx[4],
    				dirty & /*props*/ 64 && /*props*/ ctx[6]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(14:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if header}
    function create_if_block$q(ctx) {
    	let th;
    	let th_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let th_levels = [
    		{
    			class: th_class_value = "\n      mdc-data-table__header-cell\n      " + /*className*/ ctx[1] + "\n      " + (/*checkbox*/ ctx[3]
    			? 'mdc-data-table__header-cell--checkbox'
    			: '') + "\n    "
    		},
    		/*roleProp*/ ctx[5],
    		/*scopeProp*/ ctx[4],
    		/*props*/ ctx[6]
    	];

    	let th_data = {};

    	for (let i = 0; i < th_levels.length; i += 1) {
    		th_data = assign(th_data, th_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			th = element("th");
    			if (default_slot) default_slot.c();
    			set_attributes(th, th_data);
    			add_location(th, file$H, 1, 2, 15);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);

    			if (default_slot) {
    				default_slot.m(th, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, th, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, th))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(th, th_data = get_spread_update(th_levels, [
    				(!current || dirty & /*className, checkbox*/ 10 && th_class_value !== (th_class_value = "\n      mdc-data-table__header-cell\n      " + /*className*/ ctx[1] + "\n      " + (/*checkbox*/ ctx[3]
    				? 'mdc-data-table__header-cell--checkbox'
    				: '') + "\n    ")) && { class: th_class_value },
    				dirty & /*roleProp*/ 32 && /*roleProp*/ ctx[5],
    				dirty & /*scopeProp*/ 16 && /*scopeProp*/ ctx[4],
    				dirty & /*props*/ 64 && /*props*/ ctx[6]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(1:0) {#if header}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$q, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*header*/ ctx[8]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let props;
    	let roleProp;
    	let scopeProp;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let header = getContext('SMUI:data-table:row:header');
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { role = header ? 'columnheader' : undefined } = $$props;
    	let { scope = header ? 'col' : undefined } = $$props;
    	let { numeric = false } = $$props;
    	let { checkbox = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('role' in $$new_props) $$invalidate(9, role = $$new_props.role);
    		if ('scope' in $$new_props) $$invalidate(10, scope = $$new_props.scope);
    		if ('numeric' in $$new_props) $$invalidate(2, numeric = $$new_props.numeric);
    		if ('checkbox' in $$new_props) $$invalidate(3, checkbox = $$new_props.checkbox);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		header,
    		use,
    		className,
    		role,
    		scope,
    		numeric,
    		checkbox,
    		scopeProp,
    		roleProp,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ('header' in $$props) $$invalidate(8, header = $$new_props.header);
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('role' in $$props) $$invalidate(9, role = $$new_props.role);
    		if ('scope' in $$props) $$invalidate(10, scope = $$new_props.scope);
    		if ('numeric' in $$props) $$invalidate(2, numeric = $$new_props.numeric);
    		if ('checkbox' in $$props) $$invalidate(3, checkbox = $$new_props.checkbox);
    		if ('scopeProp' in $$props) $$invalidate(4, scopeProp = $$new_props.scopeProp);
    		if ('roleProp' in $$props) $$invalidate(5, roleProp = $$new_props.roleProp);
    		if ('props' in $$props) $$invalidate(6, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(6, props = exclude($$props, ['use', 'class', 'numeric', 'checkbox']));

    		if ($$self.$$.dirty & /*role*/ 512) {
    			$$invalidate(5, roleProp = role ? { role } : {});
    		}

    		if ($$self.$$.dirty & /*scope*/ 1024) {
    			$$invalidate(4, scopeProp = scope ? { scope } : {});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		numeric,
    		checkbox,
    		scopeProp,
    		roleProp,
    		props,
    		forwardEvents,
    		header,
    		role,
    		scope,
    		$$scope,
    		slots
    	];
    }

    class Cell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			use: 0,
    			class: 1,
    			role: 9,
    			scope: 10,
    			numeric: 2,
    			checkbox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get use() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scope() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scope(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get numeric() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numeric(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checkbox() {
    		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checkbox(value) {
    		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomCheckbox.svelte generated by Svelte v3.42.1 */
    const file$G = "src\\components\\CustomCheckbox.svelte";

    // (9:0) <FormField {style}>
    function create_default_slot$h(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[3](value);
    	}

    	let checkbox_props = {};

    	if (/*selected*/ ctx[0] !== void 0) {
    		checkbox_props.checked = /*selected*/ ctx[0];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (!updating_checked && dirty & /*selected*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(9:0) <FormField {style}>",
    		ctx
    	});

    	return block;
    }

    // (11:2) 
    function create_label_slot$3(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*label*/ ctx[1]);
    			attr_dev(span, "slot", "label");
    			add_location(span, file$G, 10, 2, 236);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$3.name,
    		type: "slot",
    		source: "(11:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let formfield;
    	let current;

    	formfield = new FormField({
    			props: {
    				style: /*style*/ ctx[2],
    				$$slots: {
    					label: [create_label_slot$3],
    					default: [create_default_slot$h]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfield.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const formfield_changes = {};
    			if (dirty & /*style*/ 4) formfield_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, label, selected*/ 19) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomCheckbox', slots, []);
    	let { selected = false, label = "Check me", style = "" } = $$props;
    	const writable_props = ['selected', 'label', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomCheckbox> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		FormField,
    		selected,
    		label,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, label, style, checkbox_checked_binding];
    }

    class CustomCheckbox$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$K, create_fragment$K, safe_not_equal, { selected: 0, label: 1, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomCheckbox",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get selected() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\components\FrequencyTable.svelte generated by Svelte v3.42.1 */

    const { console: console_1$g } = globals;
    const file$F = "src\\Pages\\normline\\components\\FrequencyTable.svelte";

    function get_each_context_2$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    function get_each_context_3$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (50:20) <Cell>
    function create_default_slot_31(ctx) {
    	let t_value = /*item*/ ctx[21] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31.name,
    		type: "slot",
    		source: "(50:20) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (49:16) {#each dataTableHead as item}
    function create_each_block_3$4(ctx) {
    	let cell;
    	let current;

    	cell = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_31] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				cell_changes.$$scope = { dirty, ctx };
    			}

    			cell.$set(cell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$4.name,
    		type: "each",
    		source: "(49:16) {#each dataTableHead as item}",
    		ctx
    	});

    	return block;
    }

    // (47:12) <Row>
    function create_default_slot_30(ctx) {
    	let cell0;
    	let t0;
    	let t1;
    	let cell1;
    	let current;

    	cell0 = new Cell({
    			props: { style: "width: 2em;" },
    			$$inline: true
    		});

    	let each_value_3 = /*dataTableHead*/ ctx[6];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$4(get_each_context_3$4(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	cell1 = new Cell({
    			props: { style: "width: 2em;" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(cell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(cell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTableHead*/ 64) {
    				each_value_3 = /*dataTableHead*/ ctx[6];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$4(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(cell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(cell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30.name,
    		type: "slot",
    		source: "(47:12) <Row>",
    		ctx
    	});

    	return block;
    }

    // (46:8) <Head >
    function create_default_slot_29(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_30] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(46:8) <Head >",
    		ctx
    	});

    	return block;
    }

    // (86:12) {:else}
    function create_else_block$5(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*$dataTable*/ ctx[3];
    	validate_each_argument(each_value_2);
    	const get_key = ctx => /*table*/ ctx[16].id;
    	validate_each_keys(ctx, each_value_2, get_each_context_2$6, get_key);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$6(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$6(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable, window*/ 8) {
    				each_value_2 = /*$dataTable*/ ctx[3];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$6, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2$6, each_1_anchor, get_each_context_2$6);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(86:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:93) 
    function create_if_block_1$a(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*$dataTable_avg*/ ctx[2];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*table*/ ctx[16].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$7, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$7(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$7(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg, window*/ 4) {
    				each_value_1 = /*$dataTable_avg*/ ctx[2];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$7, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$7, each_1_anchor, get_each_context_1$7);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(71:93) ",
    		ctx
    	});

    	return block;
    }

    // (56:12) {#if show_dataTable_only_weighted_averaged}
    function create_if_block$p(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*dataTable_weighted_avg*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*table*/ ctx[16].id;
    	validate_each_keys(ctx, each_value, get_each_context$d, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$d(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg, window*/ 2) {
    				each_value = /*dataTable_weighted_avg*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$d, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$d, each_1_anchor, get_each_context$d);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(56:12) {#if show_dataTable_only_weighted_averaged}",
    		ctx
    	});

    	return block;
    }

    // (90:24) <Cell style="width: 2em;">
    function create_default_slot_28(ctx) {
    	let t_value = /*index*/ ctx[18] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(90:24) <Cell style=\\\"width: 2em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (91:24) <Cell>
    function create_default_slot_27(ctx) {
    	let t_value = /*table*/ ctx[16].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(91:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (92:24) <Cell>
    function create_default_slot_26(ctx) {
    	let t_value = /*table*/ ctx[16].freq + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(92:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (93:24) <Cell>
    function create_default_slot_25(ctx) {
    	let t_value = /*table*/ ctx[16].amp + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(93:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (94:24) <Cell>
    function create_default_slot_24(ctx) {
    	let t_value = /*table*/ ctx[16].fwhm + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(94:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (95:24) <Cell>
    function create_default_slot_23(ctx) {
    	let t_value = /*table*/ ctx[16].sig + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(95:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (97:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {$dataTable = window._.filter($dataTable, (tb)=>tb.id != e.target.id)}}">
    function create_default_slot_22(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(97:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {$dataTable = window._.filter($dataTable, (tb)=>tb.id != e.target.id)}}\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:24) <Cell style="background: #f14668; cursor: pointer;">
    function create_default_slot_21(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				id: /*table*/ ctx[16].id,
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler_2*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*$dataTable*/ 8) icon_changes.id = /*table*/ ctx[16].id;

    			if (dirty & /*$$scope*/ 16777216) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(96:24) <Cell style=\\\"background: #f14668; cursor: pointer;\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:20) <Row style="background-color: {table.color};" class={table.className}>
    function create_default_slot_20(ctx) {
    	let cell0;
    	let t0;
    	let cell1;
    	let t1;
    	let cell2;
    	let t2;
    	let cell3;
    	let t3;
    	let cell4;
    	let t4;
    	let cell5;
    	let t5;
    	let cell6;
    	let t6;
    	let current;

    	cell0 = new Cell({
    			props: {
    				style: "width: 2em;",
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell2 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell3 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell4 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell5 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell6 = new Cell({
    			props: {
    				style: "background: #f14668; cursor: pointer;",
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t0 = space();
    			create_component(cell1.$$.fragment);
    			t1 = space();
    			create_component(cell2.$$.fragment);
    			t2 = space();
    			create_component(cell3.$$.fragment);
    			t3 = space();
    			create_component(cell4.$$.fragment);
    			t4 = space();
    			create_component(cell5.$$.fragment);
    			t5 = space();
    			create_component(cell6.$$.fragment);
    			t6 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cell2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cell3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cell4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(cell5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(cell6, target, anchor);
    			insert_dev(target, t6, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    			const cell2_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell2_changes.$$scope = { dirty, ctx };
    			}

    			cell2.$set(cell2_changes);
    			const cell3_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell3_changes.$$scope = { dirty, ctx };
    			}

    			cell3.$set(cell3_changes);
    			const cell4_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell4_changes.$$scope = { dirty, ctx };
    			}

    			cell4.$set(cell4_changes);
    			const cell5_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell5_changes.$$scope = { dirty, ctx };
    			}

    			cell5.$set(cell5_changes);
    			const cell6_changes = {};

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				cell6_changes.$$scope = { dirty, ctx };
    			}

    			cell6.$set(cell6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			transition_in(cell2.$$.fragment, local);
    			transition_in(cell3.$$.fragment, local);
    			transition_in(cell4.$$.fragment, local);
    			transition_in(cell5.$$.fragment, local);
    			transition_in(cell6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			transition_out(cell2.$$.fragment, local);
    			transition_out(cell3.$$.fragment, local);
    			transition_out(cell4.$$.fragment, local);
    			transition_out(cell5.$$.fragment, local);
    			transition_out(cell6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cell1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cell2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cell3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cell4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(cell5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(cell6, detaching);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(89:20) <Row style=\\\"background-color: {table.color};\\\" class={table.className}>",
    		ctx
    	});

    	return block;
    }

    // (88:16) {#each $dataTable as table, index (table.id)}
    function create_each_block_2$6(key_1, ctx) {
    	let first;
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				style: "background-color: " + /*table*/ ctx[16].color + ";",
    				class: /*table*/ ctx[16].className,
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*$dataTable*/ 8) row_changes.style = "background-color: " + /*table*/ ctx[16].color + ";";
    			if (dirty & /*$dataTable*/ 8) row_changes.class = /*table*/ ctx[16].className;

    			if (dirty & /*$$scope, $dataTable*/ 16777224) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$6.name,
    		type: "each",
    		source: "(88:16) {#each $dataTable as table, index (table.id)}",
    		ctx
    	});

    	return block;
    }

    // (74:24) <Cell style="width: 2em;">
    function create_default_slot_19(ctx) {
    	let t_value = /*index*/ ctx[18] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(74:24) <Cell style=\\\"width: 2em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:24) <Cell>
    function create_default_slot_18(ctx) {
    	let t_value = /*table*/ ctx[16].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(75:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (76:24) <Cell>
    function create_default_slot_17(ctx) {
    	let t_value = /*table*/ ctx[16].freq + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(76:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (77:24) <Cell>
    function create_default_slot_16(ctx) {
    	let t_value = /*table*/ ctx[16].amp + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(77:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (78:24) <Cell>
    function create_default_slot_15(ctx) {
    	let t_value = /*table*/ ctx[16].fwhm + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(78:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (79:24) <Cell>
    function create_default_slot_14(ctx) {
    	let t_value = /*table*/ ctx[16].sig + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(79:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (81:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {$dataTable_avg = window._.filter($dataTable_avg, (tb)=>tb.id != e.target.id)}}">
    function create_default_slot_13(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(81:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {$dataTable_avg = window._.filter($dataTable_avg, (tb)=>tb.id != e.target.id)}}\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:24) <Cell style="background: #f14668; cursor: pointer; width: 2em;">
    function create_default_slot_12(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				id: /*table*/ ctx[16].id,
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler_1*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*$dataTable_avg*/ 4) icon_changes.id = /*table*/ ctx[16].id;

    			if (dirty & /*$$scope*/ 16777216) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(80:24) <Cell style=\\\"background: #f14668; cursor: pointer; width: 2em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:20) <Row>
    function create_default_slot_11(ctx) {
    	let cell0;
    	let t0;
    	let cell1;
    	let t1;
    	let cell2;
    	let t2;
    	let cell3;
    	let t3;
    	let cell4;
    	let t4;
    	let cell5;
    	let t5;
    	let cell6;
    	let t6;
    	let current;

    	cell0 = new Cell({
    			props: {
    				style: "width: 2em;",
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell2 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell3 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell4 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell5 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell6 = new Cell({
    			props: {
    				style: "background: #f14668; cursor: pointer; width: 2em;",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t0 = space();
    			create_component(cell1.$$.fragment);
    			t1 = space();
    			create_component(cell2.$$.fragment);
    			t2 = space();
    			create_component(cell3.$$.fragment);
    			t3 = space();
    			create_component(cell4.$$.fragment);
    			t4 = space();
    			create_component(cell5.$$.fragment);
    			t5 = space();
    			create_component(cell6.$$.fragment);
    			t6 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cell2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cell3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cell4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(cell5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(cell6, target, anchor);
    			insert_dev(target, t6, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    			const cell2_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell2_changes.$$scope = { dirty, ctx };
    			}

    			cell2.$set(cell2_changes);
    			const cell3_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell3_changes.$$scope = { dirty, ctx };
    			}

    			cell3.$set(cell3_changes);
    			const cell4_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell4_changes.$$scope = { dirty, ctx };
    			}

    			cell4.$set(cell4_changes);
    			const cell5_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell5_changes.$$scope = { dirty, ctx };
    			}

    			cell5.$set(cell5_changes);
    			const cell6_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				cell6_changes.$$scope = { dirty, ctx };
    			}

    			cell6.$set(cell6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			transition_in(cell2.$$.fragment, local);
    			transition_in(cell3.$$.fragment, local);
    			transition_in(cell4.$$.fragment, local);
    			transition_in(cell5.$$.fragment, local);
    			transition_in(cell6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			transition_out(cell2.$$.fragment, local);
    			transition_out(cell3.$$.fragment, local);
    			transition_out(cell4.$$.fragment, local);
    			transition_out(cell5.$$.fragment, local);
    			transition_out(cell6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cell1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cell2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cell3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cell4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(cell5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(cell6, detaching);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(73:20) <Row>",
    		ctx
    	});

    	return block;
    }

    // (72:16) {#each $dataTable_avg as table, index (table.id)}
    function create_each_block_1$7(key_1, ctx) {
    	let first;
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};

    			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(72:16) {#each $dataTable_avg as table, index (table.id)}",
    		ctx
    	});

    	return block;
    }

    // (59:24) <Cell style="width: 2em;">
    function create_default_slot_10(ctx) {
    	let t_value = /*index*/ ctx[18] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(59:24) <Cell style=\\\"width: 2em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:24) <Cell>
    function create_default_slot_9(ctx) {
    	let t0;
    	let t1_value = /*index*/ ctx[18] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Line #");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t1_value !== (t1_value = /*index*/ ctx[18] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(60:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (61:24) <Cell>
    function create_default_slot_8(ctx) {
    	let t_value = /*table*/ ctx[16].freq + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(61:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (62:24) <Cell>
    function create_default_slot_7(ctx) {
    	let t_value = /*table*/ ctx[16].amp + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(62:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (63:24) <Cell>
    function create_default_slot_6(ctx) {
    	let t_value = /*table*/ ctx[16].fwhm + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(63:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (64:24) <Cell>
    function create_default_slot_5(ctx) {
    	let t_value = /*table*/ ctx[16].sig + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(64:24) <Cell>",
    		ctx
    	});

    	return block;
    }

    // (66:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, (tb)=>tb.id != e.target.id)}}">
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(66:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, (tb)=>tb.id != e.target.id)}}\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:24) <Cell style="background: #f14668; cursor: pointer;">
    function create_default_slot_3$2(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				id: /*table*/ ctx[16].id,
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*dataTable_weighted_avg*/ 2) icon_changes.id = /*table*/ ctx[16].id;

    			if (dirty & /*$$scope*/ 16777216) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(65:24) <Cell style=\\\"background: #f14668; cursor: pointer;\\\">",
    		ctx
    	});

    	return block;
    }

    // (58:20) <Row>
    function create_default_slot_2$5(ctx) {
    	let cell0;
    	let t0;
    	let cell1;
    	let t1;
    	let cell2;
    	let t2;
    	let cell3;
    	let t3;
    	let cell4;
    	let t4;
    	let cell5;
    	let t5;
    	let cell6;
    	let t6;
    	let current;

    	cell0 = new Cell({
    			props: {
    				style: "width: 2em;",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell1 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell2 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell3 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell4 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell5 = new Cell({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	cell6 = new Cell({
    			props: {
    				style: "background: #f14668; cursor: pointer;",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cell0.$$.fragment);
    			t0 = space();
    			create_component(cell1.$$.fragment);
    			t1 = space();
    			create_component(cell2.$$.fragment);
    			t2 = space();
    			create_component(cell3.$$.fragment);
    			t3 = space();
    			create_component(cell4.$$.fragment);
    			t4 = space();
    			create_component(cell5.$$.fragment);
    			t5 = space();
    			create_component(cell6.$$.fragment);
    			t6 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(cell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(cell2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(cell3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(cell4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(cell5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(cell6, target, anchor);
    			insert_dev(target, t6, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cell0_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell0_changes.$$scope = { dirty, ctx };
    			}

    			cell0.$set(cell0_changes);
    			const cell1_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell1_changes.$$scope = { dirty, ctx };
    			}

    			cell1.$set(cell1_changes);
    			const cell2_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell2_changes.$$scope = { dirty, ctx };
    			}

    			cell2.$set(cell2_changes);
    			const cell3_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell3_changes.$$scope = { dirty, ctx };
    			}

    			cell3.$set(cell3_changes);
    			const cell4_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell4_changes.$$scope = { dirty, ctx };
    			}

    			cell4.$set(cell4_changes);
    			const cell5_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell5_changes.$$scope = { dirty, ctx };
    			}

    			cell5.$set(cell5_changes);
    			const cell6_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				cell6_changes.$$scope = { dirty, ctx };
    			}

    			cell6.$set(cell6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cell0.$$.fragment, local);
    			transition_in(cell1.$$.fragment, local);
    			transition_in(cell2.$$.fragment, local);
    			transition_in(cell3.$$.fragment, local);
    			transition_in(cell4.$$.fragment, local);
    			transition_in(cell5.$$.fragment, local);
    			transition_in(cell6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cell0.$$.fragment, local);
    			transition_out(cell1.$$.fragment, local);
    			transition_out(cell2.$$.fragment, local);
    			transition_out(cell3.$$.fragment, local);
    			transition_out(cell4.$$.fragment, local);
    			transition_out(cell5.$$.fragment, local);
    			transition_out(cell6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cell1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(cell2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(cell3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(cell4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(cell5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(cell6, detaching);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(58:20) <Row>",
    		ctx
    	});

    	return block;
    }

    // (57:16) {#each dataTable_weighted_avg as table, index (table.id)}
    function create_each_block$d(key_1, ctx) {
    	let first;
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(57:16) {#each dataTable_weighted_avg as table, index (table.id)}",
    		ctx
    	});

    	return block;
    }

    // (55:8) <Body>
    function create_default_slot_1$8(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_if_block_1$a, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*show_dataTable_only_weighted_averaged*/ ctx[4]) return 0;
    		if (/*show_dataTable_only_averaged*/ ctx[5] && !/*show_dataTable_only_weighted_averaged*/ ctx[4]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(55:8) <Body>",
    		ctx
    	});

    	return block;
    }

    // (44:4) <DataTable table$aria-label="felix-tableAriaLabel" table$id="felixTable" id="felixTableContainer" class="tableContainer">
    function create_default_slot$g(ctx) {
    	let head;
    	let t;
    	let body;
    	let current;

    	head = new Head({
    			props: {
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	body = new Body({
    			props: {
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(head.$$.fragment);
    			t = space();
    			create_component(body.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(head, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(body, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const head_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				head_changes.$$scope = { dirty, ctx };
    			}

    			head.$set(head_changes);
    			const body_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg, show_dataTable_only_weighted_averaged, $dataTable_avg, show_dataTable_only_averaged, $dataTable*/ 16777278) {
    				body_changes.$$scope = { dirty, ctx };
    			}

    			body.$set(body_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(head.$$.fragment, local);
    			transition_in(body.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(head.$$.fragment, local);
    			transition_out(body.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(head, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(body, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(44:4) <DataTable table$aria-label=\\\"felix-tableAriaLabel\\\" table$id=\\\"felixTable\\\" id=\\\"felixTableContainer\\\" class=\\\"tableContainer\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let customcheckbox0;
    	let updating_selected;
    	let t2;
    	let customcheckbox1;
    	let updating_selected_1;
    	let t3;
    	let customcheckbox2;
    	let updating_selected_2;
    	let t4;
    	let button;
    	let t6;
    	let div2;
    	let datatable;
    	let current;
    	let mounted;
    	let dispose;

    	function customcheckbox0_selected_binding(value) {
    		/*customcheckbox0_selected_binding*/ ctx[8](value);
    	}

    	let customcheckbox0_props = { label: "Only Averaged" };

    	if (/*show_dataTable_only_averaged*/ ctx[5] !== void 0) {
    		customcheckbox0_props.selected = /*show_dataTable_only_averaged*/ ctx[5];
    	}

    	customcheckbox0 = new CustomCheckbox$1({
    			props: customcheckbox0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox0, 'selected', customcheckbox0_selected_binding));

    	function customcheckbox1_selected_binding(value) {
    		/*customcheckbox1_selected_binding*/ ctx[9](value);
    	}

    	let customcheckbox1_props = { label: "Only weighted Averaged" };

    	if (/*show_dataTable_only_weighted_averaged*/ ctx[4] !== void 0) {
    		customcheckbox1_props.selected = /*show_dataTable_only_weighted_averaged*/ ctx[4];
    	}

    	customcheckbox1 = new CustomCheckbox$1({
    			props: customcheckbox1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox1, 'selected', customcheckbox1_selected_binding));

    	function customcheckbox2_selected_binding(value) {
    		/*customcheckbox2_selected_binding*/ ctx[10](value);
    	}

    	let customcheckbox2_props = { label: "Keep table" };

    	if (/*keepTable*/ ctx[0] !== void 0) {
    		customcheckbox2_props.selected = /*keepTable*/ ctx[0];
    	}

    	customcheckbox2 = new CustomCheckbox$1({
    			props: customcheckbox2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox2, 'selected', customcheckbox2_selected_binding));

    	datatable = new DataTable({
    			props: {
    				"table$aria-label": "felix-tableAriaLabel",
    				table$id: "felixTable",
    				id: "felixTableContainer",
    				class: "tableContainer",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Frequency table";
    			t1 = space();
    			create_component(customcheckbox0.$$.fragment);
    			t2 = space();
    			create_component(customcheckbox1.$$.fragment);
    			t3 = space();
    			create_component(customcheckbox2.$$.fragment);
    			t4 = space();
    			button = element("button");
    			button.textContent = "Clear Table";
    			t6 = space();
    			div2 = element("div");
    			create_component(datatable.$$.fragment);
    			attr_dev(div0, "class", "title notification is-link svelte-1ts3clg");
    			add_location(div0, file$F, 33, 4, 1199);
    			attr_dev(button, "class", "button is-danger is-pulled-right");
    			add_location(button, file$F, 39, 4, 1539);
    			attr_dev(div1, "class", "content");
    			add_location(div1, file$F, 32, 0, 1172);
    			attr_dev(div2, "class", "dataTable svelte-1ts3clg");
    			add_location(div2, file$F, 42, 1, 1645);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			mount_component(customcheckbox0, div1, null);
    			append_dev(div1, t2);
    			mount_component(customcheckbox1, div1, null);
    			append_dev(div1, t3);
    			mount_component(customcheckbox2, div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, button);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(datatable, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*clearTable*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const customcheckbox0_changes = {};

    			if (!updating_selected && dirty & /*show_dataTable_only_averaged*/ 32) {
    				updating_selected = true;
    				customcheckbox0_changes.selected = /*show_dataTable_only_averaged*/ ctx[5];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customcheckbox0.$set(customcheckbox0_changes);
    			const customcheckbox1_changes = {};

    			if (!updating_selected_1 && dirty & /*show_dataTable_only_weighted_averaged*/ 16) {
    				updating_selected_1 = true;
    				customcheckbox1_changes.selected = /*show_dataTable_only_weighted_averaged*/ ctx[4];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customcheckbox1.$set(customcheckbox1_changes);
    			const customcheckbox2_changes = {};

    			if (!updating_selected_2 && dirty & /*keepTable*/ 1) {
    				updating_selected_2 = true;
    				customcheckbox2_changes.selected = /*keepTable*/ ctx[0];
    				add_flush_callback(() => updating_selected_2 = false);
    			}

    			customcheckbox2.$set(customcheckbox2_changes);
    			const datatable_changes = {};

    			if (dirty & /*$$scope, dataTable_weighted_avg, show_dataTable_only_weighted_averaged, $dataTable_avg, show_dataTable_only_averaged, $dataTable*/ 16777278) {
    				datatable_changes.$$scope = { dirty, ctx };
    			}

    			datatable.$set(datatable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customcheckbox0.$$.fragment, local);
    			transition_in(customcheckbox1.$$.fragment, local);
    			transition_in(customcheckbox2.$$.fragment, local);
    			transition_in(datatable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customcheckbox0.$$.fragment, local);
    			transition_out(customcheckbox1.$$.fragment, local);
    			transition_out(customcheckbox2.$$.fragment, local);
    			transition_out(datatable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(customcheckbox0);
    			destroy_component(customcheckbox1);
    			destroy_component(customcheckbox2);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div2);
    			destroy_component(datatable);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let dataTable_weighted_avg;
    	let $expfittedLinesCollectedData;
    	let $avgfittedLineCount;
    	let $dataTable_avg;
    	let $dataTable;
    	validate_store(expfittedLinesCollectedData, 'expfittedLinesCollectedData');
    	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(14, $expfittedLinesCollectedData = $$value));
    	validate_store(avgfittedLineCount, 'avgfittedLineCount');
    	component_subscribe($$self, avgfittedLineCount, $$value => $$invalidate(15, $avgfittedLineCount = $$value));
    	validate_store(dataTable_avg, 'dataTable_avg');
    	component_subscribe($$self, dataTable_avg, $$value => $$invalidate(2, $dataTable_avg = $$value));
    	validate_store(dataTable, 'dataTable');
    	component_subscribe($$self, dataTable, $$value => $$invalidate(3, $dataTable = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FrequencyTable', slots, []);
    	let { keepTable = true } = $$props;
    	const dataTableHead = ["Filename", "Frequency (cm-1)", "Amplitude", "FWHM", "Sigma"];

    	let show_dataTable_only_weighted_averaged = false,
    		show_dataTable_only_averaged = false;

    	function clearTable() {
    		set_store_value(dataTable, $dataTable = set_store_value(dataTable_avg, $dataTable_avg = [], $dataTable_avg), $dataTable);
    		set_store_value(avgfittedLineCount, $avgfittedLineCount = 0, $avgfittedLineCount);
    		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData);
    		window.createToast("Table cleared", "warning");
    	}

    	const writable_props = ['keepTable'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$g.warn(`<FrequencyTable> was created with unknown prop '${key}'`);
    	});

    	function customcheckbox0_selected_binding(value) {
    		show_dataTable_only_averaged = value;
    		$$invalidate(5, show_dataTable_only_averaged);
    	}

    	function customcheckbox1_selected_binding(value) {
    		show_dataTable_only_weighted_averaged = value;
    		$$invalidate(4, show_dataTable_only_weighted_averaged);
    	}

    	function customcheckbox2_selected_binding(value) {
    		keepTable = value;
    		$$invalidate(0, keepTable);
    	}

    	const click_handler = e => {
    		$$invalidate(1, dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, tb => tb.id != e.target.id));
    	};

    	const click_handler_1 = e => {
    		set_store_value(dataTable_avg, $dataTable_avg = window._.filter($dataTable_avg, tb => tb.id != e.target.id), $dataTable_avg);
    	};

    	const click_handler_2 = e => {
    		set_store_value(dataTable, $dataTable = window._.filter($dataTable, tb => tb.id != e.target.id), $dataTable);
    	};

    	$$self.$$set = $$props => {
    		if ('keepTable' in $$props) $$invalidate(0, keepTable = $$props.keepTable);
    	};

    	$$self.$capture_state = () => ({
    		dataTable_avg,
    		dataTable,
    		expfittedLinesCollectedData,
    		avgfittedLineCount,
    		DataTable,
    		Head,
    		Body,
    		Row,
    		Cell,
    		Icon,
    		CustomCheckbox: CustomCheckbox$1,
    		keepTable,
    		dataTableHead,
    		show_dataTable_only_weighted_averaged,
    		show_dataTable_only_averaged,
    		clearTable,
    		dataTable_weighted_avg,
    		$expfittedLinesCollectedData,
    		$avgfittedLineCount,
    		$dataTable_avg,
    		$dataTable
    	});

    	$$self.$inject_state = $$props => {
    		if ('keepTable' in $$props) $$invalidate(0, keepTable = $$props.keepTable);
    		if ('show_dataTable_only_weighted_averaged' in $$props) $$invalidate(4, show_dataTable_only_weighted_averaged = $$props.show_dataTable_only_weighted_averaged);
    		if ('show_dataTable_only_averaged' in $$props) $$invalidate(5, show_dataTable_only_averaged = $$props.show_dataTable_only_averaged);
    		if ('dataTable_weighted_avg' in $$props) $$invalidate(1, dataTable_weighted_avg = $$props.dataTable_weighted_avg);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$dataTable_avg*/ 4) {
    			$$invalidate(1, dataTable_weighted_avg = $dataTable_avg.filter(file => file.name == "weighted_mean"));
    		}

    		if ($$self.$$.dirty & /*$dataTable*/ 8) {
    			console.log("dataTable", $dataTable);
    		}

    		if ($$self.$$.dirty & /*$dataTable_avg*/ 4) {
    			console.log("dataTable_avg", $dataTable_avg);
    		}

    		if ($$self.$$.dirty & /*dataTable_weighted_avg*/ 2) {
    			console.log("dataTable_weighted_avg", dataTable_weighted_avg);
    		}
    	};

    	return [
    		keepTable,
    		dataTable_weighted_avg,
    		$dataTable_avg,
    		$dataTable,
    		show_dataTable_only_weighted_averaged,
    		show_dataTable_only_averaged,
    		dataTableHead,
    		clearTable,
    		customcheckbox0_selected_binding,
    		customcheckbox1_selected_binding,
    		customcheckbox2_selected_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class FrequencyTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$J, create_fragment$J, safe_not_equal, { keepTable: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FrequencyTable",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get keepTable() {
    		throw new Error("<FrequencyTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keepTable(value) {
    		throw new Error("<FrequencyTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomIconSwitch.svelte generated by Svelte v3.42.1 */

    // (9:4) <Icon class="material-icons" on>
    function create_default_slot_2$4(ctx) {
    	let t_value = /*icons*/ ctx[1][0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(9:4) <Icon class=\\\"material-icons\\\" on>",
    		ctx
    	});

    	return block;
    }

    // (11:4) <Icon class="material-icons">
    function create_default_slot_1$7(ctx) {
    	let t_value = /*icons*/ ctx[1][1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(11:4) <Icon class=\\\"material-icons\\\">",
    		ctx
    	});

    	return block;
    }

    // (7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>
    function create_default_slot$f(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon({
    			props: {
    				class: "material-icons",
    				on: true,
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon0_changes = {};

    			if (dirty & /*$$scope, icons*/ 34) {
    				icon0_changes.$$scope = { dirty, ctx };
    			}

    			icon0.$set(icon0_changes);
    			const icon1_changes = {};

    			if (dirty & /*$$scope, icons*/ 34) {
    				icon1_changes.$$scope = { dirty, ctx };
    			}

    			icon1.$set(icon1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let iconbutton;
    	let updating_pressed;
    	let current;

    	function iconbutton_pressed_binding(value) {
    		/*iconbutton_pressed_binding*/ ctx[3](value);
    	}

    	let iconbutton_props = {
    		style: /*style*/ ctx[2],
    		toggle: true,
    		$$slots: { default: [create_default_slot$f] },
    		$$scope: { ctx }
    	};

    	if (/*toggler*/ ctx[0] !== void 0) {
    		iconbutton_props.pressed = /*toggler*/ ctx[0];
    	}

    	iconbutton = new IconButton({ props: iconbutton_props, $$inline: true });
    	binding_callbacks.push(() => bind(iconbutton, 'pressed', iconbutton_pressed_binding));
    	iconbutton.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(iconbutton.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbutton_changes = {};
    			if (dirty & /*style*/ 4) iconbutton_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, icons*/ 34) {
    				iconbutton_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_pressed && dirty & /*toggler*/ 1) {
    				updating_pressed = true;
    				iconbutton_changes.pressed = /*toggler*/ ctx[0];
    				add_flush_callback(() => updating_pressed = false);
    			}

    			iconbutton.$set(iconbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomIconSwitch', slots, []);
    	let { icons = [], toggler = "", style = "" } = $$props;
    	const writable_props = ['icons', 'toggler', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomIconSwitch> was created with unknown prop '${key}'`);
    	});

    	function iconbutton_pressed_binding(value) {
    		toggler = value;
    		$$invalidate(0, toggler);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('icons' in $$props) $$invalidate(1, icons = $$props.icons);
    		if ('toggler' in $$props) $$invalidate(0, toggler = $$props.toggler);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ IconButton, Icon, icons, toggler, style });

    	$$self.$inject_state = $$props => {
    		if ('icons' in $$props) $$invalidate(1, icons = $$props.icons);
    		if ('toggler' in $$props) $$invalidate(0, toggler = $$props.toggler);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [toggler, icons, style, iconbutton_pressed_binding, click_handler];
    }

    class CustomIconSwitch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$I, create_fragment$I, safe_not_equal, { icons: 1, toggler: 0, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomIconSwitch",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get icons() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icons(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggler() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggler(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Modal.svelte generated by Svelte v3.42.1 */

    const { window: window_1 } = globals;
    const file$E = "src\\components\\Modal.svelte";
    const get_footerbtn_slot_changes = dirty => ({});
    const get_footerbtn_slot_context = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({ style: "white-space: pre-wrap;" });

    // (34:4) {#if $$slots.footerbtn}
    function create_if_block$o(ctx) {
    	let footer;
    	let div;
    	let current;
    	const footerbtn_slot_template = /*#slots*/ ctx[10].footerbtn;
    	const footerbtn_slot = create_slot(footerbtn_slot_template, ctx, /*$$scope*/ ctx[9], get_footerbtn_slot_context);

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			div = element("div");
    			if (footerbtn_slot) footerbtn_slot.c();
    			set_style(div, "margin-left", "auto");
    			set_style(div, "display", "flex");
    			add_location(div, file$E, 36, 8, 1336);
    			attr_dev(footer, "class", "modal-card-foot");
    			add_location(footer, file$E, 35, 4, 1294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			append_dev(footer, div);

    			if (footerbtn_slot) {
    				footerbtn_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footerbtn_slot) {
    				if (footerbtn_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						footerbtn_slot,
    						footerbtn_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(footerbtn_slot_template, /*$$scope*/ ctx[9], dirty, get_footerbtn_slot_changes),
    						get_footerbtn_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footerbtn_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footerbtn_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if (footerbtn_slot) footerbtn_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(34:4) {#if $$slots.footerbtn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let header;
    	let p;
    	let t1;
    	let t2;
    	let span;
    	let t3;
    	let section;
    	let section_style_value;
    	let section_id_value;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;
    	const content_slot_template = /*#slots*/ ctx[10].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[9], get_content_slot_context);
    	let if_block = /*$$slots*/ ctx[8].footerbtn && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			header = element("header");
    			p = element("p");
    			t1 = text(/*title*/ ctx[1]);
    			t2 = space();
    			span = element("span");
    			t3 = space();
    			section = element("section");
    			if (content_slot) content_slot.c();
    			t4 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "modal-background");
    			add_location(div0, file$E, 22, 2, 708);
    			attr_dev(p, "class", "modal-card-title svelte-eip82y");
    			add_location(p, file$E, 27, 6, 899);
    			attr_dev(span, "class", "delete is-pulled-right svelte-eip82y");
    			add_location(span, file$E, 28, 6, 946);
    			attr_dev(header, "class", "modal-card-head");
    			set_style(header, "background-color", /*headerBackground*/ ctx[6]);
    			add_location(header, file$E, 26, 4, 813);
    			attr_dev(section, "class", "modal-card-body svelte-eip82y");
    			attr_dev(section, "style", section_style_value = "background: " + /*bodyBackground*/ ctx[3] + "; " + /*bodyStyle*/ ctx[4]);
    			attr_dev(section, "id", section_id_value = /*contentID*/ ctx[5] || window.getID());
    			add_location(section, file$E, 31, 4, 1076);
    			attr_dev(div1, "class", "modal-card animated fadeIn faster");
    			attr_dev(div1, "style", /*style*/ ctx[2]);
    			add_location(div1, file$E, 23, 2, 748);
    			attr_dev(div2, "class", "modal");
    			toggle_class(div2, "is-active", /*active*/ ctx[0]);
    			add_location(div2, file$E, 21, 0, 660);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, header);
    			append_dev(header, p);
    			append_dev(p, t1);
    			append_dev(header, t2);
    			append_dev(header, span);
    			append_dev(div1, t3);
    			append_dev(div1, section);

    			if (content_slot) {
    				content_slot.m(section, null);
    			}

    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "keydown", /*keydown_handler*/ ctx[11], false, false, false),
    					listen_dev(span, "click", /*click_handler*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);

    			if (!current || dirty & /*headerBackground*/ 64) {
    				set_style(header, "background-color", /*headerBackground*/ ctx[6]);
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[9], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*bodyBackground, bodyStyle*/ 24 && section_style_value !== (section_style_value = "background: " + /*bodyBackground*/ ctx[3] + "; " + /*bodyStyle*/ ctx[4])) {
    				attr_dev(section, "style", section_style_value);
    			}

    			if (!current || dirty & /*contentID*/ 32 && section_id_value !== (section_id_value = /*contentID*/ ctx[5] || window.getID())) {
    				attr_dev(section, "id", section_id_value);
    			}

    			if (/*$$slots*/ ctx[8].footerbtn) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div1, "style", /*style*/ ctx[2]);
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div2, "is-active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (content_slot) content_slot.d(detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['content','footerbtn']);
    	const $$slots = compute_slots(slots);
    	let { active = false, title = "Title", style = "width:60vw", bodyBackground = "#634e96", bodyStyle = "max-height: 30em; height: 30em", contentID = "" } = $$props;
    	let { headerBackground = "#836ac05c" } = $$props;
    	const dispatch = createEventDispatcher();

    	const writable_props = [
    		'active',
    		'title',
    		'style',
    		'bodyBackground',
    		'bodyStyle',
    		'contentID',
    		'headerBackground'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	const keydown_handler = e => {
    		if (e.keyCode === 27) $$invalidate(0, active = false);
    	};

    	const click_handler = () => {
    		$$invalidate(0, active = false);
    		dispatch('closed', { active });
    	};

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('bodyBackground' in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
    		if ('bodyStyle' in $$props) $$invalidate(4, bodyStyle = $$props.bodyStyle);
    		if ('contentID' in $$props) $$invalidate(5, contentID = $$props.contentID);
    		if ('headerBackground' in $$props) $$invalidate(6, headerBackground = $$props.headerBackground);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		active,
    		title,
    		style,
    		bodyBackground,
    		bodyStyle,
    		contentID,
    		headerBackground,
    		dispatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('bodyBackground' in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
    		if ('bodyStyle' in $$props) $$invalidate(4, bodyStyle = $$props.bodyStyle);
    		if ('contentID' in $$props) $$invalidate(5, contentID = $$props.contentID);
    		if ('headerBackground' in $$props) $$invalidate(6, headerBackground = $$props.headerBackground);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		title,
    		style,
    		bodyBackground,
    		bodyStyle,
    		contentID,
    		headerBackground,
    		dispatch,
    		$$slots,
    		$$scope,
    		slots,
    		keydown_handler,
    		click_handler
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			active: 0,
    			title: 1,
    			style: 2,
    			bodyBackground: 3,
    			bodyStyle: 4,
    			contentID: 5,
    			headerBackground: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get active() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bodyBackground() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bodyBackground(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bodyStyle() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bodyStyle(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentID() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentID(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerBackground() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerBackground(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomCheckList.svelte generated by Svelte v3.42.1 */
    const file$D = "src\\components\\CustomCheckList.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (14:20) <Label>
    function create_default_slot_3$1(ctx) {
    	let t_value = /*item*/ ctx[5].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items*/ 2 && t_value !== (t_value = /*item*/ ctx[5].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(14:20) <Label>",
    		ctx
    	});

    	return block;
    }

    // (16:20) <Meta>
    function create_default_slot_2$3(ctx) {
    	let checkbox;
    	let updating_group;
    	let current;

    	function checkbox_group_binding(value) {
    		/*checkbox_group_binding*/ ctx[3](value);
    	}

    	let checkbox_props = { value: /*item*/ ctx[5].name };

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		checkbox_props.group = /*fileChecked*/ ctx[0];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'group', checkbox_group_binding));
    	checkbox.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};
    			if (dirty & /*items*/ 2) checkbox_changes.value = /*item*/ ctx[5].name;

    			if (!updating_group && dirty & /*fileChecked*/ 1) {
    				updating_group = true;
    				checkbox_changes.group = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_group = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(16:20) <Meta>",
    		ctx
    	});

    	return block;
    }

    // (12:16) <Item style="height:2.5em;">
    function create_default_slot_1$6(ctx) {
    	let label;
    	let t0;
    	let meta;
    	let t1;
    	let current;

    	label = new Label({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	meta = new Meta({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    			t0 = space();
    			create_component(meta.$$.fragment);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(meta, target, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope, items*/ 258) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    			const meta_changes = {};

    			if (dirty & /*$$scope, items, fileChecked*/ 259) {
    				meta_changes.$$scope = { dirty, ctx };
    			}

    			meta.$set(meta_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			transition_in(meta.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			transition_out(meta.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(meta, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(12:16) <Item style=\\\"height:2.5em;\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:12) {#each items as item}
    function create_each_block$c(ctx) {
    	let item;
    	let current;

    	item = new Item$1({
    			props: {
    				style: "height:2.5em;",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(item.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(item, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item_changes = {};

    			if (dirty & /*$$scope, items, fileChecked*/ 259) {
    				item_changes.$$scope = { dirty, ctx };
    			}

    			item.$set(item_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(item, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(11:12) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (10:8) <List checklist>
    function create_default_slot$e(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, fileChecked*/ 3) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(10:8) <List checklist>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div;
    	let list;
    	let current;

    	list = new List({
    			props: {
    				checklist: true,
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(list.$$.fragment);
    			attr_dev(div, "style", /*style*/ ctx[2]);
    			add_location(div, file$D, 8, 0, 184);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(list, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const list_changes = {};

    			if (dirty & /*$$scope, items, fileChecked*/ 259) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div, "style", /*style*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(list);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomCheckList', slots, []);
    	let { items = [], fileChecked = [], style = "" } = $$props;
    	const writable_props = ['items', 'fileChecked', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomCheckList> was created with unknown prop '${key}'`);
    	});

    	function checkbox_group_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		List,
    		Item: Item$1,
    		Meta,
    		Label,
    		Checkbox,
    		items,
    		fileChecked,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fileChecked, items, style, checkbox_group_binding, click_handler];
    }

    class CustomCheckList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$G, create_fragment$G, safe_not_equal, { items: 1, fileChecked: 0, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomCheckList",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get items() {
    		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomCheckbox.svelte generated by Svelte v3.42.1 */
    const file$C = "src\\components\\CustomCheckbox.svelte";

    // (9:0) <FormField {style}>
    function create_default_slot$d(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[3](value);
    	}

    	let checkbox_props = {};

    	if (/*selected*/ ctx[0] !== void 0) {
    		checkbox_props.checked = /*selected*/ ctx[0];
    	}

    	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (!updating_checked && dirty & /*selected*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(9:0) <FormField {style}>",
    		ctx
    	});

    	return block;
    }

    // (11:2) 
    function create_label_slot$2(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*label*/ ctx[1]);
    			attr_dev(span, "slot", "label");
    			add_location(span, file$C, 10, 2, 236);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$2.name,
    		type: "slot",
    		source: "(11:2) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let formfield;
    	let current;

    	formfield = new FormField({
    			props: {
    				style: /*style*/ ctx[2],
    				$$slots: {
    					label: [create_label_slot$2],
    					default: [create_default_slot$d]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfield.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const formfield_changes = {};
    			if (dirty & /*style*/ 4) formfield_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, label, selected*/ 19) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomCheckbox', slots, []);
    	let { selected = false, label = "Check me", style = "" } = $$props;
    	const writable_props = ['selected', 'label', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomCheckbox> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		FormField,
    		selected,
    		label,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, label, style, checkbox_checked_binding];
    }

    class CustomCheckbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$F, create_fragment$F, safe_not_equal, { selected: 0, label: 1, style: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomCheckbox",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get selected() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\modals\FelixPlotWidgets.svelte generated by Svelte v3.42.1 */
    const file$B = "src\\Pages\\normline\\modals\\FelixPlotWidgets.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[16] = list[i].value;
    	child_ctx[17] = list[i].id;
    	child_ctx[18] = list;
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[16] = list[i].value;
    	child_ctx[20] = list[i].step;
    	child_ctx[17] = list[i].id;
    	child_ctx[21] = list;
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[16] = list[i].value;
    	child_ctx[17] = list[i].id;
    	child_ctx[23] = list;
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context_3$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[25] = list[i].options;
    	child_ctx[26] = list[i].selected;
    	child_ctx[17] = list[i].id;
    	child_ctx[27] = list;
    	child_ctx[28] = i;
    	return child_ctx;
    }

    // (104:16) {#each $felixPlotCheckboxes as {label, options, selected, id}
    function create_each_block_3$3(key_1, ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*label*/ ctx[15] + "";
    	let t0;
    	let t1;
    	let customchecklist;
    	let updating_fileChecked;
    	let updating_items;
    	let t2;
    	let div1_transition;
    	let current;

    	function customchecklist_fileChecked_binding(value) {
    		/*customchecklist_fileChecked_binding*/ ctx[6](value, /*selected*/ ctx[26], /*each_value_3*/ ctx[27], /*each_index_3*/ ctx[28]);
    	}

    	function customchecklist_items_binding(value) {
    		/*customchecklist_items_binding*/ ctx[7](value, /*options*/ ctx[25], /*each_value_3*/ ctx[27], /*each_index_3*/ ctx[28]);
    	}

    	let customchecklist_props = {
    		style: "background: #836ac05c; border-radius: 20px; margin:1em 0;  height:20em; overflow:auto;"
    	};

    	if (/*selected*/ ctx[26] !== void 0) {
    		customchecklist_props.fileChecked = /*selected*/ ctx[26];
    	}

    	if (/*options*/ ctx[25] !== void 0) {
    		customchecklist_props.items = /*options*/ ctx[25];
    	}

    	customchecklist = new CustomCheckList({
    			props: customchecklist_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customchecklist, 'fileChecked', customchecklist_fileChecked_binding));
    	binding_callbacks.push(() => bind(customchecklist, 'items', customchecklist_items_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(customchecklist.$$.fragment);
    			t2 = space();
    			attr_dev(div0, "class", "subtitle felix_tkplot_filelist_header svelte-gj4r84");
    			add_location(div0, file$B, 106, 24, 2984);
    			attr_dev(div1, "class", "felix_tkplot_filelist_div svelte-gj4r84");
    			add_location(div1, file$B, 105, 20, 2903);
    			this.first = div1;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			mount_component(customchecklist, div1, null);
    			append_dev(div1, t2);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$felixPlotCheckboxes*/ 2) && t0_value !== (t0_value = /*label*/ ctx[15] + "")) set_data_dev(t0, t0_value);
    			const customchecklist_changes = {};

    			if (!updating_fileChecked && dirty & /*$felixPlotCheckboxes*/ 2) {
    				updating_fileChecked = true;
    				customchecklist_changes.fileChecked = /*selected*/ ctx[26];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			if (!updating_items && dirty & /*$felixPlotCheckboxes*/ 2) {
    				updating_items = true;
    				customchecklist_changes.items = /*options*/ ctx[25];
    				add_flush_callback(() => updating_items = false);
    			}

    			customchecklist.$set(customchecklist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customchecklist.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customchecklist.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(customchecklist);
    			if (detaching && div1_transition) div1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$3.name,
    		type: "each",
    		source: "(104:16) {#each $felixPlotCheckboxes as {label, options, selected, id}",
    		ctx
    	});

    	return block;
    }

    // (120:12) {#each felixPlotWidgets.text as {label, value, id}
    function create_each_block_2$5(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[8](value, /*value*/ ctx[16], /*each_value_2*/ ctx[23], /*each_index_2*/ ctx[24]);
    	}

    	let textfield_props = {
    		variant: "outlined",
    		type: "text",
    		label: /*label*/ ctx[15]
    	};

    	if (/*value*/ ctx[16] !== void 0) {
    		textfield_props.value = /*value*/ ctx[16];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*felixPlotWidgets*/ 1) textfield_changes.label = /*label*/ ctx[15];

    			if (!updating_value && dirty & /*felixPlotWidgets*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$5.name,
    		type: "each",
    		source: "(120:12) {#each felixPlotWidgets.text as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (135:12) {#each felixPlotWidgets.number as {label, value, step, id}
    function create_each_block_1$6(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[10](value, /*value*/ ctx[16], /*each_value_1*/ ctx[21], /*each_index_1*/ ctx[22]);
    	}

    	let textfield_props = {
    		type: "number",
    		step: /*step*/ ctx[20],
    		label: /*label*/ ctx[15]
    	};

    	if (/*value*/ ctx[16] !== void 0) {
    		textfield_props.value = /*value*/ ctx[16];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*felixPlotWidgets*/ 1) textfield_changes.step = /*step*/ ctx[20];
    			if (dirty & /*felixPlotWidgets*/ 1) textfield_changes.label = /*label*/ ctx[15];

    			if (!updating_value && dirty & /*felixPlotWidgets*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(135:12) {#each felixPlotWidgets.number as {label, value, step, id}",
    		ctx
    	});

    	return block;
    }

    // (148:12) {#each felixPlotWidgets.boolean as {label, value, id}
    function create_each_block$b(key_1, ctx) {
    	let first;
    	let customcheckbox;
    	let updating_selected;
    	let current;

    	function customcheckbox_selected_binding(value) {
    		/*customcheckbox_selected_binding*/ ctx[12](value, /*value*/ ctx[16], /*each_value*/ ctx[18], /*each_index*/ ctx[19]);
    	}

    	let customcheckbox_props = { label: /*label*/ ctx[15] };

    	if (/*value*/ ctx[16] !== void 0) {
    		customcheckbox_props.selected = /*value*/ ctx[16];
    	}

    	customcheckbox = new CustomCheckbox({
    			props: customcheckbox_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox, 'selected', customcheckbox_selected_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(customcheckbox.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(customcheckbox, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const customcheckbox_changes = {};
    			if (dirty & /*felixPlotWidgets*/ 1) customcheckbox_changes.label = /*label*/ ctx[15];

    			if (!updating_selected && dirty & /*felixPlotWidgets*/ 1) {
    				updating_selected = true;
    				customcheckbox_changes.selected = /*value*/ ctx[16];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customcheckbox.$set(customcheckbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customcheckbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customcheckbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(customcheckbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(148:12) {#each felixPlotWidgets.boolean as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div8;
    	let div1;
    	let button0;
    	let t1;
    	let div0;
    	let each_blocks_3 = [];
    	let each0_lookup = new Map();
    	let t2;
    	let div3;
    	let h10;
    	let t4;
    	let div2;
    	let each_blocks_2 = [];
    	let each1_lookup = new Map();
    	let t5;
    	let button1;
    	let t7;
    	let div5;
    	let h11;
    	let t9;
    	let div4;
    	let each_blocks_1 = [];
    	let each2_lookup = new Map();
    	let t10;
    	let button2;
    	let t12;
    	let div7;
    	let h12;
    	let t14;
    	let div6;
    	let each_blocks = [];
    	let each3_lookup = new Map();
    	let t15;
    	let button3;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*$felixPlotCheckboxes*/ ctx[1];
    	validate_each_argument(each_value_3);
    	const get_key = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value_3, get_each_context_3$3, get_key);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3$3(ctx, each_value_3, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_3[i] = create_each_block_3$3(key, child_ctx));
    	}

    	let each_value_2 = /*felixPlotWidgets*/ ctx[0].text;
    	validate_each_argument(each_value_2);
    	const get_key_1 = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key_1);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$5(ctx, each_value_2, i);
    		let key = get_key_1(child_ctx);
    		each1_lookup.set(key, each_blocks_2[i] = create_each_block_2$5(key, child_ctx));
    	}

    	let each_value_1 = /*felixPlotWidgets*/ ctx[0].number;
    	validate_each_argument(each_value_1);
    	const get_key_2 = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$6, get_key_2);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
    		let key = get_key_2(child_ctx);
    		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1$6(key, child_ctx));
    	}

    	let each_value = /*felixPlotWidgets*/ ctx[0].boolean;
    	validate_each_argument(each_value);
    	const get_key_3 = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value, get_each_context$b, get_key_3);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key_3(child_ctx);
    		each3_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Reload";
    			t1 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t2 = space();
    			div3 = element("div");
    			h10 = element("h1");
    			h10.textContent = "Text Widgets";
    			t4 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "Add widget";
    			t7 = space();
    			div5 = element("div");
    			h11 = element("h1");
    			h11.textContent = "Number Widgets";
    			t9 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Add widget";
    			t12 = space();
    			div7 = element("div");
    			h12 = element("h1");
    			h12.textContent = "Boolean Widgets";
    			t14 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t15 = space();
    			button3 = element("button");
    			button3.textContent = "Add widget";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$B, 98, 8, 2657);
    			attr_dev(div0, "class", "files__div svelte-gj4r84");
    			add_location(div0, file$B, 102, 12, 2771);
    			add_location(div1, file$B, 97, 4, 2641);
    			attr_dev(h10, "class", "subtitle");
    			add_location(h10, file$B, 116, 8, 3390);
    			attr_dev(div2, "class", "widgets svelte-gj4r84");
    			add_location(div2, file$B, 117, 8, 3438);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$B, 126, 8, 3663);
    			attr_dev(div3, "class", "felix_plotting_div svelte-gj4r84");
    			add_location(div3, file$B, 115, 4, 3348);
    			attr_dev(h11, "class", "subtitle");
    			add_location(h11, file$B, 132, 8, 3835);
    			attr_dev(div4, "class", "widgets svelte-gj4r84");
    			add_location(div4, file$B, 133, 8, 3885);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$B, 139, 8, 4102);
    			attr_dev(div5, "class", "felix_plotting_div svelte-gj4r84");
    			add_location(div5, file$B, 130, 4, 3791);
    			attr_dev(h12, "class", "subtitle");
    			add_location(h12, file$B, 145, 8, 4280);
    			attr_dev(div6, "class", "widgets svelte-gj4r84");
    			add_location(div6, file$B, 146, 8, 4331);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$B, 151, 8, 4537);
    			attr_dev(div7, "class", "felix_plotting_div svelte-gj4r84");
    			add_location(div7, file$B, 143, 4, 4232);
    			set_style(div8, "padding-bottom", "1em");
    			add_location(div8, file$B, 95, 0, 2599);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div0, null);
    			}

    			append_dev(div8, t2);
    			append_dev(div8, div3);
    			append_dev(div3, h10);
    			append_dev(div3, t4);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div2, null);
    			}

    			append_dev(div3, t5);
    			append_dev(div3, button1);
    			append_dev(div8, t7);
    			append_dev(div8, div5);
    			append_dev(div5, h11);
    			append_dev(div5, t9);
    			append_dev(div5, div4);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div4, null);
    			}

    			append_dev(div5, t10);
    			append_dev(div5, button2);
    			append_dev(div8, t12);
    			append_dev(div8, div7);
    			append_dev(div7, h12);
    			append_dev(div7, t14);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div7, t15);
    			append_dev(div7, button3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*refreshFunction*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(button2, "click", /*click_handler_1*/ ctx[11], false, false, false),
    					listen_dev(button3, "click", /*click_handler_2*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$felixPlotCheckboxes*/ 2) {
    				each_value_3 = /*$felixPlotCheckboxes*/ ctx[1];
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3$3, get_key);
    				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3$3, null, get_each_context_3$3);
    				check_outros();
    			}

    			if (dirty & /*felixPlotWidgets*/ 1) {
    				each_value_2 = /*felixPlotWidgets*/ ctx[0].text;
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key_1);
    				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div2, outro_and_destroy_block, create_each_block_2$5, null, get_each_context_2$5);
    				check_outros();
    			}

    			if (dirty & /*felixPlotWidgets*/ 1) {
    				each_value_1 = /*felixPlotWidgets*/ ctx[0].number;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$6, get_key_2);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx, each_value_1, each2_lookup, div4, outro_and_destroy_block, create_each_block_1$6, null, get_each_context_1$6);
    				check_outros();
    			}

    			if (dirty & /*felixPlotWidgets*/ 1) {
    				each_value = /*felixPlotWidgets*/ ctx[0].boolean;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$b, get_key_3);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key_3, 1, ctx, each_value, each3_lookup, div6, outro_and_destroy_block, create_each_block$b, null, get_each_context$b);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].d();
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].d();
    			}

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $felixPlotCheckboxes;
    	let $felixopoLocation;
    	validate_store(felixPlotCheckboxes, 'felixPlotCheckboxes');
    	component_subscribe($$self, felixPlotCheckboxes, $$value => $$invalidate(1, $felixPlotCheckboxes = $$value));
    	validate_store(felixopoLocation, 'felixopoLocation');
    	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(14, $felixopoLocation = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FelixPlotWidgets', slots, []);
    	let { felixPlotWidgets, theoryLocation } = $$props;
    	const dispatch = createEventDispatcher();
    	let reload = false;

    	function refreshFunction() {
    		// $felixPlotCheckboxes = []
    		let datlocation = pathResolve($felixopoLocation, "../EXPORT");

    		let datfiles = fs.existsSync(datlocation)
    		? fs.readdirSync(datlocation).filter(f => f.endsWith(".dat")).map(f => f = { name: f, id: getID() })
    		: [{ name: "", id: getID() }];

    		let calcfiles = [];

    		if (fs.existsSync(theoryLocation)) {
    			fs.readdirSync(theoryLocation).forEach(file => {
    				const isfile = fs.lstatSync(pathJoin(theoryLocation, file)).isFile();

    				if (isfile) {
    					calcfiles = [...calcfiles, { name: file, id: getID() }];
    				}
    			});
    		} else {
    			calcfiles = [{ name: "", id: getID() }];
    		}

    		set_store_value(
    			felixPlotCheckboxes,
    			$felixPlotCheckboxes = [
    				{
    					label: "DAT file",
    					options: datfiles,
    					selected: [],
    					id: getID()
    				},
    				{
    					label: "Fundamentals",
    					options: calcfiles,
    					selected: [],
    					id: getID()
    				},
    				{
    					label: "Overtones",
    					options: calcfiles,
    					selected: [],
    					id: getID()
    				},
    				{
    					label: "Combinations",
    					options: calcfiles,
    					selected: [],
    					id: getID()
    				}
    			],
    			$felixPlotCheckboxes
    		);
    	}

    	const writable_props = ['felixPlotWidgets', 'theoryLocation'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FelixPlotWidgets> was created with unknown prop '${key}'`);
    	});

    	function customchecklist_fileChecked_binding(value, selected, each_value_3, each_index_3) {
    		each_value_3[each_index_3].selected = value;
    		felixPlotCheckboxes.set($felixPlotCheckboxes);
    	}

    	function customchecklist_items_binding(value, options, each_value_3, each_index_3) {
    		each_value_3[each_index_3].options = value;
    		felixPlotCheckboxes.set($felixPlotCheckboxes);
    	}

    	function textfield_value_binding(value$1, value, each_value_2, each_index_2) {
    		each_value_2[each_index_2].value = value$1;
    		$$invalidate(0, felixPlotWidgets);
    	}

    	const click_handler = () => {
    		dispatch("addWidget", { type: "text" });
    	};

    	function textfield_value_binding_1(value$1, value, each_value_1, each_index_1) {
    		each_value_1[each_index_1].value = value$1;
    		$$invalidate(0, felixPlotWidgets);
    	}

    	const click_handler_1 = () => {
    		dispatch("addWidget", { type: "number" });
    	};

    	function customcheckbox_selected_binding(value$1, value, each_value, each_index) {
    		each_value[each_index].value = value$1;
    		$$invalidate(0, felixPlotWidgets);
    	}

    	const click_handler_2 = () => {
    		dispatch("addWidget", { type: "boolean" });
    	};

    	$$self.$$set = $$props => {
    		if ('felixPlotWidgets' in $$props) $$invalidate(0, felixPlotWidgets = $$props.felixPlotWidgets);
    		if ('theoryLocation' in $$props) $$invalidate(5, theoryLocation = $$props.theoryLocation);
    	};

    	$$self.$capture_state = () => ({
    		felixopoLocation,
    		felixPlotCheckboxes,
    		CustomCheckList,
    		Textfield,
    		CustomCheckbox,
    		createEventDispatcher,
    		fade,
    		felixPlotWidgets,
    		theoryLocation,
    		dispatch,
    		reload,
    		refreshFunction,
    		$felixPlotCheckboxes,
    		$felixopoLocation
    	});

    	$$self.$inject_state = $$props => {
    		if ('felixPlotWidgets' in $$props) $$invalidate(0, felixPlotWidgets = $$props.felixPlotWidgets);
    		if ('theoryLocation' in $$props) $$invalidate(5, theoryLocation = $$props.theoryLocation);
    		if ('reload' in $$props) $$invalidate(3, reload = $$props.reload);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		felixPlotWidgets,
    		$felixPlotCheckboxes,
    		dispatch,
    		reload,
    		refreshFunction,
    		theoryLocation,
    		customchecklist_fileChecked_binding,
    		customchecklist_items_binding,
    		textfield_value_binding,
    		click_handler,
    		textfield_value_binding_1,
    		click_handler_1,
    		customcheckbox_selected_binding,
    		click_handler_2
    	];
    }

    class FelixPlotWidgets extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$E, create_fragment$E, safe_not_equal, { felixPlotWidgets: 0, theoryLocation: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FelixPlotWidgets",
    			options,
    			id: create_fragment$E.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*felixPlotWidgets*/ ctx[0] === undefined && !('felixPlotWidgets' in props)) {
    			console.warn("<FelixPlotWidgets> was created without expected prop 'felixPlotWidgets'");
    		}

    		if (/*theoryLocation*/ ctx[5] === undefined && !('theoryLocation' in props)) {
    			console.warn("<FelixPlotWidgets> was created without expected prop 'theoryLocation'");
    		}
    	}

    	get felixPlotWidgets() {
    		throw new Error("<FelixPlotWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set felixPlotWidgets(value) {
    		throw new Error("<FelixPlotWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theoryLocation() {
    		throw new Error("<FelixPlotWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theoryLocation(value) {
    		throw new Error("<FelixPlotWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function savefile({file={}, name="", location=""}={}) {

        let filename = pathJoin(location || get_store_value(felixopoLocation), `${name}.json`);
        fs.writeFile(filename, JSON.stringify({file}), 'utf8', function (err) {

            if (err) {
                console.log("An error occured while writing to File.");
                return window.createToast("An error occured while writing to File.", "danger")
            }
            return window.createToast(`${name}.json has been saved.`, "success");
        });
    }

    function loadfile({name="", location=""}={}) {
        let filename = pathJoin( location || get_store_value(felixopoLocation), `${name}.json`);
        if(!fs.existsSync(filename)) {window.createToast(`${name}.json doesn't exist in DATA dir.`, "danger"); return {}}

        let loadedfile = JSON.parse(fs.readFileSync(filename)).file;

        window.createToast(`${name}.json has been loaded.`, "success");
        return loadedfile
    }

    function plotlySelection({graphDiv="avgplot", mode="felix"}={}) {

        const avgplot = document.getElementById(graphDiv);

        console.log("Creating plotly selection events for, ", avgplot);

        avgplot.on("plotly_selected", (data) => {

           try {
                console.log(data);
                mode === "felix" ? opoMode.set(false) : opoMode.set(true);


                const { range } = data;

                felixIndex.set(range.x);


                const output_name = data.points[0].data.name.split(".")[0];
                felixOutputName.set(output_name);
                console.log(`Selected file: ${get_store_value(felixOutputName)}`);

            } catch (error) { console.log("No data available to fit"); }

        });
    }


    function plotlyClick({graphDiv="avgplot", mode="felix"}={}){

        const avgplot = document.getElementById(graphDiv);
        console.log("Creating plotly click events for, ", avgplot);

        avgplot.on('plotly_click', (data)=>{
        
            console.log("Graph clicked: ", data);

            if (data.event.ctrlKey) {

                console.log("Data point length: ", data.points.length);


                for(let i=0; i<data.points.length; i++){

                    console.log("Running cycle: ", i);

                    let d = data.points[i];

                    let name = d.data.name;
                    mode === "felix" ? opoMode.set(false) : opoMode.set(true);

                    let output_name = get_store_value(felixOutputName);

                    if (name.includes(output_name)){

                        console.log("Filename: ", output_name);

                        let line_color = d.data.line.color;
                        console.log(name);
                        console.log(d, d.x, d.y);

                        let [freq, amp] = [parseFloat(d.x.toFixed(2)), parseFloat(d.y.toFixed(2))];
                        const annotation = { text: `(${freq}, ${amp})`, x: freq, y: amp, font:{color:line_color}, arrowcolor:line_color };
                        felixPlotAnnotations.update(annotate => _.uniqBy([...annotate, annotation], 'text'));
                        Plotly.relayout(graphDiv,{annotations: get_store_value(felixPlotAnnotations)});

                        felixPeakTable.update(table => [...table, {freq, amp, sig:get_store_value(Ngauss_sigma), id:getID()}]);
                        felixPeakTable.update(table => _.uniqBy(table, 'freq'));
                    }
                }

                console.log("Running cycle ended");
            } 
        });

    }

    /* src\Pages\normline\modals\FelixPlotExtraWidgets.svelte generated by Svelte v3.42.1 */
    const file$A = "src\\Pages\\normline\\modals\\FelixPlotExtraWidgets.svelte";

    // (14:0) {#if active}
    function create_if_block$n(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[8](value);
    	}

    	let modal_props = {
    		title: "Add widget",
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$4],
    			content: [create_content_slot$6]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, extraWidget, widgetType*/ 518) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(14:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (24:12) {#if widgetType === "number"}
    function create_if_block_1$9(ctx) {
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[7](value);
    	}

    	let textfield_props = {
    		style: "width:12em; margin-bottom:1em;",
    		variant: "outlined",
    		type: "number",
    		label: "step"
    	};

    	if (/*extraWidget*/ ctx[1].step !== void 0) {
    		textfield_props.value = /*extraWidget*/ ctx[1].step;
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*extraWidget*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*extraWidget*/ ctx[1].step;
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(24:12) {#if widgetType === \\\"number\\\"}",
    		ctx
    	});

    	return block;
    }

    // (18:8) 
    function create_content_slot$6(ctx) {
    	let div;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[5](value);
    	}

    	let textfield0_props = {
    		style: "width:12em; margin-bottom:1em;",
    		variant: "outlined",
    		type: "text",
    		label: "label"
    	};

    	if (/*extraWidget*/ ctx[1].label !== void 0) {
    		textfield0_props.value = /*extraWidget*/ ctx[1].label;
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[6](value);
    	}

    	let textfield1_props = {
    		style: "width:12em; margin-bottom:1em;",
    		variant: "outlined",
    		type: /*widgetType*/ ctx[2],
    		label: "value"
    	};

    	if (/*extraWidget*/ ctx[1].value !== void 0) {
    		textfield1_props.value = /*extraWidget*/ ctx[1].value;
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	let if_block = /*widgetType*/ ctx[2] === "number" && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "content");
    			set_style(div, "display", "grid");
    			set_style(div, "place-items", "center");
    			add_location(div, file$A, 17, 8, 405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t0);
    			mount_component(textfield1, div, null);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*extraWidget*/ 2) {
    				updating_value = true;
    				textfield0_changes.value = /*extraWidget*/ ctx[1].label;
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*widgetType*/ 4) textfield1_changes.type = /*widgetType*/ ctx[2];

    			if (!updating_value_1 && dirty & /*extraWidget*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*extraWidget*/ ctx[1].value;
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);

    			if (/*widgetType*/ ctx[2] === "number") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*widgetType*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$6.name,
    		type: "slot",
    		source: "(18:8) ",
    		ctx
    	});

    	return block;
    }

    // (31:8) 
    function create_footerbtn_slot$4(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(button, "slot", "footerbtn");
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$A, 30, 8, 1010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$4.name,
    		type: "slot",
    		source: "(31:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FelixPlotExtraWidgets', slots, []);
    	let { active = false, extraWidget = { label: "", value: "", step: "" }, widgetType = "text" } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ['active', 'extraWidget', 'widgetType'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FelixPlotExtraWidgets> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		dispatch("widgetadded");
    	};

    	function textfield0_value_binding(value) {
    		if ($$self.$$.not_equal(extraWidget.label, value)) {
    			extraWidget.label = value;
    			$$invalidate(1, extraWidget);
    		}
    	}

    	function textfield1_value_binding(value) {
    		if ($$self.$$.not_equal(extraWidget.value, value)) {
    			extraWidget.value = value;
    			$$invalidate(1, extraWidget);
    		}
    	}

    	function textfield_value_binding(value) {
    		if ($$self.$$.not_equal(extraWidget.step, value)) {
    			extraWidget.step = value;
    			$$invalidate(1, extraWidget);
    		}
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('extraWidget' in $$props) $$invalidate(1, extraWidget = $$props.extraWidget);
    		if ('widgetType' in $$props) $$invalidate(2, widgetType = $$props.widgetType);
    	};

    	$$self.$capture_state = () => ({
    		Modal: Modal$1,
    		Textfield,
    		createEventDispatcher,
    		active,
    		extraWidget,
    		widgetType,
    		dispatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('extraWidget' in $$props) $$invalidate(1, extraWidget = $$props.extraWidget);
    		if ('widgetType' in $$props) $$invalidate(2, widgetType = $$props.widgetType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		extraWidget,
    		widgetType,
    		dispatch,
    		click_handler,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield_value_binding,
    		modal_active_binding
    	];
    }

    class FelixPlotExtraWidgets extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$D, create_fragment$D, safe_not_equal, { active: 0, extraWidget: 1, widgetType: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FelixPlotExtraWidgets",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get active() {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extraWidget() {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extraWidget(value) {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get widgetType() {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set widgetType(value) {
    		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\modals\FelixPlotting.svelte generated by Svelte v3.42.1 */

    const { console: console_1$f } = globals;
    const file$z = "src\\Pages\\normline\\modals\\FelixPlotting.svelte";

    // (57:0) {#if active}
    function create_if_block$m(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[13](value);
    	}

    	let modal_props = {
    		title: "FELIX PLOTTING",
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$3],
    			content: [create_content_slot$5]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, theoryLocation, felixPlotWidgets*/ 262150) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(57:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (61:8) 
    function create_content_slot$5(ctx) {
    	let div;
    	let felixplotwidgets;
    	let updating_felixPlotWidgets;
    	let current;
    	let mounted;
    	let dispose;

    	function felixplotwidgets_felixPlotWidgets_binding(value) {
    		/*felixplotwidgets_felixPlotWidgets_binding*/ ctx[12](value);
    	}

    	let felixplotwidgets_props = {
    		theoryLocation: /*theoryLocation*/ ctx[2]
    	};

    	if (/*felixPlotWidgets*/ ctx[1] !== void 0) {
    		felixplotwidgets_props.felixPlotWidgets = /*felixPlotWidgets*/ ctx[1];
    	}

    	felixplotwidgets = new FelixPlotWidgets({
    			props: felixplotwidgets_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(felixplotwidgets, 'felixPlotWidgets', felixplotwidgets_felixPlotWidgets_binding));
    	felixplotwidgets.$on("addWidget", /*addExtraWidget*/ ctx[9]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(felixplotwidgets.$$.fragment);
    			attr_dev(div, "slot", "content");
    			set_style(div, "height", "40vh");
    			add_location(div, file$z, 60, 8, 1988);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(felixplotwidgets, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*loadExtraWidgets*/ ctx[8].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const felixplotwidgets_changes = {};
    			if (dirty & /*theoryLocation*/ 4) felixplotwidgets_changes.theoryLocation = /*theoryLocation*/ ctx[2];

    			if (!updating_felixPlotWidgets && dirty & /*felixPlotWidgets*/ 2) {
    				updating_felixPlotWidgets = true;
    				felixplotwidgets_changes.felixPlotWidgets = /*felixPlotWidgets*/ ctx[1];
    				add_flush_callback(() => updating_felixPlotWidgets = false);
    			}

    			felixplotwidgets.$set(felixplotwidgets_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(felixplotwidgets.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(felixplotwidgets.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(felixplotwidgets);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$5.name,
    		type: "slot",
    		source: "(61:8) ",
    		ctx
    	});

    	return block;
    }

    // (66:8) 
    function create_footerbtn_slot$3(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Save Widgets";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Submit";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$z, 67, 12, 2229);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$z, 69, 12, 2323);
    			attr_dev(div, "class", "");
    			attr_dev(div, "slot", "footerbtn");
    			add_location(div, file$z, 65, 8, 2182);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*saveWidget*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$3.name,
    		type: "slot",
    		source: "(66:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let t;
    	let felixplotextrawidgets;
    	let updating_active;
    	let updating_extraWidget;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$m(ctx);

    	function felixplotextrawidgets_active_binding(value) {
    		/*felixplotextrawidgets_active_binding*/ ctx[14](value);
    	}

    	function felixplotextrawidgets_extraWidget_binding(value) {
    		/*felixplotextrawidgets_extraWidget_binding*/ ctx[15](value);
    	}

    	let felixplotextrawidgets_props = { widgetType: /*widgetType*/ ctx[5] };

    	if (/*extraWidgetModal*/ ctx[4] !== void 0) {
    		felixplotextrawidgets_props.active = /*extraWidgetModal*/ ctx[4];
    	}

    	if (/*extraWidget*/ ctx[3] !== void 0) {
    		felixplotextrawidgets_props.extraWidget = /*extraWidget*/ ctx[3];
    	}

    	felixplotextrawidgets = new FelixPlotExtraWidgets({
    			props: felixplotextrawidgets_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(felixplotextrawidgets, 'active', felixplotextrawidgets_active_binding));
    	binding_callbacks.push(() => bind(felixplotextrawidgets, 'extraWidget', felixplotextrawidgets_extraWidget_binding));
    	felixplotextrawidgets.$on("widgetadded", /*widgetAdded*/ ctx[10]);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(felixplotextrawidgets.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(felixplotextrawidgets, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const felixplotextrawidgets_changes = {};
    			if (dirty & /*widgetType*/ 32) felixplotextrawidgets_changes.widgetType = /*widgetType*/ ctx[5];

    			if (!updating_active && dirty & /*extraWidgetModal*/ 16) {
    				updating_active = true;
    				felixplotextrawidgets_changes.active = /*extraWidgetModal*/ ctx[4];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_extraWidget && dirty & /*extraWidget*/ 8) {
    				updating_extraWidget = true;
    				felixplotextrawidgets_changes.extraWidget = /*extraWidget*/ ctx[3];
    				add_flush_callback(() => updating_extraWidget = false);
    			}

    			felixplotextrawidgets.$set(felixplotextrawidgets_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(felixplotextrawidgets.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(felixplotextrawidgets.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(felixplotextrawidgets, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const widgetFile = "felixplotWidgets";

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FelixPlotting', slots, []);
    	let { active = false, felixPlotWidgets = {}, theoryLocation } = $$props;
    	const dispatch = createEventDispatcher();
    	let extraWidgetCollection = { text: [], number: [], boolean: [] };
    	let extraWidget = { label: "", value: "", step: "" };
    	let extraWidgetModal = false, widgetType = "";
    	const widgetLocation = pathResolve(__dirname, "config");

    	function saveWidget() {
    		savefile({
    			file: extraWidgetCollection,
    			name: widgetFile,
    			location: widgetLocation
    		});
    	}

    	function loadExtraWidgets() {
    		const loadedContent = loadfile({
    			name: widgetFile,
    			location: widgetLocation
    		});

    		if (!loadedContent) {
    			extraWidgetCollection = loadedContent;
    			$$invalidate(1, felixPlotWidgets.text = [...felixPlotWidgets.text, extraWidgetCollection.text], felixPlotWidgets);
    			$$invalidate(1, felixPlotWidgets.number = [...felixPlotWidgets.number, extraWidgetCollection.number], felixPlotWidgets);
    			$$invalidate(1, felixPlotWidgets.boolean = [...felixPlotWidgets.boolean, extraWidgetCollection.boolean], felixPlotWidgets);
    		}
    	}

    	const addExtraWidget = event => {
    		$$invalidate(5, widgetType = event.detail.type);
    		$$invalidate(4, extraWidgetModal = true);
    	};

    	const widgetAdded = () => {
    		$$invalidate(3, extraWidget.id = window.getID(), extraWidget);
    		$$invalidate(1, felixPlotWidgets[widgetType] = [...felixPlotWidgets[widgetType], extraWidget], felixPlotWidgets);
    		console.log(felixPlotWidgets[widgetType]);
    		extraWidgetCollection[widgetType] = [...extraWidgetCollection[widgetType], extraWidget];
    		$$invalidate(3, extraWidget = { label: "", value: "", step: "" });
    		$$invalidate(4, extraWidgetModal = false);
    	};

    	const writable_props = ['active', 'felixPlotWidgets', 'theoryLocation'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$f.warn(`<FelixPlotting> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		dispatch('submit', { event: e });
    	};

    	function felixplotwidgets_felixPlotWidgets_binding(value) {
    		felixPlotWidgets = value;
    		$$invalidate(1, felixPlotWidgets);
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	function felixplotextrawidgets_active_binding(value) {
    		extraWidgetModal = value;
    		$$invalidate(4, extraWidgetModal);
    	}

    	function felixplotextrawidgets_extraWidget_binding(value) {
    		extraWidget = value;
    		$$invalidate(3, extraWidget);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('felixPlotWidgets' in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
    		if ('theoryLocation' in $$props) $$invalidate(2, theoryLocation = $$props.theoryLocation);
    	};

    	$$self.$capture_state = () => ({
    		Modal,
    		FelixPlotWidgets,
    		loadfile,
    		savefile,
    		createEventDispatcher,
    		FelixPlotExtraWidgets,
    		active,
    		felixPlotWidgets,
    		theoryLocation,
    		dispatch,
    		extraWidgetCollection,
    		extraWidget,
    		extraWidgetModal,
    		widgetType,
    		widgetLocation,
    		widgetFile,
    		saveWidget,
    		loadExtraWidgets,
    		addExtraWidget,
    		widgetAdded
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('felixPlotWidgets' in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
    		if ('theoryLocation' in $$props) $$invalidate(2, theoryLocation = $$props.theoryLocation);
    		if ('extraWidgetCollection' in $$props) extraWidgetCollection = $$props.extraWidgetCollection;
    		if ('extraWidget' in $$props) $$invalidate(3, extraWidget = $$props.extraWidget);
    		if ('extraWidgetModal' in $$props) $$invalidate(4, extraWidgetModal = $$props.extraWidgetModal);
    		if ('widgetType' in $$props) $$invalidate(5, widgetType = $$props.widgetType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		felixPlotWidgets,
    		theoryLocation,
    		extraWidget,
    		extraWidgetModal,
    		widgetType,
    		dispatch,
    		saveWidget,
    		loadExtraWidgets,
    		addExtraWidget,
    		widgetAdded,
    		click_handler,
    		felixplotwidgets_felixPlotWidgets_binding,
    		modal_active_binding,
    		felixplotextrawidgets_active_binding,
    		felixplotextrawidgets_extraWidget_binding
    	];
    }

    class FelixPlotting extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			active: 0,
    			felixPlotWidgets: 1,
    			theoryLocation: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FelixPlotting",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*theoryLocation*/ ctx[2] === undefined && !('theoryLocation' in props)) {
    			console_1$f.warn("<FelixPlotting> was created without expected prop 'theoryLocation'");
    		}
    	}

    	get active() {
    		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get felixPlotWidgets() {
    		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set felixPlotWidgets(value) {
    		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theoryLocation() {
    		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theoryLocation(value) {
    		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function beforePlot({ delta, dataFromPython, graphDiv, baseGraphDiv } = {}) {

        felixOutputName.set("averaged"), felixIndex.set([]);

        let avgdataToPlot, signal_formula, ylabel;

        if (get_store_value(normMethod) === "Log") {
            avgdataToPlot = dataFromPython["average"];
            signal_formula = "Signal = -ln(C/B)/Power(in J)";
            ylabel = "Normalised Intensity per J";
        } else if (get_store_value(normMethod) == "Relative") {
            avgdataToPlot = dataFromPython["average_rel"];
            signal_formula = "Signal = (1-C/B)*100";
            ylabel = "Relative Depletion (%)";

        } else if (get_store_value(normMethod) == "IntensityPerPhoton") {

            avgdataToPlot = dataFromPython["average_per_photon"];

            signal_formula = "Signal = -ln(C/B)/#Photons";
            ylabel = "Normalised Intensity per photon";
        }
        const get_data = (data) => {
            let dataPlot = [];
            for (let x in data) { dataPlot.push(data[x]); }
            return dataPlot
        };
        let signal = {
            "rel": "Signal = (1-C/B)*100", "log": "Signal = -ln(C/B)/Power(in J)",
            "hv": "Signal = -ln(C/B)/#Photons"
        };

        const set_title = (method) => `Normalised and Averaged Spectrum (delta=${delta})<br>${signal[method]}; {C=Measured Count, B=Baseline Count}`;

        const normMethod_datas = {
            "Relative": {
                "data": get_data(dataFromPython["average_rel"]),
                "layout": {
                    "title": set_title("rel"),
                    "yaxis": { "title": "Relative Depletion (%)" },
                    "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
                }
            },
            "Log": {
                "data": get_data(dataFromPython["average"]),
                "layout": {
                    "title": set_title("log"),
                    "yaxis": { "title": "Normalised Intensity per J" },
                    "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
                }
            },
            "IntensityPerPhoton": {
                "data": get_data(dataFromPython["average_per_photon"]),
                "layout": {
                    "title": set_title("hv"),
                    "yaxis": { "title": "Normalised Intensity per photon" },
                    "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
                }

            }

        };


        if (get_store_value(opoMode)) { opoData.set(normMethod_datas); } else { { felixData.set(normMethod_datas); } }

        plot(
            "Baseline Corrected",
            "Wavelength (cm-1)",
            "Counts",
            dataFromPython["base"], baseGraphDiv
            
        );

        plot(
            `Normalised and Averaged Spectrum (delta=${delta})<br>${signal_formula}; {C=Measured Count, B=Baseline Count}`,
            "Calibrated Wavelength (cm-1)",
            ylabel,
            avgdataToPlot, graphDiv
        );

        return Promise.resolve()

    }

    async function felix_func({ normMethod, dataFromPython, delta } = {}) {

        await beforePlot({ delta, dataFromPython, graphDiv: "avgplot", baseGraphDiv:"bplot" });

        subplot(
            "Spectrum and Power Analyser",

            "Wavelength set (cm-1)",
            "SA (cm-1)",
            dataFromPython["SA"],

            "saPlot",

            "Wavelength (cm-1)",
            `Total Power (mJ)`,
            dataFromPython["pow"]
        );

        if (!get_store_value(plotlyEventCreatedFELIX)) {
            const plot = { graphDiv: "avgplot", mode: "felix" };
            plotlySelection(plot), plotlyClick(plot);

            plotlyEventCreatedFELIX.set(true);

        }

        const graphDivIds = ["exp-theory-plot", "bplot", "saPlot", "avgplot", "opoplot", "opoSA", "opoRelPlot"];
        graphDivIds.forEach(id=>{

            const content = document.getElementById(id).innerHTML;
            
            const width = document.getElementById(id).clientWidth;
            
            if(content){ Plotly.relayout(id, {width}); }
        });



        console.log("Graph Plotted");

    }

    /* src\Pages\normline\widgets\preprocessing\InitFunctionRow.svelte generated by Svelte v3.42.1 */

    const { console: console_1$e } = globals;
    const file$y = "src\\Pages\\normline\\widgets\\preprocessing\\InitFunctionRow.svelte";

    function create_fragment$B(ctx) {
    	let felixplotting;
    	let updating_active;
    	let updating_felixPlotWidgets;
    	let t0;
    	let div;
    	let button0;
    	let t1;
    	let span;
    	let t3;
    	let button1;
    	let t5;
    	let textfield;
    	let updating_value;
    	let t6;
    	let button2;
    	let t8;
    	let customiconswitch;
    	let updating_toggler;
    	let t9;
    	let button3;
    	let t11;
    	let button4;
    	let current;
    	let mounted;
    	let dispose;

    	function felixplotting_active_binding(value) {
    		/*felixplotting_active_binding*/ ctx[16](value);
    	}

    	function felixplotting_felixPlotWidgets_binding(value) {
    		/*felixplotting_felixPlotWidgets_binding*/ ctx[17](value);
    	}

    	let felixplotting_props = {
    		theoryLocation: /*theoryLocation*/ ctx[0]
    	};

    	if (/*active*/ ctx[1] !== void 0) {
    		felixplotting_props.active = /*active*/ ctx[1];
    	}

    	if (/*felixPlotWidgets*/ ctx[4] !== void 0) {
    		felixplotting_props.felixPlotWidgets = /*felixPlotWidgets*/ ctx[4];
    	}

    	felixplotting = new FelixPlotting({
    			props: felixplotting_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(felixplotting, 'active', felixplotting_active_binding));
    	binding_callbacks.push(() => bind(felixplotting, 'felixPlotWidgets', felixplotting_felixPlotWidgets_binding));
    	felixplotting.$on("submit", /*submit_handler*/ ctx[18]);

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[21](value);
    	}

    	let textfield_props = {
    		style: "width:7em",
    		variant: "outlined",
    		input$type: "number",
    		input$step: /*fdelta*/ ctx[5],
    		input$min: "0",
    		label: "Delta"
    	};

    	if (/*delta*/ ctx[3] !== void 0) {
    		textfield_props.value = /*delta*/ ctx[3];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[23](value);
    	}

    	let customiconswitch_props = { icons: ["settings_ethernet", "code"] };

    	if (/*openShell*/ ctx[2] !== void 0) {
    		customiconswitch_props.toggler = /*openShell*/ ctx[2];
    	}

    	customiconswitch = new CustomIconSwitch({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));

    	const block = {
    		c: function create() {
    			create_component(felixplotting.$$.fragment);
    			t0 = space();
    			div = element("div");
    			button0 = element("button");
    			t1 = text("Create Baseline ");
    			span = element("span");
    			span.textContent = "b";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "FELIX Plot";
    			t5 = space();
    			create_component(textfield.$$.fragment);
    			t6 = space();
    			button2 = element("button");
    			button2.textContent = "Open in Matplotlib";
    			t8 = space();
    			create_component(customiconswitch.$$.fragment);
    			t9 = space();
    			button3 = element("button");
    			button3.textContent = "Add Theory";
    			t11 = space();
    			button4 = element("button");
    			button4.textContent = "OPO";
    			attr_dev(span, "class", "tag is-warning  svelte-8k4cg5");
    			attr_dev(span, "aria-label", "ctrl + left-click to select file for baseline correction");
    			attr_dev(span, "data-cooltipz-dir", "bottom");
    			add_location(span, file$y, 137, 132, 5280);
    			attr_dev(button0, "class", "button is-link");
    			attr_dev(button0, "id", "create_baseline_btn");
    			add_location(button0, file$y, 137, 4, 5152);
    			attr_dev(button1, "class", "button is-link");
    			attr_dev(button1, "id", "felix_plotting_btn");
    			add_location(button1, file$y, 139, 4, 5437);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$y, 143, 4, 5719);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$y, 145, 4, 5903);
    			attr_dev(button4, "class", "button is-link");
    			add_location(button4, file$y, 146, 4, 6001);
    			attr_dev(div, "class", "align");
    			add_location(div, file$y, 135, 0, 5125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(felixplotting, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(button0, t1);
    			append_dev(button0, span);
    			append_dev(div, t3);
    			append_dev(div, button1);
    			append_dev(div, t5);
    			mount_component(textfield, div, null);
    			append_dev(div, t6);
    			append_dev(div, button2);
    			append_dev(div, t8);
    			mount_component(customiconswitch, div, null);
    			append_dev(div, t9);
    			append_dev(div, button3);
    			append_dev(div, t11);
    			append_dev(div, button4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[19], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[20], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[22], false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[24], false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[25], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const felixplotting_changes = {};
    			if (dirty[0] & /*theoryLocation*/ 1) felixplotting_changes.theoryLocation = /*theoryLocation*/ ctx[0];

    			if (!updating_active && dirty[0] & /*active*/ 2) {
    				updating_active = true;
    				felixplotting_changes.active = /*active*/ ctx[1];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_felixPlotWidgets && dirty[0] & /*felixPlotWidgets*/ 16) {
    				updating_felixPlotWidgets = true;
    				felixplotting_changes.felixPlotWidgets = /*felixPlotWidgets*/ ctx[4];
    				add_flush_callback(() => updating_felixPlotWidgets = false);
    			}

    			felixplotting.$set(felixplotting_changes);
    			const textfield_changes = {};
    			if (dirty[0] & /*fdelta*/ 32) textfield_changes.input$step = /*fdelta*/ ctx[5];

    			if (!updating_value && dirty[0] & /*delta*/ 8) {
    				updating_value = true;
    				textfield_changes.value = /*delta*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty[0] & /*openShell*/ 4) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*openShell*/ ctx[2];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(felixplotting.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(customiconswitch.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(felixplotting.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(customiconswitch.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(felixplotting, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(textfield);
    			destroy_component(customiconswitch);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $felixConfigDB;
    	let $felixopoLocation;
    	let $felixPlotCheckboxes;
    	let $baselineFile;
    	let $fittedTraceCount;
    	let $expfittedLinesCollectedData;
    	let $felixPlotAnnotations;
    	let $expfittedLines;
    	let $felixPeakTable;
    	let $felixOutputName;
    	let $toggleRow;
    	let $opoMode;
    	validate_store(felixConfigDB, 'felixConfigDB');
    	component_subscribe($$self, felixConfigDB, $$value => $$invalidate(26, $felixConfigDB = $$value));
    	validate_store(felixopoLocation, 'felixopoLocation');
    	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(27, $felixopoLocation = $$value));
    	validate_store(felixPlotCheckboxes, 'felixPlotCheckboxes');
    	component_subscribe($$self, felixPlotCheckboxes, $$value => $$invalidate(28, $felixPlotCheckboxes = $$value));
    	validate_store(baselineFile, 'baselineFile');
    	component_subscribe($$self, baselineFile, $$value => $$invalidate(29, $baselineFile = $$value));
    	validate_store(fittedTraceCount, 'fittedTraceCount');
    	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(30, $fittedTraceCount = $$value));
    	validate_store(expfittedLinesCollectedData, 'expfittedLinesCollectedData');
    	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(31, $expfittedLinesCollectedData = $$value));
    	validate_store(felixPlotAnnotations, 'felixPlotAnnotations');
    	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(32, $felixPlotAnnotations = $$value));
    	validate_store(expfittedLines, 'expfittedLines');
    	component_subscribe($$self, expfittedLines, $$value => $$invalidate(33, $expfittedLines = $$value));
    	validate_store(felixPeakTable, 'felixPeakTable');
    	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(34, $felixPeakTable = $$value));
    	validate_store(felixOutputName, 'felixOutputName');
    	component_subscribe($$self, felixOutputName, $$value => $$invalidate(35, $felixOutputName = $$value));
    	validate_store(toggleRow, 'toggleRow');
    	component_subscribe($$self, toggleRow, $$value => $$invalidate(6, $toggleRow = $$value));
    	validate_store(opoMode, 'opoMode');
    	component_subscribe($$self, opoMode, $$value => $$invalidate(7, $opoMode = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InitFunctionRow', slots, []);
    	let { felixfiles, graphPlotted, opofiles, normMethod, show_theoryplot, removeExtraFile, theoryLocation } = $$props;
    	let active = false, openShell = false, delta = 1;
    	let { updateConfig = false } = $$props;

    	let felixPlotWidgets = {
    		text: [
    			{
    				label: "Fig. caption",
    				value: "caption",
    				id: getID()
    			},
    			{
    				label: "Fig. title",
    				value: "Title",
    				id: getID()
    			},
    			{
    				label: "Exp. title",
    				value: "Exp. title",
    				id: getID()
    			},
    			{
    				label: "Exp. legend",
    				value: "legend",
    				id: getID()
    			},
    			{
    				label: "Cal. title",
    				value: "calc title",
    				id: getID()
    			},
    			{
    				label: "markers",
    				value: ":1",
    				id: getID()
    			}
    		],
    		number: [
    			{
    				label: "Fig. Width",
    				value: 7,
    				step: 1,
    				id: getID()
    			},
    			{
    				label: "Fig. Height",
    				value: 7,
    				step: 1,
    				id: getID()
    			},
    			{
    				label: "Fig. DPI",
    				value: 120,
    				step: 5,
    				id: getID()
    			},
    			{
    				label: "freqScale",
    				value: 1,
    				step: 0.01,
    				id: getID()
    			},
    			{
    				label: "gridAlpha",
    				value: 0,
    				step: 0.1,
    				id: getID()
    			},
    			{
    				label: "theorySigma",
    				value: 5,
    				step: 1,
    				id: getID()
    			},
    			{
    				label: "Tick Interval",
    				value: 200,
    				step: 50,
    				id: getID()
    			}
    		],
    		boolean: [
    			{
    				label: "sameColor",
    				value: true,
    				id: getID()
    			},
    			{
    				label: "Invert ax2",
    				value: true,
    				id: getID()
    			},
    			{
    				label: "Only exp.",
    				value: true,
    				id: getID()
    			},
    			{
    				label: "hide ax2 axis.",
    				value: true,
    				id: getID()
    			},
    			{
    				label: "hide_all_axis",
    				value: false,
    				id: getID()
    			},
    			{
    				label: "legend_visible",
    				value: true,
    				id: getID()
    			}
    		]
    	};

    	function plotData({ e = null, filetype = "felix" } = {}) {
    		let pyfile = "", args;

    		switch (filetype) {
    			case "felix":
    				if (felixfiles.length < 1) return window.createToast("No files selected", "danger");
    				removeExtraFile();
    				($$invalidate(9, graphPlotted = false), set_store_value(felixOutputName, $felixOutputName = "averaged", $felixOutputName), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations), set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable));
    				(pyfile = "normline.py", args = [...felixfiles, delta]);
    				computePy_func({ e, pyfile, args }).then(dataFromPython => {
    					(set_store_value(expfittedLines, $expfittedLines = [], $expfittedLines), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations), set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount));
    					$$invalidate(10, show_theoryplot = false);
    					felix_func({ normMethod, dataFromPython, delta });
    					window.createToast("Graph Plotted", "success");
    					$$invalidate(9, graphPlotted = true);
    				}).catch(error => {
    					window.handleError(error);
    					console.error("Error main: ", error.stack || error);
    				});
    				break;
    			case "baseline":
    				if (!$baselineFile) {
    					return window.createToast("No files: ctrl + left-click to select file for baseline correction", "danger");
    				}
    				pyfile = "baseline.py";
    				args = [
    					JSON.stringify({
    						filename: pathJoin($felixopoLocation, $baselineFile)
    					})
    				];
    				computePy_func({
    					e,
    					pyfile,
    					args,
    					general: true,
    					openShell
    				}).catch(error => {
    					window.handleError(error);
    				});
    				break;
    			case "matplotlib":
    				const numberWidgets = felixPlotWidgets.number.map(n => n.value);
    				const textWidgets = felixPlotWidgets.text.map(n => n.value);
    				const booleanWidgets = felixPlotWidgets.boolean.map(n => n.value);
    				const selectedWidgets = $felixPlotCheckboxes.map(n => n.selected);
    				(pyfile = "felix_tkplot.py", args = [
    					JSON.stringify({
    						numberWidgets,
    						textWidgets,
    						booleanWidgets,
    						selectedWidgets,
    						location: $felixopoLocation,
    						normMethod,
    						theoryLocation
    					})
    				]);
    				computePy_func({
    					e,
    					pyfile,
    					args,
    					general: true,
    					openShell
    				}).catch(error => {
    					window.handleError(error);
    				});
    		}
    	}

    	let fdelta = $felixConfigDB.get("fdelta");

    	function loadConfig() {
    		$$invalidate(5, fdelta = $felixConfigDB.get("fdelta"));
    		console.log("fdelta updated", fdelta);
    	}

    	const writable_props = [
    		'felixfiles',
    		'graphPlotted',
    		'opofiles',
    		'normMethod',
    		'show_theoryplot',
    		'removeExtraFile',
    		'theoryLocation',
    		'updateConfig'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$e.warn(`<InitFunctionRow> was created with unknown prop '${key}'`);
    	});

    	function felixplotting_active_binding(value) {
    		active = value;
    		$$invalidate(1, active);
    	}

    	function felixplotting_felixPlotWidgets_binding(value) {
    		felixPlotWidgets = value;
    		$$invalidate(4, felixPlotWidgets);
    	}

    	const submit_handler = e => plotData({
    		e: e.detail.event,
    		filetype: "matplotlib"
    	});

    	const click_handler = e => plotData({ e, filetype: "baseline" });
    	const click_handler_1 = e => plotData({ e, filetype: "felix" });

    	function textfield_value_binding(value) {
    		delta = value;
    		$$invalidate(3, delta);
    	}

    	const click_handler_2 = () => $$invalidate(1, active = true);

    	function customiconswitch_toggler_binding(value) {
    		openShell = value;
    		$$invalidate(2, openShell);
    	}

    	const click_handler_3 = () => set_store_value(toggleRow, $toggleRow = !$toggleRow, $toggleRow);

    	const click_handler_4 = () => {
    		set_store_value(opoMode, $opoMode = !$opoMode, $opoMode);
    	};

    	$$self.$$set = $$props => {
    		if ('felixfiles' in $$props) $$invalidate(11, felixfiles = $$props.felixfiles);
    		if ('graphPlotted' in $$props) $$invalidate(9, graphPlotted = $$props.graphPlotted);
    		if ('opofiles' in $$props) $$invalidate(12, opofiles = $$props.opofiles);
    		if ('normMethod' in $$props) $$invalidate(13, normMethod = $$props.normMethod);
    		if ('show_theoryplot' in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
    		if ('removeExtraFile' in $$props) $$invalidate(14, removeExtraFile = $$props.removeExtraFile);
    		if ('theoryLocation' in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
    		if ('updateConfig' in $$props) $$invalidate(15, updateConfig = $$props.updateConfig);
    	};

    	$$self.$capture_state = () => ({
    		opoMode,
    		toggleRow,
    		felixOutputName,
    		felixPlotAnnotations,
    		felixPeakTable,
    		expfittedLines,
    		expfittedLinesCollectedData,
    		fittedTraceCount,
    		felixopoLocation,
    		felixPlotCheckboxes,
    		felixConfigDB,
    		baselineFile,
    		mainPreModal,
    		Textfield,
    		CustomIconSwitch,
    		FelixPlotting,
    		felix_func,
    		felixfiles,
    		graphPlotted,
    		opofiles,
    		normMethod,
    		show_theoryplot,
    		removeExtraFile,
    		theoryLocation,
    		active,
    		openShell,
    		delta,
    		updateConfig,
    		felixPlotWidgets,
    		plotData,
    		fdelta,
    		loadConfig,
    		$felixConfigDB,
    		$felixopoLocation,
    		$felixPlotCheckboxes,
    		$baselineFile,
    		$fittedTraceCount,
    		$expfittedLinesCollectedData,
    		$felixPlotAnnotations,
    		$expfittedLines,
    		$felixPeakTable,
    		$felixOutputName,
    		$toggleRow,
    		$opoMode
    	});

    	$$self.$inject_state = $$props => {
    		if ('felixfiles' in $$props) $$invalidate(11, felixfiles = $$props.felixfiles);
    		if ('graphPlotted' in $$props) $$invalidate(9, graphPlotted = $$props.graphPlotted);
    		if ('opofiles' in $$props) $$invalidate(12, opofiles = $$props.opofiles);
    		if ('normMethod' in $$props) $$invalidate(13, normMethod = $$props.normMethod);
    		if ('show_theoryplot' in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
    		if ('removeExtraFile' in $$props) $$invalidate(14, removeExtraFile = $$props.removeExtraFile);
    		if ('theoryLocation' in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
    		if ('active' in $$props) $$invalidate(1, active = $$props.active);
    		if ('openShell' in $$props) $$invalidate(2, openShell = $$props.openShell);
    		if ('delta' in $$props) $$invalidate(3, delta = $$props.delta);
    		if ('updateConfig' in $$props) $$invalidate(15, updateConfig = $$props.updateConfig);
    		if ('felixPlotWidgets' in $$props) $$invalidate(4, felixPlotWidgets = $$props.felixPlotWidgets);
    		if ('fdelta' in $$props) $$invalidate(5, fdelta = $$props.fdelta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*updateConfig*/ 32768) {
    			if (updateConfig) loadConfig();
    		}
    	};

    	return [
    		theoryLocation,
    		active,
    		openShell,
    		delta,
    		felixPlotWidgets,
    		fdelta,
    		$toggleRow,
    		$opoMode,
    		plotData,
    		graphPlotted,
    		show_theoryplot,
    		felixfiles,
    		opofiles,
    		normMethod,
    		removeExtraFile,
    		updateConfig,
    		felixplotting_active_binding,
    		felixplotting_felixPlotWidgets_binding,
    		submit_handler,
    		click_handler,
    		click_handler_1,
    		textfield_value_binding,
    		click_handler_2,
    		customiconswitch_toggler_binding,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class InitFunctionRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$B,
    			create_fragment$B,
    			safe_not_equal,
    			{
    				felixfiles: 11,
    				graphPlotted: 9,
    				opofiles: 12,
    				normMethod: 13,
    				show_theoryplot: 10,
    				removeExtraFile: 14,
    				theoryLocation: 0,
    				updateConfig: 15
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InitFunctionRow",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*felixfiles*/ ctx[11] === undefined && !('felixfiles' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'felixfiles'");
    		}

    		if (/*graphPlotted*/ ctx[9] === undefined && !('graphPlotted' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'graphPlotted'");
    		}

    		if (/*opofiles*/ ctx[12] === undefined && !('opofiles' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'opofiles'");
    		}

    		if (/*normMethod*/ ctx[13] === undefined && !('normMethod' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'normMethod'");
    		}

    		if (/*show_theoryplot*/ ctx[10] === undefined && !('show_theoryplot' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'show_theoryplot'");
    		}

    		if (/*removeExtraFile*/ ctx[14] === undefined && !('removeExtraFile' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'removeExtraFile'");
    		}

    		if (/*theoryLocation*/ ctx[0] === undefined && !('theoryLocation' in props)) {
    			console_1$e.warn("<InitFunctionRow> was created without expected prop 'theoryLocation'");
    		}
    	}

    	get felixfiles() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set felixfiles(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graphPlotted() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graphPlotted(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opofiles() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opofiles(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get normMethod() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set normMethod(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show_theoryplot() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show_theoryplot(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeExtraFile() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set removeExtraFile(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theoryLocation() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theoryLocation(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateConfig() {
    		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateConfig(value) {
    		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$3 = {
        ANCHOR: 'mdc-menu-surface--anchor',
        ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
        ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
        FIXED: 'mdc-menu-surface--fixed',
        OPEN: 'mdc-menu-surface--open',
        ROOT: 'mdc-menu-surface',
    };
    // tslint:disable:object-literal-sort-keys
    var strings$4 = {
        CLOSED_EVENT: 'MDCMenuSurface:closed',
        OPENED_EVENT: 'MDCMenuSurface:opened',
        FOCUSABLE_ELEMENTS: [
            'button:not(:disabled)', '[href]:not([aria-disabled="true"])', 'input:not(:disabled)',
            'select:not(:disabled)', 'textarea:not(:disabled)', '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])',
        ].join(', '),
    };
    // tslint:enable:object-literal-sort-keys
    var numbers$2 = {
        /** Total duration of menu-surface open animation. */
        TRANSITION_OPEN_DURATION: 120,
        /** Total duration of menu-surface close animation. */
        TRANSITION_CLOSE_DURATION: 75,
        /** Margin left to the edge of the viewport when menu-surface is at maximum possible height. */
        MARGIN_TO_EDGE: 32,
        /** Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning. */
        ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     */
    var CornerBit;
    (function (CornerBit) {
        CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
        CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
        CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
        CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
    })(CornerBit || (CornerBit = {}));
    /**
     * Enum for representing an element corner for positioning the menu-surface.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     */
    var Corner;
    (function (Corner) {
        Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
        Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
        Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
        Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
        Corner[Corner["TOP_START"] = 8] = "TOP_START";
        Corner[Corner["TOP_END"] = 12] = "TOP_END";
        Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
        Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
    })(Corner || (Corner = {}));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuSurfaceFoundation = /** @class */ (function (_super) {
        __extends(MDCMenuSurfaceFoundation, _super);
        function MDCMenuSurfaceFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCMenuSurfaceFoundation.defaultAdapter, adapter)) || this;
            _this.isOpen_ = false;
            _this.isQuickOpen_ = false;
            _this.isHoistedElement_ = false;
            _this.isFixedPosition_ = false;
            _this.openAnimationEndTimerId_ = 0;
            _this.closeAnimationEndTimerId_ = 0;
            _this.animationRequestId_ = 0;
            _this.anchorCorner_ = Corner.TOP_START;
            _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
            _this.position_ = { x: 0, y: 0 };
            return _this;
        }
        Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
            get: function () {
                return cssClasses$3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
            get: function () {
                return strings$4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
            get: function () {
                return numbers$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
            get: function () {
                return Corner;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
            /**
             * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    hasAnchor: function () { return false; },
                    isElementInContainer: function () { return false; },
                    isFocused: function () { return false; },
                    isRtl: function () { return false; },
                    getInnerDimensions: function () { return ({ height: 0, width: 0 }); },
                    getAnchorDimensions: function () { return null; },
                    getWindowDimensions: function () { return ({ height: 0, width: 0 }); },
                    getBodyDimensions: function () { return ({ height: 0, width: 0 }); },
                    getWindowScroll: function () { return ({ x: 0, y: 0 }); },
                    setPosition: function () { return undefined; },
                    setMaxHeight: function () { return undefined; },
                    setTransformOrigin: function () { return undefined; },
                    saveFocus: function () { return undefined; },
                    restoreFocus: function () { return undefined; },
                    notifyClose: function () { return undefined; },
                    notifyOpen: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCMenuSurfaceFoundation.prototype.init = function () {
            var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
            if (!this.adapter_.hasClass(ROOT)) {
                throw new Error(ROOT + " class required in root element.");
            }
            if (this.adapter_.hasClass(OPEN)) {
                this.isOpen_ = true;
            }
        };
        MDCMenuSurfaceFoundation.prototype.destroy = function () {
            clearTimeout(this.openAnimationEndTimerId_);
            clearTimeout(this.closeAnimationEndTimerId_);
            // Cancel any currently running animations.
            cancelAnimationFrame(this.animationRequestId_);
        };
        /**
         * @param corner Default anchor corner alignment of top-left menu surface corner.
         */
        MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {
            this.anchorCorner_ = corner;
        };
        /**
         * @param margin Set of margin values from anchor.
         */
        MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {
            this.anchorMargin_.top = margin.top || 0;
            this.anchorMargin_.right = margin.right || 0;
            this.anchorMargin_.bottom = margin.bottom || 0;
            this.anchorMargin_.left = margin.left || 0;
        };
        /** Used to indicate if the menu-surface is hoisted to the body. */
        MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {
            this.isHoistedElement_ = isHoisted;
        };
        /** Used to set the menu-surface calculations based on a fixed position menu. */
        MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {
            this.isFixedPosition_ = isFixedPosition;
        };
        /** Sets the menu-surface position on the page. */
        MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {
            this.position_.x = this.isFinite_(x) ? x : 0;
            this.position_.y = this.isFinite_(y) ? y : 0;
        };
        MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {
            this.isQuickOpen_ = quickOpen;
        };
        MDCMenuSurfaceFoundation.prototype.isOpen = function () {
            return this.isOpen_;
        };
        /**
         * Open the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.open = function () {
            var _this = this;
            this.adapter_.saveFocus();
            if (!this.isQuickOpen_) {
                this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
            }
            this.animationRequestId_ = requestAnimationFrame(function () {
                _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                _this.dimensions_ = _this.adapter_.getInnerDimensions();
                _this.autoPosition_();
                if (_this.isQuickOpen_) {
                    _this.adapter_.notifyOpen();
                }
                else {
                    _this.openAnimationEndTimerId_ = setTimeout(function () {
                        _this.openAnimationEndTimerId_ = 0;
                        _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                        _this.adapter_.notifyOpen();
                    }, numbers$2.TRANSITION_OPEN_DURATION);
                }
            });
            this.isOpen_ = true;
        };
        /**
         * Closes the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {
            var _this = this;
            if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
            if (!this.isQuickOpen_) {
                this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
            }
            requestAnimationFrame(function () {
                _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                if (_this.isQuickOpen_) {
                    _this.adapter_.notifyClose();
                }
                else {
                    _this.closeAnimationEndTimerId_ = setTimeout(function () {
                        _this.closeAnimationEndTimerId_ = 0;
                        _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                        _this.adapter_.notifyClose();
                    }, numbers$2.TRANSITION_CLOSE_DURATION);
                }
            });
            this.isOpen_ = false;
            if (!skipRestoreFocus) {
                this.maybeRestoreFocus_();
            }
        };
        /** Handle clicks and close if not within menu-surface element. */
        MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {
            var el = evt.target;
            if (this.adapter_.isElementInContainer(el)) {
                return;
            }
            this.close();
        };
        /** Handle keys that close the surface. */
        MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {
            var keyCode = evt.keyCode, key = evt.key;
            var isEscape = key === 'Escape' || keyCode === 27;
            if (isEscape) {
                this.close();
            }
        };
        MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {
            var _a;
            // Compute measurements for autoposition methods reuse.
            this.measurements_ = this.getAutoLayoutMeasurements_();
            var corner = this.getOriginCorner_();
            var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
            var verticalAlignment = this.hasBit_(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';
            var horizontalAlignment = this.hasBit_(corner, CornerBit.RIGHT) ? 'right' : 'left';
            var horizontalOffset = this.getHorizontalOriginOffset_(corner);
            var verticalOffset = this.getVerticalOriginOffset_(corner);
            var _b = this.measurements_, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
            var position = (_a = {},
                _a[horizontalAlignment] = horizontalOffset,
                _a[verticalAlignment] = verticalOffset,
                _a);
            // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.
            if (anchorSize.width / surfaceSize.width > numbers$2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
                horizontalAlignment = 'center';
            }
            // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element
            if (this.isHoistedElement_ || this.isFixedPosition_) {
                this.adjustPositionForHoistedElement_(position);
            }
            this.adapter_.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
            this.adapter_.setPosition(position);
            this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');
        };
        /**
         * @return Measurements used to position menu surface popup.
         */
        MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {
            var anchorRect = this.adapter_.getAnchorDimensions();
            var bodySize = this.adapter_.getBodyDimensions();
            var viewportSize = this.adapter_.getWindowDimensions();
            var windowScroll = this.adapter_.getWindowScroll();
            if (!anchorRect) {
                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                anchorRect = {
                    top: this.position_.y,
                    right: this.position_.x,
                    bottom: this.position_.y,
                    left: this.position_.x,
                    width: 0,
                    height: 0,
                };
                // tslint:enable:object-literal-sort-keys
            }
            return {
                anchorSize: anchorRect,
                bodySize: bodySize,
                surfaceSize: this.dimensions_,
                viewportDistance: {
                    // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                    top: anchorRect.top,
                    right: viewportSize.width - anchorRect.right,
                    bottom: viewportSize.height - anchorRect.bottom,
                    left: anchorRect.left,
                },
                viewportSize: viewportSize,
                windowScroll: windowScroll,
            };
        };
        /**
         * Computes the corner of the anchor from which to animate and position the menu surface.
         */
        MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {
            // Defaults: open from the top left.
            var corner = Corner.TOP_LEFT;
            var _a = this.measurements_, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
            var isBottomAligned = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var availableTop = isBottomAligned ? viewportDistance.top + anchorSize.height + this.anchorMargin_.bottom
                : viewportDistance.top + this.anchorMargin_.top;
            var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom
                : viewportDistance.bottom + anchorSize.height - this.anchorMargin_.top;
            var topOverflow = surfaceSize.height - availableTop;
            var bottomOverflow = surfaceSize.height - availableBottom;
            if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
                corner = this.setBit_(corner, CornerBit.BOTTOM);
            }
            var isRtl = this.adapter_.isRtl();
            var isFlipRtl = this.hasBit_(this.anchorCorner_, CornerBit.FLIP_RTL);
            var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
            var isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||
                (!avoidHorizontalOverlap && isFlipRtl && isRtl);
            var availableLeft = isAlignedRight ? viewportDistance.left + anchorSize.width + this.anchorMargin_.right :
                viewportDistance.left + this.anchorMargin_.left;
            var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :
                viewportDistance.right + anchorSize.width - this.anchorMargin_.left;
            var leftOverflow = surfaceSize.width - availableLeft;
            var rightOverflow = surfaceSize.width - availableRight;
            if ((leftOverflow < 0 && isAlignedRight && isRtl) ||
                (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||
                (rightOverflow > 0 && leftOverflow < rightOverflow)) {
                corner = this.setBit_(corner, CornerBit.RIGHT);
            }
            return corner;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.
         */
        MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {
            var viewportDistance = this.measurements_.viewportDistance;
            var maxHeight = 0;
            var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
            var isBottomAnchored = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
            // When maximum height is not specified, it is handled from CSS.
            if (isBottomAligned) {
                maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;
                if (!isBottomAnchored) {
                    maxHeight += this.measurements_.anchorSize.height;
                }
            }
            else {
                maxHeight =
                    viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;
                if (isBottomAnchored) {
                    maxHeight -= this.measurements_.anchorSize.height;
                }
            }
            return maxHeight;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.
         */
        MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {
            var anchorSize = this.measurements_.anchorSize;
            // isRightAligned corresponds to using the 'right' property on the surface.
            var isRightAligned = this.hasBit_(corner, CornerBit.RIGHT);
            var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
            if (isRightAligned) {
                var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right;
                // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
                // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
                // the right property is correct.
                if (this.isHoistedElement_ || this.isFixedPosition_) {
                    return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);
                }
                return rightOffset;
            }
            return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;
        };
        /**
         * @param corner Origin corner of the menu surface.
         * @return Vertical offset of menu surface origin corner from corresponding anchor corner.
         */
        MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {
            var anchorSize = this.measurements_.anchorSize;
            var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
            var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
            var y = 0;
            if (isBottomAligned) {
                y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;
            }
            else {
                y = avoidVerticalOverlap ? (anchorSize.height + this.anchorMargin_.bottom) : this.anchorMargin_.top;
            }
            return y;
        };
        /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */
        MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {
            var e_1, _a;
            var _b = this.measurements_, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;
            var props = Object.keys(position);
            try {
                for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                    var prop = props_1_1.value;
                    var value = position[prop] || 0;
                    // Hoisted surfaces need to have the anchor elements location on the page added to the
                    // position properties for proper alignment on the body.
                    value += viewportDistance[prop];
                    // Surfaces that are absolutely positioned need to have additional calculations for scroll
                    // and bottom positioning.
                    if (!this.isFixedPosition_) {
                        if (prop === 'top') {
                            value += windowScroll.y;
                        }
                        else if (prop === 'bottom') {
                            value -= windowScroll.y;
                        }
                        else if (prop === 'left') {
                            value += windowScroll.x;
                        }
                        else { // prop === 'right'
                            value -= windowScroll.x;
                        }
                    }
                    position[prop] = value;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * The last focused element when the menu surface was opened should regain focus, if the user is
         * focused on or within the menu surface when it is closed.
         */
        MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {
            var isRootFocused = this.adapter_.isFocused();
            var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);
            if (isRootFocused || childHasFocus) {
                this.adapter_.restoreFocus();
            }
        };
        MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {
            return Boolean(corner & bit); // tslint:disable-line:no-bitwise
        };
        MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {
            return corner | bit; // tslint:disable-line:no-bitwise
        };
        /**
         * isFinite that doesn't force conversion to number type.
         * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
         */
        MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {
            return typeof num === 'number' && isFinite(num);
        };
        return MDCMenuSurfaceFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cachedCssTransformPropertyName_;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     */
    function getTransformPropertyName(globalObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (cachedCssTransformPropertyName_ === undefined || forceRefresh) {
            var el = globalObj.document.createElement('div');
            cachedCssTransformPropertyName_ = 'transform' in el.style ? 'transform' : 'webkitTransform';
        }
        return cachedCssTransformPropertyName_;
    }

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuSurface = /** @class */ (function (_super) {
        __extends(MDCMenuSurface, _super);
        function MDCMenuSurface() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCMenuSurface.attachTo = function (root) {
            return new MDCMenuSurface(root);
        };
        MDCMenuSurface.prototype.initialSyncWithDOM = function () {
            var _this = this;
            var parentEl = this.root_.parentElement;
            this.anchorElement = parentEl && parentEl.classList.contains(cssClasses$3.ANCHOR) ? parentEl : null;
            if (this.root_.classList.contains(cssClasses$3.FIXED)) {
                this.setFixedPosition(true);
            }
            this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
            this.handleBodyClick_ = function (evt) { return _this.foundation_.handleBodyClick(evt); };
            this.registerBodyClickListener_ = function () { return document.body.addEventListener('click', _this.handleBodyClick_); };
            this.deregisterBodyClickListener_ = function () { return document.body.removeEventListener('click', _this.handleBodyClick_); };
            this.listen('keydown', this.handleKeydown_);
            this.listen(strings$4.OPENED_EVENT, this.registerBodyClickListener_);
            this.listen(strings$4.CLOSED_EVENT, this.deregisterBodyClickListener_);
        };
        MDCMenuSurface.prototype.destroy = function () {
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(strings$4.OPENED_EVENT, this.registerBodyClickListener_);
            this.unlisten(strings$4.CLOSED_EVENT, this.deregisterBodyClickListener_);
            _super.prototype.destroy.call(this);
        };
        MDCMenuSurface.prototype.isOpen = function () {
            return this.foundation_.isOpen();
        };
        MDCMenuSurface.prototype.open = function () {
            this.foundation_.open();
        };
        MDCMenuSurface.prototype.close = function (skipRestoreFocus) {
            if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
            this.foundation_.close(skipRestoreFocus);
        };
        Object.defineProperty(MDCMenuSurface.prototype, "quickOpen", {
            set: function (quickOpen) {
                this.foundation_.setQuickOpen(quickOpen);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Removes the menu-surface from it's current location and appends it to the
         * body to overcome any overflow:hidden issues.
         */
        MDCMenuSurface.prototype.hoistMenuToBody = function () {
            document.body.appendChild(this.root_);
            this.setIsHoisted(true);
        };
        /** Sets the foundation to use page offsets for an positioning when the menu is hoisted to the body. */
        MDCMenuSurface.prototype.setIsHoisted = function (isHoisted) {
            this.foundation_.setIsHoisted(isHoisted);
        };
        /** Sets the element that the menu-surface is anchored to. */
        MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function (element) {
            this.anchorElement = element;
        };
        /** Sets the menu-surface to position: fixed. */
        MDCMenuSurface.prototype.setFixedPosition = function (isFixed) {
            if (isFixed) {
                this.root_.classList.add(cssClasses$3.FIXED);
            }
            else {
                this.root_.classList.remove(cssClasses$3.FIXED);
            }
            this.foundation_.setFixedPosition(isFixed);
        };
        /** Sets the absolute x/y position to position based on. Requires the menu to be hoisted. */
        MDCMenuSurface.prototype.setAbsolutePosition = function (x, y) {
            this.foundation_.setAbsolutePosition(x, y);
            this.setIsHoisted(true);
        };
        /**
         * @param corner Default anchor corner alignment of top-left surface corner.
         */
        MDCMenuSurface.prototype.setAnchorCorner = function (corner) {
            this.foundation_.setAnchorCorner(corner);
        };
        MDCMenuSurface.prototype.setAnchorMargin = function (margin) {
            this.foundation_.setAnchorMargin(margin);
        };
        MDCMenuSurface.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                hasAnchor: function () { return !!_this.anchorElement; },
                notifyClose: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {}); },
                notifyOpen: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {}); },
                isElementInContainer: function (el) { return _this.root_.contains(el); },
                isRtl: function () { return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
                setTransformOrigin: function (origin) {
                    var propertyName = getTransformPropertyName(window) + "-origin";
                    _this.root_.style.setProperty(propertyName, origin);
                },
                isFocused: function () { return document.activeElement === _this.root_; },
                saveFocus: function () {
                    _this.previousFocus_ = document.activeElement;
                },
                restoreFocus: function () {
                    if (_this.root_.contains(document.activeElement)) {
                        if (_this.previousFocus_ && _this.previousFocus_.focus) {
                            _this.previousFocus_.focus();
                        }
                    }
                },
                getInnerDimensions: function () {
                    return { width: _this.root_.offsetWidth, height: _this.root_.offsetHeight };
                },
                getAnchorDimensions: function () { return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null; },
                getWindowDimensions: function () {
                    return { width: window.innerWidth, height: window.innerHeight };
                },
                getBodyDimensions: function () {
                    return { width: document.body.clientWidth, height: document.body.clientHeight };
                },
                getWindowScroll: function () {
                    return { x: window.pageXOffset, y: window.pageYOffset };
                },
                setPosition: function (position) {
                    _this.root_.style.left = 'left' in position ? position.left + "px" : '';
                    _this.root_.style.right = 'right' in position ? position.right + "px" : '';
                    _this.root_.style.top = 'top' in position ? position.top + "px" : '';
                    _this.root_.style.bottom = 'bottom' in position ? position.bottom + "px" : '';
                },
                setMaxHeight: function (height) {
                    _this.root_.style.maxHeight = height;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCMenuSurfaceFoundation(adapter);
        };
        return MDCMenuSurface;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$2 = {
        MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
        MENU_SELECTION_GROUP: 'mdc-menu__selection-group',
        ROOT: 'mdc-menu',
    };
    var strings$3 = {
        ARIA_CHECKED_ATTR: 'aria-checked',
        ARIA_DISABLED_ATTR: 'aria-disabled',
        CHECKBOX_SELECTOR: 'input[type="checkbox"]',
        LIST_SELECTOR: '.mdc-list',
        SELECTED_EVENT: 'MDCMenu:selected',
    };
    var numbers$1 = {
        FOCUS_ROOT_INDEX: -1,
    };
    var DefaultFocusState;
    (function (DefaultFocusState) {
        DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
        DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
        DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
        DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
    })(DefaultFocusState || (DefaultFocusState = {}));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenuFoundation = /** @class */ (function (_super) {
        __extends(MDCMenuFoundation, _super);
        function MDCMenuFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCMenuFoundation.defaultAdapter, adapter)) || this;
            _this.closeAnimationEndTimerId_ = 0;
            _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
            return _this;
        }
        Object.defineProperty(MDCMenuFoundation, "cssClasses", {
            get: function () {
                return cssClasses$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "strings", {
            get: function () {
                return strings$3;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "numbers", {
            get: function () {
                return numbers$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
            /**
             * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClassToElementAtIndex: function () { return undefined; },
                    removeClassFromElementAtIndex: function () { return undefined; },
                    addAttributeToElementAtIndex: function () { return undefined; },
                    removeAttributeFromElementAtIndex: function () { return undefined; },
                    elementContainsClass: function () { return false; },
                    closeSurface: function () { return undefined; },
                    getElementIndex: function () { return -1; },
                    notifySelected: function () { return undefined; },
                    getMenuItemCount: function () { return 0; },
                    focusItemAtIndex: function () { return undefined; },
                    focusListRoot: function () { return undefined; },
                    getSelectedSiblingOfItemAtIndex: function () { return -1; },
                    isSelectableItemAtIndex: function () { return false; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCMenuFoundation.prototype.destroy = function () {
            if (this.closeAnimationEndTimerId_) {
                clearTimeout(this.closeAnimationEndTimerId_);
            }
            this.adapter_.closeSurface();
        };
        MDCMenuFoundation.prototype.handleKeydown = function (evt) {
            var key = evt.key, keyCode = evt.keyCode;
            var isTab = key === 'Tab' || keyCode === 9;
            if (isTab) {
                this.adapter_.closeSurface(/** skipRestoreFocus */ true);
            }
        };
        MDCMenuFoundation.prototype.handleItemAction = function (listItem) {
            var _this = this;
            var index = this.adapter_.getElementIndex(listItem);
            if (index < 0) {
                return;
            }
            this.adapter_.notifySelected({ index: index });
            this.adapter_.closeSurface();
            // Wait for the menu to close before adding/removing classes that affect styles.
            this.closeAnimationEndTimerId_ = setTimeout(function () {
                // Recompute the index in case the menu contents have changed.
                var recomputedIndex = _this.adapter_.getElementIndex(listItem);
                if (_this.adapter_.isSelectableItemAtIndex(recomputedIndex)) {
                    _this.setSelectedIndex(recomputedIndex);
                }
            }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
        };
        MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function () {
            switch (this.defaultFocusState_) {
                case DefaultFocusState.FIRST_ITEM:
                    this.adapter_.focusItemAtIndex(0);
                    break;
                case DefaultFocusState.LAST_ITEM:
                    this.adapter_.focusItemAtIndex(this.adapter_.getMenuItemCount() - 1);
                    break;
                case DefaultFocusState.NONE:
                    // Do nothing.
                    break;
                default:
                    this.adapter_.focusListRoot();
                    break;
            }
        };
        /**
         * Sets default focus state where the menu should focus every time when menu
         * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
         * default.
         */
        MDCMenuFoundation.prototype.setDefaultFocusState = function (focusState) {
            this.defaultFocusState_ = focusState;
        };
        /**
         * Selects the list item at `index` within the menu.
         * @param index Index of list item within the menu.
         */
        MDCMenuFoundation.prototype.setSelectedIndex = function (index) {
            this.validatedIndex_(index);
            if (!this.adapter_.isSelectableItemAtIndex(index)) {
                throw new Error('MDCMenuFoundation: No selection group at specified index.');
            }
            var prevSelectedIndex = this.adapter_.getSelectedSiblingOfItemAtIndex(index);
            if (prevSelectedIndex >= 0) {
                this.adapter_.removeAttributeFromElementAtIndex(prevSelectedIndex, strings$3.ARIA_CHECKED_ATTR);
                this.adapter_.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses$2.MENU_SELECTED_LIST_ITEM);
            }
            this.adapter_.addClassToElementAtIndex(index, cssClasses$2.MENU_SELECTED_LIST_ITEM);
            this.adapter_.addAttributeToElementAtIndex(index, strings$3.ARIA_CHECKED_ATTR, 'true');
        };
        /**
         * Sets the enabled state to isEnabled for the menu item at the given index.
         * @param index Index of the menu item
         * @param isEnabled The desired enabled state of the menu item.
         */
        MDCMenuFoundation.prototype.setEnabled = function (index, isEnabled) {
            this.validatedIndex_(index);
            if (isEnabled) {
                this.adapter_.removeClassFromElementAtIndex(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.addAttributeToElementAtIndex(index, strings$3.ARIA_DISABLED_ATTR, 'false');
            }
            else {
                this.adapter_.addClassToElementAtIndex(index, cssClasses$7.LIST_ITEM_DISABLED_CLASS);
                this.adapter_.addAttributeToElementAtIndex(index, strings$3.ARIA_DISABLED_ATTR, 'true');
            }
        };
        MDCMenuFoundation.prototype.validatedIndex_ = function (index) {
            var menuSize = this.adapter_.getMenuItemCount();
            var isIndexInRange = index >= 0 && index < menuSize;
            if (!isIndexInRange) {
                throw new Error('MDCMenuFoundation: No list item at specified index.');
            }
        };
        return MDCMenuFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCMenu = /** @class */ (function (_super) {
        __extends(MDCMenu, _super);
        function MDCMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCMenu.attachTo = function (root) {
            return new MDCMenu(root);
        };
        MDCMenu.prototype.initialize = function (menuSurfaceFactory, listFactory) {
            if (menuSurfaceFactory === void 0) { menuSurfaceFactory = function (el) { return new MDCMenuSurface(el); }; }
            if (listFactory === void 0) { listFactory = function (el) { return new MDCList(el); }; }
            this.menuSurfaceFactory_ = menuSurfaceFactory;
            this.listFactory_ = listFactory;
        };
        MDCMenu.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.menuSurface_ = this.menuSurfaceFactory_(this.root_);
            var list = this.root_.querySelector(strings$3.LIST_SELECTOR);
            if (list) {
                this.list_ = this.listFactory_(list);
                this.list_.wrapFocus = true;
            }
            else {
                this.list_ = null;
            }
            this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
            this.handleItemAction_ = function (evt) { return _this.foundation_.handleItemAction(_this.items[evt.detail.index]); };
            this.handleMenuSurfaceOpened_ = function () { return _this.foundation_.handleMenuSurfaceOpened(); };
            this.menuSurface_.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
            this.listen('keydown', this.handleKeydown_);
            this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
        };
        MDCMenu.prototype.destroy = function () {
            if (this.list_) {
                this.list_.destroy();
            }
            this.menuSurface_.destroy();
            this.menuSurface_.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
            this.unlisten('keydown', this.handleKeydown_);
            this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
            _super.prototype.destroy.call(this);
        };
        Object.defineProperty(MDCMenu.prototype, "open", {
            get: function () {
                return this.menuSurface_.isOpen();
            },
            set: function (value) {
                if (value) {
                    this.menuSurface_.open();
                }
                else {
                    this.menuSurface_.close();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "wrapFocus", {
            get: function () {
                return this.list_ ? this.list_.wrapFocus : false;
            },
            set: function (value) {
                if (this.list_) {
                    this.list_.wrapFocus = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "items", {
            /**
             * Return the items within the menu. Note that this only contains the set of elements within
             * the items container that are proper list items, and not supplemental / presentational DOM
             * elements.
             */
            get: function () {
                return this.list_ ? this.list_.listElements : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCMenu.prototype, "quickOpen", {
            set: function (quickOpen) {
                this.menuSurface_.quickOpen = quickOpen;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets default focus state where the menu should focus every time when menu
         * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
         * default.
         * @param focusState Default focus state.
         */
        MDCMenu.prototype.setDefaultFocusState = function (focusState) {
            this.foundation_.setDefaultFocusState(focusState);
        };
        /**
         * @param corner Default anchor corner alignment of top-left menu corner.
         */
        MDCMenu.prototype.setAnchorCorner = function (corner) {
            this.menuSurface_.setAnchorCorner(corner);
        };
        MDCMenu.prototype.setAnchorMargin = function (margin) {
            this.menuSurface_.setAnchorMargin(margin);
        };
        /**
         * Sets the list item as the selected row at the specified index.
         * @param index Index of list item within menu.
         */
        MDCMenu.prototype.setSelectedIndex = function (index) {
            this.foundation_.setSelectedIndex(index);
        };
        /**
         * Sets the enabled state to isEnabled for the menu item at the given index.
         * @param index Index of the menu item
         * @param isEnabled The desired enabled state of the menu item.
         */
        MDCMenu.prototype.setEnabled = function (index, isEnabled) {
            this.foundation_.setEnabled(index, isEnabled);
        };
        /**
         * @return The item within the menu at the index specified.
         */
        MDCMenu.prototype.getOptionByIndex = function (index) {
            var items = this.items;
            if (index < items.length) {
                return this.items[index];
            }
            else {
                return null;
            }
        };
        MDCMenu.prototype.setFixedPosition = function (isFixed) {
            this.menuSurface_.setFixedPosition(isFixed);
        };
        MDCMenu.prototype.hoistMenuToBody = function () {
            this.menuSurface_.hoistMenuToBody();
        };
        MDCMenu.prototype.setIsHoisted = function (isHoisted) {
            this.menuSurface_.setIsHoisted(isHoisted);
        };
        MDCMenu.prototype.setAbsolutePosition = function (x, y) {
            this.menuSurface_.setAbsolutePosition(x, y);
        };
        /**
         * Sets the element that the menu-surface is anchored to.
         */
        MDCMenu.prototype.setAnchorElement = function (element) {
            this.menuSurface_.anchorElement = element;
        };
        MDCMenu.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClassToElementAtIndex: function (index, className) {
                    var list = _this.items;
                    list[index].classList.add(className);
                },
                removeClassFromElementAtIndex: function (index, className) {
                    var list = _this.items;
                    list[index].classList.remove(className);
                },
                addAttributeToElementAtIndex: function (index, attr, value) {
                    var list = _this.items;
                    list[index].setAttribute(attr, value);
                },
                removeAttributeFromElementAtIndex: function (index, attr) {
                    var list = _this.items;
                    list[index].removeAttribute(attr);
                },
                elementContainsClass: function (element, className) { return element.classList.contains(className); },
                closeSurface: function (skipRestoreFocus) { return _this.menuSurface_.close(skipRestoreFocus); },
                getElementIndex: function (element) { return _this.items.indexOf(element); },
                notifySelected: function (evtData) { return _this.emit(strings$3.SELECTED_EVENT, {
                    index: evtData.index,
                    item: _this.items[evtData.index],
                }); },
                getMenuItemCount: function () { return _this.items.length; },
                focusItemAtIndex: function (index) { return _this.items[index].focus(); },
                focusListRoot: function () { return _this.root_.querySelector(strings$3.LIST_SELECTOR).focus(); },
                isSelectableItemAtIndex: function (index) { return !!closest(_this.items[index], "." + cssClasses$2.MENU_SELECTION_GROUP); },
                getSelectedSiblingOfItemAtIndex: function (index) {
                    var selectionGroupEl = closest(_this.items[index], "." + cssClasses$2.MENU_SELECTION_GROUP);
                    var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses$2.MENU_SELECTED_LIST_ITEM);
                    return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCMenuFoundation(adapter);
        };
        return MDCMenu;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1 = {
        ACTIVATED: 'mdc-select--activated',
        DISABLED: 'mdc-select--disabled',
        FOCUSED: 'mdc-select--focused',
        INVALID: 'mdc-select--invalid',
        OUTLINED: 'mdc-select--outlined',
        REQUIRED: 'mdc-select--required',
        ROOT: 'mdc-select',
        SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
        WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
    };
    var strings$2 = {
        ARIA_CONTROLS: 'aria-controls',
        ARIA_SELECTED_ATTR: 'aria-selected',
        CHANGE_EVENT: 'MDCSelect:change',
        ENHANCED_VALUE_ATTR: 'data-value',
        HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
        LABEL_SELECTOR: '.mdc-floating-label',
        LEADING_ICON_SELECTOR: '.mdc-select__icon',
        LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
        MENU_SELECTOR: '.mdc-select__menu',
        NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
        OUTLINE_SELECTOR: '.mdc-notched-outline',
        SELECTED_ITEM_SELECTOR: "." + cssClasses$1.SELECTED_ITEM_CLASS,
        SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
    };
    var numbers = {
        LABEL_SCALE: 0.75,
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectFoundation = /** @class */ (function (_super) {
        __extends(MDCSelectFoundation, _super);
        /* istanbul ignore next: optional argument is not a branch statement */
        /**
         * @param adapter
         * @param foundationMap Map from subcomponent names to their subfoundations.
         */
        function MDCSelectFoundation(adapter, foundationMap) {
            if (foundationMap === void 0) { foundationMap = {}; }
            var _this = _super.call(this, __assign({}, MDCSelectFoundation.defaultAdapter, adapter)) || this;
            _this.leadingIcon_ = foundationMap.leadingIcon;
            _this.helperText_ = foundationMap.helperText;
            return _this;
        }
        Object.defineProperty(MDCSelectFoundation, "cssClasses", {
            get: function () {
                return cssClasses$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectFoundation, "numbers", {
            get: function () {
                return numbers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectFoundation, "strings", {
            get: function () {
                return strings$2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectFoundation, "defaultAdapter", {
            /**
             * See {@link MDCSelectAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    activateBottomLine: function () { return undefined; },
                    deactivateBottomLine: function () { return undefined; },
                    setValue: function () { return undefined; },
                    getValue: function () { return ''; },
                    floatLabel: function () { return undefined; },
                    getLabelWidth: function () { return 0; },
                    hasOutline: function () { return false; },
                    notchOutline: function () { return undefined; },
                    closeOutline: function () { return undefined; },
                    openMenu: function () { return undefined; },
                    closeMenu: function () { return undefined; },
                    isMenuOpen: function () { return false; },
                    setSelectedIndex: function () { return undefined; },
                    setDisabled: function () { return undefined; },
                    setRippleCenter: function () { return undefined; },
                    notifyChange: function () { return undefined; },
                    checkValidity: function () { return false; },
                    setValid: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCSelectFoundation.prototype.setSelectedIndex = function (index) {
            this.adapter_.setSelectedIndex(index);
            this.adapter_.closeMenu();
            var didChange = true;
            this.handleChange(didChange);
        };
        MDCSelectFoundation.prototype.setValue = function (value) {
            this.adapter_.setValue(value);
            var didChange = true;
            this.handleChange(didChange);
        };
        MDCSelectFoundation.prototype.getValue = function () {
            return this.adapter_.getValue();
        };
        MDCSelectFoundation.prototype.setDisabled = function (isDisabled) {
            if (isDisabled) {
                this.adapter_.addClass(cssClasses$1.DISABLED);
            }
            else {
                this.adapter_.removeClass(cssClasses$1.DISABLED);
            }
            this.adapter_.setDisabled(isDisabled);
            this.adapter_.closeMenu();
            if (this.leadingIcon_) {
                this.leadingIcon_.setDisabled(isDisabled);
            }
        };
        /**
         * @param content Sets the content of the helper text.
         */
        MDCSelectFoundation.prototype.setHelperTextContent = function (content) {
            if (this.helperText_) {
                this.helperText_.setContent(content);
            }
        };
        MDCSelectFoundation.prototype.layout = function () {
            var openNotch = this.getValue().length > 0;
            this.notchOutline(openNotch);
        };
        MDCSelectFoundation.prototype.handleMenuOpened = function () {
            this.adapter_.addClass(cssClasses$1.ACTIVATED);
        };
        MDCSelectFoundation.prototype.handleMenuClosed = function () {
            this.adapter_.removeClass(cssClasses$1.ACTIVATED);
        };
        /**
         * Handles value changes, via change event or programmatic updates.
         */
        MDCSelectFoundation.prototype.handleChange = function (didChange) {
            if (didChange === void 0) { didChange = true; }
            var value = this.getValue();
            var optionHasValue = value.length > 0;
            var isRequired = this.adapter_.hasClass(cssClasses$1.REQUIRED);
            this.notchOutline(optionHasValue);
            if (!this.adapter_.hasClass(cssClasses$1.FOCUSED)) {
                this.adapter_.floatLabel(optionHasValue);
            }
            if (didChange) {
                this.adapter_.notifyChange(value);
                if (isRequired) {
                    this.setValid(this.isValid());
                    if (this.helperText_) {
                        this.helperText_.setValidity(this.isValid());
                    }
                }
            }
        };
        /**
         * Handles focus events from select element.
         */
        MDCSelectFoundation.prototype.handleFocus = function () {
            this.adapter_.addClass(cssClasses$1.FOCUSED);
            this.adapter_.floatLabel(true);
            this.notchOutline(true);
            this.adapter_.activateBottomLine();
            if (this.helperText_) {
                this.helperText_.showToScreenReader();
            }
        };
        /**
         * Handles blur events from select element.
         */
        MDCSelectFoundation.prototype.handleBlur = function () {
            if (this.adapter_.isMenuOpen()) {
                return;
            }
            this.adapter_.removeClass(cssClasses$1.FOCUSED);
            this.handleChange(false);
            this.adapter_.deactivateBottomLine();
            var isRequired = this.adapter_.hasClass(cssClasses$1.REQUIRED);
            if (isRequired) {
                this.setValid(this.isValid());
                if (this.helperText_) {
                    this.helperText_.setValidity(this.isValid());
                }
            }
        };
        MDCSelectFoundation.prototype.handleClick = function (normalizedX) {
            if (this.adapter_.isMenuOpen()) {
                return;
            }
            this.adapter_.setRippleCenter(normalizedX);
            this.adapter_.openMenu();
        };
        MDCSelectFoundation.prototype.handleKeydown = function (event) {
            if (this.adapter_.isMenuOpen()) {
                return;
            }
            var isEnter = event.key === 'Enter' || event.keyCode === 13;
            var isSpace = event.key === 'Space' || event.keyCode === 32;
            var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
            var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
            if (this.adapter_.hasClass(cssClasses$1.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
                this.adapter_.openMenu();
                event.preventDefault();
            }
        };
        /**
         * Opens/closes the notched outline.
         */
        MDCSelectFoundation.prototype.notchOutline = function (openNotch) {
            if (!this.adapter_.hasOutline()) {
                return;
            }
            var isFocused = this.adapter_.hasClass(cssClasses$1.FOCUSED);
            if (openNotch) {
                var labelScale = numbers.LABEL_SCALE;
                var labelWidth = this.adapter_.getLabelWidth() * labelScale;
                this.adapter_.notchOutline(labelWidth);
            }
            else if (!isFocused) {
                this.adapter_.closeOutline();
            }
        };
        /**
         * Sets the aria label of the leading icon.
         */
        MDCSelectFoundation.prototype.setLeadingIconAriaLabel = function (label) {
            if (this.leadingIcon_) {
                this.leadingIcon_.setAriaLabel(label);
            }
        };
        /**
         * Sets the text content of the leading icon.
         */
        MDCSelectFoundation.prototype.setLeadingIconContent = function (content) {
            if (this.leadingIcon_) {
                this.leadingIcon_.setContent(content);
            }
        };
        MDCSelectFoundation.prototype.setValid = function (isValid) {
            this.adapter_.setValid(isValid);
        };
        MDCSelectFoundation.prototype.isValid = function () {
            return this.adapter_.checkValidity();
        };
        return MDCSelectFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$1 = {
        ARIA_HIDDEN: 'aria-hidden',
        ROLE: 'role',
    };
    var cssClasses = {
        HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
        HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectHelperTextFoundation = /** @class */ (function (_super) {
        __extends(MDCSelectHelperTextFoundation, _super);
        function MDCSelectHelperTextFoundation(adapter) {
            return _super.call(this, __assign({}, MDCSelectHelperTextFoundation.defaultAdapter, adapter)) || this;
        }
        Object.defineProperty(MDCSelectHelperTextFoundation, "cssClasses", {
            get: function () {
                return cssClasses;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectHelperTextFoundation, "strings", {
            get: function () {
                return strings$1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectHelperTextFoundation, "defaultAdapter", {
            /**
             * See {@link MDCSelectHelperTextAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setAttr: function () { return undefined; },
                    removeAttr: function () { return undefined; },
                    setContent: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the content of the helper text field.
         */
        MDCSelectHelperTextFoundation.prototype.setContent = function (content) {
            this.adapter_.setContent(content);
        };
        /**
         *  Sets the persistency of the helper text.
         */
        MDCSelectHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
            if (isPersistent) {
                this.adapter_.addClass(cssClasses.HELPER_TEXT_PERSISTENT);
            }
            else {
                this.adapter_.removeClass(cssClasses.HELPER_TEXT_PERSISTENT);
            }
        };
        /**
         * @param isValidation True to make the helper text act as an error validation message.
         */
        MDCSelectHelperTextFoundation.prototype.setValidation = function (isValidation) {
            if (isValidation) {
                this.adapter_.addClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
            }
            else {
                this.adapter_.removeClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
            }
        };
        /**
         * Makes the helper text visible to screen readers.
         */
        MDCSelectHelperTextFoundation.prototype.showToScreenReader = function () {
            this.adapter_.removeAttr(strings$1.ARIA_HIDDEN);
        };
        /**
         * Sets the validity of the helper text based on the select validity.
         */
        MDCSelectHelperTextFoundation.prototype.setValidity = function (selectIsValid) {
            var helperTextIsPersistent = this.adapter_.hasClass(cssClasses.HELPER_TEXT_PERSISTENT);
            var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
            var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;
            if (validationMsgNeedsDisplay) {
                this.adapter_.setAttr(strings$1.ROLE, 'alert');
            }
            else {
                this.adapter_.removeAttr(strings$1.ROLE);
            }
            if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
                this.hide_();
            }
        };
        /**
         * Hides the help text from screen readers.
         */
        MDCSelectHelperTextFoundation.prototype.hide_ = function () {
            this.adapter_.setAttr(strings$1.ARIA_HIDDEN, 'true');
        };
        return MDCSelectHelperTextFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectHelperText = /** @class */ (function (_super) {
        __extends(MDCSelectHelperText, _super);
        function MDCSelectHelperText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCSelectHelperText.attachTo = function (root) {
            return new MDCSelectHelperText(root);
        };
        Object.defineProperty(MDCSelectHelperText.prototype, "foundation", {
            get: function () {
                return this.foundation_;
            },
            enumerable: true,
            configurable: true
        });
        MDCSelectHelperText.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
                setContent: function (content) {
                    _this.root_.textContent = content;
                },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCSelectHelperTextFoundation(adapter);
        };
        return MDCSelectHelperText;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings = {
        ICON_EVENT: 'MDCSelect:icon',
        ICON_ROLE: 'button',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var INTERACTION_EVENTS = ['click', 'keydown'];
    var MDCSelectIconFoundation = /** @class */ (function (_super) {
        __extends(MDCSelectIconFoundation, _super);
        function MDCSelectIconFoundation(adapter) {
            var _this = _super.call(this, __assign({}, MDCSelectIconFoundation.defaultAdapter, adapter)) || this;
            _this.savedTabIndex_ = null;
            _this.interactionHandler_ = function (evt) { return _this.handleInteraction(evt); };
            return _this;
        }
        Object.defineProperty(MDCSelectIconFoundation, "strings", {
            get: function () {
                return strings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelectIconFoundation, "defaultAdapter", {
            /**
             * See {@link MDCSelectIconAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    getAttr: function () { return null; },
                    setAttr: function () { return undefined; },
                    removeAttr: function () { return undefined; },
                    setContent: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    notifyIconAction: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: true,
            configurable: true
        });
        MDCSelectIconFoundation.prototype.init = function () {
            var _this = this;
            this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
            INTERACTION_EVENTS.forEach(function (evtType) {
                _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
            });
        };
        MDCSelectIconFoundation.prototype.destroy = function () {
            var _this = this;
            INTERACTION_EVENTS.forEach(function (evtType) {
                _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
            });
        };
        MDCSelectIconFoundation.prototype.setDisabled = function (disabled) {
            if (!this.savedTabIndex_) {
                return;
            }
            if (disabled) {
                this.adapter_.setAttr('tabindex', '-1');
                this.adapter_.removeAttr('role');
            }
            else {
                this.adapter_.setAttr('tabindex', this.savedTabIndex_);
                this.adapter_.setAttr('role', strings.ICON_ROLE);
            }
        };
        MDCSelectIconFoundation.prototype.setAriaLabel = function (label) {
            this.adapter_.setAttr('aria-label', label);
        };
        MDCSelectIconFoundation.prototype.setContent = function (content) {
            this.adapter_.setContent(content);
        };
        MDCSelectIconFoundation.prototype.handleInteraction = function (evt) {
            var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
            if (evt.type === 'click' || isEnterKey) {
                this.adapter_.notifyIconAction();
            }
        };
        return MDCSelectIconFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectIcon = /** @class */ (function (_super) {
        __extends(MDCSelectIcon, _super);
        function MDCSelectIcon() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCSelectIcon.attachTo = function (root) {
            return new MDCSelectIcon(root);
        };
        Object.defineProperty(MDCSelectIcon.prototype, "foundation", {
            get: function () {
                return this.foundation_;
            },
            enumerable: true,
            configurable: true
        });
        MDCSelectIcon.prototype.getDefaultFoundation = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = {
                getAttr: function (attr) { return _this.root_.getAttribute(attr); },
                setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
                removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
                setContent: function (content) {
                    _this.root_.textContent = content;
                },
                registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
                deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
                notifyIconAction: function () { return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */); },
            };
            // tslint:enable:object-literal-sort-keys
            return new MDCSelectIconFoundation(adapter);
        };
        return MDCSelectIcon;
    }(MDCComponent));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var VALIDATION_ATTR_WHITELIST = ['required', 'aria-required'];
    var MDCSelect = /** @class */ (function (_super) {
        __extends(MDCSelect, _super);
        function MDCSelect() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MDCSelect.attachTo = function (root) {
            return new MDCSelect(root);
        };
        MDCSelect.prototype.initialize = function (labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
            if (labelFactory === void 0) { labelFactory = function (el) { return new MDCFloatingLabel(el); }; }
            if (lineRippleFactory === void 0) { lineRippleFactory = function (el) { return new MDCLineRipple(el); }; }
            if (outlineFactory === void 0) { outlineFactory = function (el) { return new MDCNotchedOutline(el); }; }
            if (menuFactory === void 0) { menuFactory = function (el) { return new MDCMenu(el); }; }
            if (iconFactory === void 0) { iconFactory = function (el) { return new MDCSelectIcon(el); }; }
            if (helperTextFactory === void 0) { helperTextFactory = function (el) { return new MDCSelectHelperText(el); }; }
            this.isMenuOpen_ = false;
            this.nativeControl_ = this.root_.querySelector(strings$2.NATIVE_CONTROL_SELECTOR);
            this.selectedText_ = this.root_.querySelector(strings$2.SELECTED_TEXT_SELECTOR);
            var targetElement = this.nativeControl_ || this.selectedText_;
            if (!targetElement) {
                throw new Error('MDCSelect: Missing required element: Exactly one of the following selectors must be present: ' +
                    ("'" + strings$2.NATIVE_CONTROL_SELECTOR + "' or '" + strings$2.SELECTED_TEXT_SELECTOR + "'"));
            }
            this.targetElement_ = targetElement;
            if (this.targetElement_.hasAttribute(strings$2.ARIA_CONTROLS)) {
                var helperTextElement = document.getElementById(this.targetElement_.getAttribute(strings$2.ARIA_CONTROLS));
                if (helperTextElement) {
                    this.helperText_ = helperTextFactory(helperTextElement);
                }
            }
            if (this.selectedText_) {
                this.enhancedSelectSetup_(menuFactory);
            }
            var labelElement = this.root_.querySelector(strings$2.LABEL_SELECTOR);
            this.label_ = labelElement ? labelFactory(labelElement) : null;
            var lineRippleElement = this.root_.querySelector(strings$2.LINE_RIPPLE_SELECTOR);
            this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
            var outlineElement = this.root_.querySelector(strings$2.OUTLINE_SELECTOR);
            this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
            var leadingIcon = this.root_.querySelector(strings$2.LEADING_ICON_SELECTOR);
            if (leadingIcon) {
                this.root_.classList.add(cssClasses$1.WITH_LEADING_ICON);
                this.leadingIcon_ = iconFactory(leadingIcon);
                if (this.menuElement_) {
                    this.menuElement_.classList.add(cssClasses$1.WITH_LEADING_ICON);
                }
            }
            if (!this.root_.classList.contains(cssClasses$1.OUTLINED)) {
                this.ripple = this.createRipple_();
            }
            // The required state needs to be sync'd before the mutation observer is added.
            this.initialSyncRequiredState_();
            this.addMutationObserverForRequired_();
        };
        /**
         * Initializes the select's event listeners and internal state based
         * on the environment's state.
         */
        MDCSelect.prototype.initialSyncWithDOM = function () {
            var _this = this;
            this.handleChange_ = function () { return _this.foundation_.handleChange(/* didChange */ true); };
            this.handleFocus_ = function () { return _this.foundation_.handleFocus(); };
            this.handleBlur_ = function () { return _this.foundation_.handleBlur(); };
            this.handleClick_ = function (evt) {
                if (_this.selectedText_) {
                    _this.selectedText_.focus();
                }
                _this.foundation_.handleClick(_this.getNormalizedXCoordinate_(evt));
            };
            this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
            this.handleMenuSelected_ = function (evtData) { return _this.selectedIndex = evtData.detail.index; };
            this.handleMenuOpened_ = function () {
                _this.foundation_.handleMenuOpened();
                if (_this.menu_.items.length === 0) {
                    return;
                }
                // Menu should open to the last selected element, should open to first menu item otherwise.
                var focusItemIndex = _this.selectedIndex >= 0 ? _this.selectedIndex : 0;
                var focusItemEl = _this.menu_.items[focusItemIndex];
                focusItemEl.focus();
            };
            this.handleMenuClosed_ = function () {
                _this.foundation_.handleMenuClosed();
                // isMenuOpen_ is used to track the state of the menu opening or closing since the menu.open function
                // will return false if the menu is still closing and this method listens to the closed event which
                // occurs after the menu is already closed.
                _this.isMenuOpen_ = false;
                _this.selectedText_.removeAttribute('aria-expanded');
                if (document.activeElement !== _this.selectedText_) {
                    _this.foundation_.handleBlur();
                }
            };
            this.targetElement_.addEventListener('change', this.handleChange_);
            this.targetElement_.addEventListener('focus', this.handleFocus_);
            this.targetElement_.addEventListener('blur', this.handleBlur_);
            this.targetElement_.addEventListener('click', this.handleClick_);
            if (this.menuElement_) {
                this.selectedText_.addEventListener('keydown', this.handleKeydown_);
                this.menu_.listen(strings$4.CLOSED_EVENT, this.handleMenuClosed_);
                this.menu_.listen(strings$4.OPENED_EVENT, this.handleMenuOpened_);
                this.menu_.listen(strings$3.SELECTED_EVENT, this.handleMenuSelected_);
                if (this.hiddenInput_ && this.hiddenInput_.value) {
                    // If the hidden input already has a value, use it to restore the select's value.
                    // This can happen e.g. if the user goes back or (in some browsers) refreshes the page.
                    var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
                    enhancedAdapterMethods.setValue(this.hiddenInput_.value);
                }
                else if (this.menuElement_.querySelector(strings$2.SELECTED_ITEM_SELECTOR)) {
                    // If an element is selected, the select should set the initial selected text.
                    var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
                    enhancedAdapterMethods.setValue(enhancedAdapterMethods.getValue());
                }
            }
            // Initially sync floating label
            this.foundation_.handleChange(/* didChange */ false);
            if (this.root_.classList.contains(cssClasses$1.DISABLED)
                || (this.nativeControl_ && this.nativeControl_.disabled)) {
                this.disabled = true;
            }
        };
        MDCSelect.prototype.destroy = function () {
            this.targetElement_.removeEventListener('change', this.handleChange_);
            this.targetElement_.removeEventListener('focus', this.handleFocus_);
            this.targetElement_.removeEventListener('blur', this.handleBlur_);
            this.targetElement_.removeEventListener('keydown', this.handleKeydown_);
            this.targetElement_.removeEventListener('click', this.handleClick_);
            if (this.menu_) {
                this.menu_.unlisten(strings$4.CLOSED_EVENT, this.handleMenuClosed_);
                this.menu_.unlisten(strings$4.OPENED_EVENT, this.handleMenuOpened_);
                this.menu_.unlisten(strings$3.SELECTED_EVENT, this.handleMenuSelected_);
                this.menu_.destroy();
            }
            if (this.ripple) {
                this.ripple.destroy();
            }
            if (this.outline_) {
                this.outline_.destroy();
            }
            if (this.leadingIcon_) {
                this.leadingIcon_.destroy();
            }
            if (this.helperText_) {
                this.helperText_.destroy();
            }
            if (this.validationObserver_) {
                this.validationObserver_.disconnect();
            }
            _super.prototype.destroy.call(this);
        };
        Object.defineProperty(MDCSelect.prototype, "value", {
            get: function () {
                return this.foundation_.getValue();
            },
            set: function (value) {
                this.foundation_.setValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "selectedIndex", {
            get: function () {
                var selectedIndex = -1;
                if (this.menuElement_ && this.menu_) {
                    var selectedEl = this.menuElement_.querySelector(strings$2.SELECTED_ITEM_SELECTOR);
                    selectedIndex = this.menu_.items.indexOf(selectedEl);
                }
                else if (this.nativeControl_) {
                    selectedIndex = this.nativeControl_.selectedIndex;
                }
                return selectedIndex;
            },
            set: function (selectedIndex) {
                this.foundation_.setSelectedIndex(selectedIndex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "disabled", {
            get: function () {
                return this.root_.classList.contains(cssClasses$1.DISABLED) ||
                    (this.nativeControl_ ? this.nativeControl_.disabled : false);
            },
            set: function (disabled) {
                this.foundation_.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "leadingIconAriaLabel", {
            set: function (label) {
                this.foundation_.setLeadingIconAriaLabel(label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "leadingIconContent", {
            /**
             * Sets the text content of the leading icon.
             */
            set: function (content) {
                this.foundation_.setLeadingIconContent(content);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "helperTextContent", {
            /**
             * Sets the text content of the helper text.
             */
            set: function (content) {
                this.foundation_.setHelperTextContent(content);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "valid", {
            /**
             * Checks if the select is in a valid state.
             */
            get: function () {
                return this.foundation_.isValid();
            },
            /**
             * Sets the current invalid state of the select.
             */
            set: function (isValid) {
                this.foundation_.setValid(isValid);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MDCSelect.prototype, "required", {
            /**
             * Returns whether the select is required.
             */
            get: function () {
                if (this.nativeControl_) {
                    return this.nativeControl_.required;
                }
                else {
                    return this.selectedText_.getAttribute('aria-required') === 'true';
                }
            },
            /**
             * Sets the control to the required state.
             */
            set: function (isRequired) {
                if (this.nativeControl_) {
                    this.nativeControl_.required = isRequired;
                }
                else {
                    if (isRequired) {
                        this.selectedText_.setAttribute('aria-required', isRequired.toString());
                    }
                    else {
                        this.selectedText_.removeAttribute('aria-required');
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Recomputes the outline SVG path for the outline element.
         */
        MDCSelect.prototype.layout = function () {
            this.foundation_.layout();
        };
        MDCSelect.prototype.getDefaultFoundation = function () {
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            var adapter = __assign({}, (this.nativeControl_ ? this.getNativeSelectAdapterMethods_() : this.getEnhancedSelectAdapterMethods_()), this.getCommonAdapterMethods_(), this.getOutlineAdapterMethods_(), this.getLabelAdapterMethods_());
            return new MDCSelectFoundation(adapter, this.getFoundationMap_());
        };
        /**
         * Handles setup for the enhanced menu.
         */
        MDCSelect.prototype.enhancedSelectSetup_ = function (menuFactory) {
            var isDisabled = this.root_.classList.contains(cssClasses$1.DISABLED);
            this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
            this.hiddenInput_ = this.root_.querySelector(strings$2.HIDDEN_INPUT_SELECTOR);
            this.menuElement_ = this.root_.querySelector(strings$2.MENU_SELECTOR);
            this.menu_ = menuFactory(this.menuElement_);
            this.menu_.hoistMenuToBody();
            this.menu_.setAnchorElement(this.root_);
            this.menu_.setAnchorCorner(Corner.BOTTOM_START);
            this.menu_.wrapFocus = false;
        };
        MDCSelect.prototype.createRipple_ = function () {
            var _this = this;
            // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
            // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            var adapter = __assign({}, MDCRipple.createAdapter(this), { registerInteractionHandler: function (evtType, handler) { return _this.targetElement_.addEventListener(evtType, handler); }, deregisterInteractionHandler: function (evtType, handler) { return _this.targetElement_.removeEventListener(evtType, handler); } });
            // tslint:enable:object-literal-sort-keys
            return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
        };
        MDCSelect.prototype.getNativeSelectAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getValue: function () { return _this.nativeControl_.value; },
                setValue: function (value) {
                    _this.nativeControl_.value = value;
                },
                openMenu: function () { return undefined; },
                closeMenu: function () { return undefined; },
                isMenuOpen: function () { return false; },
                setSelectedIndex: function (index) {
                    _this.nativeControl_.selectedIndex = index;
                },
                setDisabled: function (isDisabled) {
                    _this.nativeControl_.disabled = isDisabled;
                },
                setValid: function (isValid) {
                    if (isValid) {
                        _this.root_.classList.remove(cssClasses$1.INVALID);
                    }
                    else {
                        _this.root_.classList.add(cssClasses$1.INVALID);
                    }
                },
                checkValidity: function () { return _this.nativeControl_.checkValidity(); },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCSelect.prototype.getEnhancedSelectAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getValue: function () {
                    var listItem = _this.menuElement_.querySelector(strings$2.SELECTED_ITEM_SELECTOR);
                    if (listItem && listItem.hasAttribute(strings$2.ENHANCED_VALUE_ATTR)) {
                        return listItem.getAttribute(strings$2.ENHANCED_VALUE_ATTR) || '';
                    }
                    return '';
                },
                setValue: function (value) {
                    var element = _this.menuElement_.querySelector("[" + strings$2.ENHANCED_VALUE_ATTR + "=\"" + value + "\"]");
                    _this.setEnhancedSelectedIndex_(element ? _this.menu_.items.indexOf(element) : -1);
                },
                openMenu: function () {
                    if (_this.menu_ && !_this.menu_.open) {
                        _this.menu_.open = true;
                        _this.isMenuOpen_ = true;
                        _this.selectedText_.setAttribute('aria-expanded', 'true');
                    }
                },
                closeMenu: function () {
                    if (_this.menu_ && _this.menu_.open) {
                        _this.menu_.open = false;
                    }
                },
                isMenuOpen: function () { return Boolean(_this.menu_) && _this.isMenuOpen_; },
                setSelectedIndex: function (index) { return _this.setEnhancedSelectedIndex_(index); },
                setDisabled: function (isDisabled) {
                    _this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
                    _this.selectedText_.setAttribute('aria-disabled', isDisabled.toString());
                    if (_this.hiddenInput_) {
                        _this.hiddenInput_.disabled = isDisabled;
                    }
                },
                checkValidity: function () {
                    var classList = _this.root_.classList;
                    if (classList.contains(cssClasses$1.REQUIRED) && !classList.contains(cssClasses$1.DISABLED)) {
                        // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
                        // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
                        return _this.selectedIndex !== -1 && (_this.selectedIndex !== 0 || Boolean(_this.value));
                    }
                    else {
                        return true;
                    }
                },
                setValid: function (isValid) {
                    _this.selectedText_.setAttribute('aria-invalid', (!isValid).toString());
                    if (isValid) {
                        _this.root_.classList.remove(cssClasses$1.INVALID);
                    }
                    else {
                        _this.root_.classList.add(cssClasses$1.INVALID);
                    }
                },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCSelect.prototype.getCommonAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function (className) { return _this.root_.classList.add(className); },
                removeClass: function (className) { return _this.root_.classList.remove(className); },
                hasClass: function (className) { return _this.root_.classList.contains(className); },
                setRippleCenter: function (normalizedX) { return _this.lineRipple_ && _this.lineRipple_.setRippleCenter(normalizedX); },
                activateBottomLine: function () { return _this.lineRipple_ && _this.lineRipple_.activate(); },
                deactivateBottomLine: function () { return _this.lineRipple_ && _this.lineRipple_.deactivate(); },
                notifyChange: function (value) {
                    var index = _this.selectedIndex;
                    _this.emit(strings$2.CHANGE_EVENT, { value: value, index: index }, true /* shouldBubble  */);
                },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCSelect.prototype.getOutlineAdapterMethods_ = function () {
            var _this = this;
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                hasOutline: function () { return Boolean(_this.outline_); },
                notchOutline: function (labelWidth) { return _this.outline_ && _this.outline_.notch(labelWidth); },
                closeOutline: function () { return _this.outline_ && _this.outline_.closeNotch(); },
            };
            // tslint:enable:object-literal-sort-keys
        };
        MDCSelect.prototype.getLabelAdapterMethods_ = function () {
            var _this = this;
            return {
                floatLabel: function (shouldFloat) { return _this.label_ && _this.label_.float(shouldFloat); },
                getLabelWidth: function () { return _this.label_ ? _this.label_.getWidth() : 0; },
            };
        };
        /**
         * Calculates where the line ripple should start based on the x coordinate within the component.
         */
        MDCSelect.prototype.getNormalizedXCoordinate_ = function (evt) {
            var targetClientRect = evt.target.getBoundingClientRect();
            var xCoordinate = this.isTouchEvent_(evt) ? evt.touches[0].clientX : evt.clientX;
            return xCoordinate - targetClientRect.left;
        };
        MDCSelect.prototype.isTouchEvent_ = function (evt) {
            return Boolean(evt.touches);
        };
        /**
         * Returns a map of all subcomponents to subfoundations.
         */
        MDCSelect.prototype.getFoundationMap_ = function () {
            return {
                helperText: this.helperText_ ? this.helperText_.foundation : undefined,
                leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
            };
        };
        MDCSelect.prototype.setEnhancedSelectedIndex_ = function (index) {
            var selectedItem = this.menu_.items[index];
            this.selectedText_.textContent = selectedItem ? selectedItem.textContent.trim() : '';
            var previouslySelected = this.menuElement_.querySelector(strings$2.SELECTED_ITEM_SELECTOR);
            if (previouslySelected) {
                previouslySelected.classList.remove(cssClasses$1.SELECTED_ITEM_CLASS);
                previouslySelected.removeAttribute(strings$2.ARIA_SELECTED_ATTR);
            }
            if (selectedItem) {
                selectedItem.classList.add(cssClasses$1.SELECTED_ITEM_CLASS);
                selectedItem.setAttribute(strings$2.ARIA_SELECTED_ATTR, 'true');
            }
            // Synchronize hidden input's value with data-value attribute of selected item.
            // This code path is also followed when setting value directly, so this covers all cases.
            if (this.hiddenInput_) {
                this.hiddenInput_.value = selectedItem ? selectedItem.getAttribute(strings$2.ENHANCED_VALUE_ATTR) || '' : '';
            }
            this.layout();
        };
        MDCSelect.prototype.initialSyncRequiredState_ = function () {
            var isRequired = this.targetElement_.required
                || this.targetElement_.getAttribute('aria-required') === 'true'
                || this.root_.classList.contains(cssClasses$1.REQUIRED);
            if (isRequired) {
                if (this.nativeControl_) {
                    this.nativeControl_.required = true;
                }
                else {
                    this.selectedText_.setAttribute('aria-required', 'true');
                }
                this.root_.classList.add(cssClasses$1.REQUIRED);
            }
        };
        MDCSelect.prototype.addMutationObserverForRequired_ = function () {
            var _this = this;
            var observerHandler = function (attributesList) {
                attributesList.some(function (attributeName) {
                    if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) === -1) {
                        return false;
                    }
                    if (_this.selectedText_) {
                        if (_this.selectedText_.getAttribute('aria-required') === 'true') {
                            _this.root_.classList.add(cssClasses$1.REQUIRED);
                        }
                        else {
                            _this.root_.classList.remove(cssClasses$1.REQUIRED);
                        }
                    }
                    else {
                        if (_this.nativeControl_.required) {
                            _this.root_.classList.add(cssClasses$1.REQUIRED);
                        }
                        else {
                            _this.root_.classList.remove(cssClasses$1.REQUIRED);
                        }
                    }
                    return true;
                });
            };
            var getAttributesList = function (mutationsList) {
                return mutationsList
                    .map(function (mutation) { return mutation.attributeName; })
                    .filter(function (attributeName) { return attributeName; });
            };
            var observer = new MutationObserver(function (mutationsList) { return observerHandler(getAttributesList(mutationsList)); });
            observer.observe(this.targetElement_, { attributes: true });
            this.validationObserver_ = observer;
        };
        return MDCSelect;
    }(MDCComponent));

    /* node_modules\@smui\menu-surface\MenuSurface.svelte generated by Svelte v3.42.1 */
    const file$x = "node_modules\\@smui\\menu-surface\\MenuSurface.svelte";

    function create_fragment$A(ctx) {
    	let div;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

    	let div_levels = [
    		{
    			class: div_class_value = "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? 'mdc-menu-surface--fixed' : '') + "\n    " + (/*isStatic*/ ctx[4] ? 'mdc-menu-surface--open' : '') + "\n    " + (/*isStatic*/ ctx[4] ? 'smui-menu-surface--static' : '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[7], [
    			'use',
    			'class',
    			'static',
    			'anchor',
    			'fixed',
    			'open',
    			'quickOpen',
    			'anchorElement',
    			'anchorCorner',
    			'element'
    		])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$x, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[26](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, div)),
    					listen_dev(div, "MDCMenuSurface:closed", /*updateOpen*/ ctx[6], false, false, false),
    					listen_dev(div, "MDCMenuSurface:opened", /*updateOpen*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[24],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className, fixed, isStatic*/ 25 && div_class_value !== (div_class_value = "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? 'mdc-menu-surface--fixed' : '') + "\n    " + (/*isStatic*/ ctx[4] ? 'mdc-menu-surface--open' : '') + "\n    " + (/*isStatic*/ ctx[4] ? 'smui-menu-surface--static' : '') + "\n  ")) && { class: div_class_value },
    				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], [
    					'use',
    					'class',
    					'static',
    					'anchor',
    					'fixed',
    					'open',
    					'quickOpen',
    					'anchorElement',
    					'anchorCorner',
    					'element'
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[26](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MenuSurface', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCMenuSurface:closed', 'MDCMenuSurface:opened']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { static: isStatic = false } = $$props;
    	let { anchor = true } = $$props;
    	let { fixed = false } = $$props;
    	let { open = isStatic } = $$props;
    	let { quickOpen = false } = $$props;
    	let { anchorElement = null } = $$props;
    	let { anchorCorner = null } = $$props;
    	let { element = undefined } = $$props;
    	let menuSurface;
    	let instantiate = getContext('SMUI:menu-surface:instantiate');
    	let getInstance = getContext('SMUI:menu-surface:getInstance');
    	setContext('SMUI:list:role', 'menu');
    	setContext('SMUI:list:item:role', 'menuitem');
    	let oldFixed = null;

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(22, menuSurface = new MDCMenuSurface(element));
    		} else {
    			$$invalidate(22, menuSurface = await getInstance());
    		}
    	});

    	onDestroy(() => {
    		if (anchor) {
    			element && element.parentNode.classList.remove('mdc-menu-surface--anchor');
    		}

    		let isHoisted = false;

    		if (menuSurface) {
    			isHoisted = menuSurface.foundation_.isHoistedElement_;

    			if (instantiate !== false) {
    				menuSurface.destroy();
    			}
    		}

    		if (isHoisted) {
    			element.parentNode.removeChild(element);
    		}
    	});

    	function updateOpen() {
    		if (menuSurface) {
    			if (isStatic) {
    				$$invalidate(8, open = true);
    			} else {
    				$$invalidate(8, open = menuSurface.isOpen());
    			}
    		}
    	}

    	function setOpen(value) {
    		$$invalidate(8, open = value);
    	}

    	function setAnchorCorner(...args) {
    		return menuSurface.setAnchorCorner(...args);
    	}

    	function setAnchorMargin(...args) {
    		return menuSurface.setAnchorMargin(...args);
    	}

    	function setFixedPosition(isFixed, ...args) {
    		$$invalidate(0, fixed = isFixed);
    		return menuSurface.setFixedPosition(isFixed, ...args);
    	}

    	function setAbsolutePosition(...args) {
    		return menuSurface.setAbsolutePosition(...args);
    	}

    	function setMenuSurfaceAnchorElement(...args) {
    		return menuSurface.setMenuSurfaceAnchorElement(...args);
    	}

    	function hoistMenuToBody(...args) {
    		return menuSurface.hoistMenuToBody(...args);
    	}

    	function setIsHoisted(...args) {
    		return menuSurface.setIsHoisted(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return menuSurface.getDefaultFoundation(...args);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('static' in $$new_props) $$invalidate(4, isStatic = $$new_props.static);
    		if ('anchor' in $$new_props) $$invalidate(10, anchor = $$new_props.anchor);
    		if ('fixed' in $$new_props) $$invalidate(0, fixed = $$new_props.fixed);
    		if ('open' in $$new_props) $$invalidate(8, open = $$new_props.open);
    		if ('quickOpen' in $$new_props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
    		if ('anchorElement' in $$new_props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
    		if ('anchorCorner' in $$new_props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
    		if ('element' in $$new_props) $$invalidate(1, element = $$new_props.element);
    		if ('$$scope' in $$new_props) $$invalidate(24, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Corner,
    		CornerBit,
    		MDCMenuSurface,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		isStatic,
    		anchor,
    		fixed,
    		open,
    		quickOpen,
    		anchorElement,
    		anchorCorner,
    		element,
    		menuSurface,
    		instantiate,
    		getInstance,
    		oldFixed,
    		updateOpen,
    		setOpen,
    		setAnchorCorner,
    		setAnchorMargin,
    		setFixedPosition,
    		setAbsolutePosition,
    		setMenuSurfaceAnchorElement,
    		hoistMenuToBody,
    		setIsHoisted,
    		getDefaultFoundation
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('isStatic' in $$props) $$invalidate(4, isStatic = $$new_props.isStatic);
    		if ('anchor' in $$props) $$invalidate(10, anchor = $$new_props.anchor);
    		if ('fixed' in $$props) $$invalidate(0, fixed = $$new_props.fixed);
    		if ('open' in $$props) $$invalidate(8, open = $$new_props.open);
    		if ('quickOpen' in $$props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
    		if ('anchorElement' in $$props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
    		if ('anchorCorner' in $$props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
    		if ('element' in $$props) $$invalidate(1, element = $$new_props.element);
    		if ('menuSurface' in $$props) $$invalidate(22, menuSurface = $$new_props.menuSurface);
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    		if ('oldFixed' in $$props) $$invalidate(23, oldFixed = $$new_props.oldFixed);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element, anchor*/ 1026) {
    			if (element && anchor && !element.parentNode.classList.contains('mdc-menu-surface--anchor')) {
    				element.parentNode.classList.add('mdc-menu-surface--anchor');
    				$$invalidate(9, anchorElement = element.parentNode);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, quickOpen*/ 4196352) {
    			if (menuSurface && menuSurface.quickOpen !== quickOpen) {
    				$$invalidate(22, menuSurface.quickOpen = quickOpen, menuSurface);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, anchorElement*/ 4194816) {
    			if (menuSurface && menuSurface.anchorElement !== anchorElement) {
    				$$invalidate(22, menuSurface.anchorElement = anchorElement, menuSurface);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, open*/ 4194560) {
    			if (menuSurface && menuSurface.isOpen() !== open) {
    				if (open) {
    					menuSurface.open();
    				} else {
    					menuSurface.close();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, oldFixed, fixed*/ 12582913) {
    			if (menuSurface && oldFixed !== fixed) {
    				menuSurface.setFixedPosition(fixed);
    				$$invalidate(23, oldFixed = fixed);
    			}
    		}

    		if ($$self.$$.dirty & /*menuSurface, anchorCorner*/ 4198400) {
    			if (menuSurface && anchorCorner != null) {
    				if (Corner.hasOwnProperty(anchorCorner)) {
    					menuSurface.setAnchorCorner(Corner[anchorCorner]);
    				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
    					menuSurface.setAnchorCorner(Corner[anchorCorner]);
    				} else {
    					menuSurface.setAnchorCorner(anchorCorner);
    				}
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		fixed,
    		element,
    		use,
    		className,
    		isStatic,
    		forwardEvents,
    		updateOpen,
    		$$props,
    		open,
    		anchorElement,
    		anchor,
    		quickOpen,
    		anchorCorner,
    		setOpen,
    		setAnchorCorner,
    		setAnchorMargin,
    		setFixedPosition,
    		setAbsolutePosition,
    		setMenuSurfaceAnchorElement,
    		hoistMenuToBody,
    		setIsHoisted,
    		getDefaultFoundation,
    		menuSurface,
    		oldFixed,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class MenuSurface extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			use: 2,
    			class: 3,
    			static: 4,
    			anchor: 10,
    			fixed: 0,
    			open: 8,
    			quickOpen: 11,
    			anchorElement: 9,
    			anchorCorner: 12,
    			element: 1,
    			setOpen: 13,
    			setAnchorCorner: 14,
    			setAnchorMargin: 15,
    			setFixedPosition: 16,
    			setAbsolutePosition: 17,
    			setMenuSurfaceAnchorElement: 18,
    			hoistMenuToBody: 19,
    			setIsHoisted: 20,
    			getDefaultFoundation: 21
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuSurface",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get use() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get static() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set static(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchor() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchor(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quickOpen() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quickOpen(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorElement() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorElement(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorCorner() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorCorner(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setOpen() {
    		return this.$$.ctx[13];
    	}

    	set setOpen(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorCorner() {
    		return this.$$.ctx[14];
    	}

    	set setAnchorCorner(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorMargin() {
    		return this.$$.ctx[15];
    	}

    	set setAnchorMargin(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setFixedPosition() {
    		return this.$$.ctx[16];
    	}

    	set setFixedPosition(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAbsolutePosition() {
    		return this.$$.ctx[17];
    	}

    	set setAbsolutePosition(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setMenuSurfaceAnchorElement() {
    		return this.$$.ctx[18];
    	}

    	set setMenuSurfaceAnchorElement(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoistMenuToBody() {
    		return this.$$.ctx[19];
    	}

    	set hoistMenuToBody(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setIsHoisted() {
    		return this.$$.ctx[20];
    	}

    	set setIsHoisted(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[21];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\menu\Menu.svelte generated by Svelte v3.42.1 */

    // (1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class="mdc-menu {className}"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >
    function create_default_slot$c(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class=\\\"mdc-menu {className}\\\"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let menusurface;
    	let updating_element;
    	let current;

    	const menusurface_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
    		},
    		{
    			class: "mdc-menu " + /*className*/ ctx[1]
    		},
    		exclude(/*$$props*/ ctx[5], ['use', 'class', 'wrapFocus'])
    	];

    	function menusurface_element_binding(value) {
    		/*menusurface_element_binding*/ ctx[27](value);
    	}

    	let menusurface_props = {
    		$$slots: { default: [create_default_slot$c] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
    		menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
    	}

    	if (/*element*/ ctx[2] !== void 0) {
    		menusurface_props.element = /*element*/ ctx[2];
    	}

    	menusurface = new MenuSurface({ props: menusurface_props, $$inline: true });
    	binding_callbacks.push(() => bind(menusurface, 'element', menusurface_element_binding));
    	menusurface.$on("MDCMenu:selected", /*updateOpen*/ ctx[4]);
    	menusurface.$on("MDCMenuSurface:closed", /*updateOpen*/ ctx[4]);
    	menusurface.$on("MDCMenuSurface:opened", /*updateOpen*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(menusurface.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menusurface, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menusurface_changes = (dirty[0] & /*forwardEvents, use, className, $$props*/ 43)
    			? get_spread_update(menusurface_spread_levels, [
    					dirty[0] & /*forwardEvents, use*/ 9 && {
    						use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
    					},
    					dirty[0] & /*className*/ 2 && {
    						class: "mdc-menu " + /*className*/ ctx[1]
    					},
    					dirty[0] & /*$$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ['use', 'class', 'wrapFocus']))
    				])
    			: {};

    			if (dirty[0] & /*$$scope*/ 268435456) {
    				menusurface_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty[0] & /*element*/ 4) {
    				updating_element = true;
    				menusurface_changes.element = /*element*/ ctx[2];
    				add_flush_callback(() => updating_element = false);
    			}

    			menusurface.$set(menusurface_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menusurface.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menusurface.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menusurface, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Menu', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), ['MDCMenu:selected', 'MDCMenuSurface:closed', 'MDCMenuSurface:opened']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { static: isStatic = false } = $$props;
    	let { open = isStatic } = $$props;
    	let { quickOpen = false } = $$props;
    	let { anchorCorner = null } = $$props;
    	let { wrapFocus = false } = $$props;
    	let element;
    	let menu;
    	let instantiate = getContext('SMUI:menu:instantiate');
    	let getInstance = getContext('SMUI:menu:getInstance');
    	let menuSurfacePromiseResolve;
    	let menuSurfacePromise = new Promise(resolve => menuSurfacePromiseResolve = resolve);
    	let listPromiseResolve;
    	let listPromise = new Promise(resolve => listPromiseResolve = resolve);
    	setContext('SMUI:menu-surface:instantiate', false);
    	setContext('SMUI:menu-surface:getInstance', getMenuSurfaceInstancePromise);
    	setContext('SMUI:list:instantiate', false);
    	setContext('SMUI:list:getInstance', getListInstancePromise);

    	onMount(async () => {
    		if (instantiate !== false) {
    			$$invalidate(25, menu = new MDCMenu(element));
    		} else {
    			$$invalidate(25, menu = await getInstance());
    		}

    		menuSurfacePromiseResolve(menu.menuSurface_);
    		listPromiseResolve(menu.list_);
    	});

    	onDestroy(() => {
    		if (instantiate !== false) {
    			menu && menu.destroy();
    		}
    	});

    	function getMenuSurfaceInstancePromise() {
    		return menuSurfacePromise;
    	}

    	function getListInstancePromise() {
    		return listPromise;
    	}

    	function updateOpen() {
    		$$invalidate(6, open = menu.open);
    	}

    	function setOpen(value) {
    		$$invalidate(6, open = value);
    	}

    	function getItems() {
    		return menu.items;
    	}

    	function setDefaultFocusState(...args) {
    		return menu.setDefaultFocusState(...args);
    	}

    	function setAnchorCorner(...args) {
    		return menu.setAnchorCorner(...args);
    	}

    	function setAnchorMargin(...args) {
    		return menu.setAnchorMargin(...args);
    	}

    	function setSelectedIndex(...args) {
    		return menu.setSelectedIndex(...args);
    	}

    	function setEnabled(...args) {
    		return menu.setEnabled(...args);
    	}

    	function getOptionByIndex(...args) {
    		return menu.getOptionByIndex(...args);
    	}

    	function setFixedPosition(...args) {
    		return menu.setFixedPosition(...args);
    	}

    	function hoistMenuToBody(...args) {
    		return menu.hoistMenuToBody(...args);
    	}

    	function setIsHoisted(...args) {
    		return menu.setIsHoisted(...args);
    	}

    	function setAbsolutePosition(...args) {
    		return menu.setAbsolutePosition(...args);
    	}

    	function setAnchorElement(...args) {
    		return menu.setAnchorElement(...args);
    	}

    	function getDefaultFoundation(...args) {
    		return menu.getDefaultFoundation(...args);
    	}

    	function menusurface_element_binding(value) {
    		element = value;
    		$$invalidate(2, element);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('static' in $$new_props) $$invalidate(7, isStatic = $$new_props.static);
    		if ('open' in $$new_props) $$invalidate(6, open = $$new_props.open);
    		if ('quickOpen' in $$new_props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
    		if ('anchorCorner' in $$new_props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
    		if ('wrapFocus' in $$new_props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
    		if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCMenu,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		MenuSurface,
    		Corner,
    		CornerBit,
    		forwardEvents,
    		use,
    		className,
    		isStatic,
    		open,
    		quickOpen,
    		anchorCorner,
    		wrapFocus,
    		element,
    		menu,
    		instantiate,
    		getInstance,
    		menuSurfacePromiseResolve,
    		menuSurfacePromise,
    		listPromiseResolve,
    		listPromise,
    		getMenuSurfaceInstancePromise,
    		getListInstancePromise,
    		updateOpen,
    		setOpen,
    		getItems,
    		setDefaultFocusState,
    		setAnchorCorner,
    		setAnchorMargin,
    		setSelectedIndex,
    		setEnabled,
    		getOptionByIndex,
    		setFixedPosition,
    		hoistMenuToBody,
    		setIsHoisted,
    		setAbsolutePosition,
    		setAnchorElement,
    		getDefaultFoundation
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('isStatic' in $$props) $$invalidate(7, isStatic = $$new_props.isStatic);
    		if ('open' in $$props) $$invalidate(6, open = $$new_props.open);
    		if ('quickOpen' in $$props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
    		if ('anchorCorner' in $$props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
    		if ('wrapFocus' in $$props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
    		if ('element' in $$props) $$invalidate(2, element = $$new_props.element);
    		if ('menu' in $$props) $$invalidate(25, menu = $$new_props.menu);
    		if ('instantiate' in $$props) instantiate = $$new_props.instantiate;
    		if ('getInstance' in $$props) getInstance = $$new_props.getInstance;
    		if ('menuSurfacePromiseResolve' in $$props) menuSurfacePromiseResolve = $$new_props.menuSurfacePromiseResolve;
    		if ('menuSurfacePromise' in $$props) menuSurfacePromise = $$new_props.menuSurfacePromise;
    		if ('listPromiseResolve' in $$props) listPromiseResolve = $$new_props.listPromiseResolve;
    		if ('listPromise' in $$props) listPromise = $$new_props.listPromise;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*menu, open, isStatic*/ 33554624) {
    			if (menu && menu.open !== open) {
    				if (isStatic) {
    					$$invalidate(6, open = true);
    				}

    				$$invalidate(25, menu.open = open, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, wrapFocus*/ 33555456) {
    			if (menu && menu.wrapFocus !== wrapFocus) {
    				$$invalidate(25, menu.wrapFocus = wrapFocus, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, quickOpen*/ 33554688) {
    			if (menu) {
    				$$invalidate(25, menu.quickOpen = quickOpen, menu);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*menu, anchorCorner*/ 33554944) {
    			if (menu && anchorCorner != null) {
    				if (Corner.hasOwnProperty(anchorCorner)) {
    					menu.setAnchorCorner(Corner[anchorCorner]);
    				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
    					menu.setAnchorCorner(Corner[anchorCorner]);
    				} else {
    					menu.setAnchorCorner(anchorCorner);
    				}
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		className,
    		element,
    		forwardEvents,
    		updateOpen,
    		$$props,
    		open,
    		isStatic,
    		quickOpen,
    		anchorCorner,
    		wrapFocus,
    		setOpen,
    		getItems,
    		setDefaultFocusState,
    		setAnchorCorner,
    		setAnchorMargin,
    		setSelectedIndex,
    		setEnabled,
    		getOptionByIndex,
    		setFixedPosition,
    		hoistMenuToBody,
    		setIsHoisted,
    		setAbsolutePosition,
    		setAnchorElement,
    		getDefaultFoundation,
    		menu,
    		slots,
    		menusurface_element_binding,
    		$$scope
    	];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$z,
    			create_fragment$z,
    			safe_not_equal,
    			{
    				use: 0,
    				class: 1,
    				static: 7,
    				open: 6,
    				quickOpen: 8,
    				anchorCorner: 9,
    				wrapFocus: 10,
    				setOpen: 11,
    				getItems: 12,
    				setDefaultFocusState: 13,
    				setAnchorCorner: 14,
    				setAnchorMargin: 15,
    				setSelectedIndex: 16,
    				setEnabled: 17,
    				getOptionByIndex: 18,
    				setFixedPosition: 19,
    				hoistMenuToBody: 20,
    				setIsHoisted: 21,
    				setAbsolutePosition: 22,
    				setAnchorElement: 23,
    				getDefaultFoundation: 24
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get use() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get static() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set static(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quickOpen() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quickOpen(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorCorner() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorCorner(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapFocus() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapFocus(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setOpen() {
    		return this.$$.ctx[11];
    	}

    	set setOpen(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getItems() {
    		return this.$$.ctx[12];
    	}

    	set getItems(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setDefaultFocusState() {
    		return this.$$.ctx[13];
    	}

    	set setDefaultFocusState(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorCorner() {
    		return this.$$.ctx[14];
    	}

    	set setAnchorCorner(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorMargin() {
    		return this.$$.ctx[15];
    	}

    	set setAnchorMargin(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setSelectedIndex() {
    		return this.$$.ctx[16];
    	}

    	set setSelectedIndex(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setEnabled() {
    		return this.$$.ctx[17];
    	}

    	set setEnabled(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionByIndex() {
    		return this.$$.ctx[18];
    	}

    	set getOptionByIndex(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setFixedPosition() {
    		return this.$$.ctx[19];
    	}

    	set setFixedPosition(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoistMenuToBody() {
    		return this.$$.ctx[20];
    	}

    	set hoistMenuToBody(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setIsHoisted() {
    		return this.$$.ctx[21];
    	}

    	set setIsHoisted(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAbsolutePosition() {
    		return this.$$.ctx[22];
    	}

    	set setAbsolutePosition(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setAnchorElement() {
    		return this.$$.ctx[23];
    	}

    	set setAnchorElement(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getDefaultFoundation() {
    		return this.$$.ctx[24];
    	}

    	set getDefaultFoundation(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\select\Select.svelte generated by Svelte v3.42.1 */
    const file$w = "node_modules\\@smui\\select\\Select.svelte";
    const get_label_slot_changes_1 = dirty => ({});
    const get_label_slot_context_1 = ctx => ({});
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});
    const get_icon_slot_changes = dirty => ({});
    const get_icon_slot_context = ctx => ({});

    // (49:2) {:else}
    function create_else_block$4(ctx) {
    	let select_1;
    	let select_1_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[29].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[38], null);

    	let select_1_levels = [
    		{
    			class: select_1_class_value = "mdc-select__native-control " + /*input$class*/ ctx[15]
    		},
    		{ disabled: /*disabled*/ ctx[5] },
    		{ required: /*required*/ ctx[12] },
    		{ id: /*inputId*/ ctx[13] },
    		exclude(prefixFilter(/*$$props*/ ctx[22], 'input$'), ['use', 'class'])
    	];

    	let select_1_data = {};

    	for (let i = 0; i < select_1_levels.length; i += 1) {
    		select_1_data = assign(select_1_data, select_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			select_1 = element("select");
    			if (default_slot) default_slot.c();
    			set_attributes(select_1, select_1_data);
    			add_location(select_1, file$w, 49, 4, 1649);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select_1, anchor);

    			if (default_slot) {
    				default_slot.m(select_1, null);
    			}

    			(select_1_data.multiple ? select_options : select_option)(select_1, select_1_data.value);
    			if (select_1.autofocus) select_1.focus();
    			/*select_1_binding*/ ctx[36](select_1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, select_1, /*input$use*/ ctx[14])),
    					listen_dev(select_1, "change", /*change_handler_1*/ ctx[32], false, false, false),
    					listen_dev(select_1, "input", /*input_handler_1*/ ctx[33], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[38],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[38])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[38], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(select_1, select_1_data = get_spread_update(select_1_levels, [
    				(!current || dirty[0] & /*input$class*/ 32768 && select_1_class_value !== (select_1_class_value = "mdc-select__native-control " + /*input$class*/ ctx[15])) && { class: select_1_class_value },
    				(!current || dirty[0] & /*disabled*/ 32) && { disabled: /*disabled*/ ctx[5] },
    				(!current || dirty[0] & /*required*/ 4096) && { required: /*required*/ ctx[12] },
    				(!current || dirty[0] & /*inputId*/ 8192) && { id: /*inputId*/ ctx[13] },
    				dirty[0] & /*$$props*/ 4194304 && exclude(prefixFilter(/*$$props*/ ctx[22], 'input$'), ['use', 'class'])
    			]));

    			if (dirty[0] & /*input$class, disabled, required, inputId, $$props*/ 4239392) (select_1_data.multiple ? select_options : select_option)(select_1, select_1_data.value);
    			
    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 16384) useActions_action.update.call(null, /*input$use*/ ctx[14]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select_1);
    			if (default_slot) default_slot.d(detaching);
    			/*select_1_binding*/ ctx[36](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(49:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:2) {#if enhanced}
    function create_if_block_5$1(ctx) {
    	let input;
    	let useActions_action;
    	let t0;
    	let div;
    	let t1;
    	let div_id_value;
    	let div_aria_labelledby_value;
    	let div_aria_required_value;
    	let t2;
    	let menu;
    	let updating_anchorElement;
    	let current;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{ type: "hidden" },
    		{ disabled: /*disabled*/ ctx[5] },
    		{ required: /*required*/ ctx[12] },
    		{ id: /*inputId*/ ctx[13] },
    		{ value: /*value*/ ctx[0] },
    		exclude(prefixFilter(/*$$props*/ ctx[22], 'input$'), ['use'])
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const menu_spread_levels = [
    		{
    			class: "mdc-select__menu " + /*menu$class*/ ctx[17]
    		},
    		{ role: "listbox" },
    		{ anchor: false },
    		exclude(prefixFilter(/*$$props*/ ctx[22], 'menu$'), ['class'])
    	];

    	function menu_anchorElement_binding(value) {
    		/*menu_anchorElement_binding*/ ctx[35](value);
    	}

    	let menu_props = {
    		$$slots: { default: [create_default_slot_3] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < menu_spread_levels.length; i += 1) {
    		menu_props = assign(menu_props, menu_spread_levels[i]);
    	}

    	if (/*element*/ ctx[18] !== void 0) {
    		menu_props.anchorElement = /*element*/ ctx[18];
    	}

    	menu = new Menu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, 'anchorElement', menu_anchorElement_binding));

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			div = element("div");
    			t1 = text(/*selectedText*/ ctx[11]);
    			t2 = space();
    			create_component(menu.$$.fragment);
    			set_attributes(input, input_data);
    			add_location(input, file$w, 19, 4, 794);
    			attr_dev(div, "id", div_id_value = /*inputId*/ ctx[13] + '-smui-selected-text');
    			attr_dev(div, "class", "mdc-select__selected-text");
    			attr_dev(div, "role", "button");
    			attr_dev(div, "aria-haspopup", "listbox");
    			attr_dev(div, "aria-labelledby", div_aria_labelledby_value = "" + (/*inputId*/ ctx[13] + '-smui-label' + " " + (/*inputId*/ ctx[13] + '-smui-selected-text')));
    			attr_dev(div, "aria-required", div_aria_required_value = /*required*/ ctx[12] ? 'true' : 'false');
    			add_location(div, file$w, 31, 4, 1061);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			/*input_binding*/ ctx[34](input);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    			insert_dev(target, t2, anchor);
    			mount_component(menu, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[14])),
    					listen_dev(input, "change", /*change_handler*/ ctx[30], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[31], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				{ type: "hidden" },
    				(!current || dirty[0] & /*disabled*/ 32) && { disabled: /*disabled*/ ctx[5] },
    				(!current || dirty[0] & /*required*/ 4096) && { required: /*required*/ ctx[12] },
    				(!current || dirty[0] & /*inputId*/ 8192) && { id: /*inputId*/ ctx[13] },
    				(!current || dirty[0] & /*value*/ 1) && { value: /*value*/ ctx[0] },
    				dirty[0] & /*$$props*/ 4194304 && exclude(prefixFilter(/*$$props*/ ctx[22], 'input$'), ['use'])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 16384) useActions_action.update.call(null, /*input$use*/ ctx[14]);
    			if (!current || dirty[0] & /*selectedText*/ 2048) set_data_dev(t1, /*selectedText*/ ctx[11]);

    			if (!current || dirty[0] & /*inputId*/ 8192 && div_id_value !== (div_id_value = /*inputId*/ ctx[13] + '-smui-selected-text')) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (!current || dirty[0] & /*inputId*/ 8192 && div_aria_labelledby_value !== (div_aria_labelledby_value = "" + (/*inputId*/ ctx[13] + '-smui-label' + " " + (/*inputId*/ ctx[13] + '-smui-selected-text')))) {
    				attr_dev(div, "aria-labelledby", div_aria_labelledby_value);
    			}

    			if (!current || dirty[0] & /*required*/ 4096 && div_aria_required_value !== (div_aria_required_value = /*required*/ ctx[12] ? 'true' : 'false')) {
    				attr_dev(div, "aria-required", div_aria_required_value);
    			}

    			const menu_changes = (dirty[0] & /*menu$class, $$props*/ 4325376)
    			? get_spread_update(menu_spread_levels, [
    					dirty[0] & /*menu$class*/ 131072 && {
    						class: "mdc-select__menu " + /*menu$class*/ ctx[17]
    					},
    					menu_spread_levels[1],
    					menu_spread_levels[2],
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], 'menu$'), ['class']))
    				])
    			: {};

    			if (dirty[0] & /*$$props*/ 4194304 | dirty[1] & /*$$scope*/ 128) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_anchorElement && dirty[0] & /*element*/ 262144) {
    				updating_anchorElement = true;
    				menu_changes.anchorElement = /*element*/ ctx[18];
    				add_flush_callback(() => updating_anchorElement = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[34](null);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			destroy_component(menu, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(19:2) {#if enhanced}",
    		ctx
    	});

    	return block;
    }

    // (47:6) <List {...prefixFilter($$props, 'list$')}>
    function create_default_slot_4(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[29].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[38], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[38],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[38])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[38], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(47:6) <List {...prefixFilter($$props, 'list$')}>",
    		ctx
    	});

    	return block;
    }

    // (40:4) <Menu       class="mdc-select__menu {menu$class}"       role="listbox"       anchor={false}       bind:anchorElement={element}       {...exclude(prefixFilter($$props, 'menu$'), ['class'])}     >
    function create_default_slot_3(ctx) {
    	let list;
    	let current;
    	const list_spread_levels = [prefixFilter(/*$$props*/ ctx[22], 'list$')];

    	let list_props = {
    		$$slots: { default: [create_default_slot_4] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < list_spread_levels.length; i += 1) {
    		list_props = assign(list_props, list_spread_levels[i]);
    	}

    	list = new List({ props: list_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const list_changes = (dirty[0] & /*$$props*/ 4194304)
    			? get_spread_update(list_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'list$'))])
    			: {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(40:4) <Menu       class=\\\"mdc-select__menu {menu$class}\\\"       role=\\\"listbox\\\"       anchor={false}       bind:anchorElement={element}       {...exclude(prefixFilter($$props, 'menu$'), ['class'])}     >",
    		ctx
    	});

    	return block;
    }

    // (62:2) {#if variant !== 'outlined'}
    function create_if_block_2$3(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = !/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null && create_if_block_4$1(ctx);
    	let if_block1 = /*ripple*/ ctx[4] && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label*/ 1536) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*ripple*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*ripple*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(62:2) {#if variant !== 'outlined'}",
    		ctx
    	});

    	return block;
    }

    // (63:4) {#if !noLabel && label != null}
    function create_if_block_4$1(ctx) {
    	let floatinglabel;
    	let current;

    	const floatinglabel_spread_levels = [
    		{ for: /*inputId*/ ctx[13] },
    		{ id: /*inputId*/ ctx[13] + '-smui-label' },
    		{
    			class: "" + ((/*value*/ ctx[0] !== ''
    			? 'mdc-floating-label--float-above'
    			: '') + " " + /*label$class*/ ctx[16])
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[22], 'label$'), ['class'])
    	];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_2$2] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*inputId, value, label$class, $$props*/ 4268033)
    			? get_spread_update(floatinglabel_spread_levels, [
    					dirty[0] & /*inputId*/ 8192 && { for: /*inputId*/ ctx[13] },
    					dirty[0] & /*inputId*/ 8192 && { id: /*inputId*/ ctx[13] + '-smui-label' },
    					dirty[0] & /*value, label$class*/ 65537 && {
    						class: "" + ((/*value*/ ctx[0] !== ''
    						? 'mdc-floating-label--float-above'
    						: '') + " " + /*label$class*/ ctx[16])
    					},
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], 'label$'), ['class']))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 1024 | dirty[1] & /*$$scope*/ 128) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(63:4) {#if !noLabel && label != null}",
    		ctx
    	});

    	return block;
    }

    // (64:6) <FloatingLabel         for={inputId}         id={inputId+'-smui-label'}         class="{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}"         {...exclude(prefixFilter($$props, 'label$'), ['class'])}       >
    function create_default_slot_2$2(ctx) {
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[29].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[38], get_label_slot_context);

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[10]);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*label*/ 1024) set_data_dev(t, /*label*/ ctx[10]);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[1] & /*$$scope*/ 128)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[38],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[38])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[38], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(64:6) <FloatingLabel         for={inputId}         id={inputId+'-smui-label'}         class=\\\"{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}\\\"         {...exclude(prefixFilter($$props, 'label$'), ['class'])}       >",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if ripple}
    function create_if_block_3$1(ctx) {
    	let lineripple;
    	let current;
    	const lineripple_spread_levels = [prefixFilter(/*$$props*/ ctx[22], 'ripple$')];
    	let lineripple_props = {};

    	for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    		lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
    	}

    	lineripple = new LineRipple({ props: lineripple_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(lineripple.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lineripple, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lineripple_changes = (dirty[0] & /*$$props*/ 4194304)
    			? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'ripple$'))])
    			: {};

    			lineripple.$set(lineripple_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lineripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lineripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lineripple, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(71:4) {#if ripple}",
    		ctx
    	});

    	return block;
    }

    // (75:2) {#if variant === 'outlined'}
    function create_if_block$l(ctx) {
    	let notchedoutline;
    	let current;

    	const notchedoutline_spread_levels = [
    		{
    			noLabel: /*noLabel*/ ctx[9] || /*label*/ ctx[10] == null
    		},
    		prefixFilter(/*$$props*/ ctx[22], 'outline$')
    	];

    	let notchedoutline_props = {
    		$$slots: { default: [create_default_slot$b] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    		notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
    	}

    	notchedoutline = new NotchedOutline({
    			props: notchedoutline_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(notchedoutline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notchedoutline, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notchedoutline_changes = (dirty[0] & /*noLabel, label, $$props*/ 4195840)
    			? get_spread_update(notchedoutline_spread_levels, [
    					dirty[0] & /*noLabel, label*/ 1536 && {
    						noLabel: /*noLabel*/ ctx[9] || /*label*/ ctx[10] == null
    					},
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], 'outline$'))
    				])
    			: {};

    			if (dirty[0] & /*inputId, value, label$class, $$props, label, noLabel*/ 4269569 | dirty[1] & /*$$scope*/ 128) {
    				notchedoutline_changes.$$scope = { dirty, ctx };
    			}

    			notchedoutline.$set(notchedoutline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notchedoutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notchedoutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notchedoutline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(75:2) {#if variant === 'outlined'}",
    		ctx
    	});

    	return block;
    }

    // (77:6) {#if !noLabel && label != null}
    function create_if_block_1$8(ctx) {
    	let floatinglabel;
    	let current;

    	const floatinglabel_spread_levels = [
    		{ for: /*inputId*/ ctx[13] },
    		{
    			class: "" + ((/*value*/ ctx[0] !== ''
    			? 'mdc-floating-label--float-above'
    			: '') + " " + /*label$class*/ ctx[16])
    		},
    		exclude(prefixFilter(/*$$props*/ ctx[22], 'label$'), ['class'])
    	];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_1$5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*inputId, value, label$class, $$props*/ 4268033)
    			? get_spread_update(floatinglabel_spread_levels, [
    					dirty[0] & /*inputId*/ 8192 && { for: /*inputId*/ ctx[13] },
    					dirty[0] & /*value, label$class*/ 65537 && {
    						class: "" + ((/*value*/ ctx[0] !== ''
    						? 'mdc-floating-label--float-above'
    						: '') + " " + /*label$class*/ ctx[16])
    					},
    					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], 'label$'), ['class']))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 1024 | dirty[1] & /*$$scope*/ 128) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(77:6) {#if !noLabel && label != null}",
    		ctx
    	});

    	return block;
    }

    // (78:8) <FloatingLabel           for={inputId}           class="{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}"           {...exclude(prefixFilter($$props, 'label$'), ['class'])}         >
    function create_default_slot_1$5(ctx) {
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[29].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[38], get_label_slot_context_1);

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[10]);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*label*/ 1024) set_data_dev(t, /*label*/ ctx[10]);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[1] & /*$$scope*/ 128)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[38],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[38])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[38], dirty, get_label_slot_changes_1),
    						get_label_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(78:8) <FloatingLabel           for={inputId}           class=\\\"{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}\\\"           {...exclude(prefixFilter($$props, 'label$'), ['class'])}         >",
    		ctx
    	});

    	return block;
    }

    // (76:4) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>
    function create_default_slot$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label*/ 1536) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(76:4) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div;
    	let t0;
    	let i;
    	let t1;
    	let current_block_type_index;
    	let if_block0;
    	let t2;
    	let t3;
    	let div_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const icon_slot_template = /*#slots*/ ctx[29].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[38], get_icon_slot_context);
    	const if_block_creators = [create_if_block_5$1, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*enhanced*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*variant*/ ctx[7] !== 'outlined' && create_if_block_2$3(ctx);
    	let if_block2 = /*variant*/ ctx[7] === 'outlined' && create_if_block$l(ctx);

    	let div_levels = [
    		{
    			class: div_class_value = "\n    mdc-select\n    " + /*className*/ ctx[3] + "\n    " + (/*disabled*/ ctx[5] ? 'mdc-select--disabled' : '') + "\n    " + (/*variant*/ ctx[7] === 'outlined'
    			? 'mdc-select--outlined'
    			: '') + "\n    " + (/*variant*/ ctx[7] === 'standard'
    			? 'smui-select--standard'
    			: '') + "\n    " + (/*withLeadingIcon*/ ctx[8]
    			? 'mdc-select--with-leading-icon'
    			: '') + "\n    " + (/*invalid*/ ctx[1] ? 'mdc-select--invalid' : '') + "\n  "
    		},
    		exclude(/*$$props*/ ctx[22], [
    			'use',
    			'class',
    			'ripple',
    			'disabled',
    			'enhanced',
    			'variant',
    			'noLabel',
    			'withLeadingIcon',
    			'label',
    			'value',
    			'selectedIndex',
    			'selectedText',
    			'dirty',
    			'invalid',
    			'updateInvalid',
    			'required',
    			'input$',
    			'label$',
    			'ripple$',
    			'outline$',
    			'menu$',
    			'list$'
    		])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (icon_slot) icon_slot.c();
    			t0 = space();
    			i = element("i");
    			t1 = space();
    			if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(i, "class", "mdc-select__dropdown-icon");
    			add_location(i, file$w, 17, 2, 731);
    			set_attributes(div, div_data);
    			add_location(div, file$w, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (icon_slot) {
    				icon_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			append_dev(div, i);
    			append_dev(div, t1);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t2);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			/*div_binding*/ ctx[37](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[20].call(null, div)),
    					listen_dev(div, "MDCSelect:change", /*changeHandler*/ ctx[21], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (icon_slot) {
    				if (icon_slot.p && (!current || dirty[1] & /*$$scope*/ 128)) {
    					update_slot_base(
    						icon_slot,
    						icon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[38],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[38])
    						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[38], dirty, get_icon_slot_changes),
    						get_icon_slot_context
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div, t2);
    			}

    			if (/*variant*/ ctx[7] !== 'outlined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*variant*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*variant*/ ctx[7] === 'outlined') {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*variant*/ 128) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$l(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*className, disabled, variant, withLeadingIcon, invalid*/ 426 && div_class_value !== (div_class_value = "\n    mdc-select\n    " + /*className*/ ctx[3] + "\n    " + (/*disabled*/ ctx[5] ? 'mdc-select--disabled' : '') + "\n    " + (/*variant*/ ctx[7] === 'outlined'
    				? 'mdc-select--outlined'
    				: '') + "\n    " + (/*variant*/ ctx[7] === 'standard'
    				? 'smui-select--standard'
    				: '') + "\n    " + (/*withLeadingIcon*/ ctx[8]
    				? 'mdc-select--with-leading-icon'
    				: '') + "\n    " + (/*invalid*/ ctx[1] ? 'mdc-select--invalid' : '') + "\n  ")) && { class: div_class_value },
    				dirty[0] & /*$$props*/ 4194304 && exclude(/*$$props*/ ctx[22], [
    					'use',
    					'class',
    					'ripple',
    					'disabled',
    					'enhanced',
    					'variant',
    					'noLabel',
    					'withLeadingIcon',
    					'label',
    					'value',
    					'selectedIndex',
    					'selectedText',
    					'dirty',
    					'invalid',
    					'updateInvalid',
    					'required',
    					'input$',
    					'label$',
    					'ripple$',
    					'outline$',
    					'menu$',
    					'list$'
    				])
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (icon_slot) icon_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*div_binding*/ ctx[37](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let counter = 0;

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, ['icon','default','label']);
    	const forwardEvents = forwardEventsBuilder(get_current_component(), 'MDCSelect:change');

    	const uninitializedValue = () => {
    		
    	};

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { disabled = false } = $$props;
    	let { enhanced = false } = $$props;
    	let { variant = 'standard' } = $$props;
    	let { withLeadingIcon = false } = $$props;
    	let { noLabel = false } = $$props;
    	let { label = null } = $$props;
    	let { value = '' } = $$props;
    	let { selectedIndex = uninitializedValue } = $$props;
    	let { selectedText = '' } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = uninitializedValue } = $$props;
    	let { updateInvalid = invalid === uninitializedValue } = $$props;
    	let { required = false } = $$props;
    	let { inputId = 'SMUI-select-' + counter++ } = $$props;
    	let { input$use = [] } = $$props;
    	let { input$class = '' } = $$props;
    	let { label$class = '' } = $$props;
    	let { menu$class = '' } = $$props;
    	let element;
    	let select;
    	let inputElement;
    	let menuPromiseResolve;
    	let menuPromise = new Promise(resolve => menuPromiseResolve = resolve);
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;
    	setContext('SMUI:menu:instantiate', false);
    	setContext('SMUI:menu:getInstance', getMenuInstancePromise);
    	setContext('SMUI:list:role', 'listbox');
    	setContext('SMUI:select:option:enhanced', enhanced);

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(async () => {
    		$$invalidate(28, select = new MDCSelect(element));
    		menuPromiseResolve(select.menu_);

    		if (!ripple && select.ripple) {
    			select.ripple.destroy();
    		}

    		if (updateInvalid) {
    			$$invalidate(1, invalid = inputElement.matches(':invalid'));
    		}
    	});

    	onDestroy(() => {
    		select && select.destroy();

    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function getMenuInstancePromise() {
    		return menuPromise;
    	}

    	function changeHandler(e) {
    		$$invalidate(0, value = e.detail.value);
    		$$invalidate(23, selectedIndex = e.detail.index);
    		$$invalidate(24, dirty = true);

    		if (updateInvalid) {
    			$$invalidate(1, invalid = inputElement.matches(':invalid'));
    		}
    	}

    	function focus(...args) {
    		return inputElement.focus(...args);
    	}

    	function layout(...args) {
    		return select.layout(...args);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputElement = $$value;
    			$$invalidate(19, inputElement);
    		});
    	}

    	function menu_anchorElement_binding(value) {
    		element = value;
    		$$invalidate(18, element);
    	}

    	function select_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputElement = $$value;
    			$$invalidate(19, inputElement);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(18, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('ripple' in $$new_props) $$invalidate(4, ripple = $$new_props.ripple);
    		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('enhanced' in $$new_props) $$invalidate(6, enhanced = $$new_props.enhanced);
    		if ('variant' in $$new_props) $$invalidate(7, variant = $$new_props.variant);
    		if ('withLeadingIcon' in $$new_props) $$invalidate(8, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('noLabel' in $$new_props) $$invalidate(9, noLabel = $$new_props.noLabel);
    		if ('label' in $$new_props) $$invalidate(10, label = $$new_props.label);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('selectedIndex' in $$new_props) $$invalidate(23, selectedIndex = $$new_props.selectedIndex);
    		if ('selectedText' in $$new_props) $$invalidate(11, selectedText = $$new_props.selectedText);
    		if ('dirty' in $$new_props) $$invalidate(24, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(1, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(25, updateInvalid = $$new_props.updateInvalid);
    		if ('required' in $$new_props) $$invalidate(12, required = $$new_props.required);
    		if ('inputId' in $$new_props) $$invalidate(13, inputId = $$new_props.inputId);
    		if ('input$use' in $$new_props) $$invalidate(14, input$use = $$new_props.input$use);
    		if ('input$class' in $$new_props) $$invalidate(15, input$class = $$new_props.input$class);
    		if ('label$class' in $$new_props) $$invalidate(16, label$class = $$new_props.label$class);
    		if ('menu$class' in $$new_props) $$invalidate(17, menu$class = $$new_props.menu$class);
    		if ('$$scope' in $$new_props) $$invalidate(38, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		counter,
    		MDCSelect,
    		onMount,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		prefixFilter,
    		useActions,
    		Menu,
    		List,
    		FloatingLabel,
    		LineRipple,
    		NotchedOutline,
    		forwardEvents,
    		uninitializedValue,
    		use,
    		className,
    		ripple,
    		disabled,
    		enhanced,
    		variant,
    		withLeadingIcon,
    		noLabel,
    		label,
    		value,
    		selectedIndex,
    		selectedText,
    		dirty,
    		invalid,
    		updateInvalid,
    		required,
    		inputId,
    		input$use,
    		input$class,
    		label$class,
    		menu$class,
    		element,
    		select,
    		inputElement,
    		menuPromiseResolve,
    		menuPromise,
    		addLayoutListener,
    		removeLayoutListener,
    		getMenuInstancePromise,
    		changeHandler,
    		focus,
    		layout
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('ripple' in $$props) $$invalidate(4, ripple = $$new_props.ripple);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('enhanced' in $$props) $$invalidate(6, enhanced = $$new_props.enhanced);
    		if ('variant' in $$props) $$invalidate(7, variant = $$new_props.variant);
    		if ('withLeadingIcon' in $$props) $$invalidate(8, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('noLabel' in $$props) $$invalidate(9, noLabel = $$new_props.noLabel);
    		if ('label' in $$props) $$invalidate(10, label = $$new_props.label);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('selectedIndex' in $$props) $$invalidate(23, selectedIndex = $$new_props.selectedIndex);
    		if ('selectedText' in $$props) $$invalidate(11, selectedText = $$new_props.selectedText);
    		if ('dirty' in $$props) $$invalidate(24, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(1, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(25, updateInvalid = $$new_props.updateInvalid);
    		if ('required' in $$props) $$invalidate(12, required = $$new_props.required);
    		if ('inputId' in $$props) $$invalidate(13, inputId = $$new_props.inputId);
    		if ('input$use' in $$props) $$invalidate(14, input$use = $$new_props.input$use);
    		if ('input$class' in $$props) $$invalidate(15, input$class = $$new_props.input$class);
    		if ('label$class' in $$props) $$invalidate(16, label$class = $$new_props.label$class);
    		if ('menu$class' in $$props) $$invalidate(17, menu$class = $$new_props.menu$class);
    		if ('element' in $$props) $$invalidate(18, element = $$new_props.element);
    		if ('select' in $$props) $$invalidate(28, select = $$new_props.select);
    		if ('inputElement' in $$props) $$invalidate(19, inputElement = $$new_props.inputElement);
    		if ('menuPromiseResolve' in $$props) menuPromiseResolve = $$new_props.menuPromiseResolve;
    		if ('menuPromise' in $$props) menuPromise = $$new_props.menuPromise;
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*select, value*/ 268435457) {
    			if (select && select.value !== value) {
    				$$invalidate(28, select.value = value, select);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*select, selectedIndex*/ 276824064) {
    			if (select && select.selectedIndex !== selectedIndex) {
    				if (selectedIndex === uninitializedValue) {
    					$$invalidate(23, selectedIndex = select.selectedIndex);
    				} else {
    					$$invalidate(28, select.selectedIndex = selectedIndex, select);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*select, disabled*/ 268435488) {
    			if (select && select.disabled !== disabled) {
    				$$invalidate(28, select.disabled = disabled, select);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*select, invalid, updateInvalid*/ 301989890) {
    			if (select && select.valid !== !invalid) {
    				if (updateInvalid) {
    					$$invalidate(1, invalid = !select.valid);
    				} else {
    					$$invalidate(28, select.valid = !invalid, select);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*select, required*/ 268439552) {
    			if (select && select.required !== required) {
    				$$invalidate(28, select.required = required, select);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		value,
    		invalid,
    		use,
    		className,
    		ripple,
    		disabled,
    		enhanced,
    		variant,
    		withLeadingIcon,
    		noLabel,
    		label,
    		selectedText,
    		required,
    		inputId,
    		input$use,
    		input$class,
    		label$class,
    		menu$class,
    		element,
    		inputElement,
    		forwardEvents,
    		changeHandler,
    		$$props,
    		selectedIndex,
    		dirty,
    		updateInvalid,
    		focus,
    		layout,
    		select,
    		slots,
    		change_handler,
    		input_handler,
    		change_handler_1,
    		input_handler_1,
    		input_binding,
    		menu_anchorElement_binding,
    		select_1_binding,
    		div_binding,
    		$$scope
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$y,
    			create_fragment$y,
    			safe_not_equal,
    			{
    				use: 2,
    				class: 3,
    				ripple: 4,
    				disabled: 5,
    				enhanced: 6,
    				variant: 7,
    				withLeadingIcon: 8,
    				noLabel: 9,
    				label: 10,
    				value: 0,
    				selectedIndex: 23,
    				selectedText: 11,
    				dirty: 24,
    				invalid: 1,
    				updateInvalid: 25,
    				required: 12,
    				inputId: 13,
    				input$use: 14,
    				input$class: 15,
    				label$class: 16,
    				menu$class: 17,
    				focus: 26,
    				layout: 27
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get use() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get enhanced() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set enhanced(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withLeadingIcon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withLeadingIcon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$use() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$use(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input$class() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input$class(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label$class() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label$class(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get menu$class() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menu$class(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[26];
    	}

    	set focus(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[27];
    	}

    	set layout(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@smui\select\Option.svelte generated by Svelte v3.42.1 */
    const file$v = "node_modules\\@smui\\select\\Option.svelte";

    // (8:0) {:else}
    function create_else_block$3(ctx) {
    	let option;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let option_levels = [{ __value: /*value*/ ctx[1] }, /*selectedProp*/ ctx[3], /*props*/ ctx[4]];
    	let option_data = {};

    	for (let i = 0; i < option_levels.length; i += 1) {
    		option_data = assign(option_data, option_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			option = element("option");
    			if (default_slot) default_slot.c();
    			set_attributes(option, option_data);
    			add_location(option, file$v, 8, 2, 144);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);

    			if (default_slot) {
    				default_slot.m(option, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, option, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[5].call(null, option))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(option, option_data = get_spread_update(option_levels, [
    				(!current || dirty & /*value*/ 2) && { __value: /*value*/ ctx[1] },
    				dirty & /*selectedProp*/ 8 && /*selectedProp*/ ctx[3],
    				dirty & /*props*/ 16 && /*props*/ ctx[4]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(8:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if enhanced}
    function create_if_block$k(ctx) {
    	let item;
    	let current;

    	const item_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
    		},
    		{ "data-value": /*value*/ ctx[1] },
    		{ selected: /*selected*/ ctx[2] },
    		/*props*/ ctx[4]
    	];

    	let item_props = {
    		$$slots: { default: [create_default_slot$a] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < item_spread_levels.length; i += 1) {
    		item_props = assign(item_props, item_spread_levels[i]);
    	}

    	item = new Item$1({ props: item_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(item.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(item, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const item_changes = (dirty & /*forwardEvents, use, value, selected, props*/ 55)
    			? get_spread_update(item_spread_levels, [
    					dirty & /*forwardEvents, use*/ 33 && {
    						use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
    					},
    					dirty & /*value*/ 2 && { "data-value": /*value*/ ctx[1] },
    					dirty & /*selected*/ 4 && { selected: /*selected*/ ctx[2] },
    					dirty & /*props*/ 16 && get_spread_object(/*props*/ ctx[4])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 512) {
    				item_changes.$$scope = { dirty, ctx };
    			}

    			item.$set(item_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(item, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(1:0) {#if enhanced}",
    		ctx
    	});

    	return block;
    }

    // (2:2) <Item     use={[forwardEvents, ...use]}     data-value={value}     {selected}     {...props}   >
    function create_default_slot$a(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(2:2) <Item     use={[forwardEvents, ...use]}     data-value={value}     {selected}     {...props}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*enhanced*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let props;
    	let selectedProp;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Option', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	const className = '';
    	let { value = '' } = $$props;
    	let { selected = false } = $$props;
    	let element;
    	let enhanced = getContext('SMUI:select:option:enhanced');
    	setContext('SMUI:list:item:role', 'option');

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
    		if ('selected' in $$new_props) $$invalidate(2, selected = $$new_props.selected);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		exclude,
    		useActions,
    		Item: Item$1,
    		forwardEvents,
    		use,
    		className,
    		value,
    		selected,
    		element,
    		enhanced,
    		selectedProp,
    		props
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
    		if ('selected' in $$props) $$invalidate(2, selected = $$new_props.selected);
    		if ('element' in $$props) element = $$new_props.element;
    		if ('enhanced' in $$props) $$invalidate(6, enhanced = $$new_props.enhanced);
    		if ('selectedProp' in $$props) $$invalidate(3, selectedProp = $$new_props.selectedProp);
    		if ('props' in $$props) $$invalidate(4, props = $$new_props.props);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(4, props = exclude($$props, ['use', 'value', 'selected']));

    		if ($$self.$$.dirty & /*selected*/ 4) {
    			$$invalidate(3, selectedProp = !enhanced && selected ? { selected: true } : {});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		use,
    		value,
    		selected,
    		selectedProp,
    		props,
    		forwardEvents,
    		enhanced,
    		className,
    		slots,
    		$$scope
    	];
    }

    class Option extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$x, create_fragment$x, safe_not_equal, { use: 0, class: 7, value: 1, selected: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Option",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get use() {
    		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		return this.$$.ctx[7];
    	}

    	set class(value) {
    		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomSelect.svelte generated by Svelte v3.42.1 */

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (10:8) <Option value={option} selected={picked === option}>
    function create_default_slot_1$4(ctx) {
    	let t_value = /*option*/ ctx[6] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[6] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(10:8) <Option value={option} selected={picked === option}>",
    		ctx
    	});

    	return block;
    }

    // (9:4) {#each options as option}
    function create_each_block$a(ctx) {
    	let option;
    	let current;

    	option = new Option({
    			props: {
    				value: /*option*/ ctx[6],
    				selected: /*picked*/ ctx[0] === /*option*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(option.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(option, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const option_changes = {};
    			if (dirty & /*options*/ 2) option_changes.value = /*option*/ ctx[6];
    			if (dirty & /*picked, options*/ 3) option_changes.selected = /*picked*/ ctx[0] === /*option*/ ctx[6];

    			if (dirty & /*$$scope, options*/ 514) {
    				option_changes.$$scope = { dirty, ctx };
    			}

    			option.$set(option_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(option.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(option.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(option, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(9:4) {#each options as option}",
    		ctx
    	});

    	return block;
    }

    // (7:0) <Select bind:value={picked} {label} {style} on:change>
    function create_default_slot$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options, picked*/ 3) {
    				each_value = /*options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(7:0) <Select bind:value={picked} {label} {style} on:change>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let select;
    	let updating_value;
    	let current;

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[4](value);
    	}

    	let select_props = {
    		label: /*label*/ ctx[3],
    		style: /*style*/ ctx[2],
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	if (/*picked*/ ctx[0] !== void 0) {
    		select_props.value = /*picked*/ ctx[0];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind(select, 'value', select_value_binding));
    	select.$on("change", /*change_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(select.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(select, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const select_changes = {};
    			if (dirty & /*label*/ 8) select_changes.label = /*label*/ ctx[3];
    			if (dirty & /*style*/ 4) select_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, options, picked*/ 515) {
    				select_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*picked*/ 1) {
    				updating_value = true;
    				select_changes.value = /*picked*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(select, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomSelect', slots, []);
    	let { options = [], style = "", label = "", picked = "" } = $$props;
    	const writable_props = ['options', 'style', 'label', 'picked'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomSelect> was created with unknown prop '${key}'`);
    	});

    	function select_value_binding(value) {
    		picked = value;
    		$$invalidate(0, picked);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('picked' in $$props) $$invalidate(0, picked = $$props.picked);
    	};

    	$$self.$capture_state = () => ({
    		Select,
    		Option,
    		options,
    		style,
    		label,
    		picked
    	});

    	$$self.$inject_state = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('picked' in $$props) $$invalidate(0, picked = $$props.picked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [picked, options, style, label, select_value_binding, change_handler];
    }

    class CustomSelect$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			options: 1,
    			style: 2,
    			label: 3,
    			picked: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomSelect",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get options() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get picked() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set picked(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\QuickView.svelte generated by Svelte v3.42.1 */
    const file$u = "src\\components\\QuickView.svelte";
    const get_footer_slot_changes$1 = dirty => ({});
    const get_footer_slot_context$1 = ctx => ({});

    // (37:13) Contents
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Contents");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(37:13) Contents",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if footer}
    function create_if_block$j(ctx) {
    	let footer_1;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context$1);

    	const block = {
    		c: function create() {
    			footer_1 = element("footer");
    			if (footer_slot) footer_slot.c();
    			attr_dev(footer_1, "class", "quickview-footer svelte-1g2nmfc");
    			add_location(footer_1, file$u, 41, 4, 1131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer_1, anchor);

    			if (footer_slot) {
    				footer_slot.m(footer_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes$1),
    						get_footer_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer_1);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(41:2) {#if footer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div3;
    	let header;
    	let button;
    	let t1;
    	let div0;
    	let t2;
    	let t3;
    	let span;
    	let t4;
    	let div2;
    	let div1;
    	let t5;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
    	let if_block = /*footer*/ ctx[2] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			header = element("header");
    			button = element("button");
    			button.textContent = "Browse";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(/*title*/ ctx[3]);
    			t3 = space();
    			span = element("span");
    			t4 = space();
    			div2 = element("div");
    			div1 = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t5 = space();
    			if (if_block) if_block.c();
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$u, 28, 4, 728);
    			attr_dev(div0, "class", "subtitle");
    			set_style(div0, "margin", "0");
    			add_location(div0, file$u, 29, 4, 805);
    			attr_dev(span, "class", "delete is-pulled-right svelte-1g2nmfc");
    			attr_dev(span, "data-dismiss", "quickview");
    			add_location(span, file$u, 30, 4, 864);
    			attr_dev(header, "class", "quickview-header");
    			add_location(header, file$u, 26, 2, 687);
    			attr_dev(div1, "class", "quickview-block");
    			add_location(div1, file$u, 35, 4, 1026);
    			attr_dev(div2, "class", "quickview-body");
    			attr_dev(div2, "style", /*style*/ ctx[1]);
    			add_location(div2, file$u, 34, 2, 984);
    			attr_dev(div3, "class", "quickview svelte-1g2nmfc");
    			toggle_class(div3, "is-active", /*active*/ ctx[0]);
    			add_location(div3, file$u, 24, 0, 617);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, header);
    			append_dev(header, button);
    			append_dev(header, t1);
    			append_dev(header, div0);
    			append_dev(div0, t2);
    			append_dev(header, t3);
    			append_dev(header, span);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div1, null);
    			}

    			append_dev(div3, t5);
    			if (if_block) if_block.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*browse_folder*/ ctx[4], false, false, false),
    					listen_dev(span, "click", /*click_handler*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 8) set_data_dev(t2, /*title*/ ctx[3]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div2, "style", /*style*/ ctx[1]);
    			}

    			if (/*footer*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*footer*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div3, "is-active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			transition_out(if_block);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (if_block) if_block.d();
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('QuickView', slots, ['default','footer']);
    	let { active = false, style = "", footer = true, currentLocation = "", title = "" } = $$props;

    	function browse_folder() {
    		browse({ dir: true }).then(result => {
    			if (result) {
    				$$invalidate(5, currentLocation = result[0]);
    				window.createToast("Location updated");
    			}
    		});
    	}

    	const writable_props = ['active', 'style', 'footer', 'currentLocation', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<QuickView> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, active = false);

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('footer' in $$props) $$invalidate(2, footer = $$props.footer);
    		if ('currentLocation' in $$props) $$invalidate(5, currentLocation = $$props.currentLocation);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		browse,
    		fade,
    		active,
    		style,
    		footer,
    		currentLocation,
    		title,
    		browse_folder
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('footer' in $$props) $$invalidate(2, footer = $$props.footer);
    		if ('currentLocation' in $$props) $$invalidate(5, currentLocation = $$props.currentLocation);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		style,
    		footer,
    		title,
    		browse_folder,
    		currentLocation,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class QuickView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			active: 0,
    			style: 1,
    			footer: 2,
    			currentLocation: 5,
    			title: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QuickView",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get active() {
    		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentLocation() {
    		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\QuickBrowser.svelte generated by Svelte v3.42.1 */
    const file$t = "src\\components\\QuickBrowser.svelte";

    // (14:0) <QuickView style="padding:1em;" bind:active bind:currentLocation {title}>
    function create_default_slot$8(ctx) {
    	let filebrowser;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let current;

    	function filebrowser_currentLocation_binding(value) {
    		/*filebrowser_currentLocation_binding*/ ctx[8](value);
    	}

    	function filebrowser_fileChecked_binding(value) {
    		/*filebrowser_fileChecked_binding*/ ctx[9](value);
    	}

    	let filebrowser_props = { filetype: /*filetype*/ ctx[3] };

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		filebrowser_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	if (/*fileChecked*/ ctx[2] !== void 0) {
    		filebrowser_props.fileChecked = /*fileChecked*/ ctx[2];
    	}

    	filebrowser = new FileBrowser({ props: filebrowser_props, $$inline: true });
    	binding_callbacks.push(() => bind(filebrowser, 'currentLocation', filebrowser_currentLocation_binding));
    	binding_callbacks.push(() => bind(filebrowser, 'fileChecked', filebrowser_fileChecked_binding));
    	filebrowser.$on("markedFile", /*markedFile_handler*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(filebrowser.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filebrowser, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filebrowser_changes = {};
    			if (dirty & /*filetype*/ 8) filebrowser_changes.filetype = /*filetype*/ ctx[3];

    			if (!updating_currentLocation && dirty & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				filebrowser_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty & /*fileChecked*/ 4) {
    				updating_fileChecked = true;
    				filebrowser_changes.fileChecked = /*fileChecked*/ ctx[2];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			filebrowser.$set(filebrowser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filebrowser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filebrowser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filebrowser, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(14:0) <QuickView style=\\\"padding:1em;\\\" bind:active bind:currentLocation {title}>",
    		ctx
    	});

    	return block;
    }

    // (16:4) 
    function create_footer_slot$1(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Submit";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$t, 17, 8, 601);
    			attr_dev(div, "slot", "footer");
    			set_style(div, "margin", "auto");
    			add_location(div, file$t, 15, 4, 550);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot$1.name,
    		type: "slot",
    		source: "(16:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let quickview;
    	let updating_active;
    	let updating_currentLocation;
    	let current;
    	let mounted;
    	let dispose;

    	function quickview_active_binding(value) {
    		/*quickview_active_binding*/ ctx[11](value);
    	}

    	function quickview_currentLocation_binding(value) {
    		/*quickview_currentLocation_binding*/ ctx[12](value);
    	}

    	let quickview_props = {
    		style: "padding:1em;",
    		title: /*title*/ ctx[4],
    		$$slots: {
    			footer: [create_footer_slot$1],
    			default: [create_default_slot$8]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		quickview_props.active = /*active*/ ctx[0];
    	}

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		quickview_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	quickview = new QuickView({ props: quickview_props, $$inline: true });
    	binding_callbacks.push(() => bind(quickview, 'active', quickview_active_binding));
    	binding_callbacks.push(() => bind(quickview, 'currentLocation', quickview_currentLocation_binding));

    	const block = {
    		c: function create() {
    			create_component(quickview.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(quickview, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*keydown_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const quickview_changes = {};
    			if (dirty & /*title*/ 16) quickview_changes.title = /*title*/ ctx[4];

    			if (dirty & /*$$scope, filetype, currentLocation, fileChecked*/ 8206) {
    				quickview_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				quickview_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_currentLocation && dirty & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				quickview_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			quickview.$set(quickview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quickview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quickview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(quickview, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('QuickBrowser', slots, []);
    	let { active = false, currentLocation, fileChecked, filetype = "", title = "" } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ['active', 'currentLocation', 'fileChecked', 'filetype', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<QuickBrowser> was created with unknown prop '${key}'`);
    	});

    	const keydown_handler = e => {
    		if (e.keyCode === 27) $$invalidate(0, active = false);
    	};

    	const click_handler = e => {
    		dispatch('submit', { event: e });
    	};

    	function filebrowser_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	function filebrowser_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(2, fileChecked);
    	}

    	function markedFile_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function quickview_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	function quickview_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('fileChecked' in $$props) $$invalidate(2, fileChecked = $$props.fileChecked);
    		if ('filetype' in $$props) $$invalidate(3, filetype = $$props.filetype);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({
    		QuickView,
    		FileBrowser,
    		createEventDispatcher,
    		active,
    		currentLocation,
    		fileChecked,
    		filetype,
    		title,
    		dispatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('fileChecked' in $$props) $$invalidate(2, fileChecked = $$props.fileChecked);
    		if ('filetype' in $$props) $$invalidate(3, filetype = $$props.filetype);
    		if ('title' in $$props) $$invalidate(4, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		currentLocation,
    		fileChecked,
    		filetype,
    		title,
    		dispatch,
    		keydown_handler,
    		click_handler,
    		filebrowser_currentLocation_binding,
    		filebrowser_fileChecked_binding,
    		markedFile_handler,
    		quickview_active_binding,
    		quickview_currentLocation_binding
    	];
    }

    class QuickBrowser extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			active: 0,
    			currentLocation: 1,
    			fileChecked: 2,
    			filetype: 3,
    			title: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QuickBrowser",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentLocation*/ ctx[1] === undefined && !('currentLocation' in props)) {
    			console.warn("<QuickBrowser> was created without expected prop 'currentLocation'");
    		}

    		if (/*fileChecked*/ ctx[2] === undefined && !('fileChecked' in props)) {
    			console.warn("<QuickBrowser> was created without expected prop 'fileChecked'");
    		}
    	}

    	get active() {
    		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentLocation() {
    		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filetype() {
    		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filetype(value) {
    		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    async function opofile_func({ dataFromPython, delta } = {}) {

        try {
            await beforePlot({ delta, dataFromPython, graphDiv: "opoRelPlot", baseGraphDiv:"opoplot" });
            plot("OPO Calibration", "Set Wavenumber (cm-1)", "Measured Wavenumber (cm-1)", dataFromPython["SA"], "opoSA");
            if (!get_store_value(plotlyEventCreatedOPO)) {

                const plot = { graphDiv: "opoRelPlot", mode: "opo" };
                plotlySelection(plot), plotlyClick(plot);
                plotlyEventCreatedOPO.set(true);

            }


        } catch (error) {
            console.error(error);        
        }
    }

    /* src\Pages\normline\widgets\preprocessing\OPORow.svelte generated by Svelte v3.42.1 */

    const { console: console_1$d } = globals;
    const file$s = "src\\Pages\\normline\\widgets\\preprocessing\\OPORow.svelte";

    // (57:0) {#if $opoMode}
    function create_if_block$i(ctx) {
    	let div;
    	let span;
    	let t1;
    	let customselect;
    	let updating_picked;
    	let t2;
    	let textfield0;
    	let updating_value;
    	let t3;
    	let textfield1;
    	let updating_value_1;
    	let t4;
    	let button0;
    	let t6;
    	let button1;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[20](value);
    	}

    	let customselect_props = {
    		style: "width:7em;",
    		label: "Calib. file",
    		options: ["", .../*OPOcalibFiles*/ ctx[3]]
    	};

    	if (/*calibFile*/ ctx[5] !== void 0) {
    		customselect_props.picked = /*calibFile*/ ctx[5];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[21](value);
    	}

    	let textfield0_props = {
    		style: "width:7em; margin:0 0.5em;",
    		input$type: "number",
    		input$step: /*odelta*/ ctx[7],
    		input$min: "0",
    		variant: "outlined",
    		label: "Delta OPO"
    	};

    	if (/*deltaOPO*/ ctx[4] !== void 0) {
    		textfield0_props.value = /*deltaOPO*/ ctx[4];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[22](value);
    	}

    	let textfield1_props = {
    		style: "width:9em",
    		input$type: "number",
    		input$step: "0.1",
    		input$min: "0",
    		variant: "outlined",
    		label: "Power (mJ)"
    	};

    	if (/*opoPower*/ ctx[6] !== void 0) {
    		textfield1_props.value = /*opoPower*/ ctx[6];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "OPO Mode:";
    			t1 = space();
    			create_component(customselect.$$.fragment);
    			t2 = space();
    			create_component(textfield0.$$.fragment);
    			t3 = space();
    			create_component(textfield1.$$.fragment);
    			t4 = space();
    			button0 = element("button");
    			button0.textContent = "Browse File";
    			t6 = space();
    			button1 = element("button");
    			button1.textContent = "Replot";
    			attr_dev(span, "class", "tag is-warning ");
    			add_location(span, file$s, 59, 8, 2303);
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$s, 65, 8, 2815);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$s, 66, 8, 2926);
    			attr_dev(div, "class", "align");
    			add_location(div, file$s, 58, 4, 2258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			mount_component(customselect, div, null);
    			append_dev(div, t2);
    			mount_component(textfield0, div, null);
    			append_dev(div, t3);
    			mount_component(textfield1, div, null);
    			append_dev(div, t4);
    			append_dev(div, button0);
    			append_dev(div, t6);
    			append_dev(div, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[23], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[24], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const customselect_changes = {};
    			if (dirty & /*OPOcalibFiles*/ 8) customselect_changes.options = ["", .../*OPOcalibFiles*/ ctx[3]];

    			if (!updating_picked && dirty & /*calibFile*/ 32) {
    				updating_picked = true;
    				customselect_changes.picked = /*calibFile*/ ctx[5];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);
    			const textfield0_changes = {};
    			if (dirty & /*odelta*/ 128) textfield0_changes.input$step = /*odelta*/ ctx[7];

    			if (!updating_value && dirty & /*deltaOPO*/ 16) {
    				updating_value = true;
    				textfield0_changes.value = /*deltaOPO*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*opoPower*/ 64) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*opoPower*/ ctx[6];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customselect.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customselect.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customselect);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(57:0) {#if $opoMode}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let quickbrowser;
    	let updating_active;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let t;
    	let if_block_anchor;
    	let current;

    	function quickbrowser_active_binding(value) {
    		/*quickbrowser_active_binding*/ ctx[15](value);
    	}

    	function quickbrowser_currentLocation_binding(value) {
    		/*quickbrowser_currentLocation_binding*/ ctx[16](value);
    	}

    	function quickbrowser_fileChecked_binding(value) {
    		/*quickbrowser_fileChecked_binding*/ ctx[17](value);
    	}

    	let quickbrowser_props = { title: "OPO files", filetype: "ofelix" };

    	if (/*showOPOFiles*/ ctx[2] !== void 0) {
    		quickbrowser_props.active = /*showOPOFiles*/ ctx[2];
    	}

    	if (/*OPOLocation*/ ctx[0] !== void 0) {
    		quickbrowser_props.currentLocation = /*OPOLocation*/ ctx[0];
    	}

    	if (/*OPOfilesChecked*/ ctx[1] !== void 0) {
    		quickbrowser_props.fileChecked = /*OPOfilesChecked*/ ctx[1];
    	}

    	quickbrowser = new QuickBrowser({
    			props: quickbrowser_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(quickbrowser, 'active', quickbrowser_active_binding));
    	binding_callbacks.push(() => bind(quickbrowser, 'currentLocation', quickbrowser_currentLocation_binding));
    	binding_callbacks.push(() => bind(quickbrowser, 'fileChecked', quickbrowser_fileChecked_binding));
    	quickbrowser.$on("submit", /*submit_handler*/ ctx[18]);
    	quickbrowser.$on("markedFile", /*markedFile_handler*/ ctx[19]);
    	let if_block = /*$opoMode*/ ctx[8] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			create_component(quickbrowser.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(quickbrowser, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const quickbrowser_changes = {};

    			if (!updating_active && dirty & /*showOPOFiles*/ 4) {
    				updating_active = true;
    				quickbrowser_changes.active = /*showOPOFiles*/ ctx[2];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_currentLocation && dirty & /*OPOLocation*/ 1) {
    				updating_currentLocation = true;
    				quickbrowser_changes.currentLocation = /*OPOLocation*/ ctx[0];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty & /*OPOfilesChecked*/ 2) {
    				updating_fileChecked = true;
    				quickbrowser_changes.fileChecked = /*OPOfilesChecked*/ ctx[1];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			quickbrowser.$set(quickbrowser_changes);

    			if (/*$opoMode*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$opoMode*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quickbrowser.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quickbrowser.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(quickbrowser, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $opoMode;
    	let $felixPlotAnnotations;
    	let $felixConfigDB;
    	let $baselineFile;
    	validate_store(opoMode, 'opoMode');
    	component_subscribe($$self, opoMode, $$value => $$invalidate(8, $opoMode = $$value));
    	validate_store(felixPlotAnnotations, 'felixPlotAnnotations');
    	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(25, $felixPlotAnnotations = $$value));
    	validate_store(felixConfigDB, 'felixConfigDB');
    	component_subscribe($$self, felixConfigDB, $$value => $$invalidate(26, $felixConfigDB = $$value));
    	validate_store(baselineFile, 'baselineFile');
    	component_subscribe($$self, baselineFile, $$value => $$invalidate(9, $baselineFile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OPORow', slots, []);
    	let { OPOLocation, opofiles, OPOfilesChecked, graphPlotted, removeExtraFile } = $$props;
    	let { updateConfig = false } = $$props;
    	let showOPOFiles = false, OPOcalibFiles = [];
    	let deltaOPO = 0.3, calibFile = "", opoPower = 1;
    	let odelta = $felixConfigDB.get("odelta");

    	function loadConfig() {
    		$$invalidate(7, odelta = $felixConfigDB.get("odelta"));
    		console.log("odelta updated", odelta);
    	}

    	function plotData({ e = null, tkplot = "run" } = {}) {
    		let pyfile = "oposcan.py", args;
    		removeExtraFile();
    		if (opofiles.length < 1) return window.createToast("No files selected", "danger");
    		(set_store_value(opoMode, $opoMode = true, $opoMode), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations));

    		let opo_args = {
    			opofiles,
    			tkplot,
    			deltaOPO,
    			calibFile,
    			opoPower
    		};

    		args = [JSON.stringify(opo_args)];

    		computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			opofile_func({ dataFromPython, delta: deltaOPO });
    			window.createToast("Graph Plotted", "success");
    			($$invalidate(12, graphPlotted = true), set_store_value(opoMode, $opoMode = true, $opoMode));
    			$$invalidate(2, showOPOFiles = false);
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	const writable_props = [
    		'OPOLocation',
    		'opofiles',
    		'OPOfilesChecked',
    		'graphPlotted',
    		'removeExtraFile',
    		'updateConfig'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$d.warn(`<OPORow> was created with unknown prop '${key}'`);
    	});

    	function quickbrowser_active_binding(value) {
    		showOPOFiles = value;
    		$$invalidate(2, showOPOFiles);
    	}

    	function quickbrowser_currentLocation_binding(value) {
    		OPOLocation = value;
    		$$invalidate(0, OPOLocation);
    	}

    	function quickbrowser_fileChecked_binding(value) {
    		OPOfilesChecked = value;
    		$$invalidate(1, OPOfilesChecked);
    	}

    	const submit_handler = e => {
    		plotData({ e: e.detail.event });
    	};

    	const markedFile_handler = e => set_store_value(baselineFile, $baselineFile = e.detail.markedFile, $baselineFile);

    	function customselect_picked_binding(value) {
    		calibFile = value;
    		$$invalidate(5, calibFile);
    	}

    	function textfield0_value_binding(value) {
    		deltaOPO = value;
    		$$invalidate(4, deltaOPO);
    	}

    	function textfield1_value_binding(value) {
    		opoPower = value;
    		$$invalidate(6, opoPower);
    	}

    	const click_handler = () => {
    		$$invalidate(2, showOPOFiles = !showOPOFiles);
    	};

    	const click_handler_1 = e => plotData({ e });

    	$$self.$$set = $$props => {
    		if ('OPOLocation' in $$props) $$invalidate(0, OPOLocation = $$props.OPOLocation);
    		if ('opofiles' in $$props) $$invalidate(11, opofiles = $$props.opofiles);
    		if ('OPOfilesChecked' in $$props) $$invalidate(1, OPOfilesChecked = $$props.OPOfilesChecked);
    		if ('graphPlotted' in $$props) $$invalidate(12, graphPlotted = $$props.graphPlotted);
    		if ('removeExtraFile' in $$props) $$invalidate(13, removeExtraFile = $$props.removeExtraFile);
    		if ('updateConfig' in $$props) $$invalidate(14, updateConfig = $$props.updateConfig);
    	};

    	$$self.$capture_state = () => ({
    		opoMode,
    		felixPlotAnnotations,
    		felixConfigDB,
    		baselineFile,
    		mainPreModal,
    		Textfield,
    		CustomSelect: CustomSelect$1,
    		QuickBrowser,
    		fade,
    		opofile_func,
    		OPOLocation,
    		opofiles,
    		OPOfilesChecked,
    		graphPlotted,
    		removeExtraFile,
    		updateConfig,
    		showOPOFiles,
    		OPOcalibFiles,
    		deltaOPO,
    		calibFile,
    		opoPower,
    		odelta,
    		loadConfig,
    		plotData,
    		$opoMode,
    		$felixPlotAnnotations,
    		$felixConfigDB,
    		$baselineFile
    	});

    	$$self.$inject_state = $$props => {
    		if ('OPOLocation' in $$props) $$invalidate(0, OPOLocation = $$props.OPOLocation);
    		if ('opofiles' in $$props) $$invalidate(11, opofiles = $$props.opofiles);
    		if ('OPOfilesChecked' in $$props) $$invalidate(1, OPOfilesChecked = $$props.OPOfilesChecked);
    		if ('graphPlotted' in $$props) $$invalidate(12, graphPlotted = $$props.graphPlotted);
    		if ('removeExtraFile' in $$props) $$invalidate(13, removeExtraFile = $$props.removeExtraFile);
    		if ('updateConfig' in $$props) $$invalidate(14, updateConfig = $$props.updateConfig);
    		if ('showOPOFiles' in $$props) $$invalidate(2, showOPOFiles = $$props.showOPOFiles);
    		if ('OPOcalibFiles' in $$props) $$invalidate(3, OPOcalibFiles = $$props.OPOcalibFiles);
    		if ('deltaOPO' in $$props) $$invalidate(4, deltaOPO = $$props.deltaOPO);
    		if ('calibFile' in $$props) $$invalidate(5, calibFile = $$props.calibFile);
    		if ('opoPower' in $$props) $$invalidate(6, opoPower = $$props.opoPower);
    		if ('odelta' in $$props) $$invalidate(7, odelta = $$props.odelta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*updateConfig*/ 16384) {
    			if (updateConfig) loadConfig();
    		}

    		if ($$self.$$.dirty & /*OPOLocation, OPOfilesChecked*/ 3) {
    			if (fs.existsSync(OPOLocation)) {
    				$$invalidate(3, OPOcalibFiles = fs.readdirSync(OPOLocation).filter(file => file.endsWith(".calibOPO")));
    				$$invalidate(11, opofiles = OPOfilesChecked.map(file => pathResolve(OPOLocation, file)));
    			}
    		}
    	};

    	return [
    		OPOLocation,
    		OPOfilesChecked,
    		showOPOFiles,
    		OPOcalibFiles,
    		deltaOPO,
    		calibFile,
    		opoPower,
    		odelta,
    		$opoMode,
    		$baselineFile,
    		plotData,
    		opofiles,
    		graphPlotted,
    		removeExtraFile,
    		updateConfig,
    		quickbrowser_active_binding,
    		quickbrowser_currentLocation_binding,
    		quickbrowser_fileChecked_binding,
    		submit_handler,
    		markedFile_handler,
    		customselect_picked_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		click_handler,
    		click_handler_1
    	];
    }

    class OPORow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			OPOLocation: 0,
    			opofiles: 11,
    			OPOfilesChecked: 1,
    			graphPlotted: 12,
    			removeExtraFile: 13,
    			updateConfig: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OPORow",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*OPOLocation*/ ctx[0] === undefined && !('OPOLocation' in props)) {
    			console_1$d.warn("<OPORow> was created without expected prop 'OPOLocation'");
    		}

    		if (/*opofiles*/ ctx[11] === undefined && !('opofiles' in props)) {
    			console_1$d.warn("<OPORow> was created without expected prop 'opofiles'");
    		}

    		if (/*OPOfilesChecked*/ ctx[1] === undefined && !('OPOfilesChecked' in props)) {
    			console_1$d.warn("<OPORow> was created without expected prop 'OPOfilesChecked'");
    		}

    		if (/*graphPlotted*/ ctx[12] === undefined && !('graphPlotted' in props)) {
    			console_1$d.warn("<OPORow> was created without expected prop 'graphPlotted'");
    		}

    		if (/*removeExtraFile*/ ctx[13] === undefined && !('removeExtraFile' in props)) {
    			console_1$d.warn("<OPORow> was created without expected prop 'removeExtraFile'");
    		}
    	}

    	get OPOLocation() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set OPOLocation(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opofiles() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opofiles(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get OPOfilesChecked() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set OPOfilesChecked(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graphPlotted() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graphPlotted(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeExtraFile() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set removeExtraFile(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateConfig() {
    		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateConfig(value) {
    		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Table.svelte generated by Svelte v3.42.1 */
    const file$r = "src\\components\\Table.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[21] = list;
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i].key;
    	child_ctx[9] = list[i].id;
    	child_ctx[24] = list;
    	child_ctx[25] = i;
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (63:4) {#if addextraOption}
    function create_if_block_2$2(ctx) {
    	let div;
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*addRow*/ ctx[14]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			attr_dev(div, "class", "icon-holder svelte-1kiu7tv");
    			add_location(div, file$r, 63, 8, 1487);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*$$scope*/ 268435456) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(63:4) {#if addextraOption}",
    		ctx
    	});

    	return block;
    }

    // (65:12) <Icon class="material-icons"  on:click="{addRow}">
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("add");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(65:12) <Icon class=\\\"material-icons\\\"  on:click=\\\"{addRow}\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:32) {#if sortOption}
    function create_if_block_1$7(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*$$scope, sortTypeAscending*/ 268436480) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(87:32) {#if sortOption}",
    		ctx
    	});

    	return block;
    }

    // (88:36) <Icon class="material-icons" >
    function create_default_slot_1$3(ctx) {
    	let t_value = (/*sortTypeAscending*/ ctx[10]
    	? "arrow_upward"
    	: "arrow_downward") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*sortTypeAscending*/ 1024 && t_value !== (t_value = (/*sortTypeAscending*/ ctx[10]
    			? "arrow_upward"
    			: "arrow_downward") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(88:36) <Icon class=\\\"material-icons\\\" >",
    		ctx
    	});

    	return block;
    }

    // (82:20) {#each head as item, index }
    function create_each_block_2$4(ctx) {
    	let th;
    	let div;
    	let t0;
    	let t1_value = /*item*/ ctx[26] + "";
    	let t1;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*sortOption*/ ctx[6] && create_if_block_1$7(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[16](/*index*/ ctx[22]);
    	}

    	const block = {
    		c: function create() {
    			th = element("th");
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(div, "class", "tableIcon svelte-1kiu7tv");
    			add_location(div, file$r, 85, 28, 2213);
    			set_style(th, "cursor", "pointer");
    			attr_dev(th, "class", "mdc-data-table__header-cell svelte-1kiu7tv");
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			add_location(th, file$r, 83, 24, 2083);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, div);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(th, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*sortOption*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*sortOption*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*head*/ 2) && t1_value !== (t1_value = /*item*/ ctx[26] + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(82:20) {#each head as item, index }",
    		ctx
    	});

    	return block;
    }

    // (105:20) {#each keyIDSets as {key, id}
    function create_each_block_1$5(key_1, ctx) {
    	let td;
    	let input;
    	let td_id_value;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[17].call(input, /*key*/ ctx[23], /*each_value*/ ctx[21], /*index*/ ctx[22]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			set_style(input, "width", "100%");
    			attr_dev(input, "class", "svelte-1kiu7tv");
    			add_location(input, file$r, 106, 28, 3205);
    			attr_dev(td, "class", "mdc-data-table__cell  mdc-data-table__cell--numeric svelte-1kiu7tv");
    			attr_dev(td, "id", td_id_value = "" + (/*row*/ ctx[20].id + "-" + /*key*/ ctx[23]));
    			add_location(td, file$r, 105, 24, 3091);
    			this.first = td;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			set_input_value(input, /*row*/ ctx[20][/*key*/ ctx[23]]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*rows, keyIDSets*/ 4097 && input.value !== /*row*/ ctx[20][/*key*/ ctx[23]]) {
    				set_input_value(input, /*row*/ ctx[20][/*key*/ ctx[23]]);
    			}

    			if (dirty & /*rows*/ 1 && td_id_value !== (td_id_value = "" + (/*row*/ ctx[20].id + "-" + /*key*/ ctx[23]))) {
    				attr_dev(td, "id", td_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(105:20) {#each keyIDSets as {key, id}",
    		ctx
    	});

    	return block;
    }

    // (110:20) {#if closeOption}
    function create_if_block$h(ctx) {
    	let td;
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				id: /*row*/ ctx[20].id,
    				class: "material-icons",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler_1*/ ctx[18]);

    	const block = {
    		c: function create() {
    			td = element("td");
    			create_component(icon.$$.fragment);
    			attr_dev(td, "class", "mdc-data-table__cell svelte-1kiu7tv");
    			set_style(td, "background", "#f14668");
    			set_style(td, "cursor", "pointer");
    			set_style(td, "width", "2em");
    			add_location(td, file$r, 110, 24, 3406);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			mount_component(icon, td, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*rows*/ 1) icon_changes.id = /*row*/ ctx[20].id;

    			if (dirty & /*$$scope*/ 268435456) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(110:20) {#if closeOption}",
    		ctx
    	});

    	return block;
    }

    // (112:28) <Icon id="{row.id}" class="material-icons" on:click="{(e)=> {rows = window._.filter(rows, (tb)=>tb.id != e.target.id)}}">
    function create_default_slot$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("close");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(112:28) <Icon id=\\\"{row.id}\\\" class=\\\"material-icons\\\" on:click=\\\"{(e)=> {rows = window._.filter(rows, (tb)=>tb.id != e.target.id)}}\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:16) {#each rows as row, index (row.id)}
    function create_each_block$9(key_1, ctx) {
    	let tr;
    	let td;
    	let t0_value = /*index*/ ctx[22] + "";
    	let t0;
    	let t1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t2;
    	let t3;
    	let tr_transition;
    	let current;
    	let each_value_1 = /*keyIDSets*/ ctx[12];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*id*/ ctx[9];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$5, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$5(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$5(key, child_ctx));
    	}

    	let if_block = /*closeOption*/ ctx[7] && create_if_block$h(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			tr = element("tr");
    			td = element("td");
    			t0 = text(t0_value);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			attr_dev(td, "class", "mdc-data-table__cell svelte-1kiu7tv");
    			set_style(td, "width", "2em");
    			add_location(td, file$r, 103, 20, 2942);
    			attr_dev(tr, "class", "mdc-data-table__row svelte-1kiu7tv");
    			set_style(tr, "background-color", "#fafafa");
    			add_location(tr, file$r, 102, 20, 2833);
    			this.first = tr;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td);
    			append_dev(td, t0);
    			append_dev(tr, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t2);
    			if (if_block) if_block.m(tr, null);
    			append_dev(tr, t3);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*rows*/ 1) && t0_value !== (t0_value = /*index*/ ctx[22] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*rows, keyIDSets*/ 4097) {
    				each_value_1 = /*keyIDSets*/ ctx[12];
    				validate_each_argument(each_value_1);
    				validate_each_keys(ctx, each_value_1, get_each_context_1$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, destroy_block, create_each_block_1$5, t2, get_each_context_1$5);
    			}

    			if (/*closeOption*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*closeOption*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(tr, t3);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!tr_transition) tr_transition = create_bidirectional_transition(tr, /*animate*/ ctx[11], {}, true);
    				tr_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!tr_transition) tr_transition = create_bidirectional_transition(tr, /*animate*/ ctx[11], {}, false);
    			tr_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (if_block) if_block.d();
    			if (detaching && tr_transition) tr_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(101:16) {#each rows as row, index (row.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let table;
    	let thead;
    	let tr;
    	let th;
    	let t2;
    	let t3;
    	let tbody;
    	let each_blocks = [];
    	let each1_lookup = new Map();
    	let current;
    	let if_block = /*addextraOption*/ ctx[8] && create_if_block_2$2(ctx);
    	let each_value_2 = /*head*/ ctx[1];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*rows*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[20].id;
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th = element("th");
    			th.textContent = "#";
    			t2 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th, "class", "mdc-data-table__header-cell svelte-1kiu7tv");
    			set_style(th, "width", "2em");
    			attr_dev(th, "role", "columnheader");
    			attr_dev(th, "scope", "col");
    			add_location(th, file$r, 78, 20, 1903);
    			attr_dev(tr, "class", "mdc-data-table__header-row svelte-1kiu7tv");
    			add_location(tr, file$r, 76, 16, 1840);
    			attr_dev(thead, "class", "svelte-1kiu7tv");
    			add_location(thead, file$r, 74, 12, 1813);
    			attr_dev(tbody, "class", "mdc-data-table__content svelte-1kiu7tv");
    			add_location(tbody, file$r, 99, 12, 2717);
    			attr_dev(table, "class", "mdc-data-table__table svelte-1kiu7tv");
    			attr_dev(table, "aria-label", /*label*/ ctx[3]);
    			attr_dev(table, "id", /*id*/ ctx[9]);
    			set_style(table, "user-select", (/*userSelect*/ ctx[4] ? 'text' : 'none') + " ");
    			add_location(table, file$r, 73, 8, 1684);
    			attr_dev(div0, "class", "mdc-data-table tableContainer svelte-1kiu7tv");
    			add_location(div0, file$r, 71, 4, 1628);
    			attr_dev(div1, "style", /*style*/ ctx[5]);
    			attr_dev(div1, "class", "svelte-1kiu7tv");
    			add_location(div1, file$r, 59, 0, 1434);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th);
    			append_dev(tr, t2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(tr, null);
    			}

    			append_dev(table, t3);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*addextraOption*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*addextraOption*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*sortTable, keys, head, sortTypeAscending, sortOption*/ 9286) {
    				each_value_2 = /*head*/ ctx[1];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_2$4(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(tr, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*rows, window, closeOption, keyIDSets*/ 4225) {
    				each_value = /*rows*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, tbody, outro_and_destroy_block, create_each_block$9, null, get_each_context$9);
    				check_outros();
    			}

    			if (!current || dirty & /*label*/ 8) {
    				attr_dev(table, "aria-label", /*label*/ ctx[3]);
    			}

    			if (!current || dirty & /*id*/ 512) {
    				attr_dev(table, "id", /*id*/ ctx[9]);
    			}

    			if (!current || dirty & /*userSelect*/ 16) {
    				set_style(table, "user-select", (/*userSelect*/ ctx[4] ? 'text' : 'none') + " ");
    			}

    			if (!current || dirty & /*style*/ 32) {
    				attr_dev(div1, "style", /*style*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks_1, detaching);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let animate;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table', slots, []);
    	let { head, rows, keys, id = window.getID(), label = "table", userSelect = true, style = "width: 100%;" } = $$props;
    	let { sortOption = false, closeOption = true, addextraOption = true, animateRow = true } = $$props;

    	const keyIDSets = keys.map(key => {
    		return { key, id: window.getID() };
    	});

    	let sortTypeAscending = true;

    	const sortTable = type => {
    		if (sortOption) {
    			$$invalidate(10, sortTypeAscending = !sortTypeAscending);
    			$$invalidate(0, rows = _.orderBy(rows, [type], [sortTypeAscending ? "asc" : "desc"]));
    		}
    	};

    	let emptyRow = {};
    	keys.forEach(key => emptyRow[key] = "");

    	const addRow = async () => {
    		const id = window.getID();
    		$$invalidate(0, rows = [...rows, { ...emptyRow, id }]);
    		await tick();
    		const focusTargetID = `${id}-${keys[0]}`;
    		document.getElementById(focusTargetID).focus();
    	};

    	const writable_props = [
    		'head',
    		'rows',
    		'keys',
    		'id',
    		'label',
    		'userSelect',
    		'style',
    		'sortOption',
    		'closeOption',
    		'addextraOption',
    		'animateRow'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table> was created with unknown prop '${key}'`);
    	});

    	const click_handler = index => sortTable(keys[index]);

    	function input_input_handler(key, each_value, index) {
    		each_value[index][key] = this.value;
    		$$invalidate(0, rows);
    		$$invalidate(12, keyIDSets);
    	}

    	const click_handler_1 = e => {
    		$$invalidate(0, rows = window._.filter(rows, tb => tb.id != e.target.id));
    	};

    	$$self.$$set = $$props => {
    		if ('head' in $$props) $$invalidate(1, head = $$props.head);
    		if ('rows' in $$props) $$invalidate(0, rows = $$props.rows);
    		if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
    		if ('id' in $$props) $$invalidate(9, id = $$props.id);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('userSelect' in $$props) $$invalidate(4, userSelect = $$props.userSelect);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    		if ('sortOption' in $$props) $$invalidate(6, sortOption = $$props.sortOption);
    		if ('closeOption' in $$props) $$invalidate(7, closeOption = $$props.closeOption);
    		if ('addextraOption' in $$props) $$invalidate(8, addextraOption = $$props.addextraOption);
    		if ('animateRow' in $$props) $$invalidate(15, animateRow = $$props.animateRow);
    	};

    	$$self.$capture_state = () => ({
    		scale,
    		Icon,
    		tick,
    		head,
    		rows,
    		keys,
    		id,
    		label,
    		userSelect,
    		style,
    		sortOption,
    		closeOption,
    		addextraOption,
    		animateRow,
    		keyIDSets,
    		sortTypeAscending,
    		sortTable,
    		emptyRow,
    		addRow,
    		animate
    	});

    	$$self.$inject_state = $$props => {
    		if ('head' in $$props) $$invalidate(1, head = $$props.head);
    		if ('rows' in $$props) $$invalidate(0, rows = $$props.rows);
    		if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
    		if ('id' in $$props) $$invalidate(9, id = $$props.id);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('userSelect' in $$props) $$invalidate(4, userSelect = $$props.userSelect);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    		if ('sortOption' in $$props) $$invalidate(6, sortOption = $$props.sortOption);
    		if ('closeOption' in $$props) $$invalidate(7, closeOption = $$props.closeOption);
    		if ('addextraOption' in $$props) $$invalidate(8, addextraOption = $$props.addextraOption);
    		if ('animateRow' in $$props) $$invalidate(15, animateRow = $$props.animateRow);
    		if ('sortTypeAscending' in $$props) $$invalidate(10, sortTypeAscending = $$props.sortTypeAscending);
    		if ('emptyRow' in $$props) emptyRow = $$props.emptyRow;
    		if ('animate' in $$props) $$invalidate(11, animate = $$props.animate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animateRow*/ 32768) {
    			$$invalidate(11, animate = animateRow
    			? scale
    			: e => {
    					
    				});
    		}
    	};

    	return [
    		rows,
    		head,
    		keys,
    		label,
    		userSelect,
    		style,
    		sortOption,
    		closeOption,
    		addextraOption,
    		id,
    		sortTypeAscending,
    		animate,
    		keyIDSets,
    		sortTable,
    		addRow,
    		animateRow,
    		click_handler,
    		input_input_handler,
    		click_handler_1
    	];
    }

    class Table extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			head: 1,
    			rows: 0,
    			keys: 2,
    			id: 9,
    			label: 3,
    			userSelect: 4,
    			style: 5,
    			sortOption: 6,
    			closeOption: 7,
    			addextraOption: 8,
    			animateRow: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table",
    			options,
    			id: create_fragment$s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*head*/ ctx[1] === undefined && !('head' in props)) {
    			console.warn("<Table> was created without expected prop 'head'");
    		}

    		if (/*rows*/ ctx[0] === undefined && !('rows' in props)) {
    			console.warn("<Table> was created without expected prop 'rows'");
    		}

    		if (/*keys*/ ctx[2] === undefined && !('keys' in props)) {
    			console.warn("<Table> was created without expected prop 'keys'");
    		}
    	}

    	get head() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set head(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keys() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keys(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get userSelect() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set userSelect(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortOption() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortOption(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOption() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOption(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addextraOption() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addextraOption(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animateRow() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animateRow(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\modals\AdjustInitialGuess.svelte generated by Svelte v3.42.1 */

    const { console: console_1$c } = globals;
    const file$q = "src\\Pages\\normline\\modals\\AdjustInitialGuess.svelte";

    // (14:0) {#if active}
    function create_if_block$g(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[5](value);
    	}

    	let modal_props = {
    		title: "Adjust initial guess",
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$2],
    			content: [create_content_slot$4]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, $felixPeakTable*/ 66) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(14:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (16:8) 
    function create_content_slot$4(ctx) {
    	let div;
    	let table;
    	let updating_rows;
    	let current;

    	function table_rows_binding(value) {
    		/*table_rows_binding*/ ctx[4](value);
    	}

    	let table_props = {
    		head: ["Frequency", "Amplitude", "Sigma"],
    		keys: ["freq", "amp", "sig"],
    		sortOption: true
    	};

    	if (/*$felixPeakTable*/ ctx[1] !== void 0) {
    		table_props.rows = /*$felixPeakTable*/ ctx[1];
    	}

    	table = new Table({ props: table_props, $$inline: true });
    	binding_callbacks.push(() => bind(table, 'rows', table_rows_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(table.$$.fragment);
    			attr_dev(div, "slot", "content");
    			add_location(div, file$q, 15, 8, 470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(table, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (!updating_rows && dirty & /*$felixPeakTable*/ 2) {
    				updating_rows = true;
    				table_changes.rows = /*$felixPeakTable*/ ctx[1];
    				add_flush_callback(() => updating_rows = false);
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$4.name,
    		type: "slot",
    		source: "(16:8) ",
    		ctx
    	});

    	return block;
    }

    // (22:8) 
    function create_footerbtn_slot$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Save";
    			attr_dev(button, "slot", "footerbtn");
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$q, 21, 8, 664);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$2.name,
    		type: "slot",
    		source: "(22:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $felixPeakTable;
    	validate_store(felixPeakTable, 'felixPeakTable');
    	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(1, $felixPeakTable = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AdjustInitialGuess', slots, []);
    	let { active = false } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ['active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$c.warn(`<AdjustInitialGuess> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => dispatch('save');

    	function table_rows_binding(value) {
    		$felixPeakTable = value;
    		felixPeakTable.set($felixPeakTable);
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	$$self.$capture_state = () => ({
    		felixPeakTable,
    		createEventDispatcher,
    		Modal: Modal$1,
    		Table,
    		active,
    		dispatch,
    		$felixPeakTable
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$felixPeakTable*/ 2) {
    			console.log(`peakTable:`, $felixPeakTable);
    		}
    	};

    	return [
    		active,
    		$felixPeakTable,
    		dispatch,
    		click_handler,
    		table_rows_binding,
    		modal_active_binding
    	];
    }

    class AdjustInitialGuess extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$r, create_fragment$r, safe_not_equal, { active: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdjustInitialGuess",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get active() {
    		throw new Error("<AdjustInitialGuess>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<AdjustInitialGuess>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function theory_func({dataFromPython, normMethod}={}){
        let ylabel;
        if (normMethod === "Log") { ylabel = "Normalised Intensity per J"; }
        else if (normMethod === "Relative") { ylabel = "Relative Depletion (%)"; }
        else { ylabel = "Normalised Intensity per Photon"; }

        let theoryData = [];
        for (let x in dataFromPython["line_simulation"]) { theoryData.push(dataFromPython["line_simulation"][x]); }

        plot(
            "Experimental vs Theory",
            "Calibrated Wavelength (cm-1)",
            ylabel, [dataFromPython["averaged"], ...theoryData],
            "exp-theory-plot"

        );

        console.log("Graph Plotted");
    }

    /* src\components\CustomSwitch.svelte generated by Svelte v3.42.1 */
    const file$p = "src\\components\\CustomSwitch.svelte";

    // (9:0) <FormField {style}>
    function create_default_slot$6(ctx) {
    	let switch_1;
    	let updating_checked;
    	let current;

    	function switch_1_checked_binding(value) {
    		/*switch_1_checked_binding*/ ctx[3](value);
    	}

    	let switch_1_props = {};

    	if (/*selected*/ ctx[0] !== void 0) {
    		switch_1_props.checked = /*selected*/ ctx[0];
    	}

    	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));
    	switch_1.$on("change", /*change_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(switch_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(switch_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_1_changes = {};

    			if (!updating_checked && dirty & /*selected*/ 1) {
    				updating_checked = true;
    				switch_1_changes.checked = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			switch_1.$set(switch_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(switch_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(switch_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(switch_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(9:0) <FormField {style}>",
    		ctx
    	});

    	return block;
    }

    // (11:4) 
    function create_label_slot$1(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*label*/ ctx[2]);
    			attr_dev(span, "slot", "label");
    			add_location(span, file$p, 10, 4, 244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot$1.name,
    		type: "slot",
    		source: "(11:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let formfield;
    	let current;

    	formfield = new FormField({
    			props: {
    				style: /*style*/ ctx[1],
    				$$slots: {
    					label: [create_label_slot$1],
    					default: [create_default_slot$6]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfield.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const formfield_changes = {};
    			if (dirty & /*style*/ 2) formfield_changes.style = /*style*/ ctx[1];

    			if (dirty & /*$$scope, label, selected*/ 37) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomSwitch', slots, []);
    	let { selected = false, style = "", label = "" } = $$props;
    	const writable_props = ['selected', 'style', 'label'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomSwitch> was created with unknown prop '${key}'`);
    	});

    	function switch_1_checked_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({
    		Switch,
    		FormField,
    		selected,
    		style,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, style, label, switch_1_checked_binding, change_handler];
    }

    class CustomSwitch$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$q, create_fragment$q, safe_not_equal, { selected: 0, style: 1, label: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomSwitch",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get selected() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\widgets\preprocessing\TheoryRow.svelte generated by Svelte v3.42.1 */

    const { console: console_1$b } = globals;
    const file$o = "src\\Pages\\normline\\widgets\\preprocessing\\TheoryRow.svelte";

    // (49:0) {#if $toggleRow}
    function create_if_block$f(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let textfield0;
    	let updating_value;
    	let t2;
    	let textfield1;
    	let updating_value_1;
    	let t3;
    	let customswitch0;
    	let updating_selected;
    	let t4;
    	let customswitch1;
    	let updating_selected_1;
    	let t5;
    	let button1;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[18](value);
    	}

    	let textfield0_props = {
    		style: "width:7em; margin-right:0.5em;",
    		variant: "outlined",
    		label: "Sigma",
    		input$type: "number",
    		input$step: "0.5",
    		input$min: "0"
    	};

    	if (/*sigma*/ ctx[2] !== void 0) {
    		textfield0_props.value = /*sigma*/ ctx[2];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[19](value);
    	}

    	let textfield1_props = {
    		style: "width:7em",
    		variant: "outlined",
    		label: "Scale",
    		input$type: "number",
    		input$step: /*scalingBin*/ ctx[6],
    		input$min: "0",
    		input$max: "1"
    	};

    	if (/*scale*/ ctx[3] !== void 0) {
    		textfield1_props.value = /*scale*/ ctx[3];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function customswitch0_selected_binding(value) {
    		/*customswitch0_selected_binding*/ ctx[20](value);
    	}

    	let customswitch0_props = {
    		style: "margin: 0 1em;",
    		label: "Only Exp. Range"
    	};

    	if (/*onlyExpRange*/ ctx[7] !== void 0) {
    		customswitch0_props.selected = /*onlyExpRange*/ ctx[7];
    	}

    	customswitch0 = new CustomSwitch$1({
    			props: customswitch0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch0, 'selected', customswitch0_selected_binding));

    	function customswitch1_selected_binding(value) {
    		/*customswitch1_selected_binding*/ ctx[21](value);
    	}

    	let customswitch1_props = {
    		style: "margin: 0 1em;",
    		label: "Matplotlib"
    	};

    	if (/*tkplot*/ ctx[4] !== void 0) {
    		customswitch1_props.selected = /*tkplot*/ ctx[4];
    	}

    	customswitch1 = new CustomSwitch$1({
    			props: customswitch1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch1, 'selected', customswitch1_selected_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Browse File";
    			t1 = space();
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			create_component(customswitch0.$$.fragment);
    			t4 = space();
    			create_component(customswitch1.$$.fragment);
    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "Replot";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$o, 51, 8, 2102);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$o, 60, 8, 2763);
    			attr_dev(div, "class", "align");
    			add_location(div, file$o, 49, 4, 2055);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			mount_component(textfield0, div, null);
    			append_dev(div, t2);
    			mount_component(textfield1, div, null);
    			append_dev(div, t3);
    			mount_component(customswitch0, div, null);
    			append_dev(div, t4);
    			mount_component(customswitch1, div, null);
    			append_dev(div, t5);
    			append_dev(div, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[17], false, false, false),
    					listen_dev(button1, "click", /*plotData*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*sigma*/ 4) {
    				updating_value = true;
    				textfield0_changes.value = /*sigma*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*scalingBin*/ 64) textfield1_changes.input$step = /*scalingBin*/ ctx[6];

    			if (!updating_value_1 && dirty & /*scale*/ 8) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*scale*/ ctx[3];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const customswitch0_changes = {};

    			if (!updating_selected && dirty & /*onlyExpRange*/ 128) {
    				updating_selected = true;
    				customswitch0_changes.selected = /*onlyExpRange*/ ctx[7];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch0.$set(customswitch0_changes);
    			const customswitch1_changes = {};

    			if (!updating_selected_1 && dirty & /*tkplot*/ 16) {
    				updating_selected_1 = true;
    				customswitch1_changes.selected = /*tkplot*/ ctx[4];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customswitch1.$set(customswitch1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(customswitch0.$$.fragment, local);
    			transition_in(customswitch1.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(customswitch0.$$.fragment, local);
    			transition_out(customswitch1.$$.fragment, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(customswitch0);
    			destroy_component(customswitch1);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(49:0) {#if $toggleRow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let quickbrowser;
    	let updating_active;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let t;
    	let if_block_anchor;
    	let current;

    	function quickbrowser_active_binding(value) {
    		/*quickbrowser_active_binding*/ ctx[13](value);
    	}

    	function quickbrowser_currentLocation_binding(value) {
    		/*quickbrowser_currentLocation_binding*/ ctx[14](value);
    	}

    	function quickbrowser_fileChecked_binding(value) {
    		/*quickbrowser_fileChecked_binding*/ ctx[15](value);
    	}

    	let quickbrowser_props = { title: "Theory files" };

    	if (/*showTheoryFiles*/ ctx[5] !== void 0) {
    		quickbrowser_props.active = /*showTheoryFiles*/ ctx[5];
    	}

    	if (/*theoryLocation*/ ctx[0] !== void 0) {
    		quickbrowser_props.currentLocation = /*theoryLocation*/ ctx[0];
    	}

    	if (/*theoryfilesChecked*/ ctx[1] !== void 0) {
    		quickbrowser_props.fileChecked = /*theoryfilesChecked*/ ctx[1];
    	}

    	quickbrowser = new QuickBrowser({
    			props: quickbrowser_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(quickbrowser, 'active', quickbrowser_active_binding));
    	binding_callbacks.push(() => bind(quickbrowser, 'currentLocation', quickbrowser_currentLocation_binding));
    	binding_callbacks.push(() => bind(quickbrowser, 'fileChecked', quickbrowser_fileChecked_binding));
    	quickbrowser.$on("submit", /*submit_handler*/ ctx[16]);
    	let if_block = /*$toggleRow*/ ctx[8] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			create_component(quickbrowser.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(quickbrowser, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const quickbrowser_changes = {};

    			if (!updating_active && dirty & /*showTheoryFiles*/ 32) {
    				updating_active = true;
    				quickbrowser_changes.active = /*showTheoryFiles*/ ctx[5];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_currentLocation && dirty & /*theoryLocation*/ 1) {
    				updating_currentLocation = true;
    				quickbrowser_changes.currentLocation = /*theoryLocation*/ ctx[0];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty & /*theoryfilesChecked*/ 2) {
    				updating_fileChecked = true;
    				quickbrowser_changes.fileChecked = /*theoryfilesChecked*/ ctx[1];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			quickbrowser.$set(quickbrowser_changes);

    			if (/*$toggleRow*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$toggleRow*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quickbrowser.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quickbrowser.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(quickbrowser, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $felixopoLocation;
    	let $felixConfigDB;
    	let $toggleRow;
    	validate_store(felixopoLocation, 'felixopoLocation');
    	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(23, $felixopoLocation = $$value));
    	validate_store(felixConfigDB, 'felixConfigDB');
    	component_subscribe($$self, felixConfigDB, $$value => $$invalidate(24, $felixConfigDB = $$value));
    	validate_store(toggleRow, 'toggleRow');
    	component_subscribe($$self, toggleRow, $$value => $$invalidate(8, $toggleRow = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TheoryRow', slots, []);
    	let { updateConfig = false } = $$props;
    	let { theoryLocation, show_theoryplot, normMethod } = $$props;
    	let sigma = 7, scale = 1, theoryfiles = [], tkplot = false;
    	let showTheoryFiles = false, theoryfilesChecked = [];
    	let scalingBin = $felixConfigDB.get("scalingBin");

    	function loadConfig() {
    		$$invalidate(6, scalingBin = $felixConfigDB.get("scalingBin"));
    		console.log("scalingBin updated", scalingBin);
    	}

    	function plotData(e = null) {
    		let pyfile = "theory.py", args;
    		if (theoryfiles.length < 1) return window.createToast("No files selected", "danger");

    		args = {
    			theoryfiles,
    			normMethod,
    			sigma,
    			scale,
    			currentLocation: $felixopoLocation,
    			tkplot,
    			onlyExpRange
    		};

    		args = [JSON.stringify(args)];

    		computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			theory_func({ dataFromPython, normMethod });
    			window.createToast("Graph Plotted", "success");
    			($$invalidate(10, show_theoryplot = true), $$invalidate(5, showTheoryFiles = false));
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	let onlyExpRange = false;
    	const writable_props = ['updateConfig', 'theoryLocation', 'show_theoryplot', 'normMethod'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$b.warn(`<TheoryRow> was created with unknown prop '${key}'`);
    	});

    	function quickbrowser_active_binding(value) {
    		showTheoryFiles = value;
    		$$invalidate(5, showTheoryFiles);
    	}

    	function quickbrowser_currentLocation_binding(value) {
    		theoryLocation = value;
    		$$invalidate(0, theoryLocation);
    	}

    	function quickbrowser_fileChecked_binding(value) {
    		theoryfilesChecked = value;
    		$$invalidate(1, theoryfilesChecked);
    	}

    	const submit_handler = e => {
    		plotData(e.detail.event);
    	};

    	const click_handler = () => {
    		$$invalidate(5, showTheoryFiles = !showTheoryFiles);
    	};

    	function textfield0_value_binding(value) {
    		sigma = value;
    		$$invalidate(2, sigma);
    	}

    	function textfield1_value_binding(value) {
    		scale = value;
    		$$invalidate(3, scale);
    	}

    	function customswitch0_selected_binding(value) {
    		onlyExpRange = value;
    		$$invalidate(7, onlyExpRange);
    	}

    	function customswitch1_selected_binding(value) {
    		tkplot = value;
    		$$invalidate(4, tkplot);
    	}

    	$$self.$$set = $$props => {
    		if ('updateConfig' in $$props) $$invalidate(11, updateConfig = $$props.updateConfig);
    		if ('theoryLocation' in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
    		if ('show_theoryplot' in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
    		if ('normMethod' in $$props) $$invalidate(12, normMethod = $$props.normMethod);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		toggleRow,
    		felixopoLocation,
    		felixConfigDB,
    		Textfield,
    		QuickBrowser,
    		fade,
    		theory_func,
    		updateConfig,
    		CustomSwitch: CustomSwitch$1,
    		theoryLocation,
    		show_theoryplot,
    		normMethod,
    		sigma,
    		scale,
    		theoryfiles,
    		tkplot,
    		showTheoryFiles,
    		theoryfilesChecked,
    		scalingBin,
    		loadConfig,
    		plotData,
    		onlyExpRange,
    		$felixopoLocation,
    		$felixConfigDB,
    		$toggleRow
    	});

    	$$self.$inject_state = $$props => {
    		if ('updateConfig' in $$props) $$invalidate(11, updateConfig = $$props.updateConfig);
    		if ('theoryLocation' in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
    		if ('show_theoryplot' in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
    		if ('normMethod' in $$props) $$invalidate(12, normMethod = $$props.normMethod);
    		if ('sigma' in $$props) $$invalidate(2, sigma = $$props.sigma);
    		if ('scale' in $$props) $$invalidate(3, scale = $$props.scale);
    		if ('theoryfiles' in $$props) theoryfiles = $$props.theoryfiles;
    		if ('tkplot' in $$props) $$invalidate(4, tkplot = $$props.tkplot);
    		if ('showTheoryFiles' in $$props) $$invalidate(5, showTheoryFiles = $$props.showTheoryFiles);
    		if ('theoryfilesChecked' in $$props) $$invalidate(1, theoryfilesChecked = $$props.theoryfilesChecked);
    		if ('scalingBin' in $$props) $$invalidate(6, scalingBin = $$props.scalingBin);
    		if ('onlyExpRange' in $$props) $$invalidate(7, onlyExpRange = $$props.onlyExpRange);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*theoryLocation, theoryfilesChecked*/ 3) {
    			if (fs.existsSync(theoryLocation)) {
    				theoryfiles = theoryfilesChecked.map(file => pathResolve(theoryLocation, file));
    			}
    		}

    		if ($$self.$$.dirty & /*updateConfig*/ 2048) {
    			if (updateConfig) loadConfig();
    		}

    		if ($$self.$$.dirty & /*theoryLocation*/ 1) {
    			if (theoryLocation) {
    				db.set("theoryLocation", theoryLocation);
    			}
    		}
    	};

    	return [
    		theoryLocation,
    		theoryfilesChecked,
    		sigma,
    		scale,
    		tkplot,
    		showTheoryFiles,
    		scalingBin,
    		onlyExpRange,
    		$toggleRow,
    		plotData,
    		show_theoryplot,
    		updateConfig,
    		normMethod,
    		quickbrowser_active_binding,
    		quickbrowser_currentLocation_binding,
    		quickbrowser_fileChecked_binding,
    		submit_handler,
    		click_handler,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		customswitch0_selected_binding,
    		customswitch1_selected_binding
    	];
    }

    class TheoryRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			updateConfig: 11,
    			theoryLocation: 0,
    			show_theoryplot: 10,
    			normMethod: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TheoryRow",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*theoryLocation*/ ctx[0] === undefined && !('theoryLocation' in props)) {
    			console_1$b.warn("<TheoryRow> was created without expected prop 'theoryLocation'");
    		}

    		if (/*show_theoryplot*/ ctx[10] === undefined && !('show_theoryplot' in props)) {
    			console_1$b.warn("<TheoryRow> was created without expected prop 'show_theoryplot'");
    		}

    		if (/*normMethod*/ ctx[12] === undefined && !('normMethod' in props)) {
    			console_1$b.warn("<TheoryRow> was created without expected prop 'normMethod'");
    		}
    	}

    	get updateConfig() {
    		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateConfig(value) {
    		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theoryLocation() {
    		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theoryLocation(value) {
    		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show_theoryplot() {
    		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show_theoryplot(value) {
    		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get normMethod() {
    		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set normMethod(value) {
    		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function get_details_func({dataFromPython}={}) {
        
        const info = dataFromPython.files.map(data=>{
            let {filename, trap, res, b0, range} = data;
            let [min, max] = range;
            return {filename, min, max, trap, b0, res, precursor:"", ie:"", temp:"", id:getID()}

        });
        filedetails.set(info);
        
    }

    /* src\Pages\normline\widgets\preprocessing\GetFileInfoTable.svelte generated by Svelte v3.42.1 */

    const file$n = "src\\Pages\\normline\\widgets\\preprocessing\\GetFileInfoTable.svelte";

    // (42:4) {#if toggleFileDetailsTable}
    function create_if_block$e(ctx) {
    	let table;
    	let updating_rows;
    	let current;

    	function table_rows_binding(value) {
    		/*table_rows_binding*/ ctx[9](value);
    	}

    	let table_props = {
    		head: [
    			"Filename",
    			"min(cm-1)",
    			"max(cm-1)",
    			"Trap(s)",
    			"B0(ms)",
    			"Res.(V)",
    			"IE(eV)",
    			"Temp(K)",
    			"Precursor"
    		],
    		keys: ["filename", "min", "max", "trap", "b0", "res", "ie", "temp", "precursor"],
    		id: "felix_filedetails_table",
    		closeOption: false,
    		sortOption: true
    	};

    	if (/*$filedetails*/ ctx[1] !== void 0) {
    		table_props.rows = /*$filedetails*/ ctx[1];
    	}

    	table = new Table({ props: table_props, $$inline: true });
    	binding_callbacks.push(() => bind(table, 'rows', table_rows_binding));

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (!updating_rows && dirty & /*$filedetails*/ 2) {
    				updating_rows = true;
    				table_changes.rows = /*$filedetails*/ ctx[1];
    				add_flush_callback(() => updating_rows = false);
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(42:4) {#if toggleFileDetailsTable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let customiconswitch;
    	let updating_toggler;
    	let t2;
    	let button1;
    	let t4;
    	let button2;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[7](value);
    	}

    	let customiconswitch_props = {
    		icons: ["arrow_drop_down", "arrow_drop_up"]
    	};

    	if (/*toggleFileDetailsTable*/ ctx[0] !== void 0) {
    		customiconswitch_props.toggler = /*toggleFileDetailsTable*/ ctx[0];
    	}

    	customiconswitch = new CustomIconSwitch$1({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));
    	let if_block = /*toggleFileDetailsTable*/ ctx[0] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Get details";
    			t1 = space();
    			create_component(customiconswitch.$$.fragment);
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Save";
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = "Load";
    			t6 = space();
    			if (if_block) if_block.c();
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$n, 35, 4, 1314);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$n, 37, 4, 1513);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$n, 39, 4, 1632);
    			attr_dev(div, "class", "align");
    			add_location(div, file$n, 34, 0, 1288);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			mount_component(customiconswitch, div, null);
    			append_dev(div, t2);
    			append_dev(div, button1);
    			append_dev(div, t4);
    			append_dev(div, button2);
    			append_dev(div, t6);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[8], false, false, false),
    					listen_dev(button2, "click", /*loadfiledetails*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty & /*toggleFileDetailsTable*/ 1) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*toggleFileDetailsTable*/ ctx[0];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);

    			if (/*toggleFileDetailsTable*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*toggleFileDetailsTable*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customiconswitch.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customiconswitch.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customiconswitch);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $filedetails;
    	let $opoMode;
    	validate_store(filedetails, 'filedetails');
    	component_subscribe($$self, filedetails, $$value => $$invalidate(1, $filedetails = $$value));
    	validate_store(opoMode, 'opoMode');
    	component_subscribe($$self, opoMode, $$value => $$invalidate(10, $opoMode = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GetFileInfoTable', slots, []);
    	let { felixfiles, normMethod } = $$props;
    	let toggleFileDetailsTable = false;

    	function plotData({ e = null } = {}) {
    		let pyfile = "getfile_details.py", args;
    		if (felixfiles.length < 1) return window.createToast("No files selected", "danger");

    		args = [
    			JSON.stringify({
    				files: $opoMode ? opofiles : felixfiles,
    				normMethod
    			})
    		];

    		computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			get_details_func({ dataFromPython });
    			$$invalidate(0, toggleFileDetailsTable = true);
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	function loadfiledetails() {
    		const loadedfile = loadfile({ name: "filedetails" });
    		set_store_value(filedetails, $filedetails = _.uniqBy([...loadedfile, ...$filedetails], "filename"), $filedetails);
    	}

    	const writable_props = ['felixfiles', 'normMethod'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GetFileInfoTable> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => plotData({ e });

    	function customiconswitch_toggler_binding(value) {
    		toggleFileDetailsTable = value;
    		$$invalidate(0, toggleFileDetailsTable);
    	}

    	const click_handler_1 = () => savefile({ file: $filedetails, name: "filedetails" });

    	function table_rows_binding(value) {
    		$filedetails = value;
    		filedetails.set($filedetails);
    	}

    	$$self.$$set = $$props => {
    		if ('felixfiles' in $$props) $$invalidate(4, felixfiles = $$props.felixfiles);
    		if ('normMethod' in $$props) $$invalidate(5, normMethod = $$props.normMethod);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		filedetails,
    		opoMode,
    		CustomIconSwitch: CustomIconSwitch$1,
    		Table,
    		savefile,
    		loadfile,
    		get_details_func,
    		felixfiles,
    		normMethod,
    		toggleFileDetailsTable,
    		plotData,
    		loadfiledetails,
    		$filedetails,
    		$opoMode
    	});

    	$$self.$inject_state = $$props => {
    		if ('felixfiles' in $$props) $$invalidate(4, felixfiles = $$props.felixfiles);
    		if ('normMethod' in $$props) $$invalidate(5, normMethod = $$props.normMethod);
    		if ('toggleFileDetailsTable' in $$props) $$invalidate(0, toggleFileDetailsTable = $$props.toggleFileDetailsTable);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		toggleFileDetailsTable,
    		$filedetails,
    		plotData,
    		loadfiledetails,
    		felixfiles,
    		normMethod,
    		click_handler,
    		customiconswitch_toggler_binding,
    		click_handler_1,
    		table_rows_binding
    	];
    }

    class GetFileInfoTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$o, create_fragment$o, safe_not_equal, { felixfiles: 4, normMethod: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GetFileInfoTable",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*felixfiles*/ ctx[4] === undefined && !('felixfiles' in props)) {
    			console.warn("<GetFileInfoTable> was created without expected prop 'felixfiles'");
    		}

    		if (/*normMethod*/ ctx[5] === undefined && !('normMethod' in props)) {
    			console.warn("<GetFileInfoTable> was created without expected prop 'normMethod'");
    		}
    	}

    	get felixfiles() {
    		throw new Error("<GetFileInfoTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set felixfiles(value) {
    		throw new Error("<GetFileInfoTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get normMethod() {
    		throw new Error("<GetFileInfoTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set normMethod(value) {
    		throw new Error("<GetFileInfoTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\normline\widgets\postprocessing\WriteFunctionContents.svelte generated by Svelte v3.42.1 */
    const file$m = "src\\Pages\\normline\\widgets\\postprocessing\\WriteFunctionContents.svelte";

    function create_fragment$n(ctx) {
    	let div;
    	let customselect;
    	let updating_picked;
    	let t0;
    	let textfield;
    	let updating_value;
    	let t1;
    	let customswitch0;
    	let updating_selected;
    	let t2;
    	let customswitch1;
    	let updating_selected_1;
    	let t3;
    	let customswitch2;
    	let updating_selected_2;
    	let t4;
    	let button0;
    	let t6;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[7](value);
    	}

    	let customselect_props = {
    		label: "Output filename",
    		options: /*output_namelists*/ ctx[3]
    	};

    	if (/*$felixOutputName*/ ctx[4] !== void 0) {
    		customselect_props.picked = /*$felixOutputName*/ ctx[4];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[8](value);
    	}

    	let textfield_props = {
    		style: "width:7em; margin:0 0.5em;",
    		label: "writeFileName"
    	};

    	if (/*writeFileName*/ ctx[0] !== void 0) {
    		textfield_props.value = /*writeFileName*/ ctx[0];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	function customswitch0_selected_binding(value) {
    		/*customswitch0_selected_binding*/ ctx[9](value);
    	}

    	let customswitch0_props = { style: "margin: 0 1em;", label: "Write" };

    	if (/*writeFile*/ ctx[1] !== void 0) {
    		customswitch0_props.selected = /*writeFile*/ ctx[1];
    	}

    	customswitch0 = new CustomSwitch$1({
    			props: customswitch0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch0, 'selected', customswitch0_selected_binding));

    	function customswitch1_selected_binding(value) {
    		/*customswitch1_selected_binding*/ ctx[10](value);
    	}

    	let customswitch1_props = {
    		style: "margin: 0 1em;",
    		label: "Overwrite"
    	};

    	if (/*overwrite_expfit*/ ctx[2] !== void 0) {
    		customswitch1_props.selected = /*overwrite_expfit*/ ctx[2];
    	}

    	customswitch1 = new CustomSwitch$1({
    			props: customswitch1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch1, 'selected', customswitch1_selected_binding));

    	function customswitch2_selected_binding(value) {
    		/*customswitch2_selected_binding*/ ctx[11](value);
    	}

    	let customswitch2_props = {
    		style: "margin: 0 1em;",
    		label: "Collect"
    	};

    	if (/*$collectData*/ ctx[5] !== void 0) {
    		customswitch2_props.selected = /*$collectData*/ ctx[5];
    	}

    	customswitch2 = new CustomSwitch$1({
    			props: customswitch2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch2, 'selected', customswitch2_selected_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(customselect.$$.fragment);
    			t0 = space();
    			create_component(textfield.$$.fragment);
    			t1 = space();
    			create_component(customswitch0.$$.fragment);
    			t2 = space();
    			create_component(customswitch1.$$.fragment);
    			t3 = space();
    			create_component(customswitch2.$$.fragment);
    			t4 = space();
    			button0 = element("button");
    			button0.textContent = "Add files";
    			t6 = space();
    			button1 = element("button");
    			button1.textContent = "Remove files";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$m, 20, 4, 995);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$m, 21, 4, 1087);
    			attr_dev(div, "class", "align");
    			add_location(div, file$m, 13, 0, 494);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(customselect, div, null);
    			append_dev(div, t0);
    			mount_component(textfield, div, null);
    			append_dev(div, t1);
    			mount_component(customswitch0, div, null);
    			append_dev(div, t2);
    			mount_component(customswitch1, div, null);
    			append_dev(div, t3);
    			mount_component(customswitch2, div, null);
    			append_dev(div, t4);
    			append_dev(div, button0);
    			append_dev(div, t6);
    			append_dev(div, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[12], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const customselect_changes = {};
    			if (dirty & /*output_namelists*/ 8) customselect_changes.options = /*output_namelists*/ ctx[3];

    			if (!updating_picked && dirty & /*$felixOutputName*/ 16) {
    				updating_picked = true;
    				customselect_changes.picked = /*$felixOutputName*/ ctx[4];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*writeFileName*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*writeFileName*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const customswitch0_changes = {};

    			if (!updating_selected && dirty & /*writeFile*/ 2) {
    				updating_selected = true;
    				customswitch0_changes.selected = /*writeFile*/ ctx[1];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch0.$set(customswitch0_changes);
    			const customswitch1_changes = {};

    			if (!updating_selected_1 && dirty & /*overwrite_expfit*/ 4) {
    				updating_selected_1 = true;
    				customswitch1_changes.selected = /*overwrite_expfit*/ ctx[2];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customswitch1.$set(customswitch1_changes);
    			const customswitch2_changes = {};

    			if (!updating_selected_2 && dirty & /*$collectData*/ 32) {
    				updating_selected_2 = true;
    				customswitch2_changes.selected = /*$collectData*/ ctx[5];
    				add_flush_callback(() => updating_selected_2 = false);
    			}

    			customswitch2.$set(customswitch2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customselect.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(customswitch0.$$.fragment, local);
    			transition_in(customswitch1.$$.fragment, local);
    			transition_in(customswitch2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customselect.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(customswitch0.$$.fragment, local);
    			transition_out(customswitch1.$$.fragment, local);
    			transition_out(customswitch2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customselect);
    			destroy_component(textfield);
    			destroy_component(customswitch0);
    			destroy_component(customswitch1);
    			destroy_component(customswitch2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $felixOutputName;
    	let $collectData;
    	validate_store(felixOutputName, 'felixOutputName');
    	component_subscribe($$self, felixOutputName, $$value => $$invalidate(4, $felixOutputName = $$value));
    	validate_store(collectData, 'collectData');
    	component_subscribe($$self, collectData, $$value => $$invalidate(5, $collectData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WriteFunctionContents', slots, []);
    	let { output_namelists, writeFileName, writeFile, overwrite_expfit } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ['output_namelists', 'writeFileName', 'writeFile', 'overwrite_expfit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WriteFunctionContents> was created with unknown prop '${key}'`);
    	});

    	function customselect_picked_binding(value) {
    		$felixOutputName = value;
    		felixOutputName.set($felixOutputName);
    	}

    	function textfield_value_binding(value) {
    		writeFileName = value;
    		$$invalidate(0, writeFileName);
    	}

    	function customswitch0_selected_binding(value) {
    		writeFile = value;
    		$$invalidate(1, writeFile);
    	}

    	function customswitch1_selected_binding(value) {
    		overwrite_expfit = value;
    		$$invalidate(2, overwrite_expfit);
    	}

    	function customswitch2_selected_binding(value) {
    		$collectData = value;
    		collectData.set($collectData);
    	}

    	const click_handler = () => dispatch("addfile");
    	const click_handler_1 = () => dispatch("removefile");

    	$$self.$$set = $$props => {
    		if ('output_namelists' in $$props) $$invalidate(3, output_namelists = $$props.output_namelists);
    		if ('writeFileName' in $$props) $$invalidate(0, writeFileName = $$props.writeFileName);
    		if ('writeFile' in $$props) $$invalidate(1, writeFile = $$props.writeFile);
    		if ('overwrite_expfit' in $$props) $$invalidate(2, overwrite_expfit = $$props.overwrite_expfit);
    	};

    	$$self.$capture_state = () => ({
    		felixOutputName,
    		collectData,
    		Textfield,
    		CustomSelect: CustomSelect$1,
    		CustomSwitch: CustomSwitch$1,
    		createEventDispatcher,
    		output_namelists,
    		writeFileName,
    		writeFile,
    		overwrite_expfit,
    		dispatch,
    		$felixOutputName,
    		$collectData
    	});

    	$$self.$inject_state = $$props => {
    		if ('output_namelists' in $$props) $$invalidate(3, output_namelists = $$props.output_namelists);
    		if ('writeFileName' in $$props) $$invalidate(0, writeFileName = $$props.writeFileName);
    		if ('writeFile' in $$props) $$invalidate(1, writeFile = $$props.writeFile);
    		if ('overwrite_expfit' in $$props) $$invalidate(2, overwrite_expfit = $$props.overwrite_expfit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		writeFileName,
    		writeFile,
    		overwrite_expfit,
    		output_namelists,
    		$felixOutputName,
    		$collectData,
    		dispatch,
    		customselect_picked_binding,
    		textfield_value_binding,
    		customswitch0_selected_binding,
    		customswitch1_selected_binding,
    		customswitch2_selected_binding,
    		click_handler,
    		click_handler_1
    	];
    }

    class WriteFunctionContents extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			output_namelists: 3,
    			writeFileName: 0,
    			writeFile: 1,
    			overwrite_expfit: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WriteFunctionContents",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*output_namelists*/ ctx[3] === undefined && !('output_namelists' in props)) {
    			console.warn("<WriteFunctionContents> was created without expected prop 'output_namelists'");
    		}

    		if (/*writeFileName*/ ctx[0] === undefined && !('writeFileName' in props)) {
    			console.warn("<WriteFunctionContents> was created without expected prop 'writeFileName'");
    		}

    		if (/*writeFile*/ ctx[1] === undefined && !('writeFile' in props)) {
    			console.warn("<WriteFunctionContents> was created without expected prop 'writeFile'");
    		}

    		if (/*overwrite_expfit*/ ctx[2] === undefined && !('overwrite_expfit' in props)) {
    			console.warn("<WriteFunctionContents> was created without expected prop 'overwrite_expfit'");
    		}
    	}

    	get output_namelists() {
    		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set output_namelists(value) {
    		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get writeFileName() {
    		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set writeFileName(value) {
    		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get writeFile() {
    		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set writeFile(value) {
    		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overwrite_expfit() {
    		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overwrite_expfit(value) {
    		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function NGauss_fit_func({dataFromPython}={}) {

        Plotly.addTraces(get_store_value(graphDiv), dataFromPython["fitted_data"]);
        fittedTraceCount.update(n=>n+1);

        const output_name = get_store_value(felixOutputName);
        const color = output_name === "averaged" ? "#836ac05c" : "#fafafa";

        // dataTable

        let newTable = dataFromPython["fitted_parameter"].map((data)=>{
            let {freq, amp, fwhm, sig} = data;
            return {name: output_name, id:getID(), freq:freq, amp:amp, fwhm:fwhm, sig:sig, color:color}
        
        });

        dataTable.set(_.uniqBy(newTable, "freq"));

        // dataTable_avg
        if(output_name === "averaged") {
            let newTable =dataFromPython["fitted_parameter"].map((data, index)=>{
                let {freq, amp, fwhm, sig} = data;

                return {name: `Line #${index}`, id:getID(), freq:freq, amp:amp, fwhm:fwhm, sig:sig, color:color}

            });
            dataTable_avg.set(_.uniqBy(newTable, "freq"));
            avgfittedLineCount.set(get_store_value(dataTable_avg).length);
        }
    }

    function find_peaks_func({dataFromPython}={}){

        const annotations = dataFromPython[2]["annotations"];

        felixPlotAnnotations.set(annotations);

        const color = annotations["arrowcolor"];
        felixAnnotationColor.set(color);
        Plotly.relayout(get_store_value(graphDiv), { annotations  });

        const [peakX, peakY] = [dataFromPython[0]["data"].x, dataFromPython[0]["data"].y];
        for (let index = 0; index < peakX.length; index++) {
            let [freq, amp, sig] = [peakX[index], peakY[index], get_store_value(Ngauss_sigma)];

            felixPeakTable.update(table => [...table, {freq, amp, sig, id:getID()}]);

        }
        console.log(`Found peaks:\nX: ${peakX}\nY: ${peakY}`);
        console.log("Peaks found");
    }

    function exp_fit_func({dataFromPython}={}) {

        Plotly.addTraces(get_store_value(graphDiv), dataFromPython["fit"]);
        fittedTraceCount.update(n=>n+1);

        expfittedLines.update(lines=>[...lines, ...dataFromPython["line"]]);
        Plotly.relayout(get_store_value(graphDiv), { shapes: get_store_value(expfittedLines) });
        
        let annotations = dataFromPython["annotations"];
        
        felixPlotAnnotations.update(annotate => [...annotate, annotations]);

        Plotly.relayout(get_store_value(graphDiv), { annotations: get_store_value(felixPlotAnnotations) });
        
        let [freq, amp, fwhm, sig] = dataFromPython["table"].split(", ");
        
        let color = "#fafafa";

        const output_name = get_store_value(felixOutputName);
        if (output_name === "averaged") {
            color = "#836ac05c";
            dataTable_avg.update(table=>[...table, {name: `Line #${get_store_value(avgfittedLineCount)}`, id:getID(), freq, amp, fwhm, sig, color}]);
            dataTable_avg.update(table=>_.uniqBy(table, "freq"));
            avgfittedLineCount.update(n=>n+1);

        } else {
            if (get_store_value(collectData)) {
                console.log("Collecting lines");
                expfittedLinesCollectedData.update(data=>[...data, dataFromPython["for_weighted_error"]]);
            }
        }
        let newTable = {name: output_name, id:getID(), freq, amp, fwhm, sig, color};
        dataTable.update(table=>_.uniqBy([...table, newTable], "freq"));

        console.log("Line fitted");

    }

    function get_err_func({dataFromPython}={}) {

        let {freq, amp, fwhm, sig } = dataFromPython;
        let data1 = {name: "unweighted_mean", id:getID(), freq:freq.mean, amp:amp.mean, fwhm:fwhm.mean, sig:sig.mean, color:"#f14668"};

        let data2 = {name: "weighted_mean", id:getID(), freq:freq.wmean, amp:amp.wmean, fwhm:fwhm.wmean, sig:sig.wmean, color:"#2098d1"};

        dataTable.update(table => [...table, data1, data2]);
        dataTable_avg.update(table => [...table, data1, data2]);

        console.log("Weighted fit.");

    }

    /* src\Pages\normline\widgets\postprocessing\ExecuteFunctionContents.svelte generated by Svelte v3.42.1 */

    const { console: console_1$a } = globals;
    const file$l = "src\\Pages\\normline\\widgets\\postprocessing\\ExecuteFunctionContents.svelte";

    // (225:0) {#if toggleFindPeaksRow}
    function create_if_block$d(ctx) {
    	let div2;
    	let div0;
    	let customswitch;
    	let updating_selected;
    	let t0;
    	let textfield0;
    	let updating_value;
    	let t1;
    	let textfield1;
    	let updating_value_1;
    	let t2;
    	let textfield2;
    	let updating_value_2;
    	let t3;
    	let textfield3;
    	let updating_value_3;
    	let t4;
    	let button0;
    	let t6;
    	let div1;
    	let icon;
    	let t7;
    	let button1;
    	let t9;
    	let textfield4;
    	let updating_value_4;
    	let t10;
    	let button2;
    	let t12;
    	let button3;
    	let t14;
    	let button4;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function customswitch_selected_binding(value) {
    		/*customswitch_selected_binding*/ ctx[29](value);
    	}

    	let customswitch_props = {
    		style: "margin: 0 1em;",
    		label: "BoxSelected"
    	};

    	if (/*boxSelected_peakfinder*/ ctx[2] !== void 0) {
    		customswitch_props.selected = /*boxSelected_peakfinder*/ ctx[2];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[30](value);
    	}

    	let textfield0_props = {
    		type: "number",
    		style: style$2,
    		step: "0.5",
    		label: "Prominance"
    	};

    	if (/*peak_prominence*/ ctx[6] !== void 0) {
    		textfield0_props.value = /*peak_prominence*/ ctx[6];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[31](value);
    	}

    	let textfield1_props = {
    		type: "number",
    		style: style$2,
    		step: "0.5",
    		label: "Width"
    	};

    	if (/*peak_width*/ ctx[5] !== void 0) {
    		textfield1_props.value = /*peak_width*/ ctx[5];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[32](value);
    	}

    	let textfield2_props = {
    		type: "number",
    		style: style$2,
    		step: "0.1",
    		label: "Height"
    	};

    	if (/*peak_height*/ ctx[4] !== void 0) {
    		textfield2_props.value = /*peak_height*/ ctx[4];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[33](value);
    	}

    	let textfield3_props = { style: "width:9em", label: "Sigma" };

    	if (/*$Ngauss_sigma*/ ctx[12] !== void 0) {
    		textfield3_props.value = /*$Ngauss_sigma*/ ctx[12];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler_5*/ ctx[35]);

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[37](value);
    	}

    	let textfield4_props = {
    		style: "" + (style$2 + "; margin-bottom: 0.5em; margin-left: 1em; margin-right: 1em;"),
    		label: "savefile"
    	};

    	if (/*savePeakfilename*/ ctx[8] !== void 0) {
    		textfield4_props.value = /*savePeakfilename*/ ctx[8];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(customswitch.$$.fragment);
    			t0 = space();
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(textfield2.$$.fragment);
    			t3 = space();
    			create_component(textfield3.$$.fragment);
    			t4 = space();
    			button0 = element("button");
    			button0.textContent = "Get Peaks";
    			t6 = space();
    			div1 = element("div");
    			create_component(icon.$$.fragment);
    			t7 = space();
    			button1 = element("button");
    			button1.textContent = "Fit";
    			t9 = space();
    			create_component(textfield4.$$.fragment);
    			t10 = space();
    			button2 = element("button");
    			button2.textContent = "Save peaks";
    			t12 = space();
    			button3 = element("button");
    			button3.textContent = "Load peaks";
    			t14 = space();
    			button4 = element("button");
    			button4.textContent = "Clear";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$l, 235, 12, 10248);
    			attr_dev(div0, "class", "align");
    			add_location(div0, file$l, 227, 8, 9701);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$l, 240, 12, 10521);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$l, 242, 12, 10784);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$l, 243, 12, 10921);
    			attr_dev(button4, "class", "button is-danger");
    			add_location(button4, file$l, 245, 12, 11014);
    			attr_dev(div1, "class", "align");
    			add_location(div1, file$l, 238, 8, 10390);
    			add_location(div2, file$l, 226, 4, 9670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(customswitch, div0, null);
    			append_dev(div0, t0);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t1);
    			mount_component(textfield1, div0, null);
    			append_dev(div0, t2);
    			mount_component(textfield2, div0, null);
    			append_dev(div0, t3);
    			mount_component(textfield3, div0, null);
    			append_dev(div0, t4);
    			append_dev(div0, button0);
    			append_dev(div2, t6);
    			append_dev(div2, div1);
    			mount_component(icon, div1, null);
    			append_dev(div1, t7);
    			append_dev(div1, button1);
    			append_dev(div1, t9);
    			mount_component(textfield4, div1, null);
    			append_dev(div1, t10);
    			append_dev(div1, button2);
    			append_dev(div1, t12);
    			append_dev(div1, button3);
    			append_dev(div1, t14);
    			append_dev(div1, button4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_4*/ ctx[34], false, false, false),
    					listen_dev(button1, "click", /*click_handler_6*/ ctx[36], false, false, false),
    					listen_dev(button2, "click", /*click_handler_7*/ ctx[38], false, false, false),
    					listen_dev(button3, "click", /*loadpeakTable*/ ctx[15], false, false, false),
    					listen_dev(button4, "click", /*click_handler_8*/ ctx[39], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const customswitch_changes = {};

    			if (!updating_selected && dirty[0] & /*boxSelected_peakfinder*/ 4) {
    				updating_selected = true;
    				customswitch_changes.selected = /*boxSelected_peakfinder*/ ctx[2];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*peak_prominence*/ 64) {
    				updating_value = true;
    				textfield0_changes.value = /*peak_prominence*/ ctx[6];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*peak_width*/ 32) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*peak_width*/ ctx[5];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*peak_height*/ 16) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*peak_height*/ ctx[4];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty[0] & /*$Ngauss_sigma*/ 4096) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*$Ngauss_sigma*/ ctx[12];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const icon_changes = {};

    			if (dirty[1] & /*$$scope*/ 131072) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty[0] & /*savePeakfilename*/ 256) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*savePeakfilename*/ ctx[8];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customswitch.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customswitch.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(customswitch);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(icon);
    			destroy_component(textfield4);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(225:0) {#if toggleFindPeaksRow}",
    		ctx
    	});

    	return block;
    }

    // (240:12) <Icon class="material-icons" on:click="{()=> modalActivate = true}">
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("settings");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(240:12) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=> modalActivate = true}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let t7;
    	let button4;
    	let t9;
    	let button5;
    	let t11;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*toggleFindPeaksRow*/ ctx[7] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Exp Fit.";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Fit NGauss.";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "Clear Last";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "Clear All";
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "Weighted Mean";
    			t9 = space();
    			button5 = element("button");
    			button5.textContent = "Reset";
    			t11 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$l, 213, 4, 8932);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$l, 214, 4, 9040);
    			attr_dev(button2, "class", "button is-warning");
    			add_location(button2, file$l, 215, 4, 9155);
    			attr_dev(button3, "class", "button is-danger");
    			add_location(button3, file$l, 216, 4, 9239);
    			attr_dev(button4, "class", "button is-link");
    			add_location(button4, file$l, 217, 4, 9320);
    			attr_dev(button5, "class", "button is-warning");
    			add_location(button5, file$l, 218, 4, 9433);
    			attr_dev(div, "class", "align");
    			add_location(div, file$l, 212, 0, 8907);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);
    			append_dev(div, t5);
    			append_dev(div, button3);
    			append_dev(div, t7);
    			append_dev(div, button4);
    			append_dev(div, t9);
    			append_dev(div, button5);
    			insert_dev(target, t11, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[25], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[26], false, false, false),
    					listen_dev(button2, "click", /*clearLastPeak*/ ctx[14], false, false, false),
    					listen_dev(button3, "click", /*clearAllPeak*/ ctx[13], false, false, false),
    					listen_dev(button4, "click", /*click_handler_2*/ ctx[27], false, false, false),
    					listen_dev(button5, "click", /*click_handler_3*/ ctx[28], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*toggleFindPeaksRow*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*toggleFindPeaksRow*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t11);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const style$2 = "width:7em; height:3.5em; margin-right:0.5em";

    function instance$m($$self, $$props, $$invalidate) {
    	let $felixPeakTable;
    	let $expfittedLinesCollectedData;
    	let $felixopoLocation;
    	let $felixOutputName;
    	let $felixIndex;
    	let $felixPlotAnnotations;
    	let $graphDiv;
    	let $felixAnnotationColor;
    	let $fittedTraceCount;
    	let $expfittedLines;
    	let $dataTable;
    	let $Ngauss_sigma;
    	validate_store(felixPeakTable, 'felixPeakTable');
    	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(1, $felixPeakTable = $$value));
    	validate_store(expfittedLinesCollectedData, 'expfittedLinesCollectedData');
    	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(9, $expfittedLinesCollectedData = $$value));
    	validate_store(felixopoLocation, 'felixopoLocation');
    	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(40, $felixopoLocation = $$value));
    	validate_store(felixOutputName, 'felixOutputName');
    	component_subscribe($$self, felixOutputName, $$value => $$invalidate(41, $felixOutputName = $$value));
    	validate_store(felixIndex, 'felixIndex');
    	component_subscribe($$self, felixIndex, $$value => $$invalidate(42, $felixIndex = $$value));
    	validate_store(felixPlotAnnotations, 'felixPlotAnnotations');
    	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(10, $felixPlotAnnotations = $$value));
    	validate_store(graphDiv, 'graphDiv');
    	component_subscribe($$self, graphDiv, $$value => $$invalidate(11, $graphDiv = $$value));
    	validate_store(felixAnnotationColor, 'felixAnnotationColor');
    	component_subscribe($$self, felixAnnotationColor, $$value => $$invalidate(43, $felixAnnotationColor = $$value));
    	validate_store(fittedTraceCount, 'fittedTraceCount');
    	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(44, $fittedTraceCount = $$value));
    	validate_store(expfittedLines, 'expfittedLines');
    	component_subscribe($$self, expfittedLines, $$value => $$invalidate(45, $expfittedLines = $$value));
    	validate_store(dataTable, 'dataTable');
    	component_subscribe($$self, dataTable, $$value => $$invalidate(46, $dataTable = $$value));
    	validate_store(Ngauss_sigma, 'Ngauss_sigma');
    	component_subscribe($$self, Ngauss_sigma, $$value => $$invalidate(12, $Ngauss_sigma = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ExecuteFunctionContents', slots, []);
    	let { addedFileScale, addedFileCol, normMethod, writeFileName, writeFile, overwrite_expfit, fullfiles, modalActivate = false, adjustPeakTrigger = false } = $$props;
    	let boxSelected_peakfinder = false, NGauss_fit_args = {};
    	let peak_height = 1, peak_width = 3, peak_prominence = 0;
    	let toggleFindPeaksRow = false, savePeakfilename = "peakTable";

    	const clearAllPeak = () => {
    		if ($fittedTraceCount === 0) {
    			return window.createToast("No fitted lines found", "danger");
    		}

    		console.log("Removing all found peak values");
    		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = set_store_value(felixIndex, $felixIndex = set_store_value(expfittedLines, $expfittedLines = set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), $expfittedLines), $felixIndex), $felixPlotAnnotations);
    		Plotly.relayout($graphDiv, { annotations: [], shapes: [] });

    		for (let i = 0; i < $fittedTraceCount; i++) {
    			Plotly.deleteTraces($graphDiv, [-1]);
    		}

    		set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount);
    	};

    	const clearLastPeak = () => {
    		if ($fittedTraceCount === 0) {
    			return window.createToast("No fitted lines found", "danger");
    		}

    		plotData({
    			filetype: "general",
    			general: {
    				args: [$felixOutputName, $felixopoLocation, normMethod],
    				pyfile: "delete_fileLines.py"
    			}
    		});

    		set_store_value(dataTable, $dataTable = _.dropRight($dataTable, 1), $dataTable);
    		set_store_value(expfittedLines, $expfittedLines = _.dropRight($expfittedLines, 2), $expfittedLines);
    		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = _.dropRight($felixPlotAnnotations, 1), $felixPlotAnnotations);
    		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = _.dropRight($expfittedLinesCollectedData, 1), $expfittedLinesCollectedData);

    		Plotly.relayout($graphDiv, {
    			annotations: $felixPlotAnnotations,
    			shapes: $expfittedLines
    		});

    		Plotly.deleteTraces($graphDiv, [-1]);
    		console.log("Last fitted peak removed");
    		set_store_value(fittedTraceCount, $fittedTraceCount--, $fittedTraceCount);
    	};

    	function loadpeakTable() {
    		const loadedfile = loadfile({ name: savePeakfilename });
    		set_store_value(felixPeakTable, $felixPeakTable = _.uniqBy([...loadedfile, ...$felixPeakTable], "freq"), $felixPeakTable);
    		adjustPeak();
    	}

    	function adjustPeak({ closeMainModal = true } = {}) {
    		set_store_value(felixPeakTable, $felixPeakTable = _.filter($felixPeakTable, tb => tb.sig != 0), $felixPeakTable);
    		set_store_value(felixPeakTable, $felixPeakTable = _.sortBy($felixPeakTable, [o => o["freq"]]), $felixPeakTable);

    		let temp_annotate = {
    			xref: "x",
    			y: "y",
    			"showarrow": true,
    			"arrowhead": 2,
    			"ax": -25,
    			"ay": -40,
    			font: { color: $felixAnnotationColor },
    			arrowcolor: $felixAnnotationColor
    		};

    		set_store_value(
    			felixPlotAnnotations,
    			$felixPlotAnnotations = $felixPeakTable.map(f => {
    				const { freq, amp } = f;
    				const x = parseFloat(freq);
    				const y = parseFloat(amp);

    				let _annotate = {
    					x,
    					y,
    					text: `(${x.toFixed(2)}, ${y.toFixed(2)})`
    				};

    				return { ...temp_annotate, ..._annotate };
    			}),
    			$felixPlotAnnotations
    		);

    		if (closeMainModal) {
    			($$invalidate(0, modalActivate = false), window.createToast("Initial guess adjusted for full spectrum fitting"));
    		}

    		Plotly.relayout($graphDiv, { annotations: $felixPlotAnnotations });
    		$$invalidate(17, adjustPeakTrigger = false);
    	}

    	

    	function plotData({ e = null, filetype = "exp_fit", general = {} } = {}) {
    		if (filetype == "general") {
    			const { pyfile, args } = general;

    			computePy_func({ pyfile, args, general: true }).catch(error => {
    				window.handleError(error);
    			});

    			return;
    		}

    		let pyfile = "", args;
    		let expfit_args = [], find_peaks_args = {};

    		switch (filetype) {
    			case "exp_fit":
    				if ($felixIndex.length < 2) {
    					return window.createToast("Range not found!!. Select a range using Box-select", "danger");
    				}
    				expfit_args = {
    					addedFileScale,
    					addedFileCol,
    					output_name: $felixOutputName,
    					overwrite_expfit,
    					writeFile,
    					writeFileName,
    					normMethod,
    					index: $felixIndex,
    					fullfiles,
    					location: $felixopoLocation
    				};
    				(pyfile = "exp_gauss_fit.py", args = [JSON.stringify(expfit_args)]);
    				computePy_func({ e, pyfile, args }).then(dataFromPython => {
    					exp_fit_func({ dataFromPython });
    					window.createToast("Line fitted with gaussian function", "success");
    				}).catch(error => {
    					window.handleError(error);
    				});
    				break;
    			case "NGauss_fit":
    				if (boxSelected_peakfinder) {
    					if ($felixIndex.length < 2) {
    						return window.createToast("Box selection is turned ON so please select a wn. range to fit", "danger");
    					}

    					$$invalidate(3, NGauss_fit_args.index = $felixIndex, NGauss_fit_args);
    				} else {
    					delete NGauss_fit_args.index;
    				}
    				if ($felixPeakTable.length === 0) {
    					return window.createToast("No arguments initialised yet.", "danger");
    				}
    				$$invalidate(3, NGauss_fit_args.fitNGauss_arguments = {}, NGauss_fit_args);
    				set_store_value(felixPeakTable, $felixPeakTable = _.sortBy($felixPeakTable, [o => o["freq"]]), $felixPeakTable);
    				$felixPeakTable.forEach((f, index) => {
    					$$invalidate(3, NGauss_fit_args.fitNGauss_arguments[`cen${index}`] = f.freq, NGauss_fit_args);
    					$$invalidate(3, NGauss_fit_args.fitNGauss_arguments[`A${index}`] = f.amp, NGauss_fit_args);
    					$$invalidate(3, NGauss_fit_args.fitNGauss_arguments[`sigma${index}`] = f.sig, NGauss_fit_args);
    				});
    				$$invalidate(3, NGauss_fit_args = {
    					...NGauss_fit_args,
    					location: $felixopoLocation,
    					addedFileScale,
    					addedFileCol,
    					overwrite_expfit,
    					writeFile,
    					writeFileName,
    					output_name: $felixOutputName,
    					fullfiles,
    					normMethod
    				});
    				(pyfile = "multiGauss.py", args = [JSON.stringify(NGauss_fit_args)]);
    				computePy_func({ e, pyfile, args }).then(dataFromPython => {
    					NGauss_fit_func({ dataFromPython });
    					console.log("Line fitted");
    					window.createToast(`Line fitted with ${dataFromPython["fitted_parameter"].length} gaussian function`, "success");
    				}).catch(error => {
    					window.handleError(error);
    				});
    				break;
    			case "find_peaks":
    				set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable);
    				if ($felixIndex.length < 2 && boxSelected_peakfinder) {
    					return window.createToast("Box selection is turned ON so please select a wn. range to fit", "danger");
    				}
    				let selectedIndex = boxSelected_peakfinder ? $felixIndex : [0, 0];
    				find_peaks_args = {
    					addedFileScale,
    					addedFileCol,
    					output_name: $felixOutputName,
    					normMethod,
    					peak_prominence,
    					peak_width,
    					peak_height,
    					selectedIndex,
    					fullfiles,
    					location: $felixopoLocation
    				};
    				(pyfile = "fit_all.py", args = [JSON.stringify(find_peaks_args)]);
    				computePy_func({ e, pyfile, args }).then(dataFromPython => {
    					find_peaks_func({ dataFromPython });
    					console.log(`felixPeakTable:`, $felixPeakTable);
    					window.createToast("Peaks found", "success");
    				}).catch(error => {
    					window.handleError(error);
    				});
    				break;
    			case "get_err":
    				if ($expfittedLinesCollectedData.length < 2) return window.createToast("Not sufficient lines collected!", "danger");
    				(pyfile = "weighted_error.py", args = $expfittedLinesCollectedData);
    				computePy_func({ e, pyfile, args }).then(dataFromPython => {
    					get_err_func({ dataFromPython });
    					window.createToast("Weighted fit. done", "success");
    				}).catch(error => {
    					window.handleError(error);
    				});
    				break;
    		}
    	}

    	const writable_props = [
    		'addedFileScale',
    		'addedFileCol',
    		'normMethod',
    		'writeFileName',
    		'writeFile',
    		'overwrite_expfit',
    		'fullfiles',
    		'modalActivate',
    		'adjustPeakTrigger'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$a.warn(`<ExecuteFunctionContents> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => plotData({ e, filetype: "exp_fit" });
    	const click_handler_1 = () => $$invalidate(7, toggleFindPeaksRow = !toggleFindPeaksRow);
    	const click_handler_2 = e => plotData({ e, filetype: "get_err" });

    	const click_handler_3 = () => {
    		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData);
    		window.createToast("Line collection restted", "warning");
    	};

    	function customswitch_selected_binding(value) {
    		boxSelected_peakfinder = value;
    		$$invalidate(2, boxSelected_peakfinder);
    	}

    	function textfield0_value_binding(value) {
    		peak_prominence = value;
    		$$invalidate(6, peak_prominence);
    	}

    	function textfield1_value_binding(value) {
    		peak_width = value;
    		$$invalidate(5, peak_width);
    	}

    	function textfield2_value_binding(value) {
    		peak_height = value;
    		$$invalidate(4, peak_height);
    	}

    	function textfield3_value_binding(value) {
    		$Ngauss_sigma = value;
    		Ngauss_sigma.set($Ngauss_sigma);
    	}

    	const click_handler_4 = e => plotData({ e, filetype: "find_peaks" });
    	const click_handler_5 = () => $$invalidate(0, modalActivate = true);
    	const click_handler_6 = e => plotData({ e, filetype: "NGauss_fit" });

    	function textfield4_value_binding(value) {
    		savePeakfilename = value;
    		$$invalidate(8, savePeakfilename);
    	}

    	const click_handler_7 = () => savefile({
    		file: $felixPeakTable,
    		name: savePeakfilename
    	});

    	const click_handler_8 = () => {
    		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations);
    		set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable);
    		$$invalidate(3, NGauss_fit_args = {});
    		Plotly.relayout($graphDiv, { annotations: [] });
    		window.createToast("Cleared", "warning");
    	};

    	$$self.$$set = $$props => {
    		if ('addedFileScale' in $$props) $$invalidate(18, addedFileScale = $$props.addedFileScale);
    		if ('addedFileCol' in $$props) $$invalidate(19, addedFileCol = $$props.addedFileCol);
    		if ('normMethod' in $$props) $$invalidate(20, normMethod = $$props.normMethod);
    		if ('writeFileName' in $$props) $$invalidate(21, writeFileName = $$props.writeFileName);
    		if ('writeFile' in $$props) $$invalidate(22, writeFile = $$props.writeFile);
    		if ('overwrite_expfit' in $$props) $$invalidate(23, overwrite_expfit = $$props.overwrite_expfit);
    		if ('fullfiles' in $$props) $$invalidate(24, fullfiles = $$props.fullfiles);
    		if ('modalActivate' in $$props) $$invalidate(0, modalActivate = $$props.modalActivate);
    		if ('adjustPeakTrigger' in $$props) $$invalidate(17, adjustPeakTrigger = $$props.adjustPeakTrigger);
    	};

    	$$self.$capture_state = () => ({
    		fittedTraceCount,
    		felixPlotAnnotations,
    		felixIndex,
    		expfittedLines,
    		expfittedLinesCollectedData,
    		graphDiv,
    		dataTable,
    		Ngauss_sigma,
    		felixOutputName,
    		felixPeakTable,
    		felixopoLocation,
    		felixAnnotationColor,
    		mainPreModal,
    		Textfield,
    		CustomSwitch: CustomSwitch$1,
    		Icon,
    		AdjustInitialGuess,
    		savefile,
    		loadfile,
    		fade,
    		NGauss_fit_func,
    		find_peaks_func,
    		exp_fit_func,
    		get_err_func,
    		addedFileScale,
    		addedFileCol,
    		normMethod,
    		writeFileName,
    		writeFile,
    		overwrite_expfit,
    		fullfiles,
    		modalActivate,
    		adjustPeakTrigger,
    		boxSelected_peakfinder,
    		NGauss_fit_args,
    		peak_height,
    		peak_width,
    		peak_prominence,
    		toggleFindPeaksRow,
    		savePeakfilename,
    		style: style$2,
    		clearAllPeak,
    		clearLastPeak,
    		loadpeakTable,
    		adjustPeak,
    		plotData,
    		$felixPeakTable,
    		$expfittedLinesCollectedData,
    		$felixopoLocation,
    		$felixOutputName,
    		$felixIndex,
    		$felixPlotAnnotations,
    		$graphDiv,
    		$felixAnnotationColor,
    		$fittedTraceCount,
    		$expfittedLines,
    		$dataTable,
    		$Ngauss_sigma
    	});

    	$$self.$inject_state = $$props => {
    		if ('addedFileScale' in $$props) $$invalidate(18, addedFileScale = $$props.addedFileScale);
    		if ('addedFileCol' in $$props) $$invalidate(19, addedFileCol = $$props.addedFileCol);
    		if ('normMethod' in $$props) $$invalidate(20, normMethod = $$props.normMethod);
    		if ('writeFileName' in $$props) $$invalidate(21, writeFileName = $$props.writeFileName);
    		if ('writeFile' in $$props) $$invalidate(22, writeFile = $$props.writeFile);
    		if ('overwrite_expfit' in $$props) $$invalidate(23, overwrite_expfit = $$props.overwrite_expfit);
    		if ('fullfiles' in $$props) $$invalidate(24, fullfiles = $$props.fullfiles);
    		if ('modalActivate' in $$props) $$invalidate(0, modalActivate = $$props.modalActivate);
    		if ('adjustPeakTrigger' in $$props) $$invalidate(17, adjustPeakTrigger = $$props.adjustPeakTrigger);
    		if ('boxSelected_peakfinder' in $$props) $$invalidate(2, boxSelected_peakfinder = $$props.boxSelected_peakfinder);
    		if ('NGauss_fit_args' in $$props) $$invalidate(3, NGauss_fit_args = $$props.NGauss_fit_args);
    		if ('peak_height' in $$props) $$invalidate(4, peak_height = $$props.peak_height);
    		if ('peak_width' in $$props) $$invalidate(5, peak_width = $$props.peak_width);
    		if ('peak_prominence' in $$props) $$invalidate(6, peak_prominence = $$props.peak_prominence);
    		if ('toggleFindPeaksRow' in $$props) $$invalidate(7, toggleFindPeaksRow = $$props.toggleFindPeaksRow);
    		if ('savePeakfilename' in $$props) $$invalidate(8, savePeakfilename = $$props.savePeakfilename);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$felixPeakTable*/ 2) {
    			set_store_value(
    				felixPeakTable,
    				$felixPeakTable = $felixPeakTable.map(f => {
    					let { freq, amp, sig, id } = f;
    					freq = parseFloat(freq);
    					amp = parseFloat(amp);
    					sig = parseFloat(sig);
    					return { freq, amp, sig, id };
    				}),
    				$felixPeakTable
    			);
    		}

    		if ($$self.$$.dirty[0] & /*adjustPeakTrigger*/ 131072) {
    			if (adjustPeakTrigger) adjustPeak();
    		}
    	};

    	return [
    		modalActivate,
    		$felixPeakTable,
    		boxSelected_peakfinder,
    		NGauss_fit_args,
    		peak_height,
    		peak_width,
    		peak_prominence,
    		toggleFindPeaksRow,
    		savePeakfilename,
    		$expfittedLinesCollectedData,
    		$felixPlotAnnotations,
    		$graphDiv,
    		$Ngauss_sigma,
    		clearAllPeak,
    		clearLastPeak,
    		loadpeakTable,
    		plotData,
    		adjustPeakTrigger,
    		addedFileScale,
    		addedFileCol,
    		normMethod,
    		writeFileName,
    		writeFile,
    		overwrite_expfit,
    		fullfiles,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		customswitch_selected_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		textfield3_value_binding,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		textfield4_value_binding,
    		click_handler_7,
    		click_handler_8
    	];
    }

    class ExecuteFunctionContents extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$m,
    			create_fragment$m,
    			safe_not_equal,
    			{
    				addedFileScale: 18,
    				addedFileCol: 19,
    				normMethod: 20,
    				writeFileName: 21,
    				writeFile: 22,
    				overwrite_expfit: 23,
    				fullfiles: 24,
    				modalActivate: 0,
    				adjustPeakTrigger: 17
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExecuteFunctionContents",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*addedFileScale*/ ctx[18] === undefined && !('addedFileScale' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'addedFileScale'");
    		}

    		if (/*addedFileCol*/ ctx[19] === undefined && !('addedFileCol' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'addedFileCol'");
    		}

    		if (/*normMethod*/ ctx[20] === undefined && !('normMethod' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'normMethod'");
    		}

    		if (/*writeFileName*/ ctx[21] === undefined && !('writeFileName' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'writeFileName'");
    		}

    		if (/*writeFile*/ ctx[22] === undefined && !('writeFile' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'writeFile'");
    		}

    		if (/*overwrite_expfit*/ ctx[23] === undefined && !('overwrite_expfit' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'overwrite_expfit'");
    		}

    		if (/*fullfiles*/ ctx[24] === undefined && !('fullfiles' in props)) {
    			console_1$a.warn("<ExecuteFunctionContents> was created without expected prop 'fullfiles'");
    		}
    	}

    	get addedFileScale() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedFileScale(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addedFileCol() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addedFileCol(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get normMethod() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set normMethod(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get writeFileName() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set writeFileName(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get writeFile() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set writeFile(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overwrite_expfit() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overwrite_expfit(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullfiles() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullfiles(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalActivate() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalActivate(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get adjustPeakTrigger() {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set adjustPeakTrigger(value) {
    		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function init_tour_normline({filetype="felix"}={}) {
            
        const intro = introJs();
        intro.setOptions({

            steps: [

                {
                    element: document.getElementById(`${filetype}_filebrowser_btn`),
                    intro: "Browse file location folder"
                },
                {
                    element: document.getElementById(`${filetype}_filebrowser`),
                    intro: "Select file(s) here", position:"right"
                },
                {
                    element: document.getElementById('create_baseline_btn'),
                    intro: "Create/ajusting baseline"
                },
                {
                    element: document.getElementById('felix_plotting_btn'),
                    intro: "After creating baseline -> Plot the graph (NOTE: .pow file should be already present in DATA folder)"
                },

            ], showProgress: true, showBullets:false
          
        });

        console.log("Starting introduction tour");
        intro.start();

        intro.onbeforeexit(function() {
            console.log("introduction tour exited");

            // return false; // returning false means don't exit the intro
        
        });

        intro.onbeforechange(function(targetElement) {
            console.log("before new step",targetElement);
        });

        intro.onafterchange(function(targetElement) {
            console.log("after new step",targetElement);
        });

        intro.oncomplete(function() {
            console.log("introduction tour completed");
        });
    }

    /* src\Pages\Normline.svelte generated by Svelte v3.42.1 */

    const { console: console_1$9 } = globals;
    const file$k = "src\\Pages\\Normline.svelte";

    // (130:4) <svelte:fragment slot="buttonContainer">
    function create_buttonContainer_slot$3(ctx) {
    	let initfunctionrow;
    	let updating_graphPlotted;
    	let updating_show_theoryplot;
    	let t0;
    	let oporow;
    	let updating_OPOLocation;
    	let updating_OPOfilesChecked;
    	let updating_opofiles;
    	let updating_graphPlotted_1;
    	let t1;
    	let theoryrow;
    	let updating_theoryLocation;
    	let updating_show_theoryplot_1;
    	let t2;
    	let div;
    	let customradio;
    	let updating_selected;
    	let current;

    	function initfunctionrow_graphPlotted_binding(value) {
    		/*initfunctionrow_graphPlotted_binding*/ ctx[56](value);
    	}

    	function initfunctionrow_show_theoryplot_binding(value) {
    		/*initfunctionrow_show_theoryplot_binding*/ ctx[57](value);
    	}

    	let initfunctionrow_props = {
    		removeExtraFile: /*removeExtraFile*/ ctx[33],
    		opofiles: /*opofiles*/ ctx[4],
    		felixfiles: /*felixfiles*/ ctx[7],
    		normMethod: /*$normMethod*/ ctx[30],
    		theoryLocation: /*theoryLocation*/ ctx[11],
    		updateConfig: /*updateConfig*/ ctx[26]
    	};

    	if (/*graphPlotted*/ ctx[12] !== void 0) {
    		initfunctionrow_props.graphPlotted = /*graphPlotted*/ ctx[12];
    	}

    	if (/*show_theoryplot*/ ctx[10] !== void 0) {
    		initfunctionrow_props.show_theoryplot = /*show_theoryplot*/ ctx[10];
    	}

    	initfunctionrow = new InitFunctionRow({
    			props: initfunctionrow_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(initfunctionrow, 'graphPlotted', initfunctionrow_graphPlotted_binding));
    	binding_callbacks.push(() => bind(initfunctionrow, 'show_theoryplot', initfunctionrow_show_theoryplot_binding));

    	function oporow_OPOLocation_binding(value) {
    		/*oporow_OPOLocation_binding*/ ctx[58](value);
    	}

    	function oporow_OPOfilesChecked_binding(value) {
    		/*oporow_OPOfilesChecked_binding*/ ctx[59](value);
    	}

    	function oporow_opofiles_binding(value) {
    		/*oporow_opofiles_binding*/ ctx[60](value);
    	}

    	function oporow_graphPlotted_binding(value) {
    		/*oporow_graphPlotted_binding*/ ctx[61](value);
    	}

    	let oporow_props = {
    		removeExtraFile: /*removeExtraFile*/ ctx[33],
    		updateConfig: /*updateConfig*/ ctx[26]
    	};

    	if (/*OPOLocation*/ ctx[3] !== void 0) {
    		oporow_props.OPOLocation = /*OPOLocation*/ ctx[3];
    	}

    	if (/*OPOfilesChecked*/ ctx[2] !== void 0) {
    		oporow_props.OPOfilesChecked = /*OPOfilesChecked*/ ctx[2];
    	}

    	if (/*opofiles*/ ctx[4] !== void 0) {
    		oporow_props.opofiles = /*opofiles*/ ctx[4];
    	}

    	if (/*graphPlotted*/ ctx[12] !== void 0) {
    		oporow_props.graphPlotted = /*graphPlotted*/ ctx[12];
    	}

    	oporow = new OPORow({ props: oporow_props, $$inline: true });
    	binding_callbacks.push(() => bind(oporow, 'OPOLocation', oporow_OPOLocation_binding));
    	binding_callbacks.push(() => bind(oporow, 'OPOfilesChecked', oporow_OPOfilesChecked_binding));
    	binding_callbacks.push(() => bind(oporow, 'opofiles', oporow_opofiles_binding));
    	binding_callbacks.push(() => bind(oporow, 'graphPlotted', oporow_graphPlotted_binding));

    	function theoryrow_theoryLocation_binding(value) {
    		/*theoryrow_theoryLocation_binding*/ ctx[62](value);
    	}

    	function theoryrow_show_theoryplot_binding(value) {
    		/*theoryrow_show_theoryplot_binding*/ ctx[63](value);
    	}

    	let theoryrow_props = {
    		normMethod: /*$normMethod*/ ctx[30],
    		updateConfig: /*updateConfig*/ ctx[26]
    	};

    	if (/*theoryLocation*/ ctx[11] !== void 0) {
    		theoryrow_props.theoryLocation = /*theoryLocation*/ ctx[11];
    	}

    	if (/*show_theoryplot*/ ctx[10] !== void 0) {
    		theoryrow_props.show_theoryplot = /*show_theoryplot*/ ctx[10];
    	}

    	theoryrow = new TheoryRow({ props: theoryrow_props, $$inline: true });
    	binding_callbacks.push(() => bind(theoryrow, 'theoryLocation', theoryrow_theoryLocation_binding));
    	binding_callbacks.push(() => bind(theoryrow, 'show_theoryplot', theoryrow_show_theoryplot_binding));

    	function customradio_selected_binding(value) {
    		/*customradio_selected_binding*/ ctx[64](value);
    	}

    	let customradio_props = {
    		options: ["Log", "Relative", "IntensityPerPhoton"]
    	};

    	if (/*$normMethod*/ ctx[30] !== void 0) {
    		customradio_props.selected = /*$normMethod*/ ctx[30];
    	}

    	customradio = new CustomRadio({ props: customradio_props, $$inline: true });
    	binding_callbacks.push(() => bind(customradio, 'selected', customradio_selected_binding));
    	customradio.$on("change", /*replot*/ ctx[32]);

    	const block = {
    		c: function create() {
    			create_component(initfunctionrow.$$.fragment);
    			t0 = space();
    			create_component(oporow.$$.fragment);
    			t1 = space();
    			create_component(theoryrow.$$.fragment);
    			t2 = space();
    			div = element("div");
    			create_component(customradio.$$.fragment);
    			attr_dev(div, "class", "align");
    			add_location(div, file$k, 134, 8, 6121);
    		},
    		m: function mount(target, anchor) {
    			mount_component(initfunctionrow, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(oporow, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(theoryrow, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(customradio, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const initfunctionrow_changes = {};
    			if (dirty[0] & /*opofiles*/ 16) initfunctionrow_changes.opofiles = /*opofiles*/ ctx[4];
    			if (dirty[0] & /*felixfiles*/ 128) initfunctionrow_changes.felixfiles = /*felixfiles*/ ctx[7];
    			if (dirty[0] & /*$normMethod*/ 1073741824) initfunctionrow_changes.normMethod = /*$normMethod*/ ctx[30];
    			if (dirty[0] & /*theoryLocation*/ 2048) initfunctionrow_changes.theoryLocation = /*theoryLocation*/ ctx[11];
    			if (dirty[0] & /*updateConfig*/ 67108864) initfunctionrow_changes.updateConfig = /*updateConfig*/ ctx[26];

    			if (!updating_graphPlotted && dirty[0] & /*graphPlotted*/ 4096) {
    				updating_graphPlotted = true;
    				initfunctionrow_changes.graphPlotted = /*graphPlotted*/ ctx[12];
    				add_flush_callback(() => updating_graphPlotted = false);
    			}

    			if (!updating_show_theoryplot && dirty[0] & /*show_theoryplot*/ 1024) {
    				updating_show_theoryplot = true;
    				initfunctionrow_changes.show_theoryplot = /*show_theoryplot*/ ctx[10];
    				add_flush_callback(() => updating_show_theoryplot = false);
    			}

    			initfunctionrow.$set(initfunctionrow_changes);
    			const oporow_changes = {};
    			if (dirty[0] & /*updateConfig*/ 67108864) oporow_changes.updateConfig = /*updateConfig*/ ctx[26];

    			if (!updating_OPOLocation && dirty[0] & /*OPOLocation*/ 8) {
    				updating_OPOLocation = true;
    				oporow_changes.OPOLocation = /*OPOLocation*/ ctx[3];
    				add_flush_callback(() => updating_OPOLocation = false);
    			}

    			if (!updating_OPOfilesChecked && dirty[0] & /*OPOfilesChecked*/ 4) {
    				updating_OPOfilesChecked = true;
    				oporow_changes.OPOfilesChecked = /*OPOfilesChecked*/ ctx[2];
    				add_flush_callback(() => updating_OPOfilesChecked = false);
    			}

    			if (!updating_opofiles && dirty[0] & /*opofiles*/ 16) {
    				updating_opofiles = true;
    				oporow_changes.opofiles = /*opofiles*/ ctx[4];
    				add_flush_callback(() => updating_opofiles = false);
    			}

    			if (!updating_graphPlotted_1 && dirty[0] & /*graphPlotted*/ 4096) {
    				updating_graphPlotted_1 = true;
    				oporow_changes.graphPlotted = /*graphPlotted*/ ctx[12];
    				add_flush_callback(() => updating_graphPlotted_1 = false);
    			}

    			oporow.$set(oporow_changes);
    			const theoryrow_changes = {};
    			if (dirty[0] & /*$normMethod*/ 1073741824) theoryrow_changes.normMethod = /*$normMethod*/ ctx[30];
    			if (dirty[0] & /*updateConfig*/ 67108864) theoryrow_changes.updateConfig = /*updateConfig*/ ctx[26];

    			if (!updating_theoryLocation && dirty[0] & /*theoryLocation*/ 2048) {
    				updating_theoryLocation = true;
    				theoryrow_changes.theoryLocation = /*theoryLocation*/ ctx[11];
    				add_flush_callback(() => updating_theoryLocation = false);
    			}

    			if (!updating_show_theoryplot_1 && dirty[0] & /*show_theoryplot*/ 1024) {
    				updating_show_theoryplot_1 = true;
    				theoryrow_changes.show_theoryplot = /*show_theoryplot*/ ctx[10];
    				add_flush_callback(() => updating_show_theoryplot_1 = false);
    			}

    			theoryrow.$set(theoryrow_changes);
    			const customradio_changes = {};

    			if (!updating_selected && dirty[0] & /*$normMethod*/ 1073741824) {
    				updating_selected = true;
    				customradio_changes.selected = /*$normMethod*/ ctx[30];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customradio.$set(customradio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(initfunctionrow.$$.fragment, local);
    			transition_in(oporow.$$.fragment, local);
    			transition_in(theoryrow.$$.fragment, local);
    			transition_in(customradio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(initfunctionrow.$$.fragment, local);
    			transition_out(oporow.$$.fragment, local);
    			transition_out(theoryrow.$$.fragment, local);
    			transition_out(customradio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(initfunctionrow, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(oporow, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(theoryrow, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			destroy_component(customradio);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_buttonContainer_slot$3.name,
    		type: "slot",
    		source: "(130:4) <svelte:fragment slot=\\\"buttonContainer\\\">",
    		ctx
    	});

    	return block;
    }

    // (141:4) <svelte:fragment slot="plotContainer" >
    function create_plotContainer_slot$3(ctx) {
    	let getfileinfotable;
    	let t0;
    	let div7;
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let current;

    	getfileinfotable = new GetFileInfoTable({
    			props: {
    				felixfiles: /*felixfiles*/ ctx[7],
    				normMethod: /*$normMethod*/ ctx[30]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(getfileinfotable.$$.fragment);
    			t0 = space();
    			div7 = element("div");
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div2 = element("div");
    			t3 = space();
    			div3 = element("div");
    			t4 = space();
    			div4 = element("div");
    			t5 = space();
    			div5 = element("div");
    			t6 = space();
    			div6 = element("div");
    			attr_dev(div0, "class", "animated fadeIn graph__div svelte-f1bxvr");
    			attr_dev(div0, "id", "exp-theory-plot");
    			toggle_class(div0, "hide", !/*show_theoryplot*/ ctx[10]);
    			add_location(div0, file$k, 147, 12, 6596);
    			attr_dev(div1, "id", "bplot");
    			attr_dev(div1, "class", "graph__div svelte-f1bxvr");
    			add_location(div1, file$k, 148, 12, 6707);
    			attr_dev(div2, "id", "saPlot");
    			attr_dev(div2, "class", "graph__div svelte-f1bxvr");
    			add_location(div2, file$k, 149, 12, 6762);
    			attr_dev(div3, "id", "avgplot");
    			attr_dev(div3, "class", "graph__div svelte-f1bxvr");
    			add_location(div3, file$k, 150, 12, 6818);
    			attr_dev(div4, "class", "animated fadeIn graph__div svelte-f1bxvr");
    			attr_dev(div4, "id", "opoplot");
    			toggle_class(div4, "hide", !/*$opoMode*/ ctx[8]);
    			add_location(div4, file$k, 151, 12, 6875);
    			attr_dev(div5, "class", "animated fadeIn graph__div svelte-f1bxvr");
    			attr_dev(div5, "id", "opoSA");
    			toggle_class(div5, "hide", !/*$opoMode*/ ctx[8]);
    			add_location(div5, file$k, 152, 12, 6971);
    			attr_dev(div6, "class", "animated fadeIn graph__div svelte-f1bxvr");
    			attr_dev(div6, "id", "opoRelPlot");
    			toggle_class(div6, "hide", !/*$opoMode*/ ctx[8]);
    			add_location(div6, file$k, 154, 12, 7067);
    			attr_dev(div7, "class", "felixPlot svelte-f1bxvr");
    			attr_dev(div7, "id", "plot_container__div__" + filetype$3);
    			add_location(div7, file$k, 146, 8, 6522);
    		},
    		m: function mount(target, anchor) {
    			mount_component(getfileinfotable, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div1);
    			append_dev(div7, t2);
    			append_dev(div7, div2);
    			append_dev(div7, t3);
    			append_dev(div7, div3);
    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div7, t5);
    			append_dev(div7, div5);
    			append_dev(div7, t6);
    			append_dev(div7, div6);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const getfileinfotable_changes = {};
    			if (dirty[0] & /*felixfiles*/ 128) getfileinfotable_changes.felixfiles = /*felixfiles*/ ctx[7];
    			if (dirty[0] & /*$normMethod*/ 1073741824) getfileinfotable_changes.normMethod = /*$normMethod*/ ctx[30];
    			getfileinfotable.$set(getfileinfotable_changes);

    			if (dirty[0] & /*show_theoryplot*/ 1024) {
    				toggle_class(div0, "hide", !/*show_theoryplot*/ ctx[10]);
    			}

    			if (dirty[0] & /*$opoMode*/ 256) {
    				toggle_class(div4, "hide", !/*$opoMode*/ ctx[8]);
    			}

    			if (dirty[0] & /*$opoMode*/ 256) {
    				toggle_class(div5, "hide", !/*$opoMode*/ ctx[8]);
    			}

    			if (dirty[0] & /*$opoMode*/ 256) {
    				toggle_class(div6, "hide", !/*$opoMode*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(getfileinfotable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(getfileinfotable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(getfileinfotable, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_slot$3.name,
    		type: "slot",
    		source: "(141:4) <svelte:fragment slot=\\\"plotContainer\\\" >",
    		ctx
    	});

    	return block;
    }

    // (160:4) <svelte:fragment slot="plotContainer_functions" >
    function create_plotContainer_functions_slot$1(ctx) {
    	let writefunctioncontents;
    	let updating_writeFileName;
    	let updating_writeFile;
    	let updating_overwrite_expfit;
    	let t;
    	let executefunctioncontents;
    	let updating_modalActivate;
    	let updating_adjustPeakTrigger;
    	let current;

    	function writefunctioncontents_writeFileName_binding(value) {
    		/*writefunctioncontents_writeFileName_binding*/ ctx[50](value);
    	}

    	function writefunctioncontents_writeFile_binding(value) {
    		/*writefunctioncontents_writeFile_binding*/ ctx[51](value);
    	}

    	function writefunctioncontents_overwrite_expfit_binding(value) {
    		/*writefunctioncontents_overwrite_expfit_binding*/ ctx[52](value);
    	}

    	let writefunctioncontents_props = {
    		output_namelists: /*output_namelists*/ ctx[29]
    	};

    	if (/*writeFileName*/ ctx[15] !== void 0) {
    		writefunctioncontents_props.writeFileName = /*writeFileName*/ ctx[15];
    	}

    	if (/*writeFile*/ ctx[14] !== void 0) {
    		writefunctioncontents_props.writeFile = /*writeFile*/ ctx[14];
    	}

    	if (/*overwrite_expfit*/ ctx[13] !== void 0) {
    		writefunctioncontents_props.overwrite_expfit = /*overwrite_expfit*/ ctx[13];
    	}

    	writefunctioncontents = new WriteFunctionContents({
    			props: writefunctioncontents_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(writefunctioncontents, 'writeFileName', writefunctioncontents_writeFileName_binding));
    	binding_callbacks.push(() => bind(writefunctioncontents, 'writeFile', writefunctioncontents_writeFile_binding));
    	binding_callbacks.push(() => bind(writefunctioncontents, 'overwrite_expfit', writefunctioncontents_overwrite_expfit_binding));
    	writefunctioncontents.$on("addfile", /*addfile_handler*/ ctx[53]);
    	writefunctioncontents.$on("removefile", /*removeExtraFile*/ ctx[33]);

    	function executefunctioncontents_modalActivate_binding(value) {
    		/*executefunctioncontents_modalActivate_binding*/ ctx[54](value);
    	}

    	function executefunctioncontents_adjustPeakTrigger_binding(value) {
    		/*executefunctioncontents_adjustPeakTrigger_binding*/ ctx[55](value);
    	}

    	let executefunctioncontents_props = {
    		addedFileScale: /*addedFileScale*/ ctx[20],
    		addedFileCol: /*addedFileCol*/ ctx[18],
    		normMethod: /*$normMethod*/ ctx[30],
    		writeFileName: /*writeFileName*/ ctx[15],
    		writeFile: /*writeFile*/ ctx[14],
    		overwrite_expfit: /*overwrite_expfit*/ ctx[13],
    		fullfiles: /*fullfiles*/ ctx[21]
    	};

    	if (/*modalActivate*/ ctx[27] !== void 0) {
    		executefunctioncontents_props.modalActivate = /*modalActivate*/ ctx[27];
    	}

    	if (/*adjustPeakTrigger*/ ctx[28] !== void 0) {
    		executefunctioncontents_props.adjustPeakTrigger = /*adjustPeakTrigger*/ ctx[28];
    	}

    	executefunctioncontents = new ExecuteFunctionContents({
    			props: executefunctioncontents_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(executefunctioncontents, 'modalActivate', executefunctioncontents_modalActivate_binding));
    	binding_callbacks.push(() => bind(executefunctioncontents, 'adjustPeakTrigger', executefunctioncontents_adjustPeakTrigger_binding));

    	const block = {
    		c: function create() {
    			create_component(writefunctioncontents.$$.fragment);
    			t = space();
    			create_component(executefunctioncontents.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(writefunctioncontents, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(executefunctioncontents, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const writefunctioncontents_changes = {};
    			if (dirty[0] & /*output_namelists*/ 536870912) writefunctioncontents_changes.output_namelists = /*output_namelists*/ ctx[29];

    			if (!updating_writeFileName && dirty[0] & /*writeFileName*/ 32768) {
    				updating_writeFileName = true;
    				writefunctioncontents_changes.writeFileName = /*writeFileName*/ ctx[15];
    				add_flush_callback(() => updating_writeFileName = false);
    			}

    			if (!updating_writeFile && dirty[0] & /*writeFile*/ 16384) {
    				updating_writeFile = true;
    				writefunctioncontents_changes.writeFile = /*writeFile*/ ctx[14];
    				add_flush_callback(() => updating_writeFile = false);
    			}

    			if (!updating_overwrite_expfit && dirty[0] & /*overwrite_expfit*/ 8192) {
    				updating_overwrite_expfit = true;
    				writefunctioncontents_changes.overwrite_expfit = /*overwrite_expfit*/ ctx[13];
    				add_flush_callback(() => updating_overwrite_expfit = false);
    			}

    			writefunctioncontents.$set(writefunctioncontents_changes);
    			const executefunctioncontents_changes = {};
    			if (dirty[0] & /*addedFileScale*/ 1048576) executefunctioncontents_changes.addedFileScale = /*addedFileScale*/ ctx[20];
    			if (dirty[0] & /*addedFileCol*/ 262144) executefunctioncontents_changes.addedFileCol = /*addedFileCol*/ ctx[18];
    			if (dirty[0] & /*$normMethod*/ 1073741824) executefunctioncontents_changes.normMethod = /*$normMethod*/ ctx[30];
    			if (dirty[0] & /*writeFileName*/ 32768) executefunctioncontents_changes.writeFileName = /*writeFileName*/ ctx[15];
    			if (dirty[0] & /*writeFile*/ 16384) executefunctioncontents_changes.writeFile = /*writeFile*/ ctx[14];
    			if (dirty[0] & /*overwrite_expfit*/ 8192) executefunctioncontents_changes.overwrite_expfit = /*overwrite_expfit*/ ctx[13];
    			if (dirty[0] & /*fullfiles*/ 2097152) executefunctioncontents_changes.fullfiles = /*fullfiles*/ ctx[21];

    			if (!updating_modalActivate && dirty[0] & /*modalActivate*/ 134217728) {
    				updating_modalActivate = true;
    				executefunctioncontents_changes.modalActivate = /*modalActivate*/ ctx[27];
    				add_flush_callback(() => updating_modalActivate = false);
    			}

    			if (!updating_adjustPeakTrigger && dirty[0] & /*adjustPeakTrigger*/ 268435456) {
    				updating_adjustPeakTrigger = true;
    				executefunctioncontents_changes.adjustPeakTrigger = /*adjustPeakTrigger*/ ctx[28];
    				add_flush_callback(() => updating_adjustPeakTrigger = false);
    			}

    			executefunctioncontents.$set(executefunctioncontents_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(writefunctioncontents.$$.fragment, local);
    			transition_in(executefunctioncontents.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(writefunctioncontents.$$.fragment, local);
    			transition_out(executefunctioncontents.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(writefunctioncontents, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(executefunctioncontents, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_functions_slot$1.name,
    		type: "slot",
    		source: "(160:4) <svelte:fragment slot=\\\"plotContainer_functions\\\" >",
    		ctx
    	});

    	return block;
    }

    // (170:4) <svelte:fragment slot="plotContainer_reports">
    function create_plotContainer_reports_slot(ctx) {
    	let frequencytable;
    	let updating_keepTable;
    	let current;

    	function frequencytable_keepTable_binding(value) {
    		/*frequencytable_keepTable_binding*/ ctx[49](value);
    	}

    	let frequencytable_props = {};

    	if (/*keepTable*/ ctx[16] !== void 0) {
    		frequencytable_props.keepTable = /*keepTable*/ ctx[16];
    	}

    	frequencytable = new FrequencyTable({
    			props: frequencytable_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(frequencytable, 'keepTable', frequencytable_keepTable_binding));

    	const block = {
    		c: function create() {
    			create_component(frequencytable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(frequencytable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const frequencytable_changes = {};

    			if (!updating_keepTable && dirty[0] & /*keepTable*/ 65536) {
    				updating_keepTable = true;
    				frequencytable_changes.keepTable = /*keepTable*/ ctx[16];
    				add_flush_callback(() => updating_keepTable = false);
    			}

    			frequencytable.$set(frequencytable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(frequencytable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(frequencytable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(frequencytable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_reports_slot.name,
    		type: "slot",
    		source: "(170:4) <svelte:fragment slot=\\\"plotContainer_reports\\\">",
    		ctx
    	});

    	return block;
    }

    // (174:4) <svelte:fragment slot="config">
    function create_config_slot(ctx) {
    	let div;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let textfield2;
    	let updating_value_2;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[45](value);
    	}

    	let textfield0_props = {
    		label: "FELIX delta steps",
    		varient: "outlined",
    		input$type: "number",
    		input$min: "0",
    		input$step: "1e-5"
    	};

    	if (/*fdelta*/ ctx[23] !== void 0) {
    		textfield0_props.value = /*fdelta*/ ctx[23];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[46](value);
    	}

    	let textfield1_props = {
    		label: "OPO delta steps",
    		varient: "outlined",
    		input$type: "number",
    		input$min: "0",
    		input$step: "1e-5"
    	};

    	if (/*odelta*/ ctx[24] !== void 0) {
    		textfield1_props.value = /*odelta*/ ctx[24];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[47](value);
    	}

    	let textfield2_props = {
    		label: "Theory scaling steps",
    		varient: "outlined",
    		input$type: "number",
    		input$min: "0",
    		input$step: "1e-5"
    	};

    	if (/*scalingBin*/ ctx[25] !== void 0) {
    		textfield2_props.value = /*scalingBin*/ ctx[25];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			create_component(textfield2.$$.fragment);
    			attr_dev(div, "class", "align");
    			add_location(div, file$k, 175, 8, 7921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t0);
    			mount_component(textfield1, div, null);
    			append_dev(div, t1);
    			mount_component(textfield2, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "configSave", /*configSave_handler*/ ctx[48], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*fdelta*/ 8388608) {
    				updating_value = true;
    				textfield0_changes.value = /*fdelta*/ ctx[23];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*odelta*/ 16777216) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*odelta*/ ctx[24];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*scalingBin*/ 33554432) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*scalingBin*/ ctx[25];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_config_slot.name,
    		type: "slot",
    		source: "(174:4) <svelte:fragment slot=\\\"config\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let addfilestoplot;
    	let updating_extrafileAdded;
    	let updating_active;
    	let updating_addedFileCol;
    	let updating_addedFileScale;
    	let updating_addedfiles;
    	let updating_addedFile;
    	let t0;
    	let adjustinitialguess;
    	let updating_active_1;
    	let t1;
    	let layout;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let updating_toggleBrowser;
    	let updating_activateConfigModal;
    	let current;

    	function addfilestoplot_extrafileAdded_binding(value) {
    		/*addfilestoplot_extrafileAdded_binding*/ ctx[37](value);
    	}

    	function addfilestoplot_active_binding(value) {
    		/*addfilestoplot_active_binding*/ ctx[38](value);
    	}

    	function addfilestoplot_addedFileCol_binding(value) {
    		/*addfilestoplot_addedFileCol_binding*/ ctx[39](value);
    	}

    	function addfilestoplot_addedFileScale_binding(value) {
    		/*addfilestoplot_addedFileScale_binding*/ ctx[40](value);
    	}

    	function addfilestoplot_addedfiles_binding(value) {
    		/*addfilestoplot_addedfiles_binding*/ ctx[41](value);
    	}

    	function addfilestoplot_addedFile_binding(value) {
    		/*addfilestoplot_addedFile_binding*/ ctx[42](value);
    	}

    	let addfilestoplot_props = { fileChecked: /*fileChecked*/ ctx[0] };

    	if (/*extrafileAdded*/ ctx[6] !== void 0) {
    		addfilestoplot_props.extrafileAdded = /*extrafileAdded*/ ctx[6];
    	}

    	if (/*addFileModal*/ ctx[17] !== void 0) {
    		addfilestoplot_props.active = /*addFileModal*/ ctx[17];
    	}

    	if (/*addedFileCol*/ ctx[18] !== void 0) {
    		addfilestoplot_props.addedFileCol = /*addedFileCol*/ ctx[18];
    	}

    	if (/*addedFileScale*/ ctx[20] !== void 0) {
    		addfilestoplot_props.addedFileScale = /*addedFileScale*/ ctx[20];
    	}

    	if (/*addedfiles*/ ctx[5] !== void 0) {
    		addfilestoplot_props.addedfiles = /*addedfiles*/ ctx[5];
    	}

    	if (/*addedFile*/ ctx[19] !== void 0) {
    		addfilestoplot_props.addedFile = /*addedFile*/ ctx[19];
    	}

    	addfilestoplot = new AddFilesToPlot({
    			props: addfilestoplot_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(addfilestoplot, 'extrafileAdded', addfilestoplot_extrafileAdded_binding));
    	binding_callbacks.push(() => bind(addfilestoplot, 'active', addfilestoplot_active_binding));
    	binding_callbacks.push(() => bind(addfilestoplot, 'addedFileCol', addfilestoplot_addedFileCol_binding));
    	binding_callbacks.push(() => bind(addfilestoplot, 'addedFileScale', addfilestoplot_addedFileScale_binding));
    	binding_callbacks.push(() => bind(addfilestoplot, 'addedfiles', addfilestoplot_addedfiles_binding));
    	binding_callbacks.push(() => bind(addfilestoplot, 'addedFile', addfilestoplot_addedFile_binding));

    	function adjustinitialguess_active_binding(value) {
    		/*adjustinitialguess_active_binding*/ ctx[43](value);
    	}

    	let adjustinitialguess_props = {};

    	if (/*modalActivate*/ ctx[27] !== void 0) {
    		adjustinitialguess_props.active = /*modalActivate*/ ctx[27];
    	}

    	adjustinitialguess = new AdjustInitialGuess({
    			props: adjustinitialguess_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(adjustinitialguess, 'active', adjustinitialguess_active_binding));
    	adjustinitialguess.$on("save", /*save_handler*/ ctx[44]);

    	function layout_currentLocation_binding(value) {
    		/*layout_currentLocation_binding*/ ctx[65](value);
    	}

    	function layout_fileChecked_binding(value) {
    		/*layout_fileChecked_binding*/ ctx[66](value);
    	}

    	function layout_toggleBrowser_binding(value) {
    		/*layout_toggleBrowser_binding*/ ctx[67](value);
    	}

    	function layout_activateConfigModal_binding(value) {
    		/*layout_activateConfigModal_binding*/ ctx[68](value);
    	}

    	let layout_props = {
    		filetype: filetype$3,
    		graphPlotted: /*graphPlotted*/ ctx[12],
    		id: id$3,
    		$$slots: {
    			config: [create_config_slot],
    			plotContainer_reports: [create_plotContainer_reports_slot],
    			plotContainer_functions: [create_plotContainer_functions_slot$1],
    			plotContainer: [create_plotContainer_slot$3],
    			buttonContainer: [create_buttonContainer_slot$3]
    		},
    		$$scope: { ctx }
    	};

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		layout_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		layout_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	if (/*toggleBrowser*/ ctx[9] !== void 0) {
    		layout_props.toggleBrowser = /*toggleBrowser*/ ctx[9];
    	}

    	if (/*activateConfigModal*/ ctx[22] !== void 0) {
    		layout_props.activateConfigModal = /*activateConfigModal*/ ctx[22];
    	}

    	layout = new Layout({ props: layout_props, $$inline: true });
    	binding_callbacks.push(() => bind(layout, 'currentLocation', layout_currentLocation_binding));
    	binding_callbacks.push(() => bind(layout, 'fileChecked', layout_fileChecked_binding));
    	binding_callbacks.push(() => bind(layout, 'toggleBrowser', layout_toggleBrowser_binding));
    	binding_callbacks.push(() => bind(layout, 'activateConfigModal', layout_activateConfigModal_binding));
    	layout.$on("tour", /*init_tour*/ ctx[34]);
    	layout.$on("configSave", /*configSave*/ ctx[35]);
    	layout.$on("markedFile", /*markedFile_handler*/ ctx[69]);

    	const block = {
    		c: function create() {
    			create_component(addfilestoplot.$$.fragment);
    			t0 = space();
    			create_component(adjustinitialguess.$$.fragment);
    			t1 = space();
    			create_component(layout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(addfilestoplot, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(adjustinitialguess, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(layout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const addfilestoplot_changes = {};
    			if (dirty[0] & /*fileChecked*/ 1) addfilestoplot_changes.fileChecked = /*fileChecked*/ ctx[0];

    			if (!updating_extrafileAdded && dirty[0] & /*extrafileAdded*/ 64) {
    				updating_extrafileAdded = true;
    				addfilestoplot_changes.extrafileAdded = /*extrafileAdded*/ ctx[6];
    				add_flush_callback(() => updating_extrafileAdded = false);
    			}

    			if (!updating_active && dirty[0] & /*addFileModal*/ 131072) {
    				updating_active = true;
    				addfilestoplot_changes.active = /*addFileModal*/ ctx[17];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_addedFileCol && dirty[0] & /*addedFileCol*/ 262144) {
    				updating_addedFileCol = true;
    				addfilestoplot_changes.addedFileCol = /*addedFileCol*/ ctx[18];
    				add_flush_callback(() => updating_addedFileCol = false);
    			}

    			if (!updating_addedFileScale && dirty[0] & /*addedFileScale*/ 1048576) {
    				updating_addedFileScale = true;
    				addfilestoplot_changes.addedFileScale = /*addedFileScale*/ ctx[20];
    				add_flush_callback(() => updating_addedFileScale = false);
    			}

    			if (!updating_addedfiles && dirty[0] & /*addedfiles*/ 32) {
    				updating_addedfiles = true;
    				addfilestoplot_changes.addedfiles = /*addedfiles*/ ctx[5];
    				add_flush_callback(() => updating_addedfiles = false);
    			}

    			if (!updating_addedFile && dirty[0] & /*addedFile*/ 524288) {
    				updating_addedFile = true;
    				addfilestoplot_changes.addedFile = /*addedFile*/ ctx[19];
    				add_flush_callback(() => updating_addedFile = false);
    			}

    			addfilestoplot.$set(addfilestoplot_changes);
    			const adjustinitialguess_changes = {};

    			if (!updating_active_1 && dirty[0] & /*modalActivate*/ 134217728) {
    				updating_active_1 = true;
    				adjustinitialguess_changes.active = /*modalActivate*/ ctx[27];
    				add_flush_callback(() => updating_active_1 = false);
    			}

    			adjustinitialguess.$set(adjustinitialguess_changes);
    			const layout_changes = {};
    			if (dirty[0] & /*graphPlotted*/ 4096) layout_changes.graphPlotted = /*graphPlotted*/ ctx[12];

    			if (dirty[0] & /*scalingBin, odelta, fdelta, keepTable, addedFileScale, addedFileCol, $normMethod, writeFileName, writeFile, overwrite_expfit, fullfiles, modalActivate, adjustPeakTrigger, output_namelists, addFileModal, $opoMode, show_theoryplot, felixfiles, updateConfig, theoryLocation, OPOLocation, OPOfilesChecked, opofiles, graphPlotted*/ 2142764444 | dirty[2] & /*$$scope*/ 131072) {
    				layout_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			if (!updating_toggleBrowser && dirty[0] & /*toggleBrowser*/ 512) {
    				updating_toggleBrowser = true;
    				layout_changes.toggleBrowser = /*toggleBrowser*/ ctx[9];
    				add_flush_callback(() => updating_toggleBrowser = false);
    			}

    			if (!updating_activateConfigModal && dirty[0] & /*activateConfigModal*/ 4194304) {
    				updating_activateConfigModal = true;
    				layout_changes.activateConfigModal = /*activateConfigModal*/ ctx[22];
    				add_flush_callback(() => updating_activateConfigModal = false);
    			}

    			layout.$set(layout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addfilestoplot.$$.fragment, local);
    			transition_in(adjustinitialguess.$$.fragment, local);
    			transition_in(layout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addfilestoplot.$$.fragment, local);
    			transition_out(adjustinitialguess.$$.fragment, local);
    			transition_out(layout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addfilestoplot, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(adjustinitialguess, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(layout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const filetype$3 = "felix", id$3 = "Normline";

    function instance$l($$self, $$props, $$invalidate) {
    	let felixfiles;
    	let plottedFiles;
    	let output_namelists;
    	let $felixConfigDB;
    	let $opoMode;
    	let $graphDiv;
    	let $Ngauss_sigma;
    	let $felixopoLocation;
    	let $fittedTraceCount;
    	let $expfittedLinesCollectedData;
    	let $felixPlotAnnotations;
    	let $expfittedLines;
    	let $normMethod;
    	let $normMethodDatas;
    	let $baselineFile;
    	validate_store(felixConfigDB, 'felixConfigDB');
    	component_subscribe($$self, felixConfigDB, $$value => $$invalidate(70, $felixConfigDB = $$value));
    	validate_store(opoMode, 'opoMode');
    	component_subscribe($$self, opoMode, $$value => $$invalidate(8, $opoMode = $$value));
    	validate_store(graphDiv, 'graphDiv');
    	component_subscribe($$self, graphDiv, $$value => $$invalidate(71, $graphDiv = $$value));
    	validate_store(Ngauss_sigma, 'Ngauss_sigma');
    	component_subscribe($$self, Ngauss_sigma, $$value => $$invalidate(72, $Ngauss_sigma = $$value));
    	validate_store(felixopoLocation, 'felixopoLocation');
    	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(73, $felixopoLocation = $$value));
    	validate_store(fittedTraceCount, 'fittedTraceCount');
    	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(74, $fittedTraceCount = $$value));
    	validate_store(expfittedLinesCollectedData, 'expfittedLinesCollectedData');
    	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(75, $expfittedLinesCollectedData = $$value));
    	validate_store(felixPlotAnnotations, 'felixPlotAnnotations');
    	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(76, $felixPlotAnnotations = $$value));
    	validate_store(expfittedLines, 'expfittedLines');
    	component_subscribe($$self, expfittedLines, $$value => $$invalidate(77, $expfittedLines = $$value));
    	validate_store(normMethod, 'normMethod');
    	component_subscribe($$self, normMethod, $$value => $$invalidate(30, $normMethod = $$value));
    	validate_store(normMethodDatas, 'normMethodDatas');
    	component_subscribe($$self, normMethodDatas, $$value => $$invalidate(78, $normMethodDatas = $$value));
    	validate_store(baselineFile, 'baselineFile');
    	component_subscribe($$self, baselineFile, $$value => $$invalidate(31, $baselineFile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Normline', slots, []);
    	let fileChecked = [], toggleBrowser = false;
    	let currentLocation = db.get(`${filetype$3}_location`) || "";

    	///////////////////////////////////////////////////////////////////////
    	// const dispatch = createEventDispatcher();
    	// Theory file
    	let show_theoryplot = false;

    	let theoryLocation = db.get("theoryLocation") || currentLocation;

    	///////////////////////////////////////////////////////////////////////
    	let graphPlotted = false, overwrite_expfit = false, writeFile = false;

    	let OPOfilesChecked = [];
    	let writeFileName = "";
    	let keepTable = true;

    	//////// OPO Plot ///////////
    	window.getID = () => Math.random().toString(32).substring(2);

    	const replot = () => {
    		if (graphPlotted) {
    			let { data, layout } = $normMethodDatas[$normMethod];

    			try {
    				Plotly.react($graphDiv, data, layout, { editable: true });
    				(set_store_value(expfittedLines, $expfittedLines = set_store_value(felixPlotAnnotations, $felixPlotAnnotations = set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), $felixPlotAnnotations), $expfittedLines), set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount));
    			} catch(err) {
    				
    			}
    		}
    	};

    	// OPO
    	let OPOLocation = db.get("ofelix_location") || currentLocation;

    	let opofiles = [];

    	let addFileModal = false,
    		addedFileCol = "0, 1",
    		addedFile = {},
    		addedFileScale = 1,
    		addedfiles = [],
    		extrafileAdded = 0;

    	function removeExtraFile() {
    		for (let i = 0; i < extrafileAdded + 1; i++) {
    			try {
    				Plotly.deleteTraces($graphDiv, [-1]);
    				$$invalidate(6, extrafileAdded--, extrafileAdded);
    				addedfiles.pop();
    			} catch(err) {
    				console.log("The plot is empty");
    			}
    		}
    	}

    	let fullfiles = [];
    	let activateConfigModal = false;

    	const init_tour = async () => {
    		if (!toggleBrowser) {
    			$$invalidate(9, toggleBrowser = true);
    			await sleep(600);
    		} // Filebrowser toggling and its animation time to appear

    		await tick(); // For all the reactive components to render
    		init_tour_normline({ filetype: filetype$3 });
    	};

    	let fdelta = $felixConfigDB.get("fdelta") || 0.5;
    	let odelta = $felixConfigDB.get("odelta") || 0.001;
    	let scalingBin = $felixConfigDB.get("scalingBin") || 0.001;
    	let updateConfig = false;

    	async function configSave(e) {
    		$felixConfigDB.set("fdelta", fdelta);
    		$felixConfigDB.set("odelta", odelta);
    		$felixConfigDB.set("scalingBin", scalingBin);
    		$$invalidate(26, updateConfig = true);
    		console.log("Config file saved", $felixConfigDB.JSON());
    		await tick();
    		$$invalidate(26, updateConfig = false);
    		console.log("Config updated");
    	}

    	let modalActivate = false, adjustPeakTrigger = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$9.warn(`<Normline> was created with unknown prop '${key}'`);
    	});

    	function addfilestoplot_extrafileAdded_binding(value) {
    		extrafileAdded = value;
    		$$invalidate(6, extrafileAdded);
    	}

    	function addfilestoplot_active_binding(value) {
    		addFileModal = value;
    		$$invalidate(17, addFileModal);
    	}

    	function addfilestoplot_addedFileCol_binding(value) {
    		addedFileCol = value;
    		$$invalidate(18, addedFileCol);
    	}

    	function addfilestoplot_addedFileScale_binding(value) {
    		addedFileScale = value;
    		$$invalidate(20, addedFileScale);
    	}

    	function addfilestoplot_addedfiles_binding(value) {
    		addedfiles = value;
    		$$invalidate(5, addedfiles);
    	}

    	function addfilestoplot_addedFile_binding(value) {
    		addedFile = value;
    		$$invalidate(19, addedFile);
    	}

    	function adjustinitialguess_active_binding(value) {
    		modalActivate = value;
    		$$invalidate(27, modalActivate);
    	}

    	const save_handler = () => $$invalidate(28, adjustPeakTrigger = true);

    	function textfield0_value_binding(value) {
    		fdelta = value;
    		$$invalidate(23, fdelta);
    	}

    	function textfield1_value_binding(value) {
    		odelta = value;
    		$$invalidate(24, odelta);
    	}

    	function textfield2_value_binding(value) {
    		scalingBin = value;
    		$$invalidate(25, scalingBin);
    	}

    	const configSave_handler = () => console.log("Config save triggered");

    	function frequencytable_keepTable_binding(value) {
    		keepTable = value;
    		$$invalidate(16, keepTable);
    	}

    	function writefunctioncontents_writeFileName_binding(value) {
    		writeFileName = value;
    		$$invalidate(15, writeFileName);
    	}

    	function writefunctioncontents_writeFile_binding(value) {
    		writeFile = value;
    		$$invalidate(14, writeFile);
    	}

    	function writefunctioncontents_overwrite_expfit_binding(value) {
    		overwrite_expfit = value;
    		$$invalidate(13, overwrite_expfit);
    	}

    	const addfile_handler = () => {
    		$$invalidate(17, addFileModal = true);
    	};

    	function executefunctioncontents_modalActivate_binding(value) {
    		modalActivate = value;
    		$$invalidate(27, modalActivate);
    	}

    	function executefunctioncontents_adjustPeakTrigger_binding(value) {
    		adjustPeakTrigger = value;
    		$$invalidate(28, adjustPeakTrigger);
    	}

    	function initfunctionrow_graphPlotted_binding(value) {
    		graphPlotted = value;
    		$$invalidate(12, graphPlotted);
    	}

    	function initfunctionrow_show_theoryplot_binding(value) {
    		show_theoryplot = value;
    		$$invalidate(10, show_theoryplot);
    	}

    	function oporow_OPOLocation_binding(value) {
    		OPOLocation = value;
    		$$invalidate(3, OPOLocation);
    	}

    	function oporow_OPOfilesChecked_binding(value) {
    		OPOfilesChecked = value;
    		$$invalidate(2, OPOfilesChecked);
    	}

    	function oporow_opofiles_binding(value) {
    		opofiles = value;
    		$$invalidate(4, opofiles);
    	}

    	function oporow_graphPlotted_binding(value) {
    		graphPlotted = value;
    		$$invalidate(12, graphPlotted);
    	}

    	function theoryrow_theoryLocation_binding(value) {
    		theoryLocation = value;
    		$$invalidate(11, theoryLocation);
    	}

    	function theoryrow_show_theoryplot_binding(value) {
    		show_theoryplot = value;
    		$$invalidate(10, show_theoryplot);
    	}

    	function customradio_selected_binding(value) {
    		$normMethod = value;
    		normMethod.set($normMethod);
    	}

    	function layout_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	function layout_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	function layout_toggleBrowser_binding(value) {
    		toggleBrowser = value;
    		$$invalidate(9, toggleBrowser);
    	}

    	function layout_activateConfigModal_binding(value) {
    		activateConfigModal = value;
    		$$invalidate(22, activateConfigModal);
    	}

    	const markedFile_handler = e => set_store_value(baselineFile, $baselineFile = e.detail.markedFile, $baselineFile);

    	$$self.$capture_state = () => ({
    		opoMode,
    		normMethodDatas,
    		Ngauss_sigma,
    		felixopoLocation,
    		felixPlotAnnotations,
    		expfittedLines,
    		expfittedLinesCollectedData,
    		fittedTraceCount,
    		graphDiv,
    		normMethod,
    		felixConfigDB,
    		baselineFile,
    		Layout,
    		CustomRadio,
    		tick,
    		AddFilesToPlot,
    		FrequencyTable,
    		InitFunctionRow,
    		OPORow,
    		AdjustInitialGuess,
    		TheoryRow,
    		GetFileInfoTable,
    		WriteFunctionContents,
    		ExecuteFunctionContents,
    		init_tour_normline,
    		Textfield,
    		filetype: filetype$3,
    		id: id$3,
    		fileChecked,
    		toggleBrowser,
    		currentLocation,
    		show_theoryplot,
    		theoryLocation,
    		graphPlotted,
    		overwrite_expfit,
    		writeFile,
    		OPOfilesChecked,
    		writeFileName,
    		keepTable,
    		replot,
    		OPOLocation,
    		opofiles,
    		addFileModal,
    		addedFileCol,
    		addedFile,
    		addedFileScale,
    		addedfiles,
    		extrafileAdded,
    		removeExtraFile,
    		fullfiles,
    		activateConfigModal,
    		init_tour,
    		fdelta,
    		odelta,
    		scalingBin,
    		updateConfig,
    		configSave,
    		modalActivate,
    		adjustPeakTrigger,
    		felixfiles,
    		plottedFiles,
    		output_namelists,
    		$felixConfigDB,
    		$opoMode,
    		$graphDiv,
    		$Ngauss_sigma,
    		$felixopoLocation,
    		$fittedTraceCount,
    		$expfittedLinesCollectedData,
    		$felixPlotAnnotations,
    		$expfittedLines,
    		$normMethod,
    		$normMethodDatas,
    		$baselineFile
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('toggleBrowser' in $$props) $$invalidate(9, toggleBrowser = $$props.toggleBrowser);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('show_theoryplot' in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
    		if ('theoryLocation' in $$props) $$invalidate(11, theoryLocation = $$props.theoryLocation);
    		if ('graphPlotted' in $$props) $$invalidate(12, graphPlotted = $$props.graphPlotted);
    		if ('overwrite_expfit' in $$props) $$invalidate(13, overwrite_expfit = $$props.overwrite_expfit);
    		if ('writeFile' in $$props) $$invalidate(14, writeFile = $$props.writeFile);
    		if ('OPOfilesChecked' in $$props) $$invalidate(2, OPOfilesChecked = $$props.OPOfilesChecked);
    		if ('writeFileName' in $$props) $$invalidate(15, writeFileName = $$props.writeFileName);
    		if ('keepTable' in $$props) $$invalidate(16, keepTable = $$props.keepTable);
    		if ('OPOLocation' in $$props) $$invalidate(3, OPOLocation = $$props.OPOLocation);
    		if ('opofiles' in $$props) $$invalidate(4, opofiles = $$props.opofiles);
    		if ('addFileModal' in $$props) $$invalidate(17, addFileModal = $$props.addFileModal);
    		if ('addedFileCol' in $$props) $$invalidate(18, addedFileCol = $$props.addedFileCol);
    		if ('addedFile' in $$props) $$invalidate(19, addedFile = $$props.addedFile);
    		if ('addedFileScale' in $$props) $$invalidate(20, addedFileScale = $$props.addedFileScale);
    		if ('addedfiles' in $$props) $$invalidate(5, addedfiles = $$props.addedfiles);
    		if ('extrafileAdded' in $$props) $$invalidate(6, extrafileAdded = $$props.extrafileAdded);
    		if ('fullfiles' in $$props) $$invalidate(21, fullfiles = $$props.fullfiles);
    		if ('activateConfigModal' in $$props) $$invalidate(22, activateConfigModal = $$props.activateConfigModal);
    		if ('fdelta' in $$props) $$invalidate(23, fdelta = $$props.fdelta);
    		if ('odelta' in $$props) $$invalidate(24, odelta = $$props.odelta);
    		if ('scalingBin' in $$props) $$invalidate(25, scalingBin = $$props.scalingBin);
    		if ('updateConfig' in $$props) $$invalidate(26, updateConfig = $$props.updateConfig);
    		if ('modalActivate' in $$props) $$invalidate(27, modalActivate = $$props.modalActivate);
    		if ('adjustPeakTrigger' in $$props) $$invalidate(28, adjustPeakTrigger = $$props.adjustPeakTrigger);
    		if ('felixfiles' in $$props) $$invalidate(7, felixfiles = $$props.felixfiles);
    		if ('plottedFiles' in $$props) $$invalidate(36, plottedFiles = $$props.plottedFiles);
    		if ('output_namelists' in $$props) $$invalidate(29, output_namelists = $$props.output_namelists);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*fileChecked, currentLocation*/ 3) {
    			$$invalidate(7, felixfiles = fileChecked.map(file => pathResolve(currentLocation, file)));
    		}

    		if ($$self.$$.dirty[0] & /*currentLocation*/ 2) {
    			console.log(`${filetype$3} currentlocation: \n${currentLocation}`);
    		}

    		if ($$self.$$.dirty[0] & /*$opoMode, OPOfilesChecked, fileChecked*/ 261) {
    			$$invalidate(36, plottedFiles = $opoMode
    			? OPOfilesChecked.map(file => file.split(".")[0]) || []
    			: fileChecked.map(file => file.split(".")[0]) || []);
    		}

    		if ($$self.$$.dirty[0] & /*addedfiles*/ 32 | $$self.$$.dirty[1] & /*plottedFiles*/ 32) {
    			$$invalidate(29, output_namelists = [
    				"averaged",
    				...plottedFiles,
    				...addedfiles.map(file => basename(file)).map(file => file.split(".")[0])
    			]);
    		}

    		if ($$self.$$.dirty[0] & /*$opoMode, OPOLocation, currentLocation*/ 266) {
    			set_store_value(felixopoLocation, $felixopoLocation = $opoMode ? OPOLocation : currentLocation, $felixopoLocation);
    		}

    		if ($$self.$$.dirty[0] & /*$opoMode*/ 256) {
    			$opoMode
    			? window.createToast("OPO MODE", "warning")
    			: window.createToast("FELIX MODE");
    		}

    		if ($$self.$$.dirty[0] & /*$opoMode*/ 256) {
    			set_store_value(Ngauss_sigma, $Ngauss_sigma = $opoMode ? 2 : 5, $Ngauss_sigma);
    		}

    		if ($$self.$$.dirty[0] & /*extrafileAdded*/ 64) {
    			console.log(`Extrafile added: ${extrafileAdded}`);
    		}

    		if ($$self.$$.dirty[0] & /*$opoMode, opofiles, addedfiles, currentLocation, felixfiles*/ 434) {
    			$opoMode
    			? $$invalidate(21, fullfiles = [
    					...opofiles,
    					...addedfiles,
    					pathResolve(currentLocation, "averaged.felix")
    				])
    			: $$invalidate(21, fullfiles = [
    					...felixfiles,
    					...addedfiles,
    					pathResolve(currentLocation, "averaged.felix")
    				]);
    		}
    	};

    	return [
    		fileChecked,
    		currentLocation,
    		OPOfilesChecked,
    		OPOLocation,
    		opofiles,
    		addedfiles,
    		extrafileAdded,
    		felixfiles,
    		$opoMode,
    		toggleBrowser,
    		show_theoryplot,
    		theoryLocation,
    		graphPlotted,
    		overwrite_expfit,
    		writeFile,
    		writeFileName,
    		keepTable,
    		addFileModal,
    		addedFileCol,
    		addedFile,
    		addedFileScale,
    		fullfiles,
    		activateConfigModal,
    		fdelta,
    		odelta,
    		scalingBin,
    		updateConfig,
    		modalActivate,
    		adjustPeakTrigger,
    		output_namelists,
    		$normMethod,
    		$baselineFile,
    		replot,
    		removeExtraFile,
    		init_tour,
    		configSave,
    		plottedFiles,
    		addfilestoplot_extrafileAdded_binding,
    		addfilestoplot_active_binding,
    		addfilestoplot_addedFileCol_binding,
    		addfilestoplot_addedFileScale_binding,
    		addfilestoplot_addedfiles_binding,
    		addfilestoplot_addedFile_binding,
    		adjustinitialguess_active_binding,
    		save_handler,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		configSave_handler,
    		frequencytable_keepTable_binding,
    		writefunctioncontents_writeFileName_binding,
    		writefunctioncontents_writeFile_binding,
    		writefunctioncontents_overwrite_expfit_binding,
    		addfile_handler,
    		executefunctioncontents_modalActivate_binding,
    		executefunctioncontents_adjustPeakTrigger_binding,
    		initfunctionrow_graphPlotted_binding,
    		initfunctionrow_show_theoryplot_binding,
    		oporow_OPOLocation_binding,
    		oporow_OPOfilesChecked_binding,
    		oporow_opofiles_binding,
    		oporow_graphPlotted_binding,
    		theoryrow_theoryLocation_binding,
    		theoryrow_show_theoryplot_binding,
    		customradio_selected_binding,
    		layout_currentLocation_binding,
    		layout_fileChecked_binding,
    		layout_toggleBrowser_binding,
    		layout_activateConfigModal_binding,
    		markedFile_handler
    	];
    }

    class Normline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$l, create_fragment$l, safe_not_equal, {}, null, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Normline",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\components\GetLabviewSettings.svelte generated by Svelte v3.42.1 */

    const { console: console_1$8 } = globals;
    const file$j = "src\\components\\GetLabviewSettings.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context_4$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (88:0) {#if active}
    function create_if_block$c(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[18](value);
    	}

    	let modal_props = {
    		title: "Labview Settings",
    		$$slots: { content: [create_content_slot$3] },
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, variableValues, settingsLoaded, displayFiles, selected_file, showAllFiles*/ 134217790) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(88:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (98:12) {#if settingsLoaded}
    function create_if_block_1$6(ctx) {
    	let div10;
    	let div0;
    	let each_blocks_4 = [];
    	let each0_lookup = new Map();
    	let t0;
    	let div1;
    	let textfield0;
    	let t1;
    	let textfield1;
    	let t2;
    	let div2;
    	let each_blocks_3 = [];
    	let each1_lookup = new Map();
    	let t3;
    	let div3;
    	let textfield2;
    	let t4;
    	let div4;
    	let each_blocks_2 = [];
    	let each2_lookup = new Map();
    	let t5;
    	let div5;
    	let textfield3;
    	let t6;
    	let div6;
    	let each_blocks_1 = [];
    	let each3_lookup = new Map();
    	let t7;
    	let div7;
    	let textfield4;
    	let t8;
    	let div8;
    	let each_blocks = [];
    	let each4_lookup = new Map();
    	let t9;
    	let div9;
    	let textfield5;
    	let t10;
    	let textfield6;
    	let t11;
    	let textfield7;
    	let current;
    	let each_value_4 = /*settingsVariable*/ ctx[6].b0;
    	validate_each_argument(each_value_4);
    	const get_key = ctx => /*item*/ ctx[20];
    	validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key);

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		let child_ctx = get_each_context_4$2(ctx, each_value_4, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_4[i] = create_each_block_4$2(key, child_ctx));
    	}

    	textfield0 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].q1float],
    				label: "Quad 1 float"
    			},
    			$$inline: true
    		});

    	textfield1 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bq0],
    				label: "bq0"
    			},
    			$$inline: true
    		});

    	let each_value_3 = /*settingsVariable*/ ctx[6].bqLenses;
    	validate_each_argument(each_value_3);
    	const get_key_1 = ctx => /*item*/ ctx[20];
    	validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key_1);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3$2(ctx, each_value_3, i);
    		let key = get_key_1(child_ctx);
    		each1_lookup.set(key, each_blocks_3[i] = create_each_block_3$2(key, child_ctx));
    	}

    	textfield2 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bq5],
    				label: "bq5"
    			},
    			$$inline: true
    		});

    	let each_value_2 = /*settingsVariable*/ ctx[6].benderLenses;
    	validate_each_argument(each_value_2);
    	const get_key_2 = ctx => /*item*/ ctx[20];
    	validate_each_keys(ctx, each_value_2, get_each_context_2$3, get_key_2);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$3(ctx, each_value_2, i);
    		let key = get_key_2(child_ctx);
    		each2_lookup.set(key, each_blocks_2[i] = create_each_block_2$3(key, child_ctx));
    	}

    	textfield3 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bl4],
    				label: "bl4"
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*settingsVariable*/ ctx[6].se;
    	validate_each_argument(each_value_1);
    	const get_key_3 = ctx => /*item*/ ctx[20];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key_3);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
    		let key = get_key_3(child_ctx);
    		each3_lookup.set(key, each_blocks_1[i] = create_each_block_1$4(key, child_ctx));
    	}

    	textfield4 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].trapfloat],
    				label: "trapfloat"
    			},
    			$$inline: true
    		});

    	let each_value = /*settingsVariable*/ ctx[6].sa;
    	validate_each_argument(each_value);
    	const get_key_4 = ctx => /*item*/ ctx[20];
    	validate_each_keys(ctx, each_value, get_each_context$8, get_key_4);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key_4(child_ctx);
    		each4_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	textfield5 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bl5],
    				label: "bl5"
    			},
    			$$inline: true
    		});

    	textfield6 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].res],
    				label: "Resolution"
    			},
    			$$inline: true
    		});

    	textfield7 = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].q2float],
    				label: "Quad 2 float"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t3 = space();
    			div3 = element("div");
    			create_component(textfield2.$$.fragment);
    			t4 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t5 = space();
    			div5 = element("div");
    			create_component(textfield3.$$.fragment);
    			t6 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t7 = space();
    			div7 = element("div");
    			create_component(textfield4.$$.fragment);
    			t8 = space();
    			div8 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			div9 = element("div");
    			create_component(textfield5.$$.fragment);
    			t10 = space();
    			create_component(textfield6.$$.fragment);
    			t11 = space();
    			create_component(textfield7.$$.fragment);
    			attr_dev(div0, "class", "b0 col svelte-1ykr1ya");
    			add_location(div0, file$j, 101, 20, 3312);
    			attr_dev(div1, "class", "row svelte-1ykr1ya");
    			add_location(div1, file$j, 109, 20, 3666);
    			attr_dev(div2, "class", "bqLenses col svelte-1ykr1ya");
    			add_location(div2, file$j, 113, 20, 3954);
    			attr_dev(div3, "class", "row svelte-1ykr1ya");
    			add_location(div3, file$j, 119, 20, 4269);
    			attr_dev(div4, "class", "benderLenses col svelte-1ykr1ya");
    			add_location(div4, file$j, 120, 20, 4392);
    			attr_dev(div5, "class", "row svelte-1ykr1ya");
    			add_location(div5, file$j, 128, 20, 4727);
    			attr_dev(div6, "class", "se row svelte-1ykr1ya");
    			add_location(div6, file$j, 131, 20, 4898);
    			attr_dev(div7, "class", "row svelte-1ykr1ya");
    			add_location(div7, file$j, 139, 20, 5228);
    			attr_dev(div8, "class", "sa row svelte-1ykr1ya");
    			add_location(div8, file$j, 141, 20, 5365);
    			attr_dev(div9, "class", "row svelte-1ykr1ya");
    			set_style(div9, "padding", "1em 0");
    			add_location(div9, file$j, 149, 20, 5655);
    			attr_dev(div10, "class", "container svelte-1ykr1ya");
    			add_location(div10, file$j, 99, 16, 3265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(div0, null);
    			}

    			append_dev(div10, t0);
    			append_dev(div10, div1);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t1);
    			mount_component(textfield1, div1, null);
    			append_dev(div10, t2);
    			append_dev(div10, div2);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div2, null);
    			}

    			append_dev(div10, t3);
    			append_dev(div10, div3);
    			mount_component(textfield2, div3, null);
    			append_dev(div10, t4);
    			append_dev(div10, div4);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div4, null);
    			}

    			append_dev(div10, t5);
    			append_dev(div10, div5);
    			mount_component(textfield3, div5, null);
    			append_dev(div10, t6);
    			append_dev(div10, div6);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div6, null);
    			}

    			append_dev(div10, t7);
    			append_dev(div10, div7);
    			mount_component(textfield4, div7, null);
    			append_dev(div10, t8);
    			append_dev(div10, div8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			append_dev(div10, t9);
    			append_dev(div10, div9);
    			mount_component(textfield5, div9, null);
    			append_dev(div9, t10);
    			mount_component(textfield6, div9, null);
    			append_dev(div9, t11);
    			mount_component(textfield7, div9, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*style, variableValues, settingsVariable, labelRowB0*/ 196) {
    				each_value_4 = /*settingsVariable*/ ctx[6].b0;
    				validate_each_argument(each_value_4);
    				group_outros();
    				validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key);
    				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key, 1, ctx, each_value_4, each0_lookup, div0, outro_and_destroy_block, create_each_block_4$2, null, get_each_context_4$2);
    				check_outros();
    			}

    			const textfield0_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield0_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].q1float];
    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield1_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bq0];
    			textfield1.$set(textfield1_changes);

    			if (dirty & /*style, variableValues, settingsVariable, bqlensLabel*/ 1092) {
    				each_value_3 = /*settingsVariable*/ ctx[6].bqLenses;
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key_1);
    				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_1, 1, ctx, each_value_3, each1_lookup, div2, outro_and_destroy_block, create_each_block_3$2, null, get_each_context_3$2);
    				check_outros();
    			}

    			const textfield2_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield2_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bq5];
    			textfield2.$set(textfield2_changes);

    			if (dirty & /*style, variableValues, settingsVariable, benderLabel*/ 2116) {
    				each_value_2 = /*settingsVariable*/ ctx[6].benderLenses;
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$3, get_key_2);
    				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_2, 1, ctx, each_value_2, each2_lookup, div4, outro_and_destroy_block, create_each_block_2$3, null, get_each_context_2$3);
    				check_outros();
    			}

    			const textfield3_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield3_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bl4];
    			textfield3.$set(textfield3_changes);

    			if (dirty & /*style, variableValues, settingsVariable, labelRowSE*/ 324) {
    				each_value_1 = /*settingsVariable*/ ctx[6].se;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key_3);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_3, 1, ctx, each_value_1, each3_lookup, div6, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
    				check_outros();
    			}

    			const textfield4_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield4_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].trapfloat];
    			textfield4.$set(textfield4_changes);

    			if (dirty & /*style, variableValues, settingsVariable, labelRowSA*/ 580) {
    				each_value = /*settingsVariable*/ ctx[6].sa;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$8, get_key_4);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key_4, 1, ctx, each_value, each4_lookup, div8, outro_and_destroy_block, create_each_block$8, null, get_each_context$8);
    				check_outros();
    			}

    			const textfield5_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield5_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].bl5];
    			textfield5.$set(textfield5_changes);
    			const textfield6_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield6_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].res];
    			textfield6.$set(textfield6_changes);
    			const textfield7_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield7_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[6].q2float];
    			textfield7.$set(textfield7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks_4[i]);
    			}

    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			transition_in(textfield2.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			transition_in(textfield3.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(textfield4.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(textfield5.$$.fragment, local);
    			transition_in(textfield6.$$.fragment, local);
    			transition_in(textfield7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				transition_out(each_blocks_4[i]);
    			}

    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			transition_out(textfield2.$$.fragment, local);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			transition_out(textfield3.$$.fragment, local);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(textfield4.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(textfield5.$$.fragment, local);
    			transition_out(textfield6.$$.fragment, local);
    			transition_out(textfield7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].d();
    			}

    			destroy_component(textfield0);
    			destroy_component(textfield1);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].d();
    			}

    			destroy_component(textfield2);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].d();
    			}

    			destroy_component(textfield3);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			destroy_component(textfield4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(textfield5);
    			destroy_component(textfield6);
    			destroy_component(textfield7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(98:12) {#if settingsLoaded}",
    		ctx
    	});

    	return block;
    }

    // (104:24) {#each settingsVariable.b0 as item, index (item)}
    function create_each_block_4$2(key_1, ctx) {
    	let first;
    	let textfield;
    	let current;

    	textfield = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*item*/ ctx[20]],
    				label: /*labelRowB0*/ ctx[7][/*index*/ ctx[22]]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[20]];
    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$2.name,
    		type: "each",
    		source: "(104:24) {#each settingsVariable.b0 as item, index (item)}",
    		ctx
    	});

    	return block;
    }

    // (115:24) {#each settingsVariable.bqLenses as item, index (item)}
    function create_each_block_3$2(key_1, ctx) {
    	let first;
    	let textfield;
    	let current;

    	textfield = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*item*/ ctx[20]],
    				label: /*bqlensLabel*/ ctx[10][/*index*/ ctx[22]]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[20]];
    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(115:24) {#each settingsVariable.bqLenses as item, index (item)}",
    		ctx
    	});

    	return block;
    }

    // (123:24) {#each settingsVariable.benderLenses as item, index (item)}
    function create_each_block_2$3(key_1, ctx) {
    	let first;
    	let textfield;
    	let current;

    	textfield = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*item*/ ctx[20]],
    				label: /*benderLabel*/ ctx[11][/*index*/ ctx[22]]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[20]];
    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(123:24) {#each settingsVariable.benderLenses as item, index (item)}",
    		ctx
    	});

    	return block;
    }

    // (134:24) {#each settingsVariable.se as item, index (item)}
    function create_each_block_1$4(key_1, ctx) {
    	let first;
    	let textfield;
    	let current;

    	textfield = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*item*/ ctx[20]],
    				label: /*labelRowSE*/ ctx[8][/*index*/ ctx[22]]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[20]];
    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(134:24) {#each settingsVariable.se as item, index (item)}",
    		ctx
    	});

    	return block;
    }

    // (144:24) {#each settingsVariable.sa as item, index (item)}
    function create_each_block$8(key_1, ctx) {
    	let first;
    	let textfield;
    	let current;

    	textfield = new Textfield({
    			props: {
    				style: style$1,
    				value: /*variableValues*/ ctx[2][/*item*/ ctx[20]],
    				label: /*labelRowSA*/ ctx[9][/*index*/ ctx[22]]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[20]];
    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(144:24) {#each settingsVariable.sa as item, index (item)}",
    		ctx
    	});

    	return block;
    }

    // (92:8) 
    function create_content_slot$3(ctx) {
    	let div;
    	let customswitch;
    	let updating_selected;
    	let t0;
    	let customselect;
    	let updating_picked;
    	let t1;
    	let div_transition;
    	let current;

    	function customswitch_selected_binding(value) {
    		/*customswitch_selected_binding*/ ctx[16](value);
    	}

    	let customswitch_props = {
    		style: "margin: 0 1em;",
    		label: "show all"
    	};

    	if (/*showAllFiles*/ ctx[1] !== void 0) {
    		customswitch_props.selected = /*showAllFiles*/ ctx[1];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding));

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[17](value);
    	}

    	let customselect_props = {
    		style: "width:12em; height:3.5em; margin-right:0.5em",
    		label: "Filename",
    		options: ["", .../*displayFiles*/ ctx[5]]
    	};

    	if (/*selected_file*/ ctx[4] !== void 0) {
    		customselect_props.picked = /*selected_file*/ ctx[4];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));
    	let if_block = /*settingsLoaded*/ ctx[3] && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(customswitch.$$.fragment);
    			t0 = space();
    			create_component(customselect.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "content");
    			add_location(div, file$j, 91, 8, 2911);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(customswitch, div, null);
    			append_dev(div, t0);
    			mount_component(customselect, div, null);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const customswitch_changes = {};

    			if (!updating_selected && dirty & /*showAllFiles*/ 2) {
    				updating_selected = true;
    				customswitch_changes.selected = /*showAllFiles*/ ctx[1];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    			const customselect_changes = {};
    			if (dirty & /*displayFiles*/ 32) customselect_changes.options = ["", .../*displayFiles*/ ctx[5]];

    			if (!updating_picked && dirty & /*selected_file*/ 16) {
    				updating_picked = true;
    				customselect_changes.picked = /*selected_file*/ ctx[4];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);

    			if (/*settingsLoaded*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*settingsLoaded*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customswitch.$$.fragment, local);
    			transition_in(customselect.$$.fragment, local);
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customswitch.$$.fragment, local);
    			transition_out(customselect.$$.fragment, local);
    			transition_out(if_block);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customswitch);
    			destroy_component(customselect);
    			if (if_block) if_block.d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$3.name,
    		type: "slot",
    		source: "(92:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let button;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*active*/ ctx[0] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "GetLabviewSettings";
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$j, 85, 0, 2740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const style$1 = "width:7em; height:3.5em; margin-right:0.5em";

    function instance$k($$self, $$props, $$invalidate) {
    	let displayFiles;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GetLabviewSettings', slots, []);
    	let { currentLocation, fullfileslist, fileChecked } = $$props;
    	let { active = false } = $$props;

    	const settingsVariable = {
    		b0: ["m03_ao09_bl0", "m03_ao09_high", "m03_ao09_width"],
    		bq0: "m03_ao01_bq0",
    		bq5: "m03_ao03_bq5",
    		q1float: "m03_ao15_qd1_float",
    		q2float: "m04_ao09_qd2_float",
    		res: "m03_ao13_reso",
    		bqLenses: ["m03_ao08_bq1", "m03_ao07_bq2", "m03_ao06_bq3", "m03_ao05_bq4"],
    		benderLenses: ["m04_ao01_b_in", "m04_ao00_b_outer", "m04_ao02_b_inner"],
    		se: [
    			"m04_ao03_se_trap_in",
    			"m04_ao03_se_delay",
    			"m04_ao03_se_high",
    			"m04_ao03_se_width"
    		],
    		sa: [
    			"m04_ao04_sa_trap_out",
    			"m04_ao04_sa_delay",
    			"m04_ao04_sa_high",
    			"m04_ao04_sa_width"
    		],
    		trapfloat: "m04_ao05_trap_float",
    		bl4: "m04_ao07_bl4",
    		bl5: "m04_ao08_bl5"
    	};

    	let fileContents = "";
    	let variableValues = {};
    	let settingsLoaded = false;

    	afterUpdate(() => {
    		const fullFilename = pathJoin(currentLocation, selected_file);
    		console.log(fullFilename);
    		$$invalidate(3, settingsLoaded = false);

    		if (fs.existsSync(fullFilename) && selected_file) {
    			fileContents = fs.readFileSync(fullFilename);

    			for (const line of fileContents.split("\n")) {
    				if (line.trim().length > 0 && line.startsWith("# Sect01 Ion Source")) {
    					let tempLine = line.split(" ");
    					$$invalidate(2, variableValues[tempLine[7]] = parseFloat(tempLine[9]), variableValues);
    				}
    			}

    			$$invalidate(3, settingsLoaded = true);
    		}
    	});

    	let showAllFiles = true;
    	const labelRowB0 = ["B0 Low", "B0 high", "B0 Width"];
    	const labelRowSE = ["Trap-in", "SE delay", "SE high", "SE Width"];
    	const labelRowSA = ["Trap-out", "Trap time (ms)", "SA high", "SA Width"];
    	const bqlensLabel = ["bq1", "bq2", "bq3", "bq4"];
    	const benderLabel = ["Bender in", "Bender outer", "Bender inner"];
    	let selected_file = "";
    	const writable_props = ['currentLocation', 'fullfileslist', 'fileChecked', 'active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$8.warn(`<GetLabviewSettings> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, active = true);
    	};

    	function customswitch_selected_binding(value) {
    		showAllFiles = value;
    		$$invalidate(1, showAllFiles);
    	}

    	function customselect_picked_binding(value) {
    		selected_file = value;
    		$$invalidate(4, selected_file);
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('currentLocation' in $$props) $$invalidate(12, currentLocation = $$props.currentLocation);
    		if ('fullfileslist' in $$props) $$invalidate(13, fullfileslist = $$props.fullfileslist);
    		if ('fileChecked' in $$props) $$invalidate(14, fileChecked = $$props.fileChecked);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	$$self.$capture_state = () => ({
    		Modal: Modal$1,
    		fade,
    		afterUpdate,
    		Textfield,
    		CustomSelect: CustomSelect$1,
    		CustomSwitch: CustomSwitch$1,
    		currentLocation,
    		fullfileslist,
    		fileChecked,
    		active,
    		settingsVariable,
    		style: style$1,
    		fileContents,
    		variableValues,
    		settingsLoaded,
    		showAllFiles,
    		labelRowB0,
    		labelRowSE,
    		labelRowSA,
    		bqlensLabel,
    		benderLabel,
    		selected_file,
    		displayFiles
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentLocation' in $$props) $$invalidate(12, currentLocation = $$props.currentLocation);
    		if ('fullfileslist' in $$props) $$invalidate(13, fullfileslist = $$props.fullfileslist);
    		if ('fileChecked' in $$props) $$invalidate(14, fileChecked = $$props.fileChecked);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('fileContents' in $$props) fileContents = $$props.fileContents;
    		if ('variableValues' in $$props) $$invalidate(2, variableValues = $$props.variableValues);
    		if ('settingsLoaded' in $$props) $$invalidate(3, settingsLoaded = $$props.settingsLoaded);
    		if ('showAllFiles' in $$props) $$invalidate(1, showAllFiles = $$props.showAllFiles);
    		if ('selected_file' in $$props) $$invalidate(4, selected_file = $$props.selected_file);
    		if ('displayFiles' in $$props) $$invalidate(5, displayFiles = $$props.displayFiles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*showAllFiles, fullfileslist, fileChecked*/ 24578) {
    			$$invalidate(5, displayFiles = showAllFiles ? fullfileslist : fileChecked);
    		}
    	};

    	return [
    		active,
    		showAllFiles,
    		variableValues,
    		settingsLoaded,
    		selected_file,
    		displayFiles,
    		settingsVariable,
    		labelRowB0,
    		labelRowSE,
    		labelRowSA,
    		bqlensLabel,
    		benderLabel,
    		currentLocation,
    		fullfileslist,
    		fileChecked,
    		click_handler,
    		customswitch_selected_binding,
    		customselect_picked_binding,
    		modal_active_binding
    	];
    }

    class GetLabviewSettings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			currentLocation: 12,
    			fullfileslist: 13,
    			fileChecked: 14,
    			active: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GetLabviewSettings",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*currentLocation*/ ctx[12] === undefined && !('currentLocation' in props)) {
    			console_1$8.warn("<GetLabviewSettings> was created without expected prop 'currentLocation'");
    		}

    		if (/*fullfileslist*/ ctx[13] === undefined && !('fullfileslist' in props)) {
    			console_1$8.warn("<GetLabviewSettings> was created without expected prop 'fullfileslist'");
    		}

    		if (/*fileChecked*/ ctx[14] === undefined && !('fileChecked' in props)) {
    			console_1$8.warn("<GetLabviewSettings> was created without expected prop 'fileChecked'");
    		}
    	}

    	get currentLocation() {
    		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullfileslist() {
    		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullfileslist(value) {
    		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fileChecked() {
    		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Masspec.svelte generated by Svelte v3.42.1 */

    const { console: console_1$7 } = globals;

    const file$i = "src\\Pages\\Masspec.svelte";

    // (128:4) <svelte:fragment slot="buttonContainer">
    function create_buttonContainer_slot$2(ctx) {
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let getlabviewsettings;
    	let t4;
    	let button2;
    	let t6;
    	let customiconswitch;
    	let updating_toggler;
    	let t7;
    	let customswitch;
    	let updating_selected;
    	let t8;
    	let div1;
    	let customselect;
    	let updating_picked;
    	let t9;
    	let textfield0;
    	let updating_value;
    	let t10;
    	let textfield1;
    	let updating_value_1;
    	let t11;
    	let textfield2;
    	let updating_value_2;
    	let t12;
    	let button3;
    	let t14;
    	let button4;
    	let current;
    	let mounted;
    	let dispose;

    	getlabviewsettings = new GetLabviewSettings({
    			props: {
    				currentLocation: /*currentLocation*/ ctx[1],
    				fullfileslist: /*fullfileslist*/ ctx[11],
    				fileChecked: /*fileChecked*/ ctx[0]
    			},
    			$$inline: true
    		});

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[20](value);
    	}

    	let customiconswitch_props = {
    		style: "padding:0;",
    		icons: ["settings_ethernet", "code"]
    	};

    	if (/*openShell*/ ctx[2] !== void 0) {
    		customiconswitch_props.toggler = /*openShell*/ ctx[2];
    	}

    	customiconswitch = new CustomIconSwitch$1({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));

    	function customswitch_selected_binding_1(value) {
    		/*customswitch_selected_binding_1*/ ctx[21](value);
    	}

    	let customswitch_props = { style: "margin: 0 1em;", label: "Log" };

    	if (/*logScale*/ ctx[9] !== void 0) {
    		customswitch_props.selected = /*logScale*/ ctx[9];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding_1));
    	customswitch.$on("change", /*linearlogCheck*/ ctx[14]);

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[22](value);
    	}

    	let customselect_props = {
    		style: "width:12em; height:3.5em; margin-right:0.5em",
    		label: "Filename",
    		options: ["", .../*fileChecked*/ ctx[0]]
    	};

    	if (/*selected_file*/ ctx[5] !== void 0) {
    		customselect_props.picked = /*selected_file*/ ctx[5];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[23](value);
    	}

    	let textfield0_props = {
    		type: "number",
    		style,
    		label: "Prominance"
    	};

    	if (/*peak_prominance*/ ctx[6] !== void 0) {
    		textfield0_props.value = /*peak_prominance*/ ctx[6];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));
    	textfield0.$on("change", /*change_handler*/ ctx[24]);

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[25](value);
    	}

    	let textfield1_props = { type: "number", style, label: "Width" };

    	if (/*peak_width*/ ctx[7] !== void 0) {
    		textfield1_props.value = /*peak_width*/ ctx[7];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	textfield1.$on("change", /*change_handler_1*/ ctx[26]);

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[27](value);
    	}

    	let textfield2_props = { type: "number", style, label: "Height" };

    	if (/*peak_height*/ ctx[8] !== void 0) {
    		textfield2_props.value = /*peak_height*/ ctx[8];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));
    	textfield2.$on("change", /*change_handler_2*/ ctx[28]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Masspec Plot";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Find Peaks";
    			t3 = space();
    			create_component(getlabviewsettings.$$.fragment);
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = "Open in Matplotlib";
    			t6 = space();
    			create_component(customiconswitch.$$.fragment);
    			t7 = space();
    			create_component(customswitch.$$.fragment);
    			t8 = space();
    			div1 = element("div");
    			create_component(customselect.$$.fragment);
    			t9 = space();
    			create_component(textfield0.$$.fragment);
    			t10 = space();
    			create_component(textfield1.$$.fragment);
    			t11 = space();
    			create_component(textfield2.$$.fragment);
    			t12 = space();
    			button3 = element("button");
    			button3.textContent = "Get Peaks";
    			t14 = space();
    			button4 = element("button");
    			button4.textContent = "Clear";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$i, 129, 12, 5514);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$i, 130, 12, 5614);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$i, 132, 12, 5806);
    			attr_dev(div0, "class", "align ");
    			set_style(div0, "align-items", "center");
    			add_location(div0, file$i, 128, 8, 5451);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$i, 144, 12, 6860);
    			attr_dev(button4, "class", "button is-danger");
    			add_location(button4, file$i, 145, 12, 6980);
    			attr_dev(div1, "class", "align animated fadeIn");
    			toggle_class(div1, "hide", /*toggleRow1*/ ctx[4]);
    			add_location(div1, file$i, 137, 8, 6177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div0, t3);
    			mount_component(getlabviewsettings, div0, null);
    			append_dev(div0, t4);
    			append_dev(div0, button2);
    			append_dev(div0, t6);
    			mount_component(customiconswitch, div0, null);
    			append_dev(div0, t7);
    			mount_component(customswitch, div0, null);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(customselect, div1, null);
    			append_dev(div1, t9);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t10);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t11);
    			mount_component(textfield2, div1, null);
    			append_dev(div1, t12);
    			append_dev(div1, button3);
    			append_dev(div1, t14);
    			append_dev(div1, button4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[17], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[18], false, false, false),
    					listen_dev(button2, "click", /*click_handler_3*/ ctx[19], false, false, false),
    					listen_dev(button3, "click", /*click_handler_4*/ ctx[29], false, false, false),
    					listen_dev(button4, "click", /*click_handler_5*/ ctx[30], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const getlabviewsettings_changes = {};
    			if (dirty[0] & /*currentLocation*/ 2) getlabviewsettings_changes.currentLocation = /*currentLocation*/ ctx[1];
    			if (dirty[0] & /*fullfileslist*/ 2048) getlabviewsettings_changes.fullfileslist = /*fullfileslist*/ ctx[11];
    			if (dirty[0] & /*fileChecked*/ 1) getlabviewsettings_changes.fileChecked = /*fileChecked*/ ctx[0];
    			getlabviewsettings.$set(getlabviewsettings_changes);
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty[0] & /*openShell*/ 4) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*openShell*/ ctx[2];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);
    			const customswitch_changes = {};

    			if (!updating_selected && dirty[0] & /*logScale*/ 512) {
    				updating_selected = true;
    				customswitch_changes.selected = /*logScale*/ ctx[9];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    			const customselect_changes = {};
    			if (dirty[0] & /*fileChecked*/ 1) customselect_changes.options = ["", .../*fileChecked*/ ctx[0]];

    			if (!updating_picked && dirty[0] & /*selected_file*/ 32) {
    				updating_picked = true;
    				customselect_changes.picked = /*selected_file*/ ctx[5];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*peak_prominance*/ 64) {
    				updating_value = true;
    				textfield0_changes.value = /*peak_prominance*/ ctx[6];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*peak_width*/ 128) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*peak_width*/ ctx[7];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*peak_height*/ 256) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*peak_height*/ ctx[8];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);

    			if (dirty[0] & /*toggleRow1*/ 16) {
    				toggle_class(div1, "hide", /*toggleRow1*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(getlabviewsettings.$$.fragment, local);
    			transition_in(customiconswitch.$$.fragment, local);
    			transition_in(customswitch.$$.fragment, local);
    			transition_in(customselect.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(getlabviewsettings.$$.fragment, local);
    			transition_out(customiconswitch.$$.fragment, local);
    			transition_out(customswitch.$$.fragment, local);
    			transition_out(customselect.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(getlabviewsettings);
    			destroy_component(customiconswitch);
    			destroy_component(customswitch);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div1);
    			destroy_component(customselect);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_buttonContainer_slot$2.name,
    		type: "slot",
    		source: "(128:4) <svelte:fragment slot=\\\"buttonContainer\\\">",
    		ctx
    	});

    	return block;
    }

    // (151:4) <svelte:fragment slot="plotContainer">
    function create_plotContainer_slot$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "mplot");
    			attr_dev(div, "class", "graph__div");
    			add_location(div, file$i, 150, 42, 7201);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_slot$2.name,
    		type: "slot",
    		source: "(151:4) <svelte:fragment slot=\\\"plotContainer\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:4) <svelte:fragment slot="plotContainer_functions" >
    function create_plotContainer_functions_slot(ctx) {
    	let div;
    	let customswitch;
    	let updating_selected;
    	let t0;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	function customswitch_selected_binding(value) {
    		/*customswitch_selected_binding*/ ctx[15](value);
    	}

    	let customswitch_props = {
    		style: "margin: 0 1em;",
    		label: "Keep Annotaions"
    	};

    	if (/*keepAnnotaions*/ ctx[10] !== void 0) {
    		customswitch_props.selected = /*keepAnnotaions*/ ctx[10];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(customswitch.$$.fragment);
    			t0 = space();
    			button = element("button");
    			button.textContent = "Clear";
    			attr_dev(button, "class", "button is-danger");
    			add_location(button, file$i, 155, 12, 7502);
    			attr_dev(div, "class", "align");
    			set_style(div, "justify-content", "flex-end");
    			add_location(div, file$i, 153, 8, 7327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(customswitch, div, null);
    			append_dev(div, t0);
    			append_dev(div, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const customswitch_changes = {};

    			if (!updating_selected && dirty[0] & /*keepAnnotaions*/ 1024) {
    				updating_selected = true;
    				customswitch_changes.selected = /*keepAnnotaions*/ ctx[10];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customswitch.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customswitch.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customswitch);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_functions_slot.name,
    		type: "slot",
    		source: "(153:4) <svelte:fragment slot=\\\"plotContainer_functions\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let layout;
    	let updating_fullfileslist;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let current;

    	function layout_fullfileslist_binding(value) {
    		/*layout_fullfileslist_binding*/ ctx[31](value);
    	}

    	function layout_currentLocation_binding(value) {
    		/*layout_currentLocation_binding*/ ctx[32](value);
    	}

    	function layout_fileChecked_binding(value) {
    		/*layout_fileChecked_binding*/ ctx[33](value);
    	}

    	let layout_props = {
    		filetype: filetype$2,
    		id: id$2,
    		graphPlotted: /*graphPlotted*/ ctx[3],
    		$$slots: {
    			plotContainer_functions: [create_plotContainer_functions_slot],
    			plotContainer: [create_plotContainer_slot$2],
    			buttonContainer: [create_buttonContainer_slot$2]
    		},
    		$$scope: { ctx }
    	};

    	if (/*fullfileslist*/ ctx[11] !== void 0) {
    		layout_props.fullfileslist = /*fullfileslist*/ ctx[11];
    	}

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		layout_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		layout_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	layout = new Layout({ props: layout_props, $$inline: true });
    	binding_callbacks.push(() => bind(layout, 'fullfileslist', layout_fullfileslist_binding));
    	binding_callbacks.push(() => bind(layout, 'currentLocation', layout_currentLocation_binding));
    	binding_callbacks.push(() => bind(layout, 'fileChecked', layout_fileChecked_binding));

    	const block = {
    		c: function create() {
    			create_component(layout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const layout_changes = {};
    			if (dirty[0] & /*graphPlotted*/ 8) layout_changes.graphPlotted = /*graphPlotted*/ ctx[3];

    			if (dirty[0] & /*annotations, keepAnnotaions, toggleRow1, graphPlotted, peak_height, peak_width, peak_prominance, fileChecked, selected_file, logScale, openShell, currentLocation, fullfileslist*/ 8191 | dirty[1] & /*$$scope*/ 64) {
    				layout_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_fullfileslist && dirty[0] & /*fullfileslist*/ 2048) {
    				updating_fullfileslist = true;
    				layout_changes.fullfileslist = /*fullfileslist*/ ctx[11];
    				add_flush_callback(() => updating_fullfileslist = false);
    			}

    			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			layout.$set(layout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const filetype$2 = "mass", id$2 = "Masspec";
    const style = "width:7em; height:3.5em; margin-right:0.5em";

    function instance$j($$self, $$props, $$invalidate) {
    	let massfiles;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Masspec', slots, []);
    	let fileChecked = [];
    	let currentLocation = db.get(`${filetype$2}_location`) || "";
    	let openShell = false, graphPlotted = false;

    	// Find peaks
    	let toggleRow1 = true;

    	let selected_file = "", peak_prominance = 3, peak_width = 2, peak_height = 40;
    	let logScale = true;
    	let keepAnnotaions = true;

    	// Functions
    	function plotData({ e = null, filetype = "mass" } = {}) {
    		if (!fs.existsSync(currentLocation)) {
    			return window.createToast("Location not defined", "danger");
    		}

    		if (fileChecked.length < 1) {
    			return window.createToast("No files selected", "danger");
    		}

    		if (filetype === "find_peaks") {
    			if (selected_file === "") return window.createToast("No files selected", "danger");
    		}

    		// console.log("Running")
    		let pyfileInfo = {
    			mass: {
    				pyfile: "mass.py",
    				args: [...massfiles, "run"]
    			},
    			general: {
    				pyfile: "mass.py",
    				args: [...massfiles, "plot"]
    			},
    			find_peaks: {
    				pyfile: "find_peaks_masspec.py",
    				args: [
    					pathResolve(currentLocation, selected_file),
    					peak_prominance,
    					peak_width,
    					peak_height
    				]
    			}
    		};

    		let { pyfile, args } = pyfileInfo[filetype];

    		if (filetype == "general") {
    			return computePy_func({
    				e,
    				pyfile,
    				args,
    				general: true,
    				openShell
    			}).catch(error => {
    				window.handleError(error);
    			});
    		}

    		if (filetype == "mass") {
    			$$invalidate(3, graphPlotted = false);
    		}

    		return computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			if (filetype == "mass") {
    				if (!keepAnnotaions) {
    					$$invalidate(12, annotations = []);
    				}

    				plot("Mass spectrum", "Mass [u]", "Counts", dataFromPython, "mplot", logScale ? "log" : "linear");

    				if (keepAnnotaions) {
    					Plotly.relayout("mplot", { annotations });
    				}

    				plotlyEventCreatedMass
    				? console.log("Plotly event ready for mass spectrum")
    				: plotlyClick();
    			} else if (filetype == "find_peaks") {
    				Plotly.relayout("mplot", { yaxis: { title: "Counts", type: "" } });
    				Plotly.relayout("mplot", { annotations: [] });

    				Plotly.relayout("mplot", {
    					annotations: dataFromPython["annotations"]
    				});

    				Plotly.relayout("mplot", { yaxis: { title: "Counts", type: "log" } });
    			}

    			window.createToast("Graph plotted", "success");
    			$$invalidate(3, graphPlotted = true);
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	// Linearlog check
    	const linearlogCheck = () => {
    		let layout = {
    			yaxis: {
    				title: "Counts",
    				type: logScale ? "log" : null
    			}
    		};

    		if (graphPlotted) Plotly.relayout("mplot", layout);
    	};

    	let fullfileslist = [];
    	let plotlyEventCreatedMass = false;
    	let annotations = [];

    	function plotlyClick() {
    		const mplot = document.getElementById("mplot");

    		mplot.on('plotly_click', data => {
    			if (data.event.ctrlKey) {
    				const { points } = data;
    				const currentDataPoint = points[0];
    				const { x: mass, y: counts, curveNumber } = currentDataPoint;

    				if (data.event.shiftKey) {
    					const annotate = _.find(annotations, m => {
    						const massValue = m.text.split(", ")[0].split("(")[1];
    						return massValue >= mass - 0.2 && massValue <= mass + 0.2;
    					});

    					$$invalidate(12, annotations = _.differenceBy(annotations, [annotate], 'x'));
    					console.log(annotations, annotate);
    				} else {
    					const { color } = currentDataPoint.fullData.line;

    					const annotate = {
    						text: `(${mass}, ${counts})`,
    						x: mass,
    						y: logScale ? Math.log10(counts) : counts,
    						xref: 'x',
    						yref: 'y',
    						font: { color },
    						showarrow: true,
    						arrowhead: 2,
    						arrowcolor: color
    					};

    					$$invalidate(12, annotations = [...annotations, annotate]);
    				}

    				Plotly.relayout("mplot", { annotations });
    				plotlyEventCreatedMass = true;
    			}
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$7.warn(`<Masspec> was created with unknown prop '${key}'`);
    	});

    	function customswitch_selected_binding(value) {
    		keepAnnotaions = value;
    		$$invalidate(10, keepAnnotaions);
    	}

    	const click_handler = () => {
    		$$invalidate(12, annotations = []);
    		Plotly.relayout("mplot", { annotations });
    	};

    	const click_handler_1 = e => plotData({ e });

    	const click_handler_2 = () => {
    		$$invalidate(4, toggleRow1 = !toggleRow1);
    	};

    	const click_handler_3 = e => plotData({ e, filetype: "general" });

    	function customiconswitch_toggler_binding(value) {
    		openShell = value;
    		$$invalidate(2, openShell);
    	}

    	function customswitch_selected_binding_1(value) {
    		logScale = value;
    		$$invalidate(9, logScale);
    	}

    	function customselect_picked_binding(value) {
    		selected_file = value;
    		$$invalidate(5, selected_file);
    	}

    	function textfield0_value_binding(value) {
    		peak_prominance = value;
    		$$invalidate(6, peak_prominance);
    	}

    	const change_handler = e => plotData({ e, filetype: "find_peaks" });

    	function textfield1_value_binding(value) {
    		peak_width = value;
    		$$invalidate(7, peak_width);
    	}

    	const change_handler_1 = e => plotData({ e, filetype: "find_peaks" });

    	function textfield2_value_binding(value) {
    		peak_height = value;
    		$$invalidate(8, peak_height);
    	}

    	const change_handler_2 = e => plotData({ e, filetype: "find_peaks" });
    	const click_handler_4 = e => plotData({ e, filetype: "find_peaks" });

    	const click_handler_5 = () => {
    		if (graphPlotted) {
    			Plotly.relayout("mplot", { annotations: [] });
    		}
    	};

    	function layout_fullfileslist_binding(value) {
    		fullfileslist = value;
    		$$invalidate(11, fullfileslist);
    	}

    	function layout_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	function layout_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Layout,
    		CustomIconSwitch: CustomIconSwitch$1,
    		CustomSelect: CustomSelect$1,
    		CustomSwitch: CustomSwitch$1,
    		Textfield,
    		plot,
    		GetLabviewSettings,
    		filetype: filetype$2,
    		id: id$2,
    		fileChecked,
    		currentLocation,
    		openShell,
    		graphPlotted,
    		toggleRow1,
    		selected_file,
    		peak_prominance,
    		peak_width,
    		peak_height,
    		style,
    		logScale,
    		keepAnnotaions,
    		plotData,
    		linearlogCheck,
    		fullfileslist,
    		plotlyEventCreatedMass,
    		annotations,
    		plotlyClick,
    		massfiles
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('openShell' in $$props) $$invalidate(2, openShell = $$props.openShell);
    		if ('graphPlotted' in $$props) $$invalidate(3, graphPlotted = $$props.graphPlotted);
    		if ('toggleRow1' in $$props) $$invalidate(4, toggleRow1 = $$props.toggleRow1);
    		if ('selected_file' in $$props) $$invalidate(5, selected_file = $$props.selected_file);
    		if ('peak_prominance' in $$props) $$invalidate(6, peak_prominance = $$props.peak_prominance);
    		if ('peak_width' in $$props) $$invalidate(7, peak_width = $$props.peak_width);
    		if ('peak_height' in $$props) $$invalidate(8, peak_height = $$props.peak_height);
    		if ('logScale' in $$props) $$invalidate(9, logScale = $$props.logScale);
    		if ('keepAnnotaions' in $$props) $$invalidate(10, keepAnnotaions = $$props.keepAnnotaions);
    		if ('fullfileslist' in $$props) $$invalidate(11, fullfileslist = $$props.fullfileslist);
    		if ('plotlyEventCreatedMass' in $$props) plotlyEventCreatedMass = $$props.plotlyEventCreatedMass;
    		if ('annotations' in $$props) $$invalidate(12, annotations = $$props.annotations);
    		if ('massfiles' in $$props) massfiles = $$props.massfiles;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*currentLocation, fileChecked*/ 3) {
    			massfiles = fs.existsSync(currentLocation)
    			? fileChecked.map(file => pathResolve(currentLocation, file))
    			: [];
    		}
    	};

    	return [
    		fileChecked,
    		currentLocation,
    		openShell,
    		graphPlotted,
    		toggleRow1,
    		selected_file,
    		peak_prominance,
    		peak_width,
    		peak_height,
    		logScale,
    		keepAnnotaions,
    		fullfileslist,
    		annotations,
    		plotData,
    		linearlogCheck,
    		customswitch_selected_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		customiconswitch_toggler_binding,
    		customswitch_selected_binding_1,
    		customselect_picked_binding,
    		textfield0_value_binding,
    		change_handler,
    		textfield1_value_binding,
    		change_handler_1,
    		textfield2_value_binding,
    		change_handler_2,
    		click_handler_4,
    		click_handler_5,
    		layout_fullfileslist_binding,
    		layout_currentLocation_binding,
    		layout_fileChecked_binding
    	];
    }

    class Masspec extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$j, create_fragment$j, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Masspec",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\components\CustomSwitch.svelte generated by Svelte v3.42.1 */
    const file$h = "src\\components\\CustomSwitch.svelte";

    // (9:0) <FormField {style}>
    function create_default_slot$4(ctx) {
    	let switch_1;
    	let updating_checked;
    	let current;

    	function switch_1_checked_binding(value) {
    		/*switch_1_checked_binding*/ ctx[3](value);
    	}

    	let switch_1_props = {};

    	if (/*selected*/ ctx[0] !== void 0) {
    		switch_1_props.checked = /*selected*/ ctx[0];
    	}

    	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));
    	switch_1.$on("change", /*change_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(switch_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(switch_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_1_changes = {};

    			if (!updating_checked && dirty & /*selected*/ 1) {
    				updating_checked = true;
    				switch_1_changes.checked = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			switch_1.$set(switch_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(switch_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(switch_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(switch_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(9:0) <FormField {style}>",
    		ctx
    	});

    	return block;
    }

    // (11:4) 
    function create_label_slot(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*label*/ ctx[2]);
    			attr_dev(span, "slot", "label");
    			add_location(span, file$h, 10, 4, 244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_label_slot.name,
    		type: "slot",
    		source: "(11:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let formfield;
    	let current;

    	formfield = new FormField({
    			props: {
    				style: /*style*/ ctx[1],
    				$$slots: {
    					label: [create_label_slot],
    					default: [create_default_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfield.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const formfield_changes = {};
    			if (dirty & /*style*/ 2) formfield_changes.style = /*style*/ ctx[1];

    			if (dirty & /*$$scope, label, selected*/ 37) {
    				formfield_changes.$$scope = { dirty, ctx };
    			}

    			formfield.$set(formfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomSwitch', slots, []);
    	let { selected = false, style = "", label = "" } = $$props;
    	const writable_props = ['selected', 'style', 'label'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomSwitch> was created with unknown prop '${key}'`);
    	});

    	function switch_1_checked_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({
    		Switch,
    		FormField,
    		selected,
    		style,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selected, style, label, switch_1_checked_binding, change_handler];
    }

    class CustomSwitch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, { selected: 0, style: 1, label: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomSwitch",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get selected() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CustomSelect.svelte generated by Svelte v3.42.1 */

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (10:8) <Option value={option} selected={picked === option}>
    function create_default_slot_1$2(ctx) {
    	let t_value = /*option*/ ctx[6] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[6] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(10:8) <Option value={option} selected={picked === option}>",
    		ctx
    	});

    	return block;
    }

    // (9:4) {#each options as option}
    function create_each_block$7(ctx) {
    	let option;
    	let current;

    	option = new Option({
    			props: {
    				value: /*option*/ ctx[6],
    				selected: /*picked*/ ctx[0] === /*option*/ ctx[6],
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(option.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(option, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const option_changes = {};
    			if (dirty & /*options*/ 2) option_changes.value = /*option*/ ctx[6];
    			if (dirty & /*picked, options*/ 3) option_changes.selected = /*picked*/ ctx[0] === /*option*/ ctx[6];

    			if (dirty & /*$$scope, options*/ 514) {
    				option_changes.$$scope = { dirty, ctx };
    			}

    			option.$set(option_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(option.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(option.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(option, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(9:4) {#each options as option}",
    		ctx
    	});

    	return block;
    }

    // (7:0) <Select bind:value={picked} {label} {style} on:change>
    function create_default_slot$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*options, picked*/ 3) {
    				each_value = /*options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(7:0) <Select bind:value={picked} {label} {style} on:change>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let select;
    	let updating_value;
    	let current;

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[4](value);
    	}

    	let select_props = {
    		label: /*label*/ ctx[3],
    		style: /*style*/ ctx[2],
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	if (/*picked*/ ctx[0] !== void 0) {
    		select_props.value = /*picked*/ ctx[0];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind(select, 'value', select_value_binding));
    	select.$on("change", /*change_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(select.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(select, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const select_changes = {};
    			if (dirty & /*label*/ 8) select_changes.label = /*label*/ ctx[3];
    			if (dirty & /*style*/ 4) select_changes.style = /*style*/ ctx[2];

    			if (dirty & /*$$scope, options, picked*/ 515) {
    				select_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*picked*/ 1) {
    				updating_value = true;
    				select_changes.value = /*picked*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(select, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomSelect', slots, []);
    	let { options = [], style = "", label = "", picked = "" } = $$props;
    	const writable_props = ['options', 'style', 'label', 'picked'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomSelect> was created with unknown prop '${key}'`);
    	});

    	function select_value_binding(value) {
    		picked = value;
    		$$invalidate(0, picked);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('picked' in $$props) $$invalidate(0, picked = $$props.picked);
    	};

    	$$self.$capture_state = () => ({
    		Select,
    		Option,
    		options,
    		style,
    		label,
    		picked
    	});

    	$$self.$inject_state = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('label' in $$props) $$invalidate(3, label = $$props.label);
    		if ('picked' in $$props) $$invalidate(0, picked = $$props.picked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [picked, options, style, label, select_value_binding, change_handler];
    }

    class CustomSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			options: 1,
    			style: 2,
    			label: 3,
    			picked: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomSelect",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get options() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get picked() {
    		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set picked(value) {
    		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\ModalTable.svelte generated by Svelte v3.42.1 */
    const file$g = "src\\components\\ModalTable.svelte";
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});

    // (11:0) {#if active}
    function create_if_block$b(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[12](value);
    	}

    	let modal_props = {
    		title: /*title*/ ctx[2],
    		$$slots: {
    			footerbtn: [create_footerbtn_slot$1],
    			content: [create_content_slot$2]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};
    			if (dirty & /*title*/ 4) modal_changes.title = /*title*/ ctx[2];

    			if (dirty & /*$$scope, active, keys, sortOption, closeOption, addextraOption, animateRow, userSelect, rows*/ 8699) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(11:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (14:8) <svelte:fragment slot="content">
    function create_content_slot$2(ctx) {
    	let table;
    	let updating_rows;
    	let current;

    	function table_rows_binding(value) {
    		/*table_rows_binding*/ ctx[11](value);
    	}

    	let table_props = {
    		head: /*keys*/ ctx[3],
    		keys: /*keys*/ ctx[3],
    		sortOption: /*sortOption*/ ctx[5],
    		closeOption: /*closeOption*/ ctx[6],
    		addextraOption: /*addextraOption*/ ctx[7],
    		animateRow: /*animateRow*/ ctx[8],
    		userSelect: /*userSelect*/ ctx[4]
    	};

    	if (/*rows*/ ctx[1] !== void 0) {
    		table_props.rows = /*rows*/ ctx[1];
    	}

    	table = new Table({ props: table_props, $$inline: true });
    	binding_callbacks.push(() => bind(table, 'rows', table_rows_binding));

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};
    			if (dirty & /*keys*/ 8) table_changes.head = /*keys*/ ctx[3];
    			if (dirty & /*keys*/ 8) table_changes.keys = /*keys*/ ctx[3];
    			if (dirty & /*sortOption*/ 32) table_changes.sortOption = /*sortOption*/ ctx[5];
    			if (dirty & /*closeOption*/ 64) table_changes.closeOption = /*closeOption*/ ctx[6];
    			if (dirty & /*addextraOption*/ 128) table_changes.addextraOption = /*addextraOption*/ ctx[7];
    			if (dirty & /*animateRow*/ 256) table_changes.animateRow = /*animateRow*/ ctx[8];
    			if (dirty & /*userSelect*/ 16) table_changes.userSelect = /*userSelect*/ ctx[4];

    			if (!updating_rows && dirty & /*rows*/ 2) {
    				updating_rows = true;
    				table_changes.rows = /*rows*/ ctx[1];
    				add_flush_callback(() => updating_rows = false);
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$2.name,
    		type: "slot",
    		source: "(14:8) <svelte:fragment slot=\\\"content\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:32) <button class="button is-link" on:click="{()=>active=false}" >
    function fallback_block(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Close";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$g, 17, 32, 617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(18:32) <button class=\\\"button is-link\\\" on:click=\\\"{()=>active=false}\\\" >",
    		ctx
    	});

    	return block;
    }

    // (17:8) <svelte:fragment slot="footerbtn">
    function create_footerbtn_slot$1(ctx) {
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[9].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[13], get_footer_slot_context);
    	const footer_slot_or_fallback = footer_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (footer_slot_or_fallback) {
    				footer_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[13], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			} else {
    				if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty & /*active*/ 1)) {
    					footer_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot$1.name,
    		type: "slot",
    		source: "(17:8) <svelte:fragment slot=\\\"footerbtn\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModalTable', slots, ['footer']);
    	let { active = false, title = "Title", rows = [], keys = [], userSelect = true } = $$props;
    	let { sortOption = false, closeOption = true, addextraOption = true, animateRow = false } = $$props;

    	const writable_props = [
    		'active',
    		'title',
    		'rows',
    		'keys',
    		'userSelect',
    		'sortOption',
    		'closeOption',
    		'addextraOption',
    		'animateRow'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModalTable> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, active = false);

    	function table_rows_binding(value) {
    		rows = value;
    		$$invalidate(1, rows);
    	}

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('rows' in $$props) $$invalidate(1, rows = $$props.rows);
    		if ('keys' in $$props) $$invalidate(3, keys = $$props.keys);
    		if ('userSelect' in $$props) $$invalidate(4, userSelect = $$props.userSelect);
    		if ('sortOption' in $$props) $$invalidate(5, sortOption = $$props.sortOption);
    		if ('closeOption' in $$props) $$invalidate(6, closeOption = $$props.closeOption);
    		if ('addextraOption' in $$props) $$invalidate(7, addextraOption = $$props.addextraOption);
    		if ('animateRow' in $$props) $$invalidate(8, animateRow = $$props.animateRow);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Modal: Modal$1,
    		Table,
    		active,
    		title,
    		rows,
    		keys,
    		userSelect,
    		sortOption,
    		closeOption,
    		addextraOption,
    		animateRow
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('rows' in $$props) $$invalidate(1, rows = $$props.rows);
    		if ('keys' in $$props) $$invalidate(3, keys = $$props.keys);
    		if ('userSelect' in $$props) $$invalidate(4, userSelect = $$props.userSelect);
    		if ('sortOption' in $$props) $$invalidate(5, sortOption = $$props.sortOption);
    		if ('closeOption' in $$props) $$invalidate(6, closeOption = $$props.closeOption);
    		if ('addextraOption' in $$props) $$invalidate(7, addextraOption = $$props.addextraOption);
    		if ('animateRow' in $$props) $$invalidate(8, animateRow = $$props.animateRow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		rows,
    		title,
    		keys,
    		userSelect,
    		sortOption,
    		closeOption,
    		addextraOption,
    		animateRow,
    		slots,
    		click_handler,
    		table_rows_binding,
    		modal_active_binding,
    		$$scope
    	];
    }

    class ModalTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			active: 0,
    			title: 2,
    			rows: 1,
    			keys: 3,
    			userSelect: 4,
    			sortOption: 5,
    			closeOption: 6,
    			addextraOption: 7,
    			animateRow: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalTable",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get active() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keys() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keys(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get userSelect() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set userSelect(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortOption() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortOption(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOption() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOption(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addextraOption() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addextraOption(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get animateRow() {
    		throw new Error("<ModalTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animateRow(value) {
    		throw new Error("<ModalTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\timescan\components\ROSAAkinetics.svelte generated by Svelte v3.42.1 */

    const { Object: Object_1$2, console: console_1$6 } = globals;
    const file$f = "src\\Pages\\timescan\\components\\ROSAAkinetics.svelte";

    // (219:4) <svelte:fragment slot="footer">
    function create_footer_slot(ctx) {
    	let button0;
    	let t1;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "Save";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Close";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$f, 220, 8, 8116);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$f, 222, 8, 8197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button1, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*saveConfig*/ ctx[23], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot.name,
    		type: "slot",
    		source: "(219:4) <svelte:fragment slot=\\\"footer\\\">",
    		ctx
    	});

    	return block;
    }

    // (260:8) <Icon class="material-icons" on:click="{()=> adjustConfig = true}">
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("settings");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(260:8) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=> adjustConfig = true}\\\">",
    		ctx
    	});

    	return block;
    }

    // (264:8) {#if pyEventCounter}
    function create_if_block$a(ctx) {
    	let div;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*pyEventCounter*/ ctx[17]);
    			t1 = text(" process running");
    			attr_dev(div, "class", "subtitle");
    			add_location(div, file$f, 265, 12, 10229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pyEventCounter*/ 131072) set_data_dev(t0, /*pyEventCounter*/ ctx[17]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(264:8) {#if pyEventCounter}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let modaltable;
    	let updating_active;
    	let updating_rows;
    	let t0;
    	let div3;
    	let div0;
    	let customswitch0;
    	let updating_selected;
    	let t1;
    	let textfield0;
    	let updating_value;
    	let t2;
    	let textfield1;
    	let updating_value_1;
    	let t3;
    	let textfield2;
    	let updating_value_2;
    	let t4;
    	let textfield3;
    	let updating_value_3;
    	let t5;
    	let textfield4;
    	let updating_value_4;
    	let t6;
    	let div1;
    	let customselect;
    	let updating_picked;
    	let t7;
    	let textfield5;
    	let updating_value_5;
    	let t8;
    	let textfield6;
    	let updating_value_6;
    	let t9;
    	let textfield7;
    	let updating_value_7;
    	let t10;
    	let textfield8;
    	let updating_value_8;
    	let t11;
    	let customswitch1;
    	let updating_selected_1;
    	let t12;
    	let textfield9;
    	let updating_value_9;
    	let t13;
    	let textfield10;
    	let updating_value_10;
    	let t14;
    	let textfield11;
    	let updating_value_11;
    	let t15;
    	let textfield12;
    	let updating_value_12;
    	let t16;
    	let textfield13;
    	let updating_value_13;
    	let t17;
    	let div2;
    	let button0;
    	let t19;
    	let button1;
    	let t21;
    	let icon;
    	let t22;
    	let button2;
    	let t24;
    	let current;
    	let mounted;
    	let dispose;

    	function modaltable_active_binding(value) {
    		/*modaltable_active_binding*/ ctx[35](value);
    	}

    	function modaltable_rows_binding(value) {
    		/*modaltable_rows_binding*/ ctx[36](value);
    	}

    	let modaltable_props = {
    		title: "Config table",
    		keys: /*configKeys*/ ctx[27],
    		userSelect: false,
    		sortOption: true,
    		$$slots: { footer: [create_footer_slot] },
    		$$scope: { ctx }
    	};

    	if (/*adjustConfig*/ ctx[20] !== void 0) {
    		modaltable_props.active = /*adjustConfig*/ ctx[20];
    	}

    	if (/*configArray*/ ctx[21] !== void 0) {
    		modaltable_props.rows = /*configArray*/ ctx[21];
    	}

    	modaltable = new ModalTable({ props: modaltable_props, $$inline: true });
    	binding_callbacks.push(() => bind(modaltable, 'active', modaltable_active_binding));
    	binding_callbacks.push(() => bind(modaltable, 'rows', modaltable_rows_binding));

    	function customswitch0_selected_binding(value) {
    		/*customswitch0_selected_binding*/ ctx[37](value);
    	}

    	let customswitch0_props = { label: "SRG" };

    	if (/*srgMode*/ ctx[1] !== void 0) {
    		customswitch0_props.selected = /*srgMode*/ ctx[1];
    	}

    	customswitch0 = new CustomSwitch({
    			props: customswitch0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch0, 'selected', customswitch0_selected_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[38](value);
    	}

    	let textfield0_props = { label: "pbefore" };

    	if (/*pbefore*/ ctx[2] !== void 0) {
    		textfield0_props.value = /*pbefore*/ ctx[2];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[39](value);
    	}

    	let textfield1_props = { label: "pafter" };

    	if (/*pafter*/ ctx[3] !== void 0) {
    		textfield1_props.value = /*pafter*/ ctx[3];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[40](value);
    	}

    	let textfield2_props = {
    		input$type: "number",
    		input$step: "0.5",
    		label: "calibrationFactor"
    	};

    	if (/*calibrationFactor*/ ctx[7] !== void 0) {
    		textfield2_props.value = /*calibrationFactor*/ ctx[7];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[41](value);
    	}

    	let textfield3_props = {
    		input$type: "number",
    		input$step: "0.1",
    		label: "temp(K)"
    	};

    	if (/*temp*/ ctx[4] !== void 0) {
    		textfield3_props.value = /*temp*/ ctx[4];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[42](value);
    	}

    	let textfield4_props = { label: "numberDensity", disabled: true };

    	if (/*numberDensity*/ ctx[16] !== void 0) {
    		textfield4_props.value = /*numberDensity*/ ctx[16];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[43](value);
    	}

    	let customselect_props = {
    		label: "Filename",
    		options: ["", .../*fileCollections*/ ctx[8]],
    		style: "min-width: 7em; "
    	};

    	if (/*selectedFile*/ ctx[6] !== void 0) {
    		customselect_props.picked = /*selectedFile*/ ctx[6];
    	}

    	customselect = new CustomSelect({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));

    	function textfield5_value_binding(value) {
    		/*textfield5_value_binding*/ ctx[44](value);
    	}

    	let textfield5_props = { label: "Molecule" };

    	if (/*molecule*/ ctx[9] !== void 0) {
    		textfield5_props.value = /*molecule*/ ctx[9];
    	}

    	textfield5 = new Textfield({ props: textfield5_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield5, 'value', textfield5_value_binding));

    	function textfield6_value_binding(value) {
    		/*textfield6_value_binding*/ ctx[45](value);
    	}

    	let textfield6_props = { label: "tag" };

    	if (/*tag*/ ctx[10] !== void 0) {
    		textfield6_props.value = /*tag*/ ctx[10];
    	}

    	textfield6 = new Textfield({ props: textfield6_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield6, 'value', textfield6_value_binding));

    	function textfield7_value_binding(value) {
    		/*textfield7_value_binding*/ ctx[46](value);
    	}

    	let textfield7_props = { label: "massOfReactants" };

    	if (/*massOfReactants*/ ctx[5] !== void 0) {
    		textfield7_props.value = /*massOfReactants*/ ctx[5];
    	}

    	textfield7 = new Textfield({ props: textfield7_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield7, 'value', textfield7_value_binding));

    	function textfield8_value_binding(value) {
    		/*textfield8_value_binding*/ ctx[47](value);
    	}

    	let textfield8_props = { label: "nameOfReactants" };

    	if (/*nameOfReactants*/ ctx[11] !== void 0) {
    		textfield8_props.value = /*nameOfReactants*/ ctx[11];
    	}

    	textfield8 = new Textfield({ props: textfield8_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield8, 'value', textfield8_value_binding));

    	function customswitch1_selected_binding(value) {
    		/*customswitch1_selected_binding*/ ctx[48](value);
    	}

    	let customswitch1_props = { label: "defaultInitialValues" };

    	if (/*defaultInitialValues*/ ctx[18] !== void 0) {
    		customswitch1_props.selected = /*defaultInitialValues*/ ctx[18];
    	}

    	customswitch1 = new CustomSwitch({
    			props: customswitch1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch1, 'selected', customswitch1_selected_binding));

    	function textfield9_value_binding(value) {
    		/*textfield9_value_binding*/ ctx[49](value);
    	}

    	let textfield9_props = { label: "initialValues" };

    	if (/*initialValues*/ ctx[19] !== void 0) {
    		textfield9_props.value = /*initialValues*/ ctx[19];
    	}

    	textfield9 = new Textfield({ props: textfield9_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield9, 'value', textfield9_value_binding));

    	function textfield10_value_binding(value) {
    		/*textfield10_value_binding*/ ctx[50](value);
    	}

    	let textfield10_props = { label: "ratek3" };

    	if (/*ratek3*/ ctx[12] !== void 0) {
    		textfield10_props.value = /*ratek3*/ ctx[12];
    	}

    	textfield10 = new Textfield({ props: textfield10_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield10, 'value', textfield10_value_binding));

    	function textfield11_value_binding(value) {
    		/*textfield11_value_binding*/ ctx[51](value);
    	}

    	let textfield11_props = { label: "k3Guess" };

    	if (/*k3Guess*/ ctx[14] !== void 0) {
    		textfield11_props.value = /*k3Guess*/ ctx[14];
    	}

    	textfield11 = new Textfield({ props: textfield11_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield11, 'value', textfield11_value_binding));

    	function textfield12_value_binding(value) {
    		/*textfield12_value_binding*/ ctx[52](value);
    	}

    	let textfield12_props = { label: "ratekCID" };

    	if (/*ratekCID*/ ctx[13] !== void 0) {
    		textfield12_props.value = /*ratekCID*/ ctx[13];
    	}

    	textfield12 = new Textfield({ props: textfield12_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield12, 'value', textfield12_value_binding));

    	function textfield13_value_binding(value) {
    		/*textfield13_value_binding*/ ctx[53](value);
    	}

    	let textfield13_props = { label: "kCIDGuess" };

    	if (/*kCIDGuess*/ ctx[15] !== void 0) {
    		textfield13_props.value = /*kCIDGuess*/ ctx[15];
    	}

    	textfield13 = new Textfield({ props: textfield13_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield13, 'value', textfield13_value_binding));

    	icon = new Icon({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon.$on("click", /*click_handler_1*/ ctx[54]);
    	let if_block = /*pyEventCounter*/ ctx[17] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			create_component(modaltable.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div0 = element("div");
    			create_component(customswitch0.$$.fragment);
    			t1 = space();
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			create_component(textfield2.$$.fragment);
    			t4 = space();
    			create_component(textfield3.$$.fragment);
    			t5 = space();
    			create_component(textfield4.$$.fragment);
    			t6 = space();
    			div1 = element("div");
    			create_component(customselect.$$.fragment);
    			t7 = space();
    			create_component(textfield5.$$.fragment);
    			t8 = space();
    			create_component(textfield6.$$.fragment);
    			t9 = space();
    			create_component(textfield7.$$.fragment);
    			t10 = space();
    			create_component(textfield8.$$.fragment);
    			t11 = space();
    			create_component(customswitch1.$$.fragment);
    			t12 = space();
    			create_component(textfield9.$$.fragment);
    			t13 = space();
    			create_component(textfield10.$$.fragment);
    			t14 = space();
    			create_component(textfield11.$$.fragment);
    			t15 = space();
    			create_component(textfield12.$$.fragment);
    			t16 = space();
    			create_component(textfield13.$$.fragment);
    			t17 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Compute parameters";
    			t19 = space();
    			button1 = element("button");
    			button1.textContent = "loadConfig";
    			t21 = space();
    			create_component(icon.$$.fragment);
    			t22 = space();
    			button2 = element("button");
    			button2.textContent = "Submit";
    			t24 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "align");
    			add_location(div0, file$f, 229, 4, 8394);
    			attr_dev(div1, "class", "align");
    			add_location(div1, file$f, 238, 4, 8904);
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$f, 256, 8, 9789);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$f, 257, 8, 9889);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$f, 261, 8, 10069);
    			attr_dev(div2, "class", "align v-center");
    			add_location(div2, file$f, 254, 4, 9749);
    			attr_dev(div3, "class", "align animated fadeIn");
    			toggle_class(div3, "hide", !/*kineticMode*/ ctx[0]);
    			add_location(div3, file$f, 227, 0, 8324);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modaltable, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(customswitch0, div0, null);
    			append_dev(div0, t1);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t2);
    			mount_component(textfield1, div0, null);
    			append_dev(div0, t3);
    			mount_component(textfield2, div0, null);
    			append_dev(div0, t4);
    			mount_component(textfield3, div0, null);
    			append_dev(div0, t5);
    			mount_component(textfield4, div0, null);
    			append_dev(div3, t6);
    			append_dev(div3, div1);
    			mount_component(customselect, div1, null);
    			append_dev(div1, t7);
    			mount_component(textfield5, div1, null);
    			append_dev(div1, t8);
    			mount_component(textfield6, div1, null);
    			append_dev(div1, t9);
    			mount_component(textfield7, div1, null);
    			append_dev(div1, t10);
    			mount_component(textfield8, div1, null);
    			append_dev(div1, t11);
    			mount_component(customswitch1, div1, null);
    			append_dev(div1, t12);
    			mount_component(textfield9, div1, null);
    			append_dev(div1, t13);
    			mount_component(textfield10, div1, null);
    			append_dev(div1, t14);
    			mount_component(textfield11, div1, null);
    			append_dev(div1, t15);
    			mount_component(textfield12, div1, null);
    			append_dev(div1, t16);
    			mount_component(textfield13, div1, null);
    			append_dev(div3, t17);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t19);
    			append_dev(div2, button1);
    			append_dev(div2, t21);
    			mount_component(icon, div2, null);
    			append_dev(div2, t22);
    			append_dev(div2, button2);
    			append_dev(div2, t24);
    			if (if_block) if_block.m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*computeParameters*/ ctx[22], false, false, false),
    					listen_dev(button1, "click", /*loadConfig*/ ctx[24], false, false, false),
    					listen_dev(button2, "click", /*kineticSimulation*/ ctx[25], false, false, false),
    					listen_dev(button2, "pyEventClosed", /*pyEventClosed*/ ctx[26], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const modaltable_changes = {};

    			if (dirty[0] & /*adjustConfig*/ 1048576 | dirty[2] & /*$$scope*/ 4) {
    				modaltable_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty[0] & /*adjustConfig*/ 1048576) {
    				updating_active = true;
    				modaltable_changes.active = /*adjustConfig*/ ctx[20];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_rows && dirty[0] & /*configArray*/ 2097152) {
    				updating_rows = true;
    				modaltable_changes.rows = /*configArray*/ ctx[21];
    				add_flush_callback(() => updating_rows = false);
    			}

    			modaltable.$set(modaltable_changes);
    			const customswitch0_changes = {};

    			if (!updating_selected && dirty[0] & /*srgMode*/ 2) {
    				updating_selected = true;
    				customswitch0_changes.selected = /*srgMode*/ ctx[1];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch0.$set(customswitch0_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*pbefore*/ 4) {
    				updating_value = true;
    				textfield0_changes.value = /*pbefore*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*pafter*/ 8) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*pafter*/ ctx[3];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*calibrationFactor*/ 128) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*calibrationFactor*/ ctx[7];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty[0] & /*temp*/ 16) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*temp*/ ctx[4];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty[0] & /*numberDensity*/ 65536) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*numberDensity*/ ctx[16];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const customselect_changes = {};
    			if (dirty[0] & /*fileCollections*/ 256) customselect_changes.options = ["", .../*fileCollections*/ ctx[8]];

    			if (!updating_picked && dirty[0] & /*selectedFile*/ 64) {
    				updating_picked = true;
    				customselect_changes.picked = /*selectedFile*/ ctx[6];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);
    			const textfield5_changes = {};

    			if (!updating_value_5 && dirty[0] & /*molecule*/ 512) {
    				updating_value_5 = true;
    				textfield5_changes.value = /*molecule*/ ctx[9];
    				add_flush_callback(() => updating_value_5 = false);
    			}

    			textfield5.$set(textfield5_changes);
    			const textfield6_changes = {};

    			if (!updating_value_6 && dirty[0] & /*tag*/ 1024) {
    				updating_value_6 = true;
    				textfield6_changes.value = /*tag*/ ctx[10];
    				add_flush_callback(() => updating_value_6 = false);
    			}

    			textfield6.$set(textfield6_changes);
    			const textfield7_changes = {};

    			if (!updating_value_7 && dirty[0] & /*massOfReactants*/ 32) {
    				updating_value_7 = true;
    				textfield7_changes.value = /*massOfReactants*/ ctx[5];
    				add_flush_callback(() => updating_value_7 = false);
    			}

    			textfield7.$set(textfield7_changes);
    			const textfield8_changes = {};

    			if (!updating_value_8 && dirty[0] & /*nameOfReactants*/ 2048) {
    				updating_value_8 = true;
    				textfield8_changes.value = /*nameOfReactants*/ ctx[11];
    				add_flush_callback(() => updating_value_8 = false);
    			}

    			textfield8.$set(textfield8_changes);
    			const customswitch1_changes = {};

    			if (!updating_selected_1 && dirty[0] & /*defaultInitialValues*/ 262144) {
    				updating_selected_1 = true;
    				customswitch1_changes.selected = /*defaultInitialValues*/ ctx[18];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customswitch1.$set(customswitch1_changes);
    			const textfield9_changes = {};

    			if (!updating_value_9 && dirty[0] & /*initialValues*/ 524288) {
    				updating_value_9 = true;
    				textfield9_changes.value = /*initialValues*/ ctx[19];
    				add_flush_callback(() => updating_value_9 = false);
    			}

    			textfield9.$set(textfield9_changes);
    			const textfield10_changes = {};

    			if (!updating_value_10 && dirty[0] & /*ratek3*/ 4096) {
    				updating_value_10 = true;
    				textfield10_changes.value = /*ratek3*/ ctx[12];
    				add_flush_callback(() => updating_value_10 = false);
    			}

    			textfield10.$set(textfield10_changes);
    			const textfield11_changes = {};

    			if (!updating_value_11 && dirty[0] & /*k3Guess*/ 16384) {
    				updating_value_11 = true;
    				textfield11_changes.value = /*k3Guess*/ ctx[14];
    				add_flush_callback(() => updating_value_11 = false);
    			}

    			textfield11.$set(textfield11_changes);
    			const textfield12_changes = {};

    			if (!updating_value_12 && dirty[0] & /*ratekCID*/ 8192) {
    				updating_value_12 = true;
    				textfield12_changes.value = /*ratekCID*/ ctx[13];
    				add_flush_callback(() => updating_value_12 = false);
    			}

    			textfield12.$set(textfield12_changes);
    			const textfield13_changes = {};

    			if (!updating_value_13 && dirty[0] & /*kCIDGuess*/ 32768) {
    				updating_value_13 = true;
    				textfield13_changes.value = /*kCIDGuess*/ ctx[15];
    				add_flush_callback(() => updating_value_13 = false);
    			}

    			textfield13.$set(textfield13_changes);
    			const icon_changes = {};

    			if (dirty[2] & /*$$scope*/ 4) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);

    			if (/*pyEventCounter*/ ctx[17]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*kineticMode*/ 1) {
    				toggle_class(div3, "hide", !/*kineticMode*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modaltable.$$.fragment, local);
    			transition_in(customswitch0.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(customselect.$$.fragment, local);
    			transition_in(textfield5.$$.fragment, local);
    			transition_in(textfield6.$$.fragment, local);
    			transition_in(textfield7.$$.fragment, local);
    			transition_in(textfield8.$$.fragment, local);
    			transition_in(customswitch1.$$.fragment, local);
    			transition_in(textfield9.$$.fragment, local);
    			transition_in(textfield10.$$.fragment, local);
    			transition_in(textfield11.$$.fragment, local);
    			transition_in(textfield12.$$.fragment, local);
    			transition_in(textfield13.$$.fragment, local);
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modaltable.$$.fragment, local);
    			transition_out(customswitch0.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(customselect.$$.fragment, local);
    			transition_out(textfield5.$$.fragment, local);
    			transition_out(textfield6.$$.fragment, local);
    			transition_out(textfield7.$$.fragment, local);
    			transition_out(textfield8.$$.fragment, local);
    			transition_out(customswitch1.$$.fragment, local);
    			transition_out(textfield9.$$.fragment, local);
    			transition_out(textfield10.$$.fragment, local);
    			transition_out(textfield11.$$.fragment, local);
    			transition_out(textfield12.$$.fragment, local);
    			transition_out(textfield13.$$.fragment, local);
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modaltable, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div3);
    			destroy_component(customswitch0);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(customselect);
    			destroy_component(textfield5);
    			destroy_component(textfield6);
    			destroy_component(textfield7);
    			destroy_component(textfield8);
    			destroy_component(customswitch1);
    			destroy_component(textfield9);
    			destroy_component(textfield10);
    			destroy_component(textfield11);
    			destroy_component(textfield12);
    			destroy_component(textfield13);
    			destroy_component(icon);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ROSAAkinetics', slots, []);
    	let { fileChecked = [], currentLocation = "", kineticMode = true, kineticData = {} } = $$props;
    	let fileCollections = [];
    	let srgMode = true, pbefore = 0, pafter = 0, temp = 5;
    	let molecule = "CD^+", tag = "He", massOfReactants = "", nameOfReactants = "";
    	let ratek3 = "k31", ratekCID = "kCID1";
    	let selectedFile = "", totalMass = [], requiredLength = 0;
    	let k3Guess = "1e-30", kCIDGuess = "1e-15";
    	let currentData = {};

    	function computeParameters() {
    		currentData = kineticData[selectedFile];

    		if (currentData) {
    			totalMass = Object.keys(currentData);
    			totalMass = totalMass.slice(0, totalMass.length - 1);
    			$$invalidate(5, massOfReactants = totalMass.join(", "));
    			computeOtherParameters();
    		}
    	}

    	function computeOtherParameters() {
    		masses = massOfReactants.split(",").map(m => m.trim());
    		requiredLength = masses.length;

    		if (defaultInitialValues && masses) {
    			$$invalidate(19, initialValues = [
    				currentData?.[masses[0]]["y"][0].toFixed(0),
    				...Array(requiredLength - 1).fill(1)
    			]);
    		}

    		$$invalidate(11, nameOfReactants = `${molecule}, ${molecule}${tag}`);
    		($$invalidate(12, ratek3 = "k31"), $$invalidate(13, ratekCID = "kCID1"));

    		for (let index = 2; index < requiredLength; index++) {
    			$$invalidate(12, ratek3 += `, k3${index}`);
    			$$invalidate(13, ratekCID += `, kCID${index}`);
    			$$invalidate(11, nameOfReactants += `, ${molecule}${tag}_${index}`);
    		}
    	}

    	let masses;
    	let calibrationFactor = 1;
    	let update_pbefore = true;
    	let numberDensity = 0;

    	const computeNumberDensity = async () => {
    		await tick();
    		const constantValue = 4.2e17;
    		const pDiff = Number(pafter) - Number(pbefore);
    		$$invalidate(7, calibrationFactor = Number(calibrationFactor));
    		$$invalidate(4, temp = Number(temp));
    		$$invalidate(16, numberDensity = Number(constantValue * calibrationFactor * pDiff / temp ** 0.5).toExponential(3));
    	};

    	let config_file_ROSAAkinetics = "config_file_ROSAAkinetics.json";
    	let config_content = {};

    	function saveConfig() {
    		if (!fs.existsSync(currentLocation)) {
    			return window.createToast("Invalid location or filename", "danger");
    		}

    		const keys = configKeys.slice(1, configKeys.length);

    		configArray.forEach(content => {
    			const filename = content["filename"];
    			const newKeyValue = {};

    			keys.forEach(key => {
    				newKeyValue[key] = content[key];
    			});

    			$$invalidate(32, config_content[filename] = newKeyValue, config_content);
    		});

    		const save_config_content = JSON.stringify(config_content, null, 4);
    		const config_file = pathJoin(currentLocation, config_file_ROSAAkinetics);

    		fs.writeFile(config_file, save_config_content, function (err) {
    			if (err) return window.createToast("Error occured while saving file", "danger");
    			window.createToast("Config file saved" + config_file_ROSAAkinetics, "warning");
    		});
    	}

    	function makeConfigArray(obj) {
    		const keys = Object.keys(obj);

    		$$invalidate(21, configArray = keys.map(filename => {
    			const id = window.getID();
    			return { filename, id, ...obj[filename] };
    		}));

    		const fileCheckedRemaining = _.difference(fileChecked, keys);

    		fileCheckedRemaining.forEach(filename => {
    			const id = window.getID();

    			if (filename in obj) {
    				const currentValue = { filename, id };
    				const currentObj = obj[filename];

    				configKeys.forEach(key => {
    					if (key in currentObj) {
    						currentValue[key] = currentObj[key];
    					}
    				});

    				$$invalidate(21, configArray = [...configArray, currentValue]);
    			} else if (filename) {
    				const currentValue = { filename, id };

    				configKeys.forEach(key => {
    					if (key !== "filename") {
    						currentValue[key] = "";
    					}
    				});

    				$$invalidate(21, configArray = [...configArray, currentValue]);
    			}
    		});
    	}

    	function updateConfig() {
    		$$invalidate(31, update_pbefore = false);

    		try {
    			if (!config_content[selectedFile]) {
    				return window.createToast("config file not available for selected file: " + selectedFile, "danger");
    			}

    			$$invalidate(1, { srgMode, pbefore, pafter, calibrationFactor, temp } = config_content[selectedFile], srgMode, (($$invalidate(2, pbefore), $$invalidate(1, srgMode)), $$invalidate(31, update_pbefore)), $$invalidate(3, pafter), (($$invalidate(7, calibrationFactor), $$invalidate(1, srgMode)), $$invalidate(31, update_pbefore)), $$invalidate(4, temp));
    			$$invalidate(1, srgMode = JSON.parse(srgMode));
    		} catch(error) {
    			console.error(error.stack);
    			window.createToast("Error while reading the values: Check config file", "danger");
    		}
    	}

    	let config_loaded = false;

    	async function loadConfig() {
    		try {
    			const config_file = pathJoin(currentLocation, config_file_ROSAAkinetics);

    			if (fs.existsSync(config_file)) {
    				$$invalidate(32, config_content = JSON.parse(fs.readFileSync(config_file, "utf8")));
    				window.createToast("Config file loaded: " + config_file_ROSAAkinetics, "warning");
    				makeConfigArray(config_content);
    				$$invalidate(33, config_loaded = true);
    			} else {
    				return window.createToast("config file not available", "danger");
    			}
    		} catch(error) {
    			console.log(error);
    			window.handleError(error);
    		}
    	}

    	async function kineticSimulation(e) {
    		try {
    			if (!selectedFile) return createToast("Select a file", "danger");
    			if (Object.keys(kineticData).length === 0) return createToast("No data available", "danger");
    			const pyfile = "ROSAA/kinetics.py";
    			const nameOfReactantsArray = nameOfReactants.split(",").map(m => m.trim());
    			const data = {};
    			massOfReactants.split(",").map(mass => mass.trim()).forEach((mass, i) => data[nameOfReactantsArray[i]] = currentData[mass]);

    			if (typeof initialValues === "string") {
    				$$invalidate(19, initialValues = initialValues.split(","));
    			}

    			const args = [
    				JSON.stringify({
    					data,
    					selectedFile,
    					temp,
    					currentLocation,
    					nameOfReactantsArray,
    					ratek3,
    					ratekCID,
    					numberDensity,
    					k3Guess,
    					kCIDGuess,
    					initialValues
    				})
    			];

    			$$invalidate(17, pyEventCounter++, pyEventCounter);
    			await computePy_func({ e, pyfile, args, general: true });
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	let pyEventCounter = 0;

    	const pyEventClosed = e => {
    		$$invalidate(17, pyEventCounter--, pyEventCounter);
    		const { error_occured_py, dataReceived } = e.detail;

    		if (!error_occured_py) {
    			mainPreModal.info(dataReceived);
    		}
    	};

    	let defaultInitialValues = true;
    	let initialValues = "";
    	let adjustConfig = false;
    	let configArray = [];
    	let configKeys = ["filename", "srgMode", "pbefore", "pafter", "calibrationFactor", "temp"];
    	const writable_props = ['fileChecked', 'currentLocation', 'kineticMode', 'kineticData'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<ROSAAkinetics> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(20, adjustConfig = false);

    	function modaltable_active_binding(value) {
    		adjustConfig = value;
    		$$invalidate(20, adjustConfig);
    	}

    	function modaltable_rows_binding(value) {
    		configArray = value;
    		$$invalidate(21, configArray);
    	}

    	function customswitch0_selected_binding(value) {
    		srgMode = value;
    		$$invalidate(1, srgMode);
    	}

    	function textfield0_value_binding(value) {
    		pbefore = value;
    		(($$invalidate(2, pbefore), $$invalidate(1, srgMode)), $$invalidate(31, update_pbefore));
    	}

    	function textfield1_value_binding(value) {
    		pafter = value;
    		$$invalidate(3, pafter);
    	}

    	function textfield2_value_binding(value) {
    		calibrationFactor = value;
    		(($$invalidate(7, calibrationFactor), $$invalidate(1, srgMode)), $$invalidate(31, update_pbefore));
    	}

    	function textfield3_value_binding(value) {
    		temp = value;
    		$$invalidate(4, temp);
    	}

    	function textfield4_value_binding(value) {
    		numberDensity = value;
    		$$invalidate(16, numberDensity);
    	}

    	function customselect_picked_binding(value) {
    		selectedFile = value;
    		$$invalidate(6, selectedFile);
    	}

    	function textfield5_value_binding(value) {
    		molecule = value;
    		$$invalidate(9, molecule);
    	}

    	function textfield6_value_binding(value) {
    		tag = value;
    		$$invalidate(10, tag);
    	}

    	function textfield7_value_binding(value) {
    		massOfReactants = value;
    		$$invalidate(5, massOfReactants);
    	}

    	function textfield8_value_binding(value) {
    		nameOfReactants = value;
    		$$invalidate(11, nameOfReactants);
    	}

    	function customswitch1_selected_binding(value) {
    		defaultInitialValues = value;
    		$$invalidate(18, defaultInitialValues);
    	}

    	function textfield9_value_binding(value) {
    		initialValues = value;
    		$$invalidate(19, initialValues);
    	}

    	function textfield10_value_binding(value) {
    		ratek3 = value;
    		$$invalidate(12, ratek3);
    	}

    	function textfield11_value_binding(value) {
    		k3Guess = value;
    		$$invalidate(14, k3Guess);
    	}

    	function textfield12_value_binding(value) {
    		ratekCID = value;
    		$$invalidate(13, ratekCID);
    	}

    	function textfield13_value_binding(value) {
    		kCIDGuess = value;
    		$$invalidate(15, kCIDGuess);
    	}

    	const click_handler_1 = () => $$invalidate(20, adjustConfig = true);

    	$$self.$$set = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(28, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(29, currentLocation = $$props.currentLocation);
    		if ('kineticMode' in $$props) $$invalidate(0, kineticMode = $$props.kineticMode);
    		if ('kineticData' in $$props) $$invalidate(30, kineticData = $$props.kineticData);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		CustomSwitch,
    		CustomSelect,
    		Textfield,
    		ModalTable,
    		Icon,
    		tick,
    		fileChecked,
    		currentLocation,
    		kineticMode,
    		kineticData,
    		fileCollections,
    		srgMode,
    		pbefore,
    		pafter,
    		temp,
    		molecule,
    		tag,
    		massOfReactants,
    		nameOfReactants,
    		ratek3,
    		ratekCID,
    		selectedFile,
    		totalMass,
    		requiredLength,
    		k3Guess,
    		kCIDGuess,
    		currentData,
    		computeParameters,
    		computeOtherParameters,
    		masses,
    		calibrationFactor,
    		update_pbefore,
    		numberDensity,
    		computeNumberDensity,
    		config_file_ROSAAkinetics,
    		config_content,
    		saveConfig,
    		makeConfigArray,
    		updateConfig,
    		config_loaded,
    		loadConfig,
    		kineticSimulation,
    		pyEventCounter,
    		pyEventClosed,
    		defaultInitialValues,
    		initialValues,
    		adjustConfig,
    		configArray,
    		configKeys
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(28, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(29, currentLocation = $$props.currentLocation);
    		if ('kineticMode' in $$props) $$invalidate(0, kineticMode = $$props.kineticMode);
    		if ('kineticData' in $$props) $$invalidate(30, kineticData = $$props.kineticData);
    		if ('fileCollections' in $$props) $$invalidate(8, fileCollections = $$props.fileCollections);
    		if ('srgMode' in $$props) $$invalidate(1, srgMode = $$props.srgMode);
    		if ('pbefore' in $$props) $$invalidate(2, pbefore = $$props.pbefore);
    		if ('pafter' in $$props) $$invalidate(3, pafter = $$props.pafter);
    		if ('temp' in $$props) $$invalidate(4, temp = $$props.temp);
    		if ('molecule' in $$props) $$invalidate(9, molecule = $$props.molecule);
    		if ('tag' in $$props) $$invalidate(10, tag = $$props.tag);
    		if ('massOfReactants' in $$props) $$invalidate(5, massOfReactants = $$props.massOfReactants);
    		if ('nameOfReactants' in $$props) $$invalidate(11, nameOfReactants = $$props.nameOfReactants);
    		if ('ratek3' in $$props) $$invalidate(12, ratek3 = $$props.ratek3);
    		if ('ratekCID' in $$props) $$invalidate(13, ratekCID = $$props.ratekCID);
    		if ('selectedFile' in $$props) $$invalidate(6, selectedFile = $$props.selectedFile);
    		if ('totalMass' in $$props) totalMass = $$props.totalMass;
    		if ('requiredLength' in $$props) requiredLength = $$props.requiredLength;
    		if ('k3Guess' in $$props) $$invalidate(14, k3Guess = $$props.k3Guess);
    		if ('kCIDGuess' in $$props) $$invalidate(15, kCIDGuess = $$props.kCIDGuess);
    		if ('currentData' in $$props) currentData = $$props.currentData;
    		if ('masses' in $$props) masses = $$props.masses;
    		if ('calibrationFactor' in $$props) $$invalidate(7, calibrationFactor = $$props.calibrationFactor);
    		if ('update_pbefore' in $$props) $$invalidate(31, update_pbefore = $$props.update_pbefore);
    		if ('numberDensity' in $$props) $$invalidate(16, numberDensity = $$props.numberDensity);
    		if ('config_file_ROSAAkinetics' in $$props) config_file_ROSAAkinetics = $$props.config_file_ROSAAkinetics;
    		if ('config_content' in $$props) $$invalidate(32, config_content = $$props.config_content);
    		if ('config_loaded' in $$props) $$invalidate(33, config_loaded = $$props.config_loaded);
    		if ('pyEventCounter' in $$props) $$invalidate(17, pyEventCounter = $$props.pyEventCounter);
    		if ('defaultInitialValues' in $$props) $$invalidate(18, defaultInitialValues = $$props.defaultInitialValues);
    		if ('initialValues' in $$props) $$invalidate(19, initialValues = $$props.initialValues);
    		if ('adjustConfig' in $$props) $$invalidate(20, adjustConfig = $$props.adjustConfig);
    		if ('configArray' in $$props) $$invalidate(21, configArray = $$props.configArray);
    		if ('configKeys' in $$props) $$invalidate(27, configKeys = $$props.configKeys);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*fileChecked, kineticData, kineticMode*/ 1342177281) {
    			if (fileChecked && kineticData && kineticMode) {
    				const keys = Object.keys(kineticData);
    				$$invalidate(8, fileCollections = fileChecked.filter(filename => keys.includes(filename)));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*massOfReactants*/ 32) {
    			if (massOfReactants) {
    				computeOtherParameters();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*srgMode*/ 2 | $$self.$$.dirty[1] & /*update_pbefore*/ 1) {
    			if (srgMode) {
    				$$invalidate(7, calibrationFactor = 1);
    				if (update_pbefore) $$invalidate(2, pbefore = Number(7e-5).toExponential(0));
    			} else {
    				$$invalidate(7, calibrationFactor = 200);
    				if (update_pbefore) $$invalidate(2, pbefore = Number(1e-8).toExponential(0));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*pbefore, pafter, temp, calibrationFactor, selectedFile*/ 220 | $$self.$$.dirty[1] & /*config_content*/ 2) {
    			if (pbefore || pafter || temp || calibrationFactor || config_content[selectedFile]) {
    				computeNumberDensity();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*selectedFile, kineticData*/ 1073741888) {
    			if (selectedFile || kineticData) {
    				computeParameters();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*selectedFile*/ 64 | $$self.$$.dirty[1] & /*config_content, config_loaded*/ 6) {
    			if (selectedFile && config_content && config_loaded) {
    				updateConfig();
    			}
    		}
    	};

    	return [
    		kineticMode,
    		srgMode,
    		pbefore,
    		pafter,
    		temp,
    		massOfReactants,
    		selectedFile,
    		calibrationFactor,
    		fileCollections,
    		molecule,
    		tag,
    		nameOfReactants,
    		ratek3,
    		ratekCID,
    		k3Guess,
    		kCIDGuess,
    		numberDensity,
    		pyEventCounter,
    		defaultInitialValues,
    		initialValues,
    		adjustConfig,
    		configArray,
    		computeParameters,
    		saveConfig,
    		loadConfig,
    		kineticSimulation,
    		pyEventClosed,
    		configKeys,
    		fileChecked,
    		currentLocation,
    		kineticData,
    		update_pbefore,
    		config_content,
    		config_loaded,
    		click_handler,
    		modaltable_active_binding,
    		modaltable_rows_binding,
    		customswitch0_selected_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		textfield3_value_binding,
    		textfield4_value_binding,
    		customselect_picked_binding,
    		textfield5_value_binding,
    		textfield6_value_binding,
    		textfield7_value_binding,
    		textfield8_value_binding,
    		customswitch1_selected_binding,
    		textfield9_value_binding,
    		textfield10_value_binding,
    		textfield11_value_binding,
    		textfield12_value_binding,
    		textfield13_value_binding,
    		click_handler_1
    	];
    }

    class ROSAAkinetics extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$f,
    			create_fragment$f,
    			safe_not_equal,
    			{
    				fileChecked: 28,
    				currentLocation: 29,
    				kineticMode: 0,
    				kineticData: 30
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ROSAAkinetics",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get fileChecked() {
    		throw new Error("<ROSAAkinetics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fileChecked(value) {
    		throw new Error("<ROSAAkinetics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentLocation() {
    		throw new Error("<ROSAAkinetics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentLocation(value) {
    		throw new Error("<ROSAAkinetics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get kineticMode() {
    		throw new Error("<ROSAAkinetics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kineticMode(value) {
    		throw new Error("<ROSAAkinetics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get kineticData() {
    		throw new Error("<ROSAAkinetics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kineticData(value) {
    		throw new Error("<ROSAAkinetics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Timescan.svelte generated by Svelte v3.42.1 */

    const { Object: Object_1$1, console: console_1$5 } = globals;
    const file$e = "src\\Pages\\Timescan.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[44] = list[i];
    	return child_ctx;
    }

    // (139:4) <svelte:fragment slot="buttonContainer">
    function create_buttonContainer_slot$1(ctx) {
    	let div0;
    	let button0;
    	let t1;
    	let textfield0;
    	let updating_value;
    	let t2;
    	let button1;
    	let t4;
    	let button2;
    	let t6;
    	let button3;
    	let t8;
    	let customiconswitch;
    	let updating_toggler;
    	let t9;
    	let customswitch0;
    	let updating_selected;
    	let t10;
    	let div1;
    	let customselect0;
    	let updating_picked;
    	let t11;
    	let customselect1;
    	let updating_picked_1;
    	let t12;
    	let textfield1;
    	let updating_value_1;
    	let t13;
    	let textfield2;
    	let updating_value_2;
    	let t14;
    	let textfield3;
    	let updating_value_3;
    	let t15;
    	let customswitch1;
    	let updating_selected_1;
    	let t16;
    	let textfield4;
    	let updating_value_4;
    	let t17;
    	let button4;
    	let t19;
    	let rosaakinetics;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[24](value);
    	}

    	let textfield0_props = {
    		type: "number",
    		input$min: "0",
    		input$max: /*dataLength*/ ctx[15],
    		style: /*style*/ ctx[19],
    		label: "Time Index"
    	};

    	if (/*timestartIndexScan*/ ctx[11] !== void 0) {
    		textfield0_props.value = /*timestartIndexScan*/ ctx[11];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));
    	textfield0.$on("change", /*updateData*/ ctx[22]);

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[28](value);
    	}

    	let customiconswitch_props = { icons: ["settings_ethernet", "code"] };

    	if (/*openShell*/ ctx[5] !== void 0) {
    		customiconswitch_props.toggler = /*openShell*/ ctx[5];
    	}

    	customiconswitch = new CustomIconSwitch$1({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));

    	function customswitch0_selected_binding(value) {
    		/*customswitch0_selected_binding*/ ctx[29](value);
    	}

    	let customswitch0_props = { label: "Log" };

    	if (/*logScale*/ ctx[14] !== void 0) {
    		customswitch0_props.selected = /*logScale*/ ctx[14];
    	}

    	customswitch0 = new CustomSwitch$1({
    			props: customswitch0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch0, 'selected', customswitch0_selected_binding));
    	customswitch0.$on("change", /*linearlogCheck*/ ctx[21]);

    	function customselect0_picked_binding(value) {
    		/*customselect0_picked_binding*/ ctx[30](value);
    	}

    	let customselect0_props = {
    		style: "min-width: 7em;",
    		label: "ResOn",
    		options: /*fullfiles*/ ctx[12]
    	};

    	if (/*resON_Files*/ ctx[2] !== void 0) {
    		customselect0_props.picked = /*resON_Files*/ ctx[2];
    	}

    	customselect0 = new CustomSelect$1({
    			props: customselect0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect0, 'picked', customselect0_picked_binding));

    	function customselect1_picked_binding(value) {
    		/*customselect1_picked_binding*/ ctx[31](value);
    	}

    	let customselect1_props = {
    		style: "min-width: 7em;",
    		label: "ResOFF",
    		options: /*fullfiles*/ ctx[12]
    	};

    	if (/*resOFF_Files*/ ctx[3] !== void 0) {
    		customselect1_props.picked = /*resOFF_Files*/ ctx[3];
    	}

    	customselect1 = new CustomSelect$1({
    			props: customselect1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect1, 'picked', customselect1_picked_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[32](value);
    	}

    	let textfield1_props = { label: "Power (ON, OFF) [mJ]" };

    	if (/*power*/ ctx[10] !== void 0) {
    		textfield1_props.value = /*power*/ ctx[10];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[33](value);
    	}

    	let textfield2_props = {
    		type: "number",
    		style: /*style*/ ctx[19],
    		label: "FELIX Hz"
    	};

    	if (/*nshots*/ ctx[9] !== void 0) {
    		textfield2_props.value = /*nshots*/ ctx[9];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[34](value);
    	}

    	let textfield3_props = {
    		type: "number",
    		style: /*style*/ ctx[19],
    		label: "Mass Index"
    	};

    	if (/*massIndex*/ ctx[7] !== void 0) {
    		textfield3_props.value = /*massIndex*/ ctx[7];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	function customswitch1_selected_binding(value) {
    		/*customswitch1_selected_binding*/ ctx[35](value);
    	}

    	let customswitch1_props = { label: "save_output" };

    	if (/*saveOutputDepletion*/ ctx[17] !== void 0) {
    		customswitch1_props.selected = /*saveOutputDepletion*/ ctx[17];
    	}

    	customswitch1 = new CustomSwitch$1({
    			props: customswitch1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch1, 'selected', customswitch1_selected_binding));

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[36](value);
    	}

    	let textfield4_props = {
    		type: "number",
    		style: /*style*/ ctx[19],
    		label: "Time Index"
    	};

    	if (/*timestartIndex*/ ctx[8] !== void 0) {
    		textfield4_props.value = /*timestartIndex*/ ctx[8];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	rosaakinetics = new ROSAAkinetics({
    			props: {
    				fileChecked: /*fileChecked*/ ctx[0],
    				currentLocation: /*currentLocation*/ ctx[1],
    				kineticMode: /*kineticMode*/ ctx[4],
    				kineticData: /*kineticData*/ ctx[16]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Timescan Plot";
    			t1 = space();
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Depletion Plot";
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = "ROSAA Kinetics";
    			t6 = space();
    			button3 = element("button");
    			button3.textContent = "Open in Matplotlib";
    			t8 = space();
    			create_component(customiconswitch.$$.fragment);
    			t9 = space();
    			create_component(customswitch0.$$.fragment);
    			t10 = space();
    			div1 = element("div");
    			create_component(customselect0.$$.fragment);
    			t11 = space();
    			create_component(customselect1.$$.fragment);
    			t12 = space();
    			create_component(textfield1.$$.fragment);
    			t13 = space();
    			create_component(textfield2.$$.fragment);
    			t14 = space();
    			create_component(textfield3.$$.fragment);
    			t15 = space();
    			create_component(customswitch1.$$.fragment);
    			t16 = space();
    			create_component(textfield4.$$.fragment);
    			t17 = space();
    			button4 = element("button");
    			button4.textContent = "Submit";
    			t19 = space();
    			create_component(rosaakinetics.$$.fragment);
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$e, 140, 12, 5252);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$e, 144, 12, 5526);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$e, 145, 12, 5636);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$e, 147, 12, 5764);
    			attr_dev(div0, "class", "align ");
    			set_style(div0, "align-items", "center");
    			add_location(div0, file$e, 139, 8, 5189);
    			attr_dev(button4, "class", "button is-link");
    			add_location(button4, file$e, 162, 12, 6843);
    			attr_dev(div1, "class", "align animated fadeIn");
    			toggle_class(div1, "hide", /*toggleRow*/ ctx[13]);
    			add_location(div1, file$e, 153, 8, 6107);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t2);
    			append_dev(div0, button1);
    			append_dev(div0, t4);
    			append_dev(div0, button2);
    			append_dev(div0, t6);
    			append_dev(div0, button3);
    			append_dev(div0, t8);
    			mount_component(customiconswitch, div0, null);
    			append_dev(div0, t9);
    			mount_component(customswitch0, div0, null);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(customselect0, div1, null);
    			append_dev(div1, t11);
    			mount_component(customselect1, div1, null);
    			append_dev(div1, t12);
    			mount_component(textfield1, div1, null);
    			append_dev(div1, t13);
    			mount_component(textfield2, div1, null);
    			append_dev(div1, t14);
    			mount_component(textfield3, div1, null);
    			append_dev(div1, t15);
    			mount_component(customswitch1, div1, null);
    			append_dev(div1, t16);
    			mount_component(textfield4, div1, null);
    			append_dev(div1, t17);
    			append_dev(div1, button4);
    			insert_dev(target, t19, anchor);
    			mount_component(rosaakinetics, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[23], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[25], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[26], false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[27], false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[37], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};
    			if (dirty[0] & /*dataLength*/ 32768) textfield0_changes.input$max = /*dataLength*/ ctx[15];

    			if (!updating_value && dirty[0] & /*timestartIndexScan*/ 2048) {
    				updating_value = true;
    				textfield0_changes.value = /*timestartIndexScan*/ ctx[11];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty[0] & /*openShell*/ 32) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*openShell*/ ctx[5];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);
    			const customswitch0_changes = {};

    			if (!updating_selected && dirty[0] & /*logScale*/ 16384) {
    				updating_selected = true;
    				customswitch0_changes.selected = /*logScale*/ ctx[14];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch0.$set(customswitch0_changes);
    			const customselect0_changes = {};
    			if (dirty[0] & /*fullfiles*/ 4096) customselect0_changes.options = /*fullfiles*/ ctx[12];

    			if (!updating_picked && dirty[0] & /*resON_Files*/ 4) {
    				updating_picked = true;
    				customselect0_changes.picked = /*resON_Files*/ ctx[2];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect0.$set(customselect0_changes);
    			const customselect1_changes = {};
    			if (dirty[0] & /*fullfiles*/ 4096) customselect1_changes.options = /*fullfiles*/ ctx[12];

    			if (!updating_picked_1 && dirty[0] & /*resOFF_Files*/ 8) {
    				updating_picked_1 = true;
    				customselect1_changes.picked = /*resOFF_Files*/ ctx[3];
    				add_flush_callback(() => updating_picked_1 = false);
    			}

    			customselect1.$set(customselect1_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*power*/ 1024) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*power*/ ctx[10];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*nshots*/ 512) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*nshots*/ ctx[9];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty[0] & /*massIndex*/ 128) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*massIndex*/ ctx[7];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const customswitch1_changes = {};

    			if (!updating_selected_1 && dirty[0] & /*saveOutputDepletion*/ 131072) {
    				updating_selected_1 = true;
    				customswitch1_changes.selected = /*saveOutputDepletion*/ ctx[17];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customswitch1.$set(customswitch1_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty[0] & /*timestartIndex*/ 256) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*timestartIndex*/ ctx[8];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);

    			if (dirty[0] & /*toggleRow*/ 8192) {
    				toggle_class(div1, "hide", /*toggleRow*/ ctx[13]);
    			}

    			const rosaakinetics_changes = {};
    			if (dirty[0] & /*fileChecked*/ 1) rosaakinetics_changes.fileChecked = /*fileChecked*/ ctx[0];
    			if (dirty[0] & /*currentLocation*/ 2) rosaakinetics_changes.currentLocation = /*currentLocation*/ ctx[1];
    			if (dirty[0] & /*kineticMode*/ 16) rosaakinetics_changes.kineticMode = /*kineticMode*/ ctx[4];
    			if (dirty[0] & /*kineticData*/ 65536) rosaakinetics_changes.kineticData = /*kineticData*/ ctx[16];
    			rosaakinetics.$set(rosaakinetics_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(customiconswitch.$$.fragment, local);
    			transition_in(customswitch0.$$.fragment, local);
    			transition_in(customselect0.$$.fragment, local);
    			transition_in(customselect1.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(customswitch1.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(rosaakinetics.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(customiconswitch.$$.fragment, local);
    			transition_out(customswitch0.$$.fragment, local);
    			transition_out(customselect0.$$.fragment, local);
    			transition_out(customselect1.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(customswitch1.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(rosaakinetics.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			destroy_component(customiconswitch);
    			destroy_component(customswitch0);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div1);
    			destroy_component(customselect0);
    			destroy_component(customselect1);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(customswitch1);
    			destroy_component(textfield4);
    			if (detaching) detach_dev(t19);
    			destroy_component(rosaakinetics, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_buttonContainer_slot$1.name,
    		type: "slot",
    		source: "(139:4) <svelte:fragment slot=\\\"buttonContainer\\\">",
    		ctx
    	});

    	return block;
    }

    // (171:8) {#each fileChecked as scanfile}
    function create_each_block$6(ctx) {
    	let div;
    	let div_id_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", div_id_value = "" + (/*scanfile*/ ctx[44] + "_tplot"));
    			attr_dev(div, "class", "graph__div");
    			set_style(div, "padding-bottom", "1em");
    			add_location(div, file$e, 171, 12, 7207);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = action_destroyer(/*lookForGraph*/ ctx[43].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*fileChecked*/ 1 && div_id_value !== (div_id_value = "" + (/*scanfile*/ ctx[44] + "_tplot"))) {
    				attr_dev(div, "id", div_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(171:8) {#each fileChecked as scanfile}",
    		ctx
    	});

    	return block;
    }

    // (170:4) <svelte:fragment slot="plotContainer" let:lookForGraph>
    function create_plotContainer_slot$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*fileChecked*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*fileChecked*/ 1) {
    				each_value = /*fileChecked*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_slot$1.name,
    		type: "slot",
    		source: "(170:4) <svelte:fragment slot=\\\"plotContainer\\\" let:lookForGraph>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let layout;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let current;

    	function layout_currentLocation_binding(value) {
    		/*layout_currentLocation_binding*/ ctx[38](value);
    	}

    	function layout_fileChecked_binding(value) {
    		/*layout_fileChecked_binding*/ ctx[39](value);
    	}

    	let layout_props = {
    		filetype: filetype$1,
    		graphPlotted: /*graphPlotted*/ ctx[6],
    		id: id$1,
    		$$slots: {
    			plotContainer: [
    				create_plotContainer_slot$1,
    				({ lookForGraph }) => ({ 43: lookForGraph }),
    				({ lookForGraph }) => [0, lookForGraph ? 4096 : 0]
    			],
    			buttonContainer: [create_buttonContainer_slot$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		layout_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		layout_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	layout = new Layout({ props: layout_props, $$inline: true });
    	binding_callbacks.push(() => bind(layout, 'currentLocation', layout_currentLocation_binding));
    	binding_callbacks.push(() => bind(layout, 'fileChecked', layout_fileChecked_binding));
    	layout.$on("chdir", /*dir_changed*/ ctx[18]);

    	const block = {
    		c: function create() {
    			create_component(layout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(layout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const layout_changes = {};
    			if (dirty[0] & /*graphPlotted*/ 64) layout_changes.graphPlotted = /*graphPlotted*/ ctx[6];

    			if (dirty[0] & /*fileChecked, currentLocation, kineticMode, kineticData, toggleRow, timestartIndex, saveOutputDepletion, massIndex, nshots, power, fullfiles, resOFF_Files, resON_Files, logScale, openShell, dataLength, timestartIndexScan*/ 262079 | dirty[1] & /*$$scope*/ 65536) {
    				layout_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			layout.$set(layout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(layout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(layout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(layout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const filetype$1 = "scan", id$1 = "Timescan";

    function instance$e($$self, $$props, $$invalidate) {
    	let scanfiles;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Timescan', slots, []);
    	let fileChecked = [];
    	let currentLocation = db.get(`${filetype$1}_location`) || "";
    	let openShell = false, graphPlotted = false;

    	let massIndex = 0,
    		timestartIndex = 1,
    		nshots = 10,
    		power = "21, 21",
    		resON_Files = "",
    		resOFF_Files = "";

    	let timestartIndexScan = 0;
    	let fullfiles = [];

    	function dir_changed() {
    		if (fs.existsSync(currentLocation)) {
    			$$invalidate(12, fullfiles = [
    				"",
    				...fs.readdirSync(currentLocation).filter(file => file.endsWith(".scan"))
    			]);
    		}
    	}

    	// Depletion Row
    	let toggleRow = true;

    	let style = "width:7em; height:3.5em; margin-right:0.5em";
    	let logScale = false;
    	let timescanData = {};
    	let dataLength = 1;

    	function sliceData(modifyData) {
    		const reduceData = _.cloneDeep(modifyData);

    		Object.keys(reduceData).forEach(data => {
    			Object.keys(reduceData[data]).forEach(innerData => {
    				const newData = reduceData[data][innerData];
    				newData.x = newData.x.slice(timestartIndexScan, dataLength);
    				newData.y = newData.y.slice(timestartIndexScan, dataLength);
    				newData["error_y"]["array"] = newData["error_y"]["array"].slice(timestartIndexScan, dataLength);
    				reduceData[data][innerData] = newData;
    			});
    		});

    		return _.cloneDeep(reduceData);
    	}

    	async function plotData({ e = null, filetype = "scan", tkplot = "run" } = {}) {
    		if (fileChecked.length === 0 && filetype === "scan") {
    			return window.createToast("No files selected", "danger");
    		}

    		if (filetype === "general") {
    			if (resOFF_Files === "" || resON_Files === "") {
    				return window.createToast("No files selected", "danger");
    			}
    		}

    		const depletionArgs = [
    			JSON.stringify({
    				currentLocation,
    				resON_Files,
    				resOFF_Files,
    				power,
    				nshots,
    				massIndex,
    				timestartIndex,
    				saveOutputDepletion
    			})
    		];

    		let pyfileInfo = {
    			scan: {
    				pyfile: "timescan.py",
    				args: [...scanfiles, tkplot]
    			},
    			general: {
    				pyfile: "depletionscan.py",
    				args: depletionArgs
    			}
    		};

    		let { pyfile, args } = pyfileInfo[filetype];

    		if (filetype == "scan") {
    			$$invalidate(6, graphPlotted = false);
    		}

    		if (filetype == "general") {
    			return computePy_func({
    				e,
    				pyfile,
    				args,
    				general: true,
    				openShell
    			}).catch(error => {
    				window.handleError(error);
    			});
    		}

    		try {
    			const dataFromPython = await computePy_func({ e, pyfile, args });

    			if (filetype == "scan") {
    				Object.keys(dataFromPython).forEach(data => {
    					Object.keys(dataFromPython[data]).forEach(innerData => {
    						$$invalidate(15, dataLength = dataFromPython[data][innerData].x.length);
    					});
    				});

    				timescanData = sliceData(dataFromPython);
    				$$invalidate(16, kineticData = sliceData(dataFromPython));

    				fileChecked.forEach(file => {
    					plot(`Timescan Plot: ${file}`, "Time (in ms)", "Counts", timescanData[file], `${file}_tplot`, logScale ? "log" : null);
    				});
    			}

    			window.createToast("Graph plotted", "success");
    			$$invalidate(6, graphPlotted = true);
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const linearlogCheck = () => {
    		let layout = {
    			yaxis: {
    				title: "Counts",
    				type: logScale ? "log" : null
    			}
    		};

    		if (graphPlotted) {
    			fileChecked.forEach(file => {
    				let tplot = file + "_tplot";
    				const id = document.getElementById(tplot);

    				if (id?.data) {
    					Plotly.relayout(id, layout);
    				}
    			});
    		}
    	};

    	let kineticMode = false;
    	let kineticData = {};

    	async function updateData() {
    		$$invalidate(16, kineticData = sliceData(timescanData));

    		fileChecked.forEach(file => {
    			plot(`Timescan Plot: ${file}`, "Time (in ms)", "Counts", kineticData[file], `${file}_tplot`, logScale ? "log" : null);
    		});
    	}

    	let saveOutputDepletion = true;
    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<Timescan> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => plotData({ e });

    	function textfield0_value_binding(value) {
    		timestartIndexScan = value;
    		$$invalidate(11, timestartIndexScan);
    	}

    	const click_handler_1 = () => {
    		$$invalidate(13, toggleRow = !toggleRow);
    	};

    	const click_handler_2 = () => {
    		$$invalidate(4, kineticMode = !kineticMode);
    	};

    	const click_handler_3 = e => plotData({ e, filetype: "scan", tkplot: "plot" });

    	function customiconswitch_toggler_binding(value) {
    		openShell = value;
    		$$invalidate(5, openShell);
    	}

    	function customswitch0_selected_binding(value) {
    		logScale = value;
    		$$invalidate(14, logScale);
    	}

    	function customselect0_picked_binding(value) {
    		resON_Files = value;
    		$$invalidate(2, resON_Files);
    	}

    	function customselect1_picked_binding(value) {
    		resOFF_Files = value;
    		$$invalidate(3, resOFF_Files);
    	}

    	function textfield1_value_binding(value) {
    		power = value;
    		$$invalidate(10, power);
    	}

    	function textfield2_value_binding(value) {
    		nshots = value;
    		$$invalidate(9, nshots);
    	}

    	function textfield3_value_binding(value) {
    		massIndex = value;
    		$$invalidate(7, massIndex);
    	}

    	function customswitch1_selected_binding(value) {
    		saveOutputDepletion = value;
    		$$invalidate(17, saveOutputDepletion);
    	}

    	function textfield4_value_binding(value) {
    		timestartIndex = value;
    		$$invalidate(8, timestartIndex);
    	}

    	const click_handler_4 = e => plotData({ e, filetype: "general" });

    	function layout_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	function layout_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Layout,
    		CustomIconSwitch: CustomIconSwitch$1,
    		CustomSelect: CustomSelect$1,
    		CustomSwitch: CustomSwitch$1,
    		ROSAAkinetics,
    		Textfield,
    		plot,
    		filetype: filetype$1,
    		id: id$1,
    		fileChecked,
    		currentLocation,
    		openShell,
    		graphPlotted,
    		massIndex,
    		timestartIndex,
    		nshots,
    		power,
    		resON_Files,
    		resOFF_Files,
    		timestartIndexScan,
    		fullfiles,
    		dir_changed,
    		toggleRow,
    		style,
    		logScale,
    		timescanData,
    		dataLength,
    		sliceData,
    		plotData,
    		linearlogCheck,
    		kineticMode,
    		kineticData,
    		updateData,
    		saveOutputDepletion,
    		scanfiles
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('openShell' in $$props) $$invalidate(5, openShell = $$props.openShell);
    		if ('graphPlotted' in $$props) $$invalidate(6, graphPlotted = $$props.graphPlotted);
    		if ('massIndex' in $$props) $$invalidate(7, massIndex = $$props.massIndex);
    		if ('timestartIndex' in $$props) $$invalidate(8, timestartIndex = $$props.timestartIndex);
    		if ('nshots' in $$props) $$invalidate(9, nshots = $$props.nshots);
    		if ('power' in $$props) $$invalidate(10, power = $$props.power);
    		if ('resON_Files' in $$props) $$invalidate(2, resON_Files = $$props.resON_Files);
    		if ('resOFF_Files' in $$props) $$invalidate(3, resOFF_Files = $$props.resOFF_Files);
    		if ('timestartIndexScan' in $$props) $$invalidate(11, timestartIndexScan = $$props.timestartIndexScan);
    		if ('fullfiles' in $$props) $$invalidate(12, fullfiles = $$props.fullfiles);
    		if ('toggleRow' in $$props) $$invalidate(13, toggleRow = $$props.toggleRow);
    		if ('style' in $$props) $$invalidate(19, style = $$props.style);
    		if ('logScale' in $$props) $$invalidate(14, logScale = $$props.logScale);
    		if ('timescanData' in $$props) timescanData = $$props.timescanData;
    		if ('dataLength' in $$props) $$invalidate(15, dataLength = $$props.dataLength);
    		if ('kineticMode' in $$props) $$invalidate(4, kineticMode = $$props.kineticMode);
    		if ('kineticData' in $$props) $$invalidate(16, kineticData = $$props.kineticData);
    		if ('saveOutputDepletion' in $$props) $$invalidate(17, saveOutputDepletion = $$props.saveOutputDepletion);
    		if ('scanfiles' in $$props) scanfiles = $$props.scanfiles;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*fileChecked, currentLocation*/ 3) {
    			scanfiles = fileChecked.map(file => pathResolve(currentLocation, file));
    		}

    		if ($$self.$$.dirty[0] & /*resON_Files, resOFF_Files*/ 12) {
    			console.log(`ResOn: ${resON_Files}\nResOff: ${resOFF_Files}`);
    		}

    		if ($$self.$$.dirty[0] & /*kineticMode*/ 16) {
    			if (kineticMode) createToast("Kinetic mode", "warning");
    		}
    	};

    	return [
    		fileChecked,
    		currentLocation,
    		resON_Files,
    		resOFF_Files,
    		kineticMode,
    		openShell,
    		graphPlotted,
    		massIndex,
    		timestartIndex,
    		nshots,
    		power,
    		timestartIndexScan,
    		fullfiles,
    		toggleRow,
    		logScale,
    		dataLength,
    		kineticData,
    		saveOutputDepletion,
    		dir_changed,
    		style,
    		plotData,
    		linearlogCheck,
    		updateData,
    		click_handler,
    		textfield0_value_binding,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		customiconswitch_toggler_binding,
    		customswitch0_selected_binding,
    		customselect0_picked_binding,
    		customselect1_picked_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		textfield3_value_binding,
    		customswitch1_selected_binding,
    		textfield4_value_binding,
    		click_handler_4,
    		layout_currentLocation_binding,
    		layout_fileChecked_binding
    	];
    }

    class Timescan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Timescan",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\components\SeparateWindow.svelte generated by Svelte v3.42.1 */

    const { console: console_1$4 } = globals;
    const file$d = "src\\components\\SeparateWindow.svelte";
    const get_footer_content__slot_slot_changes = dirty => ({});
    const get_footer_content__slot_slot_context = ctx => ({});
    const get_main_content__slot_slot_changes = dirty => ({});
    const get_main_content__slot_slot_context = ctx => ({});
    const get_header_content__slot_slot_changes = dirty => ({});
    const get_header_content__slot_slot_context = ctx => ({});

    function create_fragment$d(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;
    	const header_content__slot_slot_template = /*#slots*/ ctx[15].header_content__slot;
    	const header_content__slot_slot = create_slot(header_content__slot_slot_template, ctx, /*$$scope*/ ctx[14], get_header_content__slot_slot_context);
    	const main_content__slot_slot_template = /*#slots*/ ctx[15].main_content__slot;
    	const main_content__slot_slot = create_slot(main_content__slot_slot_template, ctx, /*$$scope*/ ctx[14], get_main_content__slot_slot_context);
    	const footer_content__slot_slot_template = /*#slots*/ ctx[15].footer_content__slot;
    	const footer_content__slot_slot = create_slot(footer_content__slot_slot_template, ctx, /*$$scope*/ ctx[14], get_footer_content__slot_slot_context);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if (header_content__slot_slot) header_content__slot_slot.c();
    			t0 = space();
    			div1 = element("div");
    			if (main_content__slot_slot) main_content__slot_slot.c();
    			t1 = space();
    			div2 = element("div");
    			if (footer_content__slot_slot) footer_content__slot_slot.c();
    			attr_dev(div0, "class", "header_content svelte-159amfl");
    			add_location(div0, file$d, 75, 4, 2042);
    			attr_dev(div1, "class", "main_content svelte-159amfl");
    			add_location(div1, file$d, 77, 4, 2120);
    			attr_dev(div2, "class", "footer_content svelte-159amfl");
    			add_location(div2, file$d, 79, 4, 2215);
    			attr_dev(div3, "id", /*id*/ ctx[1]);
    			attr_dev(div3, "class", "main_content__div svelte-159amfl");
    			toggle_class(div3, "hide", !/*active*/ ctx[0]);
    			add_location(div3, file$d, 74, 0, 1979);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);

    			if (header_content__slot_slot) {
    				header_content__slot_slot.m(div0, null);
    			}

    			append_dev(div3, t0);
    			append_dev(div3, div1);

    			if (main_content__slot_slot) {
    				main_content__slot_slot.m(div1, null);
    			}

    			append_dev(div3, t1);
    			append_dev(div3, div2);

    			if (footer_content__slot_slot) {
    				footer_content__slot_slot.m(div2, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*lookForGraph*/ ctx[2].call(null, div1));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (header_content__slot_slot) {
    				if (header_content__slot_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						header_content__slot_slot,
    						header_content__slot_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(header_content__slot_slot_template, /*$$scope*/ ctx[14], dirty, get_header_content__slot_slot_changes),
    						get_header_content__slot_slot_context
    					);
    				}
    			}

    			if (main_content__slot_slot) {
    				if (main_content__slot_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						main_content__slot_slot,
    						main_content__slot_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(main_content__slot_slot_template, /*$$scope*/ ctx[14], dirty, get_main_content__slot_slot_changes),
    						get_main_content__slot_slot_context
    					);
    				}
    			}

    			if (footer_content__slot_slot) {
    				if (footer_content__slot_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						footer_content__slot_slot,
    						footer_content__slot_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(footer_content__slot_slot_template, /*$$scope*/ ctx[14], dirty, get_footer_content__slot_slot_changes),
    						get_footer_content__slot_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 2) {
    				attr_dev(div3, "id", /*id*/ ctx[1]);
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div3, "hide", !/*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_content__slot_slot, local);
    			transition_in(main_content__slot_slot, local);
    			transition_in(footer_content__slot_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_content__slot_slot, local);
    			transition_out(main_content__slot_slot, local);
    			transition_out(footer_content__slot_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (header_content__slot_slot) header_content__slot_slot.d(detaching);
    			if (main_content__slot_slot) main_content__slot_slot.d(detaching);
    			if (footer_content__slot_slot) footer_content__slot_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SeparateWindow', slots, ['header_content__slot','main_content__slot','footer_content__slot']);
    	let { id = window.getID(), title = "Title", active = false } = $$props;
    	let { top = 50, bottom = 50 } = $$props;
    	let { width = "70%", height = "70%" } = $$props;
    	let { x = "center", y = "center" } = $$props;
    	let { background = "#634e96" } = $$props;
    	let { graphWindow = null, windowReady = false, maximize = true } = $$props;
    	let graphWindowClosed = true;

    	async function openGraph() {
    		await tick();

    		if (!graphWindowClosed) {
    			return graphWindow.show();
    		}

    		graphWindowClosed = false;

    		$$invalidate(3, graphWindow = new WinBox({
    				root: document.getElementById("pageContainer"),
    				mount: document.getElementById(id),
    				title,
    				x,
    				y,
    				width,
    				height,
    				top,
    				bottom,
    				background,
    				onclose() {
    					graphWindowClosed = true;
    					$$invalidate(0, active = false);
    					$$invalidate(4, windowReady = false);
    					return false;
    				},
    				onfocus() {
    					$$invalidate(4, windowReady = true);
    				},
    				onresize(width, height) {
    					changeGraphDivWidth();
    				}
    			}));

    		graphWindow.maximize(maximize);
    	}

    	const changeGraphDivWidth = async (ms = 0) => {
    		await tick();
    		if (ms > 0) await sleep(ms);

    		graphDivs.forEach(id => {
    			if (id.data) {
    				Plotly.relayout(id, { width: id.clientWidth });
    			}
    		});
    	};

    	let graphDivs = [];

    	function lookForGraph() {
    		try {
    			graphDivs = Array.from(document.querySelectorAll(`#${id} .graph__div`));
    		} catch(error) {
    			console.log("No graph in this window");
    		}
    	}

    	const writable_props = [
    		'id',
    		'title',
    		'active',
    		'top',
    		'bottom',
    		'width',
    		'height',
    		'x',
    		'y',
    		'background',
    		'graphWindow',
    		'windowReady',
    		'maximize'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<SeparateWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('title' in $$props) $$invalidate(5, title = $$props.title);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('top' in $$props) $$invalidate(6, top = $$props.top);
    		if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ('width' in $$props) $$invalidate(8, width = $$props.width);
    		if ('height' in $$props) $$invalidate(9, height = $$props.height);
    		if ('x' in $$props) $$invalidate(10, x = $$props.x);
    		if ('y' in $$props) $$invalidate(11, y = $$props.y);
    		if ('background' in $$props) $$invalidate(12, background = $$props.background);
    		if ('graphWindow' in $$props) $$invalidate(3, graphWindow = $$props.graphWindow);
    		if ('windowReady' in $$props) $$invalidate(4, windowReady = $$props.windowReady);
    		if ('maximize' in $$props) $$invalidate(13, maximize = $$props.maximize);
    		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		id,
    		title,
    		active,
    		top,
    		bottom,
    		width,
    		height,
    		x,
    		y,
    		background,
    		graphWindow,
    		windowReady,
    		maximize,
    		graphWindowClosed,
    		openGraph,
    		changeGraphDivWidth,
    		graphDivs,
    		lookForGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('title' in $$props) $$invalidate(5, title = $$props.title);
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('top' in $$props) $$invalidate(6, top = $$props.top);
    		if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ('width' in $$props) $$invalidate(8, width = $$props.width);
    		if ('height' in $$props) $$invalidate(9, height = $$props.height);
    		if ('x' in $$props) $$invalidate(10, x = $$props.x);
    		if ('y' in $$props) $$invalidate(11, y = $$props.y);
    		if ('background' in $$props) $$invalidate(12, background = $$props.background);
    		if ('graphWindow' in $$props) $$invalidate(3, graphWindow = $$props.graphWindow);
    		if ('windowReady' in $$props) $$invalidate(4, windowReady = $$props.windowReady);
    		if ('maximize' in $$props) $$invalidate(13, maximize = $$props.maximize);
    		if ('graphWindowClosed' in $$props) graphWindowClosed = $$props.graphWindowClosed;
    		if ('graphDivs' in $$props) graphDivs = $$props.graphDivs;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*active*/ 1) {
    			if (active) openGraph();
    		}
    	};

    	return [
    		active,
    		id,
    		lookForGraph,
    		graphWindow,
    		windowReady,
    		title,
    		top,
    		bottom,
    		width,
    		height,
    		x,
    		y,
    		background,
    		maximize,
    		$$scope,
    		slots
    	];
    }

    class SeparateWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			id: 1,
    			title: 5,
    			active: 0,
    			top: 6,
    			bottom: 7,
    			width: 8,
    			height: 9,
    			x: 10,
    			y: 11,
    			background: 12,
    			graphWindow: 3,
    			windowReady: 4,
    			maximize: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SeparateWindow",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get id() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bottom() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bottom(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get x() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set x(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get y() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set y(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graphWindow() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graphWindow(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get windowReady() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set windowReady(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maximize() {
    		throw new Error("<SeparateWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maximize(value) {
    		throw new Error("<SeparateWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function boltzman_distribution({energyLevels, trapTemp=5, electronSpin=false, zeemanSplit=false, energyUnit="cm-1"}={}){
        const boltzmanConstant = 1.38064852e-23; // in m2.kg.s-2.K-1
        const boltzmanConstantInWavenumber = boltzmanConstant/1.98630e-23; // in cm-1
        const KT = boltzmanConstantInWavenumber*trapTemp;
        const speedOfLight = 299792458; // in m/s
        const speedOfLightIn_cm = speedOfLight*100; // in cm/s

        try {

            // console.log(energyLevels)
            
            
            energyLevels = energyLevels.map(({label, value})=> {
                if ( typeof value === "string") {
                    if (value.includes("_")) {value = parseFloat(value.replaceAll("_", ""));}
                    else {value = parseFloat(value);}
                }
                
                
                return {label, value}
            });


            if (energyUnit==="MHz") {
                energyLevels = energyLevels.map(({label, value})=>{
                    value = (value*1e6)/speedOfLightIn_cm;
                    return {label, value}
                });

            }
            
            let distribution = energyLevels.map(({label, value:currentEnergy})=>{
                let Gj;
                if (electronSpin) {
                    if (zeemanSplit) {Gj = 1;}
                    else {
                        j = label.split("_")[1];
                        Gj = parseInt( 2*+j + 1 );
                    }
                } else {
                    if (zeemanSplit) {Gj = 1;}
                    else {Gj = parseInt( 2*+label + 1 );}
                }
                const value = Gj*Math.exp(-currentEnergy/KT);
                return {label, value}
            });


            // console.log(distribution)
            const partitionValue = _.sumBy(distribution, energy=>energy.value).toFixed(2);

            distribution = distribution.map(({label, value})=>{
                value /= partitionValue;
                return {label, value}
            });
            return distribution
        } catch (error) {return error}
    }

    /* src\Pages\thz\windows\BoltzmanDistribution.svelte generated by Svelte v3.42.1 */
    const file$c = "src\\Pages\\thz\\windows\\BoltzmanDistribution.svelte";

    // (48:4) <svelte:fragment slot="header_content__slot" >
    function create_header_content__slot_slot$2(ctx) {
    	let div;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[10](value);
    	}

    	let textfield0_props = { label: "stepSize", style: "width:auto;" };

    	if (/*stepSize*/ ctx[4] !== void 0) {
    		textfield0_props.value = /*stepSize*/ ctx[4];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[11](value);
    	}

    	let textfield1_props = {
    		label: "temperature",
    		input$type: "number",
    		input$step: /*stepSize*/ ctx[4],
    		input$min: "0",
    		style: "width:auto;"
    	};

    	if (/*trapTemp*/ ctx[0] !== void 0) {
    		textfield1_props.value = /*trapTemp*/ ctx[0];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			button = element("button");
    			button.textContent = "Compute";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$c, 51, 12, 2024);
    			attr_dev(div, "class", "header svelte-dm69mm");
    			add_location(div, file$c, 48, 8, 1763);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t0);
    			mount_component(textfield1, div, null);
    			append_dev(div, t1);
    			append_dev(div, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*plotGraph*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*stepSize*/ 16) {
    				updating_value = true;
    				textfield0_changes.value = /*stepSize*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*stepSize*/ 16) textfield1_changes.input$step = /*stepSize*/ ctx[4];

    			if (!updating_value_1 && dirty & /*trapTemp*/ 1) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*trapTemp*/ ctx[0];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_content__slot_slot$2.name,
    		type: "slot",
    		source: "(48:4) <svelte:fragment slot=\\\"header_content__slot\\\" >",
    		ctx
    	});

    	return block;
    }

    // (56:4) <svelte:fragment slot="main_content__slot">
    function create_main_content__slot_slot$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", plotID$1);
    			attr_dev(div, "class", "graph__div");
    			add_location(div, file$c, 56, 8, 2193);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_main_content__slot_slot$2.name,
    		type: "slot",
    		source: "(56:4) <svelte:fragment slot=\\\"main_content__slot\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let separatewindow;
    	let updating_active;
    	let updating_windowReady;
    	let updating_graphWindow;
    	let current;

    	function separatewindow_active_binding(value) {
    		/*separatewindow_active_binding*/ ctx[12](value);
    	}

    	function separatewindow_windowReady_binding(value) {
    		/*separatewindow_windowReady_binding*/ ctx[13](value);
    	}

    	function separatewindow_graphWindow_binding(value) {
    		/*separatewindow_graphWindow_binding*/ ctx[14](value);
    	}

    	let separatewindow_props = {
    		title: title$2,
    		maximize: false,
    		$$slots: {
    			main_content__slot: [create_main_content__slot_slot$2],
    			header_content__slot: [create_header_content__slot_slot$2]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[1] !== void 0) {
    		separatewindow_props.active = /*active*/ ctx[1];
    	}

    	if (/*windowReady*/ ctx[3] !== void 0) {
    		separatewindow_props.windowReady = /*windowReady*/ ctx[3];
    	}

    	if (/*graphWindow*/ ctx[2] !== void 0) {
    		separatewindow_props.graphWindow = /*graphWindow*/ ctx[2];
    	}

    	separatewindow = new SeparateWindow({
    			props: separatewindow_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(separatewindow, 'active', separatewindow_active_binding));
    	binding_callbacks.push(() => bind(separatewindow, 'windowReady', separatewindow_windowReady_binding));
    	binding_callbacks.push(() => bind(separatewindow, 'graphWindow', separatewindow_graphWindow_binding));

    	const block = {
    		c: function create() {
    			create_component(separatewindow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(separatewindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const separatewindow_changes = {};

    			if (dirty & /*$$scope, stepSize, trapTemp*/ 32785) {
    				separatewindow_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 2) {
    				updating_active = true;
    				separatewindow_changes.active = /*active*/ ctx[1];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_windowReady && dirty & /*windowReady*/ 8) {
    				updating_windowReady = true;
    				separatewindow_changes.windowReady = /*windowReady*/ ctx[3];
    				add_flush_callback(() => updating_windowReady = false);
    			}

    			if (!updating_graphWindow && dirty & /*graphWindow*/ 4) {
    				updating_graphWindow = true;
    				separatewindow_changes.graphWindow = /*graphWindow*/ ctx[2];
    				add_flush_callback(() => updating_graphWindow = false);
    			}

    			separatewindow.$set(separatewindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(separatewindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(separatewindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(separatewindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const title$2 = "Boltzman Distribution";
    const plotID$1 = "boltzmanDistributionPlot";

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BoltzmanDistribution', slots, []);
    	let { active } = $$props;
    	let { energyLevels, trapTemp, electronSpin, zeemanSplit, energyUnit } = $$props;
    	let graphWindow = null, windowReady = false;
    	let stepSize = 0.1;

    	function plotGraph() {
    		const distribution = boltzman_distribution({
    			energyLevels,
    			trapTemp,
    			electronSpin,
    			zeemanSplit,
    			energyUnit
    		});

    		// console.log(distribution)
    		if (distribution) {
    			const totalSum = _.sumBy(distribution, e => e.value).toFixed(2);
    			const energyLevel = distribution.map(e => e.label);
    			const populations = distribution.map(e => e.value);

    			const data = {
    				x: energyLevel,
    				y: populations,
    				mode: "lines+markers",
    				showlegend: true,
    				name: `Temp: ${trapTemp}K, Total: ${totalSum}`
    			};

    			const dataToPlot = { data };
    			plot(`${title$2}: ${trapTemp}K`, "Energy Levels", "Population", dataToPlot, plotID$1);
    		} // setTimeout(()=>graphWindow.focus(), 100)
    	}

    	const writable_props = [
    		'active',
    		'energyLevels',
    		'trapTemp',
    		'electronSpin',
    		'zeemanSplit',
    		'energyUnit'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BoltzmanDistribution> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		stepSize = value;
    		$$invalidate(4, stepSize);
    	}

    	function textfield1_value_binding(value) {
    		trapTemp = value;
    		$$invalidate(0, trapTemp);
    	}

    	function separatewindow_active_binding(value) {
    		active = value;
    		$$invalidate(1, active);
    	}

    	function separatewindow_windowReady_binding(value) {
    		windowReady = value;
    		$$invalidate(3, windowReady);
    	}

    	function separatewindow_graphWindow_binding(value) {
    		graphWindow = value;
    		$$invalidate(2, graphWindow);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(1, active = $$props.active);
    		if ('energyLevels' in $$props) $$invalidate(6, energyLevels = $$props.energyLevels);
    		if ('trapTemp' in $$props) $$invalidate(0, trapTemp = $$props.trapTemp);
    		if ('electronSpin' in $$props) $$invalidate(7, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(8, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(9, energyUnit = $$props.energyUnit);
    	};

    	$$self.$capture_state = () => ({
    		SeparateWindow,
    		plot,
    		boltzmanDistribution: boltzman_distribution,
    		Textfield,
    		active,
    		energyLevels,
    		trapTemp,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		title: title$2,
    		plotID: plotID$1,
    		graphWindow,
    		windowReady,
    		stepSize,
    		plotGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(1, active = $$props.active);
    		if ('energyLevels' in $$props) $$invalidate(6, energyLevels = $$props.energyLevels);
    		if ('trapTemp' in $$props) $$invalidate(0, trapTemp = $$props.trapTemp);
    		if ('electronSpin' in $$props) $$invalidate(7, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(8, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(9, energyUnit = $$props.energyUnit);
    		if ('graphWindow' in $$props) $$invalidate(2, graphWindow = $$props.graphWindow);
    		if ('windowReady' in $$props) $$invalidate(3, windowReady = $$props.windowReady);
    		if ('stepSize' in $$props) $$invalidate(4, stepSize = $$props.stepSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*windowReady, graphWindow*/ 12) {
    			if (windowReady) {
    				setTimeout(() => graphWindow.focus(), 100);
    			}
    		}

    		if ($$self.$$.dirty & /*windowReady, trapTemp*/ 9) {
    			if (windowReady && trapTemp > 0) {
    				plotGraph();
    			}
    		}
    	};

    	return [
    		trapTemp,
    		active,
    		graphWindow,
    		windowReady,
    		stepSize,
    		plotGraph,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		separatewindow_active_binding,
    		separatewindow_windowReady_binding,
    		separatewindow_graphWindow_binding
    	];
    }

    class BoltzmanDistribution extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			active: 1,
    			energyLevels: 6,
    			trapTemp: 0,
    			electronSpin: 7,
    			zeemanSplit: 8,
    			energyUnit: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BoltzmanDistribution",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*active*/ ctx[1] === undefined && !('active' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'active'");
    		}

    		if (/*energyLevels*/ ctx[6] === undefined && !('energyLevels' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'energyLevels'");
    		}

    		if (/*trapTemp*/ ctx[0] === undefined && !('trapTemp' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'trapTemp'");
    		}

    		if (/*electronSpin*/ ctx[7] === undefined && !('electronSpin' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'electronSpin'");
    		}

    		if (/*zeemanSplit*/ ctx[8] === undefined && !('zeemanSplit' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'zeemanSplit'");
    		}

    		if (/*energyUnit*/ ctx[9] === undefined && !('energyUnit' in props)) {
    			console.warn("<BoltzmanDistribution> was created without expected prop 'energyUnit'");
    		}
    	}

    	get active() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyLevels() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyLevels(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trapTemp() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trapTemp(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get electronSpin() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set electronSpin(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zeemanSplit() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zeemanSplit(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyUnit() {
    		throw new Error("<BoltzmanDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyUnit(value) {
    		throw new Error("<BoltzmanDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const ALIAS = Symbol.for('yaml.alias');
    const DOC = Symbol.for('yaml.document');
    const MAP = Symbol.for('yaml.map');
    const PAIR = Symbol.for('yaml.pair');
    const SCALAR$1 = Symbol.for('yaml.scalar');
    const SEQ = Symbol.for('yaml.seq');
    const NODE_TYPE = Symbol.for('yaml.node.type');
    const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
    const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
    const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
    const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
    const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;
    const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
        if (node && typeof node === 'object')
            switch (node[NODE_TYPE]) {
                case MAP:
                case SEQ:
                    return true;
            }
        return false;
    }
    function isNode(node) {
        if (node && typeof node === 'object')
            switch (node[NODE_TYPE]) {
                case ALIAS:
                case MAP:
                case SCALAR$1:
                case SEQ:
                    return true;
            }
        return false;
    }
    const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    class NodeBase {
        constructor(type) {
            Object.defineProperty(this, NODE_TYPE, { value: type });
        }
    }

    const BREAK = Symbol('break visit');
    const SKIP = Symbol('skip children');
    const REMOVE = Symbol('remove node');
    /**
     * Apply a visitor to an AST node or document.
     *
     * Walks through the tree (depth-first) starting from `node`, calling a
     * `visitor` function with three arguments:
     *   - `key`: For sequence values and map `Pair`, the node's index in the
     *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
     *     `null` for the root node.
     *   - `node`: The current node.
     *   - `path`: The ancestry of the current node.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this node, continue with next
     *     sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current node, then continue with the next one
     *   - `Node`: Replace the current node, then continue by visiting it
     *   - `number`: While iterating the items of a sequence or map, set the index
     *     of the next step. This is useful especially if the index of the current
     *     node has changed.
     *
     * If `visitor` is a single function, it will be called with all values
     * encountered in the tree, including e.g. `null` values. Alternatively,
     * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
     * `Alias` and `Scalar` node. To define the same visitor function for more than
     * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
     * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
     * specific defined one will be used for each node.
     */
    function visit(node, visitor) {
        if (typeof visitor === 'object' &&
            (visitor.Collection || visitor.Node || visitor.Value)) {
            visitor = Object.assign({
                Alias: visitor.Node,
                Map: visitor.Node,
                Scalar: visitor.Node,
                Seq: visitor.Node
            }, visitor.Value && {
                Map: visitor.Value,
                Scalar: visitor.Value,
                Seq: visitor.Value
            }, visitor.Collection && {
                Map: visitor.Collection,
                Seq: visitor.Collection
            }, visitor);
        }
        if (isDocument(node)) {
            const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
            if (cd === REMOVE)
                node.contents = null;
        }
        else
            _visit(null, node, visitor, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visit.BREAK = BREAK;
    /** Do not visit the children of the current node */
    visit.SKIP = SKIP;
    /** Remove the current node */
    visit.REMOVE = REMOVE;
    function _visit(key, node, visitor, path) {
        let ctrl = undefined;
        if (typeof visitor === 'function')
            ctrl = visitor(key, node, path);
        else if (isMap(node)) {
            if (visitor.Map)
                ctrl = visitor.Map(key, node, path);
        }
        else if (isSeq(node)) {
            if (visitor.Seq)
                ctrl = visitor.Seq(key, node, path);
        }
        else if (isPair(node)) {
            if (visitor.Pair)
                ctrl = visitor.Pair(key, node, path);
        }
        else if (isScalar(node)) {
            if (visitor.Scalar)
                ctrl = visitor.Scalar(key, node, path);
        }
        else if (isAlias(node)) {
            if (visitor.Alias)
                ctrl = visitor.Alias(key, node, path);
        }
        if (isNode(ctrl) || isPair(ctrl)) {
            const parent = path[path.length - 1];
            if (isCollection(parent)) {
                parent.items[key] = ctrl;
            }
            else if (isPair(parent)) {
                if (key === 'key')
                    parent.key = ctrl;
                else
                    parent.value = ctrl;
            }
            else if (isDocument(parent)) {
                parent.contents = ctrl;
            }
            else {
                const pt = isAlias(parent) ? 'alias' : 'scalar';
                throw new Error(`Cannot replace node with ${pt} parent`);
            }
            return _visit(key, ctrl, visitor, path);
        }
        if (typeof ctrl !== 'symbol') {
            if (isCollection(node)) {
                path = Object.freeze(path.concat(node));
                for (let i = 0; i < node.items.length; ++i) {
                    const ci = _visit(i, node.items[i], visitor, path);
                    if (typeof ci === 'number')
                        i = ci - 1;
                    else if (ci === BREAK)
                        return BREAK;
                    else if (ci === REMOVE) {
                        node.items.splice(i, 1);
                        i -= 1;
                    }
                }
            }
            else if (isPair(node)) {
                path = Object.freeze(path.concat(node));
                const ck = _visit('key', node.key, visitor, path);
                if (ck === BREAK)
                    return BREAK;
                else if (ck === REMOVE)
                    node.key = null;
                const cv = _visit('value', node.value, visitor, path);
                if (cv === BREAK)
                    return BREAK;
                else if (cv === REMOVE)
                    node.value = null;
            }
        }
        return ctrl;
    }

    const escapeChars = {
        '!': '%21',
        ',': '%2C',
        '[': '%5B',
        ']': '%5D',
        '{': '%7B',
        '}': '%7D'
    };
    const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
    class Directives {
        constructor(yaml, tags) {
            /**
             * The directives-end/doc-start marker `---`. If `null`, a marker may still be
             * included in the document's stringified representation.
             */
            this.marker = null;
            this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
            this.tags = Object.assign({}, Directives.defaultTags, tags);
        }
        /**
         * During parsing, get a Directives instance for the current document and
         * update the stream state according to the current version's spec.
         */
        atDocument() {
            const res = new Directives(this.yaml, this.tags);
            switch (this.yaml.version) {
                case '1.1':
                    this.atNextDocument = true;
                    break;
                case '1.2':
                    this.atNextDocument = false;
                    this.yaml = {
                        explicit: Directives.defaultYaml.explicit,
                        version: '1.2'
                    };
                    this.tags = Object.assign({}, Directives.defaultTags);
                    break;
            }
            return res;
        }
        /**
         * @param onError - May be called even if the action was successful
         * @returns `true` on success
         */
        add(line, onError) {
            if (this.atNextDocument) {
                this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
                this.tags = Object.assign({}, Directives.defaultTags);
                this.atNextDocument = false;
            }
            const parts = line.trim().split(/[ \t]+/);
            const name = parts.shift();
            switch (name) {
                case '%TAG': {
                    if (parts.length !== 2) {
                        onError(0, '%TAG directive should contain exactly two parts');
                        if (parts.length < 2)
                            return false;
                    }
                    const [handle, prefix] = parts;
                    this.tags[handle] = prefix;
                    return true;
                }
                case '%YAML': {
                    this.yaml.explicit = true;
                    if (parts.length < 1) {
                        onError(0, '%YAML directive should contain exactly one part');
                        return false;
                    }
                    const [version] = parts;
                    if (version === '1.1' || version === '1.2') {
                        this.yaml.version = version;
                        return true;
                    }
                    else {
                        onError(6, `Unsupported YAML version ${version}`, true);
                        return false;
                    }
                }
                default:
                    onError(0, `Unknown directive ${name}`, true);
                    return false;
            }
        }
        /**
         * Resolves a tag, matching handles to those defined in %TAG directives.
         *
         * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
         *   `'!local'` tag, or `null` if unresolvable.
         */
        tagName(source, onError) {
            if (source === '!')
                return '!'; // non-specific tag
            if (source[0] !== '!') {
                onError(`Not a valid tag: ${source}`);
                return null;
            }
            if (source[1] === '<') {
                const verbatim = source.slice(2, -1);
                if (verbatim === '!' || verbatim === '!!') {
                    onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                    return null;
                }
                if (source[source.length - 1] !== '>')
                    onError('Verbatim tags must end with a >');
                return verbatim;
            }
            const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
            if (!suffix)
                onError(`The ${source} tag has no suffix`);
            const prefix = this.tags[handle];
            if (prefix)
                return prefix + decodeURIComponent(suffix);
            if (handle === '!')
                return source; // local tag
            onError(`Could not resolve tag: ${source}`);
            return null;
        }
        /**
         * Given a fully resolved tag, returns its printable string form,
         * taking into account current tag prefixes and defaults.
         */
        tagString(tag) {
            for (const [handle, prefix] of Object.entries(this.tags)) {
                if (tag.startsWith(prefix))
                    return handle + escapeTagName(tag.substring(prefix.length));
            }
            return tag[0] === '!' ? tag : `!<${tag}>`;
        }
        toString(doc) {
            const lines = this.yaml.explicit
                ? [`%YAML ${this.yaml.version || '1.2'}`]
                : [];
            const tagEntries = Object.entries(this.tags);
            let tagNames;
            if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
                const tags = {};
                visit(doc.contents, (_key, node) => {
                    if (isNode(node) && node.tag)
                        tags[node.tag] = true;
                });
                tagNames = Object.keys(tags);
            }
            else
                tagNames = [];
            for (const [handle, prefix] of tagEntries) {
                if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                    continue;
                if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                    lines.push(`%TAG ${handle} ${prefix}`);
            }
            return lines.join('\n');
        }
    }
    Directives.defaultYaml = { explicit: false, version: '1.2' };
    Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

    /**
     * Verify that the input string is a valid anchor.
     *
     * Will throw on errors.
     */
    function anchorIsValid(anchor) {
        if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
            const sa = JSON.stringify(anchor);
            const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
            throw new Error(msg);
        }
        return true;
    }
    function anchorNames(root) {
        const anchors = new Set();
        visit(root, {
            Value(_key, node) {
                if (node.anchor)
                    anchors.add(node.anchor);
            }
        });
        return anchors;
    }
    /** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
    function findNewAnchor(prefix, exclude) {
        for (let i = 1; true; ++i) {
            const name = `${prefix}${i}`;
            if (!exclude.has(name))
                return name;
        }
    }
    function createNodeAnchors(doc, prefix) {
        const aliasObjects = [];
        const sourceObjects = new Map();
        let prevAnchors = null;
        return {
            onAnchor(source) {
                aliasObjects.push(source);
                if (!prevAnchors)
                    prevAnchors = anchorNames(doc);
                const anchor = findNewAnchor(prefix, prevAnchors);
                prevAnchors.add(anchor);
                return anchor;
            },
            /**
             * With circular references, the source node is only resolved after all
             * of its child nodes are. This is why anchors are set only after all of
             * the nodes have been created.
             */
            setAnchors() {
                for (const source of aliasObjects) {
                    const ref = sourceObjects.get(source);
                    if (typeof ref === 'object' &&
                        ref.anchor &&
                        (isScalar(ref.node) || isCollection(ref.node))) {
                        ref.node.anchor = ref.anchor;
                    }
                    else {
                        const error = new Error('Failed to resolve repeated object (this should not happen)');
                        error.source = source;
                        throw error;
                    }
                }
            },
            sourceObjects
        };
    }

    class Alias extends NodeBase {
        constructor(source) {
            super(ALIAS);
            this.source = source;
            Object.defineProperty(this, 'tag', {
                set() {
                    throw new Error('Alias nodes cannot have tags');
                }
            });
        }
        /**
         * Resolve the value of this alias within `doc`, finding the last
         * instance of the `source` anchor before this node.
         */
        resolve(doc) {
            let found = undefined;
            visit(doc, {
                Node: (_key, node) => {
                    if (node === this)
                        return visit.BREAK;
                    if (node.anchor === this.source)
                        found = node;
                }
            });
            return found;
        }
        toJSON(_arg, ctx) {
            if (!ctx)
                return { source: this.source };
            const { anchors, doc, maxAliasCount } = ctx;
            const source = this.resolve(doc);
            if (!source) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new ReferenceError(msg);
            }
            const data = anchors.get(source);
            /* istanbul ignore if */
            if (!data || data.res === undefined) {
                const msg = 'This should not happen: Alias anchor was not resolved?';
                throw new ReferenceError(msg);
            }
            if (maxAliasCount >= 0) {
                data.count += 1;
                if (data.aliasCount === 0)
                    data.aliasCount = getAliasCount(doc, source, anchors);
                if (data.count * data.aliasCount > maxAliasCount) {
                    const msg = 'Excessive alias count indicates a resource exhaustion attack';
                    throw new ReferenceError(msg);
                }
            }
            return data.res;
        }
        toString(ctx, _onComment, _onChompKeep) {
            const src = `*${this.source}`;
            if (ctx) {
                anchorIsValid(this.source);
                if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                    const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                    throw new Error(msg);
                }
                if (ctx.implicitKey)
                    return `${src} `;
            }
            return src;
        }
    }
    function getAliasCount(doc, node, anchors) {
        if (isAlias(node)) {
            const source = node.resolve(doc);
            const anchor = anchors && source && anchors.get(source);
            return anchor ? anchor.count * anchor.aliasCount : 0;
        }
        else if (isCollection(node)) {
            let count = 0;
            for (const item of node.items) {
                const c = getAliasCount(doc, item, anchors);
                if (c > count)
                    count = c;
            }
            return count;
        }
        else if (isPair(node)) {
            const kc = getAliasCount(doc, node.key, anchors);
            const vc = getAliasCount(doc, node.value, anchors);
            return Math.max(kc, vc);
        }
        return 1;
    }

    /**
     * Recursively convert any node or its contents to native JavaScript
     *
     * @param value - The input value
     * @param arg - If `value` defines a `toJSON()` method, use this
     *   as its first argument
     * @param ctx - Conversion context, originally set in Document#toJS(). If
     *   `{ keep: true }` is not set, output should be suitable for JSON
     *   stringification.
     */
    function toJS(value, arg, ctx) {
        if (Array.isArray(value))
            return value.map((v, i) => toJS(v, String(i), ctx));
        if (value && typeof value.toJSON === 'function') {
            if (!ctx || !hasAnchor(value))
                return value.toJSON(arg, ctx);
            const data = { aliasCount: 0, count: 1, res: undefined };
            ctx.anchors.set(value, data);
            ctx.onCreate = res => {
                data.res = res;
                delete ctx.onCreate;
            };
            const res = value.toJSON(arg, ctx);
            if (ctx.onCreate)
                ctx.onCreate(res);
            return res;
        }
        if (typeof value === 'bigint' && !(ctx && ctx.keep))
            return Number(value);
        return value;
    }

    const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
    class Scalar extends NodeBase {
        constructor(value) {
            super(SCALAR$1);
            this.value = value;
        }
        toJSON(arg, ctx) {
            return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);
        }
        toString() {
            return String(this.value);
        }
    }
    Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
    Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
    Scalar.PLAIN = 'PLAIN';
    Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
    Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

    const defaultTagPrefix = 'tag:yaml.org,2002:';
    function findTagObject(value, tagName, tags) {
        if (tagName) {
            const match = tags.filter(t => t.tag === tagName);
            const tagObj = match.find(t => !t.format) || match[0];
            if (!tagObj)
                throw new Error(`Tag ${tagName} not found`);
            return tagObj;
        }
        return tags.find(t => t.identify && t.identify(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
        var _a, _b;
        if (isNode(value))
            return value;
        if (isPair(value)) {
            const map = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
            map.items.push(value);
            return map;
        }
        if (value instanceof String ||
            value instanceof Number ||
            value instanceof Boolean ||
            (typeof BigInt === 'function' && value instanceof BigInt) // not supported everywhere
        ) {
            // https://tc39.es/ecma262/#sec-serializejsonproperty
            value = value.valueOf();
        }
        const { onAnchor, onTagObj, schema, sourceObjects } = ctx;
        // Detect duplicate references to the same object & use Alias nodes for all
        // after first. The `ref` wrapper allows for circular references to resolve.
        let ref = undefined;
        if (value && typeof value === 'object') {
            ref = sourceObjects.get(value);
            if (ref) {
                if (!ref.anchor)
                    ref.anchor = onAnchor(value);
                return new Alias(ref.anchor);
            }
            else {
                ref = { anchor: null, node: null };
                sourceObjects.set(value, ref);
            }
        }
        if (tagName && tagName.startsWith('!!'))
            tagName = defaultTagPrefix + tagName.slice(2);
        let tagObj = findTagObject(value, tagName, schema.tags);
        if (!tagObj) {
            if (value && typeof value.toJSON === 'function')
                value = value.toJSON();
            if (!value || typeof value !== 'object')
                return new Scalar(value);
            tagObj =
                value instanceof Map
                    ? schema[MAP]
                    : Symbol.iterator in Object(value)
                        ? schema[SEQ]
                        : schema[MAP];
        }
        if (onTagObj) {
            onTagObj(tagObj);
            delete ctx.onTagObj;
        }
        const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode)
            ? tagObj.createNode(ctx.schema, value, ctx)
            : new Scalar(value);
        if (tagName)
            node.tag = tagName;
        if (ref)
            ref.node = node;
        return node;
    }

    function collectionFromPath(schema, path, value) {
        let v = value;
        for (let i = path.length - 1; i >= 0; --i) {
            const k = path[i];
            if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
                const a = [];
                a[k] = v;
                v = a;
            }
            else {
                const o = {};
                Object.defineProperty(o, typeof k === 'symbol' ? k : String(k), {
                    value: v,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
                v = o;
            }
        }
        return createNode(v, undefined, {
            onAnchor() {
                throw new Error('Repeated objects are not supported here');
            },
            schema,
            sourceObjects: new Map()
        });
    }
    // null, undefined, or an empty non-string iterable (e.g. [])
    const isEmptyPath = (path) => path == null ||
        (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
    class Collection extends NodeBase {
        constructor(type, schema) {
            super(type);
            Object.defineProperty(this, 'schema', {
                value: schema,
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
        /**
         * Adds a value to the collection. For `!!map` and `!!omap` the value must
         * be a Pair instance or a `{ key, value }` object, which may not have a key
         * that already exists in the map.
         */
        addIn(path, value) {
            if (isEmptyPath(path))
                this.add(value);
            else {
                const [key, ...rest] = path;
                const node = this.get(key, true);
                if (isCollection(node))
                    node.addIn(rest, value);
                else if (node === undefined && this.schema)
                    this.set(key, collectionFromPath(this.schema, rest, value));
                else
                    throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
        }
        /**
         * Removes a value from the collection.
         * @returns `true` if the item was found and removed.
         */
        deleteIn([key, ...rest]) {
            if (rest.length === 0)
                return this.delete(key);
            const node = this.get(key, true);
            if (isCollection(node))
                return node.deleteIn(rest);
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
        /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        getIn([key, ...rest], keepScalar) {
            const node = this.get(key, true);
            if (rest.length === 0)
                return !keepScalar && isScalar(node) ? node.value : node;
            else
                return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
        }
        hasAllNullValues(allowScalar) {
            return this.items.every(node => {
                if (!isPair(node))
                    return false;
                const n = node.value;
                return (n == null ||
                    (allowScalar &&
                        isScalar(n) &&
                        n.value == null &&
                        !n.commentBefore &&
                        !n.comment &&
                        !n.tag));
            });
        }
        /**
         * Checks if the collection includes a value with the key `key`.
         */
        hasIn([key, ...rest]) {
            if (rest.length === 0)
                return this.has(key);
            const node = this.get(key, true);
            return isCollection(node) ? node.hasIn(rest) : false;
        }
        /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        setIn([key, ...rest], value) {
            if (rest.length === 0) {
                this.set(key, value);
            }
            else {
                const node = this.get(key, true);
                if (isCollection(node))
                    node.setIn(rest, value);
                else if (node === undefined && this.schema)
                    this.set(key, collectionFromPath(this.schema, rest, value));
                else
                    throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
        }
    }
    Collection.maxFlowStringSingleLineLength = 60;

    const FOLD_FLOW = 'flow';
    const FOLD_BLOCK = 'block';
    const FOLD_QUOTED = 'quoted';
    /**
     * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
     * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
     * terminated with `\n` and started with `indent`.
     */
    function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
        if (!lineWidth || lineWidth < 0)
            return text;
        const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
        if (text.length <= endStep)
            return text;
        const folds = [];
        const escapedFolds = {};
        let end = lineWidth - indent.length;
        if (typeof indentAtStart === 'number') {
            if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
                folds.push(0);
            else
                end = lineWidth - indentAtStart;
        }
        let split = undefined;
        let prev = undefined;
        let overflow = false;
        let i = -1;
        let escStart = -1;
        let escEnd = -1;
        if (mode === FOLD_BLOCK) {
            i = consumeMoreIndentedLines(text, i);
            if (i !== -1)
                end = i + endStep;
        }
        for (let ch; (ch = text[(i += 1)]);) {
            if (mode === FOLD_QUOTED && ch === '\\') {
                escStart = i;
                switch (text[i + 1]) {
                    case 'x':
                        i += 3;
                        break;
                    case 'u':
                        i += 5;
                        break;
                    case 'U':
                        i += 9;
                        break;
                    default:
                        i += 1;
                }
                escEnd = i;
            }
            if (ch === '\n') {
                if (mode === FOLD_BLOCK)
                    i = consumeMoreIndentedLines(text, i);
                end = i + endStep;
                split = undefined;
            }
            else {
                if (ch === ' ' &&
                    prev &&
                    prev !== ' ' &&
                    prev !== '\n' &&
                    prev !== '\t') {
                    // space surrounded by non-space can be replaced with newline + indent
                    const next = text[i + 1];
                    if (next && next !== ' ' && next !== '\n' && next !== '\t')
                        split = i;
                }
                if (i >= end) {
                    if (split) {
                        folds.push(split);
                        end = split + endStep;
                        split = undefined;
                    }
                    else if (mode === FOLD_QUOTED) {
                        // white-space collected at end may stretch past lineWidth
                        while (prev === ' ' || prev === '\t') {
                            prev = ch;
                            ch = text[(i += 1)];
                            overflow = true;
                        }
                        // Account for newline escape, but don't break preceding escape
                        const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                        // Bail out if lineWidth & minContentWidth are shorter than an escape string
                        if (escapedFolds[j])
                            return text;
                        folds.push(j);
                        escapedFolds[j] = true;
                        end = j + endStep;
                        split = undefined;
                    }
                    else {
                        overflow = true;
                    }
                }
            }
            prev = ch;
        }
        if (overflow && onOverflow)
            onOverflow();
        if (folds.length === 0)
            return text;
        if (onFold)
            onFold();
        let res = text.slice(0, folds[0]);
        for (let i = 0; i < folds.length; ++i) {
            const fold = folds[i];
            const end = folds[i + 1] || text.length;
            if (fold === 0)
                res = `\n${indent}${text.slice(0, end)}`;
            else {
                if (mode === FOLD_QUOTED && escapedFolds[fold])
                    res += `${text[fold]}\\`;
                res += `\n${indent}${text.slice(fold + 1, end)}`;
            }
        }
        return res;
    }
    /**
     * Presumes `i + 1` is at the start of a line
     * @returns index of last newline in more-indented block
     */
    function consumeMoreIndentedLines(text, i) {
        let ch = text[i + 1];
        while (ch === ' ' || ch === '\t') {
            do {
                ch = text[(i += 1)];
            } while (ch && ch !== '\n');
            ch = text[i + 1];
        }
        return i;
    }

    const getFoldOptions = (ctx) => ({
        indentAtStart: ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
    });
    // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
    // presume that's starting a new document.
    const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
        if (!lineWidth || lineWidth < 0)
            return false;
        const limit = lineWidth - indentLength;
        const strLen = str.length;
        if (strLen <= limit)
            return false;
        for (let i = 0, start = 0; i < strLen; ++i) {
            if (str[i] === '\n') {
                if (i - start > limit)
                    return true;
                start = i + 1;
                if (strLen - start <= limit)
                    return false;
            }
        }
        return true;
    }
    function doubleQuotedString(value, ctx) {
        const json = JSON.stringify(value);
        if (ctx.options.doubleQuotedAsJSON)
            return json;
        const { implicitKey } = ctx;
        const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
        const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
        let str = '';
        let start = 0;
        for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
            if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
                // space before newline needs to be escaped to not be folded
                str += json.slice(start, i) + '\\ ';
                i += 1;
                start = i;
                ch = '\\';
            }
            if (ch === '\\')
                switch (json[i + 1]) {
                    case 'u':
                        {
                            str += json.slice(start, i);
                            const code = json.substr(i + 2, 4);
                            switch (code) {
                                case '0000':
                                    str += '\\0';
                                    break;
                                case '0007':
                                    str += '\\a';
                                    break;
                                case '000b':
                                    str += '\\v';
                                    break;
                                case '001b':
                                    str += '\\e';
                                    break;
                                case '0085':
                                    str += '\\N';
                                    break;
                                case '00a0':
                                    str += '\\_';
                                    break;
                                case '2028':
                                    str += '\\L';
                                    break;
                                case '2029':
                                    str += '\\P';
                                    break;
                                default:
                                    if (code.substr(0, 2) === '00')
                                        str += '\\x' + code.substr(2);
                                    else
                                        str += json.substr(i, 6);
                            }
                            i += 5;
                            start = i + 1;
                        }
                        break;
                    case 'n':
                        if (implicitKey ||
                            json[i + 2] === '"' ||
                            json.length < minMultiLineLength) {
                            i += 1;
                        }
                        else {
                            // folding will eat first newline
                            str += json.slice(start, i) + '\n\n';
                            while (json[i + 2] === '\\' &&
                                json[i + 3] === 'n' &&
                                json[i + 4] !== '"') {
                                str += '\n';
                                i += 2;
                            }
                            str += indent;
                            // space after newline needs to be escaped to not be folded
                            if (json[i + 2] === ' ')
                                str += '\\';
                            i += 1;
                            start = i + 1;
                        }
                        break;
                    default:
                        i += 1;
                }
        }
        str = start ? str + json.slice(start) : json;
        return implicitKey
            ? str
            : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
        if (ctx.implicitKey) {
            if (/\n/.test(value))
                return doubleQuotedString(value, ctx);
        }
        else {
            // single quoted string can't have leading or trailing whitespace around newline
            if (/[ \t]\n|\n[ \t]/.test(value))
                return doubleQuotedString(value, ctx);
        }
        const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
        const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
        return ctx.implicitKey
            ? res
            : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
        // 1. Block can't end in whitespace unless the last line is non-empty.
        // 2. Strings consisting of only whitespace are best rendered explicitly.
        if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
            return doubleQuotedString(value, ctx);
        }
        const indent = ctx.indent ||
            (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
        const literal = type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, ctx.options.lineWidth, indent.length);
        if (!value)
            return literal ? '|\n' : '>\n';
        // determine chomping from whitespace at value end
        let chomp;
        let endStart;
        for (endStart = value.length; endStart > 0; --endStart) {
            const ch = value[endStart - 1];
            if (ch !== '\n' && ch !== '\t' && ch !== ' ')
                break;
        }
        let end = value.substring(endStart);
        const endNlPos = end.indexOf('\n');
        if (endNlPos === -1) {
            chomp = '-'; // strip
        }
        else if (value === end || endNlPos !== end.length - 1) {
            chomp = '+'; // keep
            if (onChompKeep)
                onChompKeep();
        }
        else {
            chomp = ''; // clip
        }
        if (end) {
            value = value.slice(0, -end.length);
            if (end[end.length - 1] === '\n')
                end = end.slice(0, -1);
            end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
        }
        // determine indent indicator from whitespace at value start
        let startWithSpace = false;
        let startEnd;
        let startNlPos = -1;
        for (startEnd = 0; startEnd < value.length; ++startEnd) {
            const ch = value[startEnd];
            if (ch === ' ')
                startWithSpace = true;
            else if (ch === '\n')
                startNlPos = startEnd;
            else
                break;
        }
        let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
        if (start) {
            value = value.substring(start.length);
            start = start.replace(/\n+/g, `$&${indent}`);
        }
        const indentSize = indent ? '2' : '1'; // root is at -1
        let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
        if (comment) {
            header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
            if (onComment)
                onComment();
        }
        if (literal) {
            value = value.replace(/\n+/g, `$&${indent}`);
            return `${header}\n${indent}${start}${value}${end}`;
        }
        value = value
            .replace(/\n+/g, '\n$&')
            .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, `$&${indent}`);
        const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
        return `${header}\n${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
        var _a;
        const { type, value } = item;
        const { actualString, implicitKey, indent, inFlow } = ctx;
        if ((implicitKey && /[\n[\]{},]/.test(value)) ||
            (inFlow && /[[\]{},]/.test(value))) {
            return doubleQuotedString(value, ctx);
        }
        if (!value ||
            /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
            const hasDouble = value.indexOf('"') !== -1;
            const hasSingle = value.indexOf("'") !== -1;
            let quotedString;
            if (hasDouble && !hasSingle) {
                quotedString = singleQuotedString;
            }
            else if (hasSingle && !hasDouble) {
                quotedString = doubleQuotedString;
            }
            else if (ctx.options.singleQuote) {
                quotedString = singleQuotedString;
            }
            else {
                quotedString = doubleQuotedString;
            }
            // not allowed:
            // - empty string, '-' or '?'
            // - start with an indicator character (except [?:-]) or /[?-] /
            // - '\n ', ': ' or ' \n' anywhere
            // - '#' not preceded by a non-space char
            // - end with ' ' or ':'
            return implicitKey || inFlow || value.indexOf('\n') === -1
                ? quotedString(value, ctx)
                : blockString(item, ctx, onComment, onChompKeep);
        }
        if (!implicitKey &&
            !inFlow &&
            type !== Scalar.PLAIN &&
            value.indexOf('\n') !== -1) {
            // Where allowed & type not set explicitly, prefer block style for multiline strings
            return blockString(item, ctx, onComment, onChompKeep);
        }
        if (indent === '' && containsDocumentMarker(value)) {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        const str = value.replace(/\n+/g, `$&\n${indent}`);
        // Verify that output will be parsed as a string, as e.g. plain numbers and
        // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
        // and others in v1.1.
        if (actualString) {
            for (const tag of ctx.doc.schema.tags) {
                if (tag.default &&
                    tag.tag !== 'tag:yaml.org,2002:str' &&
                    ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))
                    return doubleQuotedString(value, ctx);
            }
        }
        return implicitKey
            ? str
            : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
        const { implicitKey, inFlow } = ctx;
        const ss = typeof item.value === 'string'
            ? item
            : Object.assign({}, item, { value: String(item.value) });
        let { type } = item;
        if (type !== Scalar.QUOTE_DOUBLE) {
            // force double quotes on control characters & unpaired surrogates
            if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
                type = Scalar.QUOTE_DOUBLE;
        }
        const _stringify = (_type) => {
            switch (_type) {
                case Scalar.BLOCK_FOLDED:
                case Scalar.BLOCK_LITERAL:
                    return implicitKey || inFlow
                        ? doubleQuotedString(ss.value, ctx) // blocks are not valid inside flow containers
                        : blockString(ss, ctx, onComment, onChompKeep);
                case Scalar.QUOTE_DOUBLE:
                    return doubleQuotedString(ss.value, ctx);
                case Scalar.QUOTE_SINGLE:
                    return singleQuotedString(ss.value, ctx);
                case Scalar.PLAIN:
                    return plainString(ss, ctx, onComment, onChompKeep);
                default:
                    return null;
            }
        };
        let res = _stringify(type);
        if (res === null) {
            const { defaultKeyType, defaultStringType } = ctx.options;
            const t = (implicitKey && defaultKeyType) || defaultStringType;
            res = _stringify(t);
            if (res === null)
                throw new Error(`Unsupported default string type ${t}`);
        }
        return res;
    }

    const createStringifyContext = (doc, options) => ({
        anchors: new Set(),
        doc,
        indent: '',
        indentStep: typeof options.indent === 'number' ? ' '.repeat(options.indent) : '  ',
        options: Object.assign({
            defaultKeyType: null,
            defaultStringType: 'PLAIN',
            directives: null,
            doubleQuotedAsJSON: false,
            doubleQuotedMinMultiLineLength: 40,
            falseStr: 'false',
            indentSeq: true,
            lineWidth: 80,
            minContentWidth: 20,
            nullStr: 'null',
            simpleKeys: false,
            singleQuote: false,
            trueStr: 'true',
            verifyAliasOrder: true
        }, options)
    });
    function getTagObject(tags, item) {
        if (item.tag) {
            const match = tags.filter(t => t.tag === item.tag);
            if (match.length > 0)
                return match.find(t => t.format === item.format) || match[0];
        }
        let tagObj = undefined;
        let obj;
        if (isScalar(item)) {
            obj = item.value;
            const match = tags.filter(t => t.identify && t.identify(obj));
            tagObj =
                match.find(t => t.format === item.format) || match.find(t => !t.format);
        }
        else {
            obj = item;
            tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
        }
        if (!tagObj) {
            // @ts-ignore
            const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
            throw new Error(`Tag not resolved for ${name} value`);
        }
        return tagObj;
    }
    // needs to be called before value stringifier to allow for circular anchor refs
    function stringifyProps(node, tagObj, { anchors, doc }) {
        const props = [];
        const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
        if (anchor && anchorIsValid(anchor)) {
            anchors.add(anchor);
            props.push(`&${anchor}`);
        }
        if (node.tag) {
            props.push(doc.directives.tagString(node.tag));
        }
        else if (!tagObj.default) {
            props.push(doc.directives.tagString(tagObj.tag));
        }
        return props.join(' ');
    }
    function stringify(item, ctx, onComment, onChompKeep) {
        if (isPair(item))
            return item.toString(ctx, onComment, onChompKeep);
        if (isAlias(item))
            return item.toString(ctx);
        let tagObj = undefined;
        const node = isNode(item)
            ? item
            : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
        if (!tagObj)
            tagObj = getTagObject(ctx.doc.schema.tags, node);
        const props = stringifyProps(node, tagObj, ctx);
        if (props.length > 0)
            ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
        const str = typeof tagObj.stringify === 'function'
            ? tagObj.stringify(node, ctx, onComment, onChompKeep)
            : isScalar(node)
                ? stringifyString(node, ctx, onComment, onChompKeep)
                : node.toString(ctx, onComment, onChompKeep);
        if (!props)
            return str;
        return isScalar(node) || str[0] === '{' || str[0] === '['
            ? `${props} ${str}`
            : `${props}\n${ctx.indent}${str}`;
    }

    const stringifyComment = (comment, indent) => /^\n+$/.test(comment)
        ? comment.substring(1)
        : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);
    function addComment(str, indent, comment) {
        return !comment
            ? str
            : comment.includes('\n')
                ? `${str}\n` + stringifyComment(comment, indent)
                : str.endsWith(' ')
                    ? `${str}#${comment}`
                    : `${str} #${comment}`;
    }

    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
        const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;
        let keyComment = (isNode(key) && key.comment) || null;
        if (simpleKeys) {
            if (keyComment) {
                throw new Error('With simple keys, key nodes cannot have comments');
            }
            if (isCollection(key)) {
                const msg = 'With simple keys, collection cannot be used as a key value';
                throw new Error(msg);
            }
        }
        let explicitKey = !simpleKeys &&
            (!key ||
                (keyComment && value == null && !ctx.inFlow) ||
                isCollection(key) ||
                (isScalar(key)
                    ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                    : typeof key === 'object'));
        ctx = Object.assign({}, ctx, {
            allNullValues: false,
            implicitKey: !explicitKey && (simpleKeys || !allNullValues),
            indent: indent + indentStep
        });
        let keyCommentDone = false;
        let chompKeep = false;
        let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
        if (!explicitKey && !ctx.inFlow && str.length > 1024) {
            if (simpleKeys)
                throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
            explicitKey = true;
        }
        if (ctx.inFlow) {
            if (allNullValues || value == null) {
                if (keyCommentDone && onComment)
                    onComment();
                return explicitKey ? `? ${str}` : str;
            }
        }
        else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
            if (keyCommentDone)
                keyComment = null;
            if (chompKeep && !keyComment && onChompKeep)
                onChompKeep();
            return addComment(`? ${str}`, ctx.indent, keyComment);
        }
        if (keyCommentDone)
            keyComment = null;
        str = explicitKey
            ? `? ${addComment(str, ctx.indent, keyComment)}\n${indent}:`
            : addComment(`${str}:`, ctx.indent, keyComment);
        let vcb = '';
        let valueComment = null;
        if (isNode(value)) {
            if (value.spaceBefore)
                vcb = '\n';
            if (value.commentBefore)
                vcb += `\n${stringifyComment(value.commentBefore, ctx.indent)}`;
            valueComment = value.comment;
        }
        else if (value && typeof value === 'object') {
            value = doc.createNode(value);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !keyComment && isScalar(value))
            ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq &&
            indentStep.length >= 2 &&
            !ctx.inFlow &&
            !explicitKey &&
            isSeq(value) &&
            !value.flow &&
            !value.tag &&
            !value.anchor) {
            // If indentSeq === false, consider '- ' as part of indentation where possible
            ctx.indent = ctx.indent.substr(2);
        }
        let valueCommentDone = false;
        const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
        let ws = ' ';
        if (vcb || keyComment) {
            ws = `${vcb}\n${ctx.indent}`;
        }
        else if (!explicitKey && isCollection(value)) {
            const flow = valueStr[0] === '[' || valueStr[0] === '{';
            if (!flow || valueStr.includes('\n'))
                ws = `\n${ctx.indent}`;
        }
        else if (valueStr[0] === '\n')
            ws = '';
        if (ctx.inFlow) {
            if (valueCommentDone && onComment)
                onComment();
            return str + ws + valueStr;
        }
        else {
            if (valueCommentDone)
                valueComment = null;
            if (chompKeep && !valueComment && onChompKeep)
                onChompKeep();
            return addComment(str + ws + valueStr, ctx.indent, valueComment);
        }
    }

    var global$1 = (typeof global$1 !== "undefined" ? global$1 :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title$1 = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title$1,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var process = browser$1;

    function warn(logLevel, warning) {
        if (logLevel === 'debug' || logLevel === 'warn') {
            if (typeof process !== 'undefined' && process.emitWarning)
                process.emitWarning(warning);
            else
                console.warn(warning);
        }
    }

    const MERGE_KEY = '<<';
    function addPairToJSMap(ctx, map, { key, value }) {
        if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
            if (isSeq(value))
                for (const it of value.items)
                    mergeToJSMap(ctx, map, it);
            else if (Array.isArray(value))
                for (const it of value)
                    mergeToJSMap(ctx, map, it);
            else
                mergeToJSMap(ctx, map, value);
        }
        else {
            const jsKey = toJS(key, '', ctx);
            if (map instanceof Map) {
                map.set(jsKey, toJS(value, jsKey, ctx));
            }
            else if (map instanceof Set) {
                map.add(jsKey);
            }
            else {
                const stringKey = stringifyKey(key, jsKey, ctx);
                const jsValue = toJS(value, stringKey, ctx);
                if (stringKey in map)
                    Object.defineProperty(map, stringKey, {
                        value: jsValue,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                else
                    map[stringKey] = jsValue;
            }
        }
        return map;
    }
    const isMergeKey = (key) => key === MERGE_KEY ||
        (isScalar(key) &&
            key.value === MERGE_KEY &&
            (!key.type || key.type === Scalar.PLAIN));
    // If the value associated with a merge key is a single mapping node, each of
    // its key/value pairs is inserted into the current mapping, unless the key
    // already exists in it. If the value associated with the merge key is a
    // sequence, then this sequence is expected to contain mapping nodes and each
    // of these nodes is merged in turn according to its order in the sequence.
    // Keys in mapping nodes earlier in the sequence override keys specified in
    // later mapping nodes. -- http://yaml.org/type/merge.html
    function mergeToJSMap(ctx, map, value) {
        const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : null;
        if (!isMap(source))
            throw new Error('Merge sources must be map aliases');
        const srcMap = source.toJSON(null, ctx, Map);
        for (const [key, value] of srcMap) {
            if (map instanceof Map) {
                if (!map.has(key))
                    map.set(key, value);
            }
            else if (map instanceof Set) {
                map.add(key);
            }
            else if (!Object.prototype.hasOwnProperty.call(map, key)) {
                Object.defineProperty(map, key, {
                    value,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            }
        }
        return map;
    }
    function stringifyKey(key, jsKey, ctx) {
        if (jsKey === null)
            return '';
        if (typeof jsKey !== 'object')
            return String(jsKey);
        if (isNode(key) && ctx && ctx.doc) {
            const strCtx = createStringifyContext(ctx.doc, {});
            strCtx.anchors = new Set();
            for (const node of ctx.anchors.keys())
                strCtx.anchors.add(node.anchor);
            strCtx.inFlow = true;
            strCtx.inStringifyKey = true;
            const strKey = key.toString(strCtx);
            if (!ctx.mapKeyWarned) {
                let jsonStr = JSON.stringify(strKey);
                if (jsonStr.length > 40)
                    jsonStr = jsonStr.substring(0, 36) + '..."';
                warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
                ctx.mapKeyWarned = true;
            }
            return strKey;
        }
        return JSON.stringify(jsKey);
    }

    function createPair(key, value, ctx) {
        const k = createNode(key, undefined, ctx);
        const v = createNode(value, undefined, ctx);
        return new Pair(k, v);
    }
    class Pair {
        constructor(key, value = null) {
            Object.defineProperty(this, NODE_TYPE, { value: PAIR });
            this.key = key;
            this.value = value;
        }
        toJSON(_, ctx) {
            const pair = ctx && ctx.mapAsMap ? new Map() : {};
            return addPairToJSMap(ctx, pair, this);
        }
        toString(ctx, onComment, onChompKeep) {
            return ctx && ctx.doc
                ? stringifyPair(this, ctx, onComment, onChompKeep)
                : JSON.stringify(this);
        }
    }

    /**
     * `yaml` defines document-specific options in three places: as an argument of
     * parse, create and stringify calls, in the values of `YAML.defaultOptions`,
     * and in the version-dependent `YAML.Document.defaults` object. Values set in
     * `YAML.defaultOptions` override version-dependent defaults, and argument
     * options override both.
     */
    const defaultOptions = {
        intAsBigInt: false,
        logLevel: 'warn',
        prettyErrors: true,
        strict: true,
        uniqueKeys: true,
        version: '1.2'
    };

    function stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {
        const { indent, indentStep } = ctx;
        const inFlow = flow || ctx.inFlow;
        if (inFlow)
            itemIndent += indentStep;
        ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });
        let singleLineOutput = true;
        let chompKeep = false; // flag for the preceding node's status
        const nodes = items.reduce((nodes, item, i) => {
            let comment = null;
            if (isNode(item)) {
                if (!chompKeep && item.spaceBefore)
                    nodes.push({ comment: true, str: '' });
                let cb = item.commentBefore;
                if (cb && chompKeep)
                    cb = cb.replace(/^\n+/, '');
                if (cb) {
                    if (/^\n+$/.test(cb))
                        cb = cb.substring(1);
                    // This match will always succeed on a non-empty string
                    for (const line of cb.match(/^.*$/gm)) {
                        const str = line === ' ' ? '#' : line ? `#${line}` : '';
                        nodes.push({ comment: true, str });
                    }
                }
                if (item.comment) {
                    comment = item.comment;
                    singleLineOutput = false;
                }
            }
            else if (isPair(item)) {
                const ik = isNode(item.key) ? item.key : null;
                if (ik) {
                    if (!chompKeep && ik.spaceBefore)
                        nodes.push({ comment: true, str: '' });
                    let cb = ik.commentBefore;
                    if (cb && chompKeep)
                        cb = cb.replace(/^\n+/, '');
                    if (cb) {
                        if (/^\n+$/.test(cb))
                            cb = cb.substring(1);
                        // This match will always succeed on a non-empty string
                        for (const line of cb.match(/^.*$/gm)) {
                            const str = line === ' ' ? '#' : line ? `#${line}` : '';
                            nodes.push({ comment: true, str });
                        }
                    }
                    if (ik.comment)
                        singleLineOutput = false;
                }
                if (inFlow) {
                    const iv = isNode(item.value) ? item.value : null;
                    if (iv) {
                        if (iv.comment)
                            comment = iv.comment;
                        if (iv.comment || iv.commentBefore)
                            singleLineOutput = false;
                    }
                    else if (item.value == null && ik && ik.comment) {
                        comment = ik.comment;
                    }
                }
            }
            chompKeep = false;
            let str = stringify(item, ctx, () => (comment = null), () => (chompKeep = true));
            if (inFlow && i < items.length - 1)
                str += ',';
            str = addComment(str, itemIndent, comment);
            if (chompKeep && (comment || inFlow))
                chompKeep = false;
            nodes.push({ comment: false, str });
            return nodes;
        }, []);
        let str;
        if (nodes.length === 0) {
            str = flowChars.start + flowChars.end;
        }
        else if (inFlow) {
            const { start, end } = flowChars;
            const strings = nodes.map(n => n.str);
            let singleLineLength = 2;
            for (const node of nodes) {
                if (node.comment || node.str.includes('\n')) {
                    singleLineOutput = false;
                    break;
                }
                singleLineLength += node.str.length + 2;
            }
            if (!singleLineOutput ||
                singleLineLength > Collection.maxFlowStringSingleLineLength) {
                str = start;
                for (const s of strings) {
                    str += s ? `\n${indentStep}${indent}${s}` : '\n';
                }
                str += `\n${indent}${end}`;
            }
            else {
                str = `${start} ${strings.join(' ')} ${end}`;
            }
        }
        else {
            const strings = nodes.map(blockItem);
            str = strings.shift() || '';
            for (const s of strings)
                str += s ? `\n${indent}${s}` : '\n';
        }
        if (comment) {
            str += '\n' + stringifyComment(comment, indent);
            if (onComment)
                onComment();
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }

    function findPair(items, key) {
        const k = isScalar(key) ? key.value : key;
        for (const it of items) {
            if (isPair(it)) {
                if (it.key === key || it.key === k)
                    return it;
                if (isScalar(it.key) && it.key.value === k)
                    return it;
            }
        }
        return undefined;
    }
    class YAMLMap extends Collection {
        constructor(schema) {
            super(MAP, schema);
            this.items = [];
        }
        static get tagName() {
            return 'tag:yaml.org,2002:map';
        }
        /**
         * Adds a value to the collection.
         *
         * @param overwrite - If not set `true`, using a key that is already in the
         *   collection will throw. Otherwise, overwrites the previous value.
         */
        add(pair, overwrite) {
            let _pair;
            if (isPair(pair))
                _pair = pair;
            else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
                // In TypeScript, this never happens.
                _pair = new Pair(pair, pair.value);
            }
            else
                _pair = new Pair(pair.key, pair.value);
            const prev = findPair(this.items, _pair.key);
            const sortEntries = this.schema && this.schema.sortMapEntries;
            if (prev) {
                if (!overwrite)
                    throw new Error(`Key ${_pair.key} already set`);
                // For scalars, keep the old node & its comments and anchors
                if (isScalar(prev.value) && isScalarValue(_pair.value))
                    prev.value.value = _pair.value;
                else
                    prev.value = _pair.value;
            }
            else if (sortEntries) {
                const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
                if (i === -1)
                    this.items.push(_pair);
                else
                    this.items.splice(i, 0, _pair);
            }
            else {
                this.items.push(_pair);
            }
        }
        delete(key) {
            const it = findPair(this.items, key);
            if (!it)
                return false;
            const del = this.items.splice(this.items.indexOf(it), 1);
            return del.length > 0;
        }
        get(key, keepScalar) {
            const it = findPair(this.items, key);
            const node = it && it.value;
            return !keepScalar && isScalar(node) ? node.value : node;
        }
        has(key) {
            return !!findPair(this.items, key);
        }
        set(key, value) {
            this.add(new Pair(key, value), true);
        }
        /**
         * @param ctx - Conversion context, originally set in Document#toJS()
         * @param {Class} Type - If set, forces the returned collection type
         * @returns Instance of Type, Map, or Object
         */
        toJSON(_, ctx, Type) {
            const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
            if (ctx && ctx.onCreate)
                ctx.onCreate(map);
            for (const item of this.items)
                addPairToJSMap(ctx, map, item);
            return map;
        }
        toString(ctx, onComment, onChompKeep) {
            if (!ctx)
                return JSON.stringify(this);
            for (const item of this.items) {
                if (!isPair(item))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
            }
            if (!ctx.allNullValues && this.hasAllNullValues(false))
                ctx = Object.assign({}, ctx, { allNullValues: true });
            return stringifyCollection(this, ctx, {
                blockItem: n => n.str,
                flowChars: { start: '{', end: '}' },
                itemIndent: ctx.indent || '',
                onChompKeep,
                onComment
            });
        }
    }

    function createMap(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new YAMLMap(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    const map = {
        collection: 'map',
        createNode: createMap,
        default: true,
        nodeClass: YAMLMap,
        tag: 'tag:yaml.org,2002:map',
        resolve(map, onError) {
            if (!isMap(map))
                onError('Expected a mapping for this tag');
            return map;
        }
    };

    class YAMLSeq extends Collection {
        constructor(schema) {
            super(SEQ, schema);
            this.items = [];
        }
        static get tagName() {
            return 'tag:yaml.org,2002:seq';
        }
        add(value) {
            this.items.push(value);
        }
        /**
         * Removes a value from the collection.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         *
         * @returns `true` if the item was found and removed.
         */
        delete(key) {
            const idx = asItemIndex(key);
            if (typeof idx !== 'number')
                return false;
            const del = this.items.splice(idx, 1);
            return del.length > 0;
        }
        /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         */
        get(key, keepScalar) {
            const idx = asItemIndex(key);
            if (typeof idx !== 'number')
                return undefined;
            const it = this.items[idx];
            return !keepScalar && isScalar(it) ? it.value : it;
        }
        /**
         * Checks if the collection includes a value with the key `key`.
         *
         * `key` must contain a representation of an integer for this to succeed.
         * It may be wrapped in a `Scalar`.
         */
        has(key) {
            const idx = asItemIndex(key);
            return typeof idx === 'number' && idx < this.items.length;
        }
        /**
         * Sets a value in this collection. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         *
         * If `key` does not contain a representation of an integer, this will throw.
         * It may be wrapped in a `Scalar`.
         */
        set(key, value) {
            const idx = asItemIndex(key);
            if (typeof idx !== 'number')
                throw new Error(`Expected a valid index, not ${key}.`);
            const prev = this.items[idx];
            if (isScalar(prev) && isScalarValue(value))
                prev.value = value;
            else
                this.items[idx] = value;
        }
        toJSON(_, ctx) {
            const seq = [];
            if (ctx && ctx.onCreate)
                ctx.onCreate(seq);
            let i = 0;
            for (const item of this.items)
                seq.push(toJS(item, String(i++), ctx));
            return seq;
        }
        toString(ctx, onComment, onChompKeep) {
            if (!ctx)
                return JSON.stringify(this);
            return stringifyCollection(this, ctx, {
                blockItem: n => (n.comment ? n.str : `- ${n.str}`),
                flowChars: { start: '[', end: ']' },
                itemIndent: (ctx.indent || '') + '  ',
                onChompKeep,
                onComment
            });
        }
    }
    function asItemIndex(key) {
        let idx = isScalar(key) ? key.value : key;
        if (idx && typeof idx === 'string')
            idx = Number(idx);
        return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
            ? idx
            : null;
    }

    function createSeq(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new YAMLSeq(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
    const seq = {
        collection: 'seq',
        createNode: createSeq,
        default: true,
        nodeClass: YAMLSeq,
        tag: 'tag:yaml.org,2002:seq',
        resolve(seq, onError) {
            if (!isSeq(seq))
                onError('Expected a sequence for this tag');
            return seq;
        }
    };

    const string = {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify(item, ctx, onComment, onChompKeep) {
            ctx = Object.assign({ actualString: true }, ctx);
            return stringifyString(item, ctx, onComment, onChompKeep);
        }
    };

    const nullTag = {
        identify: value => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: () => new Scalar(null),
        stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
    };

    const boolTag = {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),
        stringify({ source, value }, ctx) {
            if (source && boolTag.test.test(source)) {
                const sv = source[0] === 't' || source[0] === 'T';
                if (value === sv)
                    return source;
            }
            return value ? ctx.options.trueStr : ctx.options.falseStr;
        }
    };

    function stringifyNumber({ format, minFractionDigits, tag, value }) {
        if (typeof value === 'bigint')
            return String(value);
        const num = typeof value === 'number' ? value : Number(value);
        if (!isFinite(num))
            return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
        let n = JSON.stringify(value);
        if (!format &&
            minFractionDigits &&
            (!tag || tag === 'tag:yaml.org,2002:float') &&
            /^\d/.test(n)) {
            let i = n.indexOf('.');
            if (i < 0) {
                i = n.length;
                n += '.';
            }
            let d = minFractionDigits - (n.length - i - 1);
            while (d-- > 0)
                n += '0';
        }
        return n;
    }

    const floatNaN$1 = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
        resolve: str => str.slice(-3).toLowerCase() === 'nan'
            ? NaN
            : str[0] === '-'
                ? Number.NEGATIVE_INFINITY
                : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber
    };
    const floatExp$1 = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'EXP',
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: str => parseFloat(str),
        stringify: ({ value }) => Number(value).toExponential()
    };
    const float$1 = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve(str) {
            const node = new Scalar(parseFloat(str));
            const dot = str.indexOf('.');
            if (dot !== -1 && str[str.length - 1] === '0')
                node.minFractionDigits = str.length - dot - 1;
            return node;
        },
        stringify: stringifyNumber
    };

    const intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
    const intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
    function intStringify$1(node, radix, prefix) {
        const { value } = node;
        if (intIdentify$2(value) && value >= 0)
            return prefix + value.toString(radix);
        return stringifyNumber(node);
    }
    const intOct$1 = {
        identify: value => intIdentify$2(value) && value >= 0,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'OCT',
        test: /^0o[0-7]+$/,
        resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
        stringify: node => intStringify$1(node, 8, '0o')
    };
    const int$1 = {
        identify: intIdentify$2,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^[-+]?[0-9]+$/,
        resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
        stringify: stringifyNumber
    };
    const intHex$1 = {
        identify: value => intIdentify$2(value) && value >= 0,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'HEX',
        test: /^0x[0-9a-fA-F]+$/,
        resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
        stringify: node => intStringify$1(node, 16, '0x')
    };

    const schema$2 = [
        map,
        seq,
        string,
        nullTag,
        boolTag,
        intOct$1,
        int$1,
        intHex$1,
        floatNaN$1,
        floatExp$1,
        float$1
    ];

    function intIdentify$1(value) {
        return typeof value === 'bigint' || Number.isInteger(value);
    }
    const stringifyJSON = ({ value }) => JSON.stringify(value);
    const jsonScalars = [
        {
            identify: value => typeof value === 'string',
            default: true,
            tag: 'tag:yaml.org,2002:str',
            resolve: str => str,
            stringify: stringifyJSON
        },
        {
            identify: value => value == null,
            createNode: () => new Scalar(null),
            default: true,
            tag: 'tag:yaml.org,2002:null',
            test: /^null$/,
            resolve: () => null,
            stringify: stringifyJSON
        },
        {
            identify: value => typeof value === 'boolean',
            default: true,
            tag: 'tag:yaml.org,2002:bool',
            test: /^true|false$/,
            resolve: str => str === 'true',
            stringify: stringifyJSON
        },
        {
            identify: intIdentify$1,
            default: true,
            tag: 'tag:yaml.org,2002:int',
            test: /^-?(?:0|[1-9][0-9]*)$/,
            resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
            stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
        },
        {
            identify: value => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:float',
            test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
            resolve: str => parseFloat(str),
            stringify: stringifyJSON
        }
    ];
    const jsonError = {
        default: true,
        tag: '',
        test: /^/,
        resolve(str, onError) {
            onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
            return str;
        }
    };
    const schema$1 = [map, seq].concat(jsonScalars, jsonError);

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString$1 = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString$1.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    const binary = {
        identify: value => value instanceof Uint8Array,
        default: false,
        tag: 'tag:yaml.org,2002:binary',
        /**
         * Returns a Buffer in node and an Uint8Array in browsers
         *
         * To use the resulting buffer as an image, you'll want to do something like:
         *
         *   const blob = new Blob([buffer], { type: 'image/jpeg' })
         *   document.querySelector('#photo').src = URL.createObjectURL(blob)
         */
        resolve(src, onError) {
            if (typeof Buffer === 'function') {
                return Buffer.from(src, 'base64');
            }
            else if (typeof atob === 'function') {
                // On IE 11, atob() can't handle newlines
                const str = atob(src.replace(/[\n\r]/g, ''));
                const buffer = new Uint8Array(str.length);
                for (let i = 0; i < str.length; ++i)
                    buffer[i] = str.charCodeAt(i);
                return buffer;
            }
            else {
                onError('This environment does not support reading binary tags; either Buffer or atob is required');
                return src;
            }
        },
        stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
            const buf = value; // checked earlier by binary.identify()
            let str;
            if (typeof Buffer === 'function') {
                str =
                    buf instanceof Buffer
                        ? buf.toString('base64')
                        : Buffer.from(buf.buffer).toString('base64');
            }
            else if (typeof btoa === 'function') {
                let s = '';
                for (let i = 0; i < buf.length; ++i)
                    s += String.fromCharCode(buf[i]);
                str = btoa(s);
            }
            else {
                throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
            }
            if (!type)
                type = Scalar.BLOCK_LITERAL;
            if (type !== Scalar.QUOTE_DOUBLE) {
                const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
                const n = Math.ceil(str.length / lineWidth);
                const lines = new Array(n);
                for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                    lines[i] = str.substr(o, lineWidth);
                }
                str = lines.join(type === Scalar.BLOCK_LITERAL ? '\n' : ' ');
            }
            return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
        }
    };

    function resolvePairs(seq, onError) {
        if (isSeq(seq)) {
            for (let i = 0; i < seq.items.length; ++i) {
                let item = seq.items[i];
                if (isPair(item))
                    continue;
                else if (isMap(item)) {
                    if (item.items.length > 1)
                        onError('Each pair must have its own sequence indicator');
                    const pair = item.items[0] || new Pair(new Scalar(null));
                    if (item.commentBefore)
                        pair.key.commentBefore = pair.key.commentBefore
                            ? `${item.commentBefore}\n${pair.key.commentBefore}`
                            : item.commentBefore;
                    if (item.comment) {
                        const cn = pair.value || pair.key;
                        cn.comment = cn.comment
                            ? `${item.comment}\n${cn.comment}`
                            : item.comment;
                    }
                    item = pair;
                }
                seq.items[i] = isPair(item) ? item : new Pair(item);
            }
        }
        else
            onError('Expected a sequence for this tag');
        return seq;
    }
    function createPairs(schema, iterable, ctx) {
        const { replacer } = ctx;
        const pairs = new YAMLSeq(schema);
        pairs.tag = 'tag:yaml.org,2002:pairs';
        let i = 0;
        if (iterable && Symbol.iterator in Object(iterable))
            for (let it of iterable) {
                if (typeof replacer === 'function')
                    it = replacer.call(iterable, String(i++), it);
                let key, value;
                if (Array.isArray(it)) {
                    if (it.length === 2) {
                        key = it[0];
                        value = it[1];
                    }
                    else
                        throw new TypeError(`Expected [key, value] tuple: ${it}`);
                }
                else if (it && it instanceof Object) {
                    const keys = Object.keys(it);
                    if (keys.length === 1) {
                        key = keys[0];
                        value = it[key];
                    }
                    else
                        throw new TypeError(`Expected { key: value } tuple: ${it}`);
                }
                else {
                    key = it;
                }
                pairs.items.push(createPair(key, value, ctx));
            }
        return pairs;
    }
    const pairs = {
        collection: 'seq',
        default: false,
        tag: 'tag:yaml.org,2002:pairs',
        resolve: resolvePairs,
        createNode: createPairs
    };

    class YAMLOMap extends YAMLSeq {
        constructor() {
            super();
            this.add = YAMLMap.prototype.add.bind(this);
            this.delete = YAMLMap.prototype.delete.bind(this);
            this.get = YAMLMap.prototype.get.bind(this);
            this.has = YAMLMap.prototype.has.bind(this);
            this.set = YAMLMap.prototype.set.bind(this);
            this.tag = YAMLOMap.tag;
        }
        /**
         * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
         * but TypeScript won't allow widening the signature of a child method.
         */
        toJSON(_, ctx) {
            if (!ctx)
                return super.toJSON(_);
            const map = new Map();
            if (ctx && ctx.onCreate)
                ctx.onCreate(map);
            for (const pair of this.items) {
                let key, value;
                if (isPair(pair)) {
                    key = toJS(pair.key, '', ctx);
                    value = toJS(pair.value, key, ctx);
                }
                else {
                    key = toJS(pair, '', ctx);
                }
                if (map.has(key))
                    throw new Error('Ordered maps must not include duplicate keys');
                map.set(key, value);
            }
            return map;
        }
    }
    YAMLOMap.tag = 'tag:yaml.org,2002:omap';
    const omap = {
        collection: 'seq',
        identify: value => value instanceof Map,
        nodeClass: YAMLOMap,
        default: false,
        tag: 'tag:yaml.org,2002:omap',
        resolve(seq, onError) {
            const pairs = resolvePairs(seq, onError);
            const seenKeys = [];
            for (const { key } of pairs.items) {
                if (isScalar(key)) {
                    if (seenKeys.includes(key.value)) {
                        onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                    }
                    else {
                        seenKeys.push(key.value);
                    }
                }
            }
            return Object.assign(new YAMLOMap(), pairs);
        },
        createNode(schema, iterable, ctx) {
            const pairs = createPairs(schema, iterable, ctx);
            const omap = new YAMLOMap();
            omap.items = pairs.items;
            return omap;
        }
    };

    function boolStringify({ value, source }, ctx) {
        const boolObj = value ? trueTag : falseTag;
        if (source && boolObj.test.test(source))
            return source;
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    const trueTag = {
        identify: value => value === true,
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: () => new Scalar(true),
        stringify: boolStringify
    };
    const falseTag = {
        identify: value => value === false,
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
        resolve: () => new Scalar(false),
        stringify: boolStringify
    };

    const floatNaN = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
        resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
            ? NaN
            : str[0] === '-'
                ? Number.NEGATIVE_INFINITY
                : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber
    };
    const floatExp = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'EXP',
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: (str) => parseFloat(str.replace(/_/g, '')),
        stringify: ({ value }) => Number(value).toExponential()
    };
    const float = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve(str) {
            const node = new Scalar(parseFloat(str.replace(/_/g, '')));
            const dot = str.indexOf('.');
            if (dot !== -1) {
                const f = str.substring(dot + 1).replace(/_/g, '');
                if (f[f.length - 1] === '0')
                    node.minFractionDigits = f.length;
            }
            return node;
        },
        stringify: stringifyNumber
    };

    const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
        const sign = str[0];
        if (sign === '-' || sign === '+')
            offset += 1;
        str = str.substring(offset).replace(/_/g, '');
        if (intAsBigInt) {
            switch (radix) {
                case 2:
                    str = `0b${str}`;
                    break;
                case 8:
                    str = `0o${str}`;
                    break;
                case 16:
                    str = `0x${str}`;
                    break;
            }
            const n = BigInt(str);
            return sign === '-' ? BigInt(-1) * n : n;
        }
        const n = parseInt(str, radix);
        return sign === '-' ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
        const { value } = node;
        if (intIdentify(value)) {
            const str = value.toString(radix);
            return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
        }
        return stringifyNumber(node);
    }
    const intBin = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'BIN',
        test: /^[-+]?0b[0-1_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
        stringify: node => intStringify(node, 2, '0b')
    };
    const intOct = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'OCT',
        test: /^[-+]?0[0-7_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
        stringify: node => intStringify(node, 8, '0')
    };
    const int = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
        stringify: stringifyNumber
    };
    const intHex = {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'HEX',
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
        stringify: node => intStringify(node, 16, '0x')
    };

    class YAMLSet extends YAMLMap {
        constructor(schema) {
            super(schema);
            this.tag = YAMLSet.tag;
        }
        add(key) {
            let pair;
            if (isPair(key))
                pair = key;
            else if (typeof key === 'object' &&
                'key' in key &&
                'value' in key &&
                key.value === null)
                pair = new Pair(key.key, null);
            else
                pair = new Pair(key, null);
            const prev = findPair(this.items, pair.key);
            if (!prev)
                this.items.push(pair);
        }
        get(key, keepPair) {
            const pair = findPair(this.items, key);
            return !keepPair && isPair(pair)
                ? isScalar(pair.key)
                    ? pair.key.value
                    : pair.key
                : pair;
        }
        set(key, value) {
            if (typeof value !== 'boolean')
                throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
            const prev = findPair(this.items, key);
            if (prev && !value) {
                this.items.splice(this.items.indexOf(prev), 1);
            }
            else if (!prev && value) {
                this.items.push(new Pair(key));
            }
        }
        toJSON(_, ctx) {
            return super.toJSON(_, ctx, Set);
        }
        toString(ctx, onComment, onChompKeep) {
            if (!ctx)
                return JSON.stringify(this);
            if (this.hasAllNullValues(true))
                return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
            else
                throw new Error('Set items must all have null values');
        }
    }
    YAMLSet.tag = 'tag:yaml.org,2002:set';
    const set = {
        collection: 'map',
        identify: value => value instanceof Set,
        nodeClass: YAMLSet,
        default: false,
        tag: 'tag:yaml.org,2002:set',
        resolve(map, onError) {
            if (isMap(map)) {
                if (map.hasAllNullValues(true))
                    return Object.assign(new YAMLSet(), map);
                else
                    onError('Set items must all have null values');
            }
            else
                onError('Expected a mapping for this tag');
            return map;
        },
        createNode(schema, iterable, ctx) {
            const { replacer } = ctx;
            const set = new YAMLSet(schema);
            if (iterable && Symbol.iterator in Object(iterable))
                for (let value of iterable) {
                    if (typeof replacer === 'function')
                        value = replacer.call(iterable, value, value);
                    set.items.push(createPair(value, null, ctx));
                }
            return set;
        }
    };

    /** Internal types handle bigint as number, because TS can't figure it out. */
    function parseSexagesimal(str, asBigInt) {
        const sign = str[0];
        const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
        const num = (n) => asBigInt ? BigInt(n) : Number(n);
        const res = parts
            .replace(/_/g, '')
            .split(':')
            .reduce((res, p) => res * num(60) + num(p), num(0));
        return (sign === '-' ? num(-1) * res : res);
    }
    /**
     * hhhh:mm:ss.sss
     *
     * Internal types handle bigint as number, because TS can't figure it out.
     */
    function stringifySexagesimal(node) {
        let { value } = node;
        let num = (n) => n;
        if (typeof value === 'bigint')
            num = n => BigInt(n);
        else if (isNaN(value) || !isFinite(value))
            return stringifyNumber(node);
        let sign = '';
        if (value < 0) {
            sign = '-';
            value *= num(-1);
        }
        const _60 = num(60);
        const parts = [value % _60]; // seconds, including ms
        if (value < 60) {
            parts.unshift(0); // at least one : is required
        }
        else {
            value = (value - parts[0]) / _60;
            parts.unshift(value % _60); // minutes
            if (value >= 60) {
                value = (value - parts[0]) / _60;
                parts.unshift(value); // hours
            }
        }
        return (sign +
            parts
                .map(n => (n < 10 ? '0' + String(n) : String(n)))
                .join(':')
                .replace(/000000\d*$/, '') // % 60 may introduce error
        );
    }
    const intTime = {
        identify: value => typeof value === 'bigint' || Number.isInteger(value),
        default: true,
        tag: 'tag:yaml.org,2002:int',
        format: 'TIME',
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
        stringify: stringifySexagesimal
    };
    const floatTime = {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        format: 'TIME',
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: str => parseSexagesimal(str, false),
        stringify: stringifySexagesimal
    };
    const timestamp = {
        identify: value => value instanceof Date,
        default: true,
        tag: 'tag:yaml.org,2002:timestamp',
        // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
        // may be omitted altogether, resulting in a date format. In such a case, the time part is
        // assumed to be 00:00:00Z (start of day, UTC).
        test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
            '(?:' + // time is optional
            '(?:t|T|[ \\t]+)' + // t | T | whitespace
            '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
            '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
            ')?$'),
        resolve(str) {
            const match = str.match(timestamp.test);
            if (!match)
                throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
            const [, year, month, day, hour, minute, second] = match.map(Number);
            const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
            let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
            const tz = match[8];
            if (tz && tz !== 'Z') {
                let d = parseSexagesimal(tz, false);
                if (Math.abs(d) < 30)
                    d *= 60;
                date -= 60000 * d;
            }
            return new Date(date);
        },
        stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
    };

    const schema = [
        map,
        seq,
        string,
        nullTag,
        trueTag,
        falseTag,
        intBin,
        intOct,
        int,
        intHex,
        floatNaN,
        floatExp,
        float,
        binary,
        omap,
        pairs,
        set,
        intTime,
        floatTime,
        timestamp
    ];

    const schemas = {
        core: schema$2,
        failsafe: [map, seq, string],
        json: schema$1,
        yaml11: schema,
        'yaml-1.1': schema
    };
    const tagsByName = {
        binary,
        bool: boolTag,
        float: float$1,
        floatExp: floatExp$1,
        floatNaN: floatNaN$1,
        floatTime,
        int: int$1,
        intHex: intHex$1,
        intOct: intOct$1,
        intTime,
        map,
        null: nullTag,
        omap,
        pairs,
        seq,
        set,
        timestamp
    };
    const coreKnownTags = {
        'tag:yaml.org,2002:binary': binary,
        'tag:yaml.org,2002:omap': omap,
        'tag:yaml.org,2002:pairs': pairs,
        'tag:yaml.org,2002:set': set,
        'tag:yaml.org,2002:timestamp': timestamp
    };
    function getTags(customTags, schemaName) {
        let tags = schemas[schemaName];
        if (!tags) {
            const keys = Object.keys(schemas)
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys}`);
        }
        if (Array.isArray(customTags)) {
            for (const tag of customTags)
                tags = tags.concat(tag);
        }
        else if (typeof customTags === 'function') {
            tags = customTags(tags.slice());
        }
        return tags.map(tag => {
            if (typeof tag !== 'string')
                return tag;
            const tagObj = tagsByName[tag];
            if (tagObj)
                return tagObj;
            const keys = Object.keys(tagsByName)
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
        });
    }

    const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    class Schema {
        constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {
            this.merge = !!merge;
            this.name = schema || 'core';
            this.knownTags = resolveKnownTags ? coreKnownTags : {};
            this.tags = getTags(customTags, this.name);
            Object.defineProperty(this, MAP, { value: map });
            Object.defineProperty(this, SCALAR$1, { value: string });
            Object.defineProperty(this, SEQ, { value: seq });
            // Used by createMap()
            this.sortMapEntries =
                sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        }
    }

    function stringifyDocument(doc, options) {
        const lines = [];
        let hasDirectives = options.directives === true;
        if (options.directives !== false) {
            const dir = doc.directives.toString(doc);
            if (dir) {
                lines.push(dir);
                hasDirectives = true;
            }
            else if (doc.directives.marker)
                hasDirectives = true;
        }
        if (hasDirectives)
            lines.push('---');
        if (doc.commentBefore) {
            if (lines.length !== 1)
                lines.unshift('');
            lines.unshift(stringifyComment(doc.commentBefore, ''));
        }
        const ctx = createStringifyContext(doc, options);
        let chompKeep = false;
        let contentComment = null;
        if (doc.contents) {
            if (isNode(doc.contents)) {
                if (doc.contents.spaceBefore && hasDirectives)
                    lines.push('');
                if (doc.contents.commentBefore)
                    lines.push(stringifyComment(doc.contents.commentBefore, ''));
                // top-level block scalars need to be indented if followed by a comment
                ctx.forceBlockIndent = !!doc.comment;
                contentComment = doc.contents.comment;
            }
            const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
            let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
            if (contentComment)
                body = addComment(body, '', contentComment);
            if ((body[0] === '|' || body[0] === '>') &&
                lines[lines.length - 1] === '---') {
                // Top-level block scalars with a preceding doc marker ought to use the
                // same line for their header.
                lines[lines.length - 1] = `--- ${body}`;
            }
            else
                lines.push(body);
        }
        else {
            lines.push(stringify(doc.contents, ctx));
        }
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment(dc, ''));
        }
        return lines.join('\n') + '\n';
    }

    /**
     * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
     * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
     * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
     *
     * Includes extensions for handling Map and Set objects.
     */
    function applyReviver(reviver, obj, key, val) {
        if (val && typeof val === 'object') {
            if (Array.isArray(val)) {
                for (let i = 0, len = val.length; i < len; ++i) {
                    const v0 = val[i];
                    const v1 = applyReviver(reviver, val, String(i), v0);
                    if (v1 === undefined)
                        delete val[i];
                    else if (v1 !== v0)
                        val[i] = v1;
                }
            }
            else if (val instanceof Map) {
                for (const k of Array.from(val.keys())) {
                    const v0 = val.get(k);
                    const v1 = applyReviver(reviver, val, k, v0);
                    if (v1 === undefined)
                        val.delete(k);
                    else if (v1 !== v0)
                        val.set(k, v1);
                }
            }
            else if (val instanceof Set) {
                for (const v0 of Array.from(val)) {
                    const v1 = applyReviver(reviver, val, v0, v0);
                    if (v1 === undefined)
                        val.delete(v0);
                    else if (v1 !== v0) {
                        val.delete(v0);
                        val.add(v1);
                    }
                }
            }
            else {
                for (const [k, v0] of Object.entries(val)) {
                    const v1 = applyReviver(reviver, val, k, v0);
                    if (v1 === undefined)
                        delete val[k];
                    else if (v1 !== v0)
                        val[k] = v1;
                }
            }
        }
        return reviver.call(obj, key, val);
    }

    class Document$1 {
        constructor(value, replacer, options) {
            /** A comment before this Document */
            this.commentBefore = null;
            /** A comment immediately after this Document */
            this.comment = null;
            /** Errors encountered during parsing. */
            this.errors = [];
            /** Warnings encountered during parsing. */
            this.warnings = [];
            Object.defineProperty(this, NODE_TYPE, { value: DOC });
            let _replacer = null;
            if (typeof replacer === 'function' || Array.isArray(replacer)) {
                _replacer = replacer;
            }
            else if (options === undefined && replacer) {
                options = replacer;
                replacer = undefined;
            }
            const opt = Object.assign({}, defaultOptions, options);
            this.options = opt;
            let { version } = opt;
            if (options === null || options === void 0 ? void 0 : options.directives) {
                this.directives = options.directives.atDocument();
                if (this.directives.yaml.explicit)
                    version = this.directives.yaml.version;
            }
            else
                this.directives = new Directives({ version });
            this.setSchema(version, options);
            if (value === undefined)
                this.contents = null;
            else {
                this.contents = this.createNode(value, _replacer, options);
            }
        }
        /** Adds a value to the document. */
        add(value) {
            if (assertCollection(this.contents))
                this.contents.add(value);
        }
        /** Adds a value to the document. */
        addIn(path, value) {
            if (assertCollection(this.contents))
                this.contents.addIn(path, value);
        }
        /**
         * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
         *
         * If `node` already has an anchor, `name` is ignored.
         * Otherwise, the `node.anchor` value will be set to `name`,
         * or if an anchor with that name is already present in the document,
         * `name` will be used as a prefix for a new unique anchor.
         * If `name` is undefined, the generated anchor will use 'a' as a prefix.
         */
        createAlias(node, name) {
            if (!node.anchor) {
                const prev = anchorNames(this);
                node.anchor =
                    !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
            }
            return new Alias(node.anchor);
        }
        createNode(value, replacer, options) {
            let _replacer = undefined;
            if (typeof replacer === 'function') {
                value = replacer.call({ '': value }, '', value);
                _replacer = replacer;
            }
            else if (Array.isArray(replacer)) {
                const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
                const asStr = replacer.filter(keyToStr).map(String);
                if (asStr.length > 0)
                    replacer = replacer.concat(asStr);
                _replacer = replacer;
            }
            else if (options === undefined && replacer) {
                options = replacer;
                replacer = undefined;
            }
            const { anchorPrefix, flow, keepUndefined, onTagObj, tag } = options || {};
            const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || 'a');
            const ctx = {
                keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
                onAnchor,
                onTagObj,
                replacer: _replacer,
                schema: this.schema,
                sourceObjects
            };
            const node = createNode(value, tag, ctx);
            if (flow && isCollection(node))
                node.flow = true;
            setAnchors();
            return node;
        }
        /**
         * Convert a key and a value into a `Pair` using the current schema,
         * recursively wrapping all values as `Scalar` or `Collection` nodes.
         */
        createPair(key, value, options = {}) {
            const k = this.createNode(key, null, options);
            const v = this.createNode(value, null, options);
            return new Pair(k, v);
        }
        /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
        delete(key) {
            return assertCollection(this.contents) ? this.contents.delete(key) : false;
        }
        /**
         * Removes a value from the document.
         * @returns `true` if the item was found and removed.
         */
        deleteIn(path) {
            if (isEmptyPath(path)) {
                if (this.contents == null)
                    return false;
                this.contents = null;
                return true;
            }
            return assertCollection(this.contents)
                ? this.contents.deleteIn(path)
                : false;
        }
        /**
         * Returns item at `key`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        get(key, keepScalar) {
            return isCollection(this.contents)
                ? this.contents.get(key, keepScalar)
                : undefined;
        }
        /**
         * Returns item at `path`, or `undefined` if not found. By default unwraps
         * scalar values from their surrounding node; to disable set `keepScalar` to
         * `true` (collections are always returned intact).
         */
        getIn(path, keepScalar) {
            if (isEmptyPath(path))
                return !keepScalar && isScalar(this.contents)
                    ? this.contents.value
                    : this.contents;
            return isCollection(this.contents)
                ? this.contents.getIn(path, keepScalar)
                : undefined;
        }
        /**
         * Checks if the document includes a value with the key `key`.
         */
        has(key) {
            return isCollection(this.contents) ? this.contents.has(key) : false;
        }
        /**
         * Checks if the document includes a value at `path`.
         */
        hasIn(path) {
            if (isEmptyPath(path))
                return this.contents !== undefined;
            return isCollection(this.contents) ? this.contents.hasIn(path) : false;
        }
        /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        set(key, value) {
            if (this.contents == null) {
                this.contents = collectionFromPath(this.schema, [key], value);
            }
            else if (assertCollection(this.contents)) {
                this.contents.set(key, value);
            }
        }
        /**
         * Sets a value in this document. For `!!set`, `value` needs to be a
         * boolean to add/remove the item from the set.
         */
        setIn(path, value) {
            if (isEmptyPath(path))
                this.contents = value;
            else if (this.contents == null) {
                this.contents = collectionFromPath(this.schema, Array.from(path), value);
            }
            else if (assertCollection(this.contents)) {
                this.contents.setIn(path, value);
            }
        }
        /**
         * Change the YAML version and schema used by the document.
         *
         * Overrides all previously set schema options
         */
        setSchema(version, options) {
            let _options;
            switch (String(version)) {
                case '1.1':
                    this.directives.yaml.version = '1.1';
                    _options = Object.assign({ merge: true, resolveKnownTags: false, schema: 'yaml-1.1' }, options);
                    break;
                case '1.2':
                    this.directives.yaml.version = '1.2';
                    _options = Object.assign({ merge: false, resolveKnownTags: true, schema: 'core' }, options);
                    break;
                default: {
                    const sv = JSON.stringify(version);
                    throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);
                }
            }
            this.schema = new Schema(_options);
        }
        // json & jsonArg are only used from toJSON()
        toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
            const ctx = {
                anchors: new Map(),
                doc: this,
                keep: !json,
                mapAsMap: mapAsMap === true,
                mapKeyWarned: false,
                maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
                stringify
            };
            const res = toJS(this.contents, jsonArg || '', ctx);
            if (typeof onAnchor === 'function')
                for (const { count, res } of ctx.anchors.values())
                    onAnchor(res, count);
            return typeof reviver === 'function'
                ? applyReviver(reviver, { '': res }, '', res)
                : res;
        }
        /**
         * A JSON representation of the document `contents`.
         *
         * @param jsonArg Used by `JSON.stringify` to indicate the array index or
         *   property name.
         */
        toJSON(jsonArg, onAnchor) {
            return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
        }
        /** A YAML representation of the document. */
        toString(options = {}) {
            if (this.errors.length > 0)
                throw new Error('Document with errors cannot be stringified');
            if ('indent' in options &&
                (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
                const s = JSON.stringify(options.indent);
                throw new Error(`"indent" option must be a positive integer, not ${s}`);
            }
            return stringifyDocument(this, options);
        }
    }
    function assertCollection(contents) {
        if (isCollection(contents))
            return true;
        throw new Error('Expected a YAML collection as document contents');
    }

    class YAMLError extends Error {
        constructor(name, pos, code, message) {
            super();
            this.name = name;
            this.code = code;
            this.message = message;
            this.pos = pos;
        }
    }
    class YAMLParseError extends YAMLError {
        constructor(pos, code, message) {
            super('YAMLParseError', pos, code, message);
        }
    }
    class YAMLWarning extends YAMLError {
        constructor(pos, code, message) {
            super('YAMLWarning', pos, code, message);
        }
    }
    const prettifyError = (src, lc) => (error) => {
        if (error.pos[0] === -1)
            return;
        error.linePos = error.pos.map(pos => lc.linePos(pos));
        const { line, col } = error.linePos[0];
        error.message += ` at line ${line}, column ${col}`;
        let ci = col - 1;
        let lineStr = src
            .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
            .replace(/[\n\r]+$/, '');
        // Trim to max 80 chars, keeping col position near the middle
        if (ci >= 60 && lineStr.length > 80) {
            const trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = '…' + lineStr.substring(trimStart);
            ci -= trimStart - 1;
        }
        if (lineStr.length > 80)
            lineStr = lineStr.substring(0, 79) + '…';
        // Include previous line in context if pointing at line start
        if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            // Regexp won't match if start is trimmed
            let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            if (prev.length > 80)
                prev = prev.substring(0, 79) + '…\n';
            lineStr = prev + lineStr;
        }
        if (/[^ ]/.test(lineStr)) {
            let count = 1;
            const end = error.linePos[1];
            if (end && end.line === line && end.col > col) {
                count = Math.min(end.col - col, 80 - ci);
            }
            const pointer = ' '.repeat(ci) + '^'.repeat(count);
            error.message += `:\n\n${lineStr}\n${pointer}\n`;
        }
    };

    function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
        let spaceBefore = false;
        let atNewline = startOnNewline;
        let hasSpace = startOnNewline;
        let comment = '';
        let commentSep = '';
        let hasNewline = false;
        let reqSpace = false;
        let anchor = null;
        let tag = null;
        let comma = null;
        let found = null;
        let start = null;
        for (const token of tokens) {
            if (reqSpace) {
                if (token.type !== 'space' &&
                    token.type !== 'newline' &&
                    token.type !== 'comma')
                    onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
                reqSpace = false;
            }
            switch (token.type) {
                case 'space':
                    // At the doc level, tabs at line start may be parsed
                    // as leading white space rather than indentation.
                    // In a flow collection, only the parser handles indent.
                    if (!flow &&
                        atNewline &&
                        indicator !== 'doc-start' &&
                        token.source[0] === '\t')
                        onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (!hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = token.source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += commentSep + cb;
                    commentSep = '';
                    atNewline = false;
                    break;
                }
                case 'newline':
                    if (atNewline) {
                        if (comment)
                            comment += token.source;
                        else
                            spaceBefore = true;
                    }
                    else
                        commentSep += token.source;
                    atNewline = true;
                    hasNewline = true;
                    hasSpace = true;
                    break;
                case 'anchor':
                    if (anchor)
                        onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                    anchor = token;
                    if (start === null)
                        start = token.offset;
                    atNewline = false;
                    hasSpace = false;
                    reqSpace = true;
                    break;
                case 'tag': {
                    if (tag)
                        onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                    tag = token;
                    if (start === null)
                        start = token.offset;
                    atNewline = false;
                    hasSpace = false;
                    reqSpace = true;
                    break;
                }
                case indicator:
                    // Could here handle preceding comments differently
                    if (anchor || tag)
                        onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                    found = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                case 'comma':
                    if (flow) {
                        if (comma)
                            onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                        comma = token;
                        atNewline = false;
                        hasSpace = false;
                        break;
                    }
                // else fallthrough
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                    atNewline = false;
                    hasSpace = false;
            }
        }
        const last = tokens[tokens.length - 1];
        const end = last ? last.offset + last.source.length : offset;
        if (reqSpace &&
            next &&
            next.type !== 'space' &&
            next.type !== 'newline' &&
            next.type !== 'comma' &&
            (next.type !== 'scalar' || next.source !== ''))
            onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
        return {
            comma,
            found,
            spaceBefore,
            comment,
            hasNewline,
            anchor,
            tag,
            end,
            start: start !== null && start !== void 0 ? start : end
        };
    }

    function containsNewline(key) {
        if (!key)
            return null;
        switch (key.type) {
            case 'alias':
            case 'scalar':
            case 'double-quoted-scalar':
            case 'single-quoted-scalar':
                if (key.source.includes('\n'))
                    return true;
                if (key.end)
                    for (const st of key.end)
                        if (st.type === 'newline')
                            return true;
                return false;
            case 'flow-collection':
                for (const it of key.items) {
                    for (const st of it.start)
                        if (st.type === 'newline')
                            return true;
                    if (it.sep)
                        for (const st of it.sep)
                            if (st.type === 'newline')
                                return true;
                    if (containsNewline(it.key) || containsNewline(it.value))
                        return true;
                }
                return false;
            default:
                return true;
        }
    }

    function mapIncludes(ctx, items, search) {
        const { uniqueKeys } = ctx.options;
        if (uniqueKeys === false)
            return false;
        const isEqual = typeof uniqueKeys === 'function'
            ? uniqueKeys
            : (a, b) => a === b ||
                (isScalar(a) &&
                    isScalar(b) &&
                    a.value === b.value &&
                    !(a.value === '<<' && ctx.schema.merge));
        return items.some(pair => isEqual(pair.key, search));
    }

    const startColMsg = 'All mapping items must start at the same column';
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
        var _a;
        const map = new YAMLMap(ctx.schema);
        let offset = bm.offset;
        for (const { start, key, sep, value } of bm.items) {
            // key properties
            const keyProps = resolveProps(start, {
                indicator: 'explicit-key-ind',
                next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
                offset,
                onError,
                startOnNewline: true
            });
            const implicitKey = !keyProps.found;
            if (implicitKey) {
                if (key) {
                    if (key.type === 'block-seq')
                        onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                    else if ('indent' in key && key.indent !== bm.indent)
                        onError(offset, 'BAD_INDENT', startColMsg);
                }
                if (!keyProps.anchor && !keyProps.tag && !sep) {
                    // TODO: assert being at last item?
                    if (keyProps.comment) {
                        if (map.comment)
                            map.comment += '\n' + keyProps.comment;
                        else
                            map.comment = keyProps.comment;
                    }
                    continue;
                }
            }
            else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
                onError(offset, 'BAD_INDENT', startColMsg);
            if (implicitKey && containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            // key value
            const keyStart = keyProps.end;
            const keyNode = key
                ? composeNode(ctx, key, keyProps, onError)
                : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
            if (mapIncludes(ctx, map.items, keyNode))
                onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
            // value properties
            const valueProps = resolveProps(sep || [], {
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: !key || key.type === 'block-scalar'
            });
            offset = valueProps.end;
            if (valueProps.found) {
                if (implicitKey) {
                    if ((value === null || value === void 0 ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline)
                        onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                    if (ctx.options.strict &&
                        keyProps.start < valueProps.found.offset - 1024)
                        onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
                }
                // value value
                const valueNode = value
                    ? composeNode(ctx, value, valueProps, onError)
                    : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
                offset = valueNode.range[2];
                map.items.push(new Pair(keyNode, valueNode));
            }
            else {
                // key with no value
                if (implicitKey)
                    onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
                if (valueProps.comment) {
                    if (keyNode.comment)
                        keyNode.comment += '\n' + valueProps.comment;
                    else
                        keyNode.comment = valueProps.comment;
                }
                map.items.push(new Pair(keyNode));
            }
        }
        map.range = [bm.offset, offset, offset];
        return map;
    }

    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
        const seq = new YAMLSeq(ctx.schema);
        let offset = bs.offset;
        for (const { start, value } of bs.items) {
            const props = resolveProps(start, {
                indicator: 'seq-item-ind',
                next: value,
                offset,
                onError,
                startOnNewline: true
            });
            offset = props.end;
            if (!props.found) {
                if (props.anchor || props.tag || value) {
                    if (value && value.type === 'block-seq')
                        onError(offset, 'BAD_INDENT', 'All sequence items must start at the same column');
                    else
                        onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
                }
                else {
                    // TODO: assert being at last item?
                    if (props.comment)
                        seq.comment = props.comment;
                    continue;
                }
            }
            const node = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, offset, start, null, props, onError);
            offset = node.range[2];
            seq.items.push(node);
        }
        seq.range = [bs.offset, offset, offset];
        return seq;
    }

    function resolveEnd(end, offset, reqSpace, onError) {
        let comment = '';
        if (end) {
            let hasSpace = false;
            let sep = '';
            for (const token of end) {
                const { source, type } = token;
                switch (type) {
                    case 'space':
                        hasSpace = true;
                        break;
                    case 'comment': {
                        if (reqSpace && !hasSpace)
                            onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                        const cb = source.substring(1) || ' ';
                        if (!comment)
                            comment = cb;
                        else
                            comment += sep + cb;
                        sep = '';
                        break;
                    }
                    case 'newline':
                        if (comment)
                            sep += source;
                        hasSpace = true;
                        break;
                    default:
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
                }
                offset += source.length;
            }
        }
        return { comment, offset };
    }

    const blockMsg = 'Block collections are not allowed within flow collections';
    const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
        const isMap = fc.start.source === '{';
        const fcName = isMap ? 'flow map' : 'flow sequence';
        const coll = isMap
            ? new YAMLMap(ctx.schema)
            : new YAMLSeq(ctx.schema);
        coll.flow = true;
        let offset = fc.offset;
        for (let i = 0; i < fc.items.length; ++i) {
            const { start, key, sep, value } = fc.items[i];
            const props = resolveProps(start, {
                flow: fcName,
                indicator: 'explicit-key-ind',
                next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
                offset,
                onError,
                startOnNewline: false
            });
            if (!props.found) {
                if (!props.anchor && !props.tag && !sep && !value) {
                    if (i === 0 && props.comma)
                        onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                    else if (i < fc.items.length - 1)
                        onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                    if (props.comment) {
                        if (coll.comment)
                            coll.comment += '\n' + props.comment;
                        else
                            coll.comment = props.comment;
                    }
                    continue;
                }
                if (!isMap && ctx.options.strict && containsNewline(key))
                    onError(key, // checked by containsNewline()
                    'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
            }
            if (i === 0) {
                if (props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
            }
            else {
                if (!props.comma)
                    onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
                if (props.comment) {
                    let prevItemComment = '';
                    loop: for (const st of start) {
                        switch (st.type) {
                            case 'comma':
                            case 'space':
                                break;
                            case 'comment':
                                prevItemComment = st.source.substring(1);
                                break loop;
                            default:
                                break loop;
                        }
                    }
                    if (prevItemComment) {
                        let prev = coll.items[coll.items.length - 1];
                        if (isPair(prev))
                            prev = prev.value || prev.key;
                        if (prev.comment)
                            prev.comment += '\n' + prevItemComment;
                        else
                            prev.comment = prevItemComment;
                        props.comment = props.comment.substring(prevItemComment.length + 1);
                    }
                }
            }
            if (!isMap && !sep && !props.found) {
                // item is a value in a seq
                // → key & sep are empty, start does not include ? or :
                const valueNode = value
                    ? composeNode(ctx, value, props, onError)
                    : composeEmptyNode(ctx, props.end, sep, null, props, onError);
                coll.items.push(valueNode);
                offset = valueNode.range[2];
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else {
                // item is a key+value pair
                // key value
                const keyStart = props.end;
                const keyNode = key
                    ? composeNode(ctx, key, props, onError)
                    : composeEmptyNode(ctx, keyStart, start, null, props, onError);
                if (isBlock(key))
                    onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
                // value properties
                const valueProps = resolveProps(sep || [], {
                    flow: fcName,
                    indicator: 'map-value-ind',
                    next: value,
                    offset: keyNode.range[2],
                    onError,
                    startOnNewline: false
                });
                if (valueProps.found) {
                    if (!isMap && !props.found && ctx.options.strict) {
                        if (sep)
                            for (const st of sep) {
                                if (st === valueProps.found)
                                    break;
                                if (st.type === 'newline') {
                                    onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                    break;
                                }
                            }
                        if (props.start < valueProps.found.offset - 1024)
                            onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                    }
                }
                else if (value) {
                    if ('source' in value && value.source && value.source[0] === ':')
                        onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                    else
                        onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
                }
                // value value
                const valueNode = value
                    ? composeNode(ctx, value, valueProps, onError)
                    : valueProps.found
                        ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                        : null;
                if (valueNode) {
                    if (isBlock(value))
                        onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
                }
                else if (valueProps.comment) {
                    if (keyNode.comment)
                        keyNode.comment += '\n' + valueProps.comment;
                    else
                        keyNode.comment = valueProps.comment;
                }
                const pair = new Pair(keyNode, valueNode);
                if (isMap) {
                    const map = coll;
                    if (mapIncludes(ctx, map.items, keyNode))
                        onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                    map.items.push(pair);
                }
                else {
                    const map = new YAMLMap(ctx.schema);
                    map.flow = true;
                    map.items.push(pair);
                    coll.items.push(map);
                }
                offset = valueNode ? valueNode.range[2] : valueProps.end;
            }
        }
        const expectedEnd = isMap ? '}' : ']';
        const [ce, ...ee] = fc.end;
        let cePos = offset;
        if (ce && ce.source === expectedEnd)
            cePos = ce.offset + ce.source.length;
        else {
            onError(offset + 1, 'MISSING_CHAR', `Expected ${fcName} to end with ${expectedEnd}`);
            if (ce && ce.source.length !== 1)
                ee.unshift(ce);
        }
        if (ee.length > 0) {
            const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
            if (end.comment) {
                if (coll.comment)
                    coll.comment += '\n' + end.comment;
                else
                    coll.comment = end.comment;
            }
            coll.range = [fc.offset, cePos, end.offset];
        }
        else {
            coll.range = [fc.offset, cePos, cePos];
        }
        return coll;
    }

    function composeCollection(CN, ctx, token, tagToken, onError) {
        let coll;
        switch (token.type) {
            case 'block-map': {
                coll = resolveBlockMap(CN, ctx, token, onError);
                break;
            }
            case 'block-seq': {
                coll = resolveBlockSeq(CN, ctx, token, onError);
                break;
            }
            case 'flow-collection': {
                coll = resolveFlowCollection(CN, ctx, token, onError);
                break;
            }
        }
        if (!tagToken)
            return coll;
        const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
        if (!tagName)
            return coll;
        // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841
        const Coll = coll.constructor;
        if (tagName === '!' || tagName === Coll.tagName) {
            coll.tag = Coll.tagName;
            return coll;
        }
        const expType = isMap(coll) ? 'map' : 'seq';
        let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);
        if (!tag) {
            const kt = ctx.schema.knownTags[tagName];
            if (kt && kt.collection === expType) {
                ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
                tag = kt;
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
                coll.tag = tagName;
                return coll;
            }
        }
        const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        const node = isNode(res)
            ? res
            : new Scalar(res);
        node.range = coll.range;
        node.tag = tagName;
        if (tag === null || tag === void 0 ? void 0 : tag.format)
            node.format = tag.format;
        return node;
    }

    function resolveBlockScalar(scalar, strict, onError) {
        const start = scalar.offset;
        const header = parseBlockScalarHeader(scalar, strict, onError);
        if (!header)
            return { value: '', type: null, comment: '', range: [start, start, start] };
        const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
        const lines = scalar.source ? splitLines(scalar.source) : [];
        // determine the end of content & start of chomping
        let chompStart = lines.length;
        for (let i = lines.length - 1; i >= 0; --i) {
            const content = lines[i][1];
            if (content === '' || content === '\r')
                chompStart = i;
            else
                break;
        }
        // shortcut for empty contents
        if (!scalar.source || chompStart === 0) {
            const value = header.chomp === '+' ? lines.map(line => line[0]).join('\n') : '';
            let end = start + header.length;
            if (scalar.source)
                end += scalar.source.length;
            return { value, type, comment: header.comment, range: [start, end, end] };
        }
        // find the indentation level to trim from start
        let trimIndent = scalar.indent + header.indent;
        let offset = scalar.offset + header.length;
        let contentStart = 0;
        for (let i = 0; i < chompStart; ++i) {
            const [indent, content] = lines[i];
            if (content === '' || content === '\r') {
                if (header.indent === 0 && indent.length > trimIndent)
                    trimIndent = indent.length;
            }
            else {
                if (indent.length < trimIndent) {
                    const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                    onError(offset + indent.length, 'MISSING_CHAR', message);
                }
                if (header.indent === 0)
                    trimIndent = indent.length;
                contentStart = i;
                break;
            }
            offset += indent.length + content.length + 1;
        }
        let value = '';
        let sep = '';
        let prevMoreIndented = false;
        // leading whitespace is kept intact
        for (let i = 0; i < contentStart; ++i)
            value += lines[i][0].slice(trimIndent) + '\n';
        for (let i = contentStart; i < chompStart; ++i) {
            let [indent, content] = lines[i];
            offset += indent.length + content.length + 1;
            const crlf = content[content.length - 1] === '\r';
            if (crlf)
                content = content.slice(0, -1);
            /* istanbul ignore if already caught in lexer */
            if (content && indent.length < trimIndent) {
                const src = header.indent
                    ? 'explicit indentation indicator'
                    : 'first line';
                const message = `Block scalar lines must not be less indented than their ${src}`;
                onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
                indent = '';
            }
            if (type === Scalar.BLOCK_LITERAL) {
                value += sep + indent.slice(trimIndent) + content;
                sep = '\n';
            }
            else if (indent.length > trimIndent || content[0] === '\t') {
                // more-indented content within a folded block
                if (sep === ' ')
                    sep = '\n';
                else if (!prevMoreIndented && sep === '\n')
                    sep = '\n\n';
                value += sep + indent.slice(trimIndent) + content;
                sep = '\n';
                prevMoreIndented = true;
            }
            else if (content === '') {
                // empty line
                if (sep === '\n')
                    value += '\n';
                else
                    sep = '\n';
            }
            else {
                value += sep + content;
                sep = ' ';
                prevMoreIndented = false;
            }
        }
        switch (header.chomp) {
            case '-':
                break;
            case '+':
                for (let i = chompStart; i < lines.length; ++i)
                    value += '\n' + lines[i][0].slice(trimIndent);
                if (value[value.length - 1] !== '\n')
                    value += '\n';
                break;
            default:
                value += '\n';
        }
        const end = start + header.length + scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
        /* istanbul ignore if should not happen */
        if (props[0].type !== 'block-scalar-header') {
            onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
            return null;
        }
        const { source } = props[0];
        const mode = source[0];
        let indent = 0;
        let chomp = '';
        let error = -1;
        for (let i = 1; i < source.length; ++i) {
            const ch = source[i];
            if (!chomp && (ch === '-' || ch === '+'))
                chomp = ch;
            else {
                const n = Number(ch);
                if (!indent && n)
                    indent = n;
                else if (error === -1)
                    error = offset + i;
            }
        }
        if (error !== -1)
            onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
        let hasSpace = false;
        let comment = '';
        let length = source.length;
        for (let i = 1; i < props.length; ++i) {
            const token = props[i];
            switch (token.type) {
                case 'space':
                    hasSpace = true;
                // fallthrough
                case 'newline':
                    length += token.source.length;
                    break;
                case 'comment':
                    if (strict && !hasSpace) {
                        const message = 'Comments must be separated from other tokens by white space characters';
                        onError(token, 'MISSING_CHAR', message);
                    }
                    length += token.source.length;
                    comment = token.source.substring(1);
                    break;
                case 'error':
                    onError(token, 'UNEXPECTED_TOKEN', token.message);
                    length += token.source.length;
                    break;
                /* istanbul ignore next should not happen */
                default: {
                    const message = `Unexpected token in block scalar header: ${token.type}`;
                    onError(token, 'UNEXPECTED_TOKEN', message);
                    const ts = token.source;
                    if (ts && typeof ts === 'string')
                        length += ts.length;
                }
            }
        }
        return { mode, indent, chomp, comment, length };
    }
    /** @returns Array of lines split up as `[indent, content]` */
    function splitLines(source) {
        const split = source.split(/\n( *)/);
        const first = split[0];
        const m = first.match(/^( *)/);
        const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ['', first];
        const lines = [line0];
        for (let i = 1; i < split.length; i += 2)
            lines.push([split[i], split[i + 1]]);
        return lines;
    }

    function resolveFlowScalar(scalar, strict, onError) {
        const { offset, type, source, end } = scalar;
        let _type;
        let value;
        const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
        switch (type) {
            case 'scalar':
                _type = Scalar.PLAIN;
                value = plainValue(source, _onError);
                break;
            case 'single-quoted-scalar':
                _type = Scalar.QUOTE_SINGLE;
                value = singleQuotedValue(source, _onError);
                break;
            case 'double-quoted-scalar':
                _type = Scalar.QUOTE_DOUBLE;
                value = doubleQuotedValue(source, _onError);
                break;
            /* istanbul ignore next should not happen */
            default:
                onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
                return {
                    value: '',
                    type: null,
                    comment: '',
                    range: [offset, offset + source.length, offset + source.length]
                };
        }
        const valueEnd = offset + source.length;
        const re = resolveEnd(end, valueEnd, strict, onError);
        return {
            value,
            type: _type,
            comment: re.comment,
            range: [offset, valueEnd, re.offset]
        };
    }
    function plainValue(source, onError) {
        let message = '';
        switch (source[0]) {
            /* istanbul ignore next should not happen */
            case '\t':
                message = 'Plain value cannot start with a tab character';
                break;
            case '|':
            case '>': {
                message = `Plain value cannot start with block scalar indicator ${source[0]}`;
                break;
            }
            case '@':
            case '`': {
                message = `Plain value cannot start with reserved character ${source[0]}`;
                break;
            }
        }
        if (message)
            onError(0, 'BAD_SCALAR_START', message);
        return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
        if (source[source.length - 1] !== "'" || source.length === 1)
            onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
        return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
        /**
         * The negative lookbehind here and in the `re` RegExp is to
         * prevent causing a polynomial search time in certain cases.
         *
         * The try-catch is for Safari, which doesn't support this yet:
         * https://caniuse.com/js-regexp-lookbehind
         */
        let first, line;
        try {
            first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
            line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
        }
        catch (_) {
            first = /(.*?)[ \t]*\r?\n/sy;
            line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
        }
        let match = first.exec(source);
        if (!match)
            return source;
        let res = match[1];
        let sep = ' ';
        let pos = first.lastIndex;
        line.lastIndex = pos;
        while ((match = line.exec(source))) {
            if (match[1] === '') {
                if (sep === '\n')
                    res += sep;
                else
                    sep = '\n';
            }
            else {
                res += sep + match[1];
                sep = ' ';
            }
            pos = line.lastIndex;
        }
        const last = /[ \t]*(.*)/sy;
        last.lastIndex = pos;
        match = last.exec(source);
        return res + sep + ((match && match[1]) || '');
    }
    function doubleQuotedValue(source, onError) {
        let res = '';
        for (let i = 1; i < source.length - 1; ++i) {
            const ch = source[i];
            if (ch === '\r' && source[i + 1] === '\n')
                continue;
            if (ch === '\n') {
                const { fold, offset } = foldNewline(source, i);
                res += fold;
                i = offset;
            }
            else if (ch === '\\') {
                let next = source[++i];
                const cc = escapeCodes[next];
                if (cc)
                    res += cc;
                else if (next === '\n') {
                    // skip escaped newlines, but still trim the following line
                    next = source[i + 1];
                    while (next === ' ' || next === '\t')
                        next = source[++i + 1];
                }
                else if (next === 'x' || next === 'u' || next === 'U') {
                    const length = { x: 2, u: 4, U: 8 }[next];
                    res += parseCharCode(source, i + 1, length, onError);
                    i += length;
                }
                else {
                    const raw = source.substr(i - 1, 2);
                    onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                    res += raw;
                }
            }
            else if (ch === ' ' || ch === '\t') {
                // trim trailing whitespace
                const wsStart = i;
                let next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
                if (next !== '\n')
                    res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
            }
            else {
                res += ch;
            }
        }
        if (source[source.length - 1] !== '"' || source.length === 1)
            onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
        return res;
    }
    /**
     * Fold a single newline into a space, multiple newlines to N - 1 newlines.
     * Presumes `source[offset] === '\n'`
     */
    function foldNewline(source, offset) {
        let fold = '';
        let ch = source[offset + 1];
        while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
            if (ch === '\r' && source[offset + 2] !== '\n')
                break;
            if (ch === '\n')
                fold += '\n';
            offset += 1;
            ch = source[offset + 1];
        }
        if (!fold)
            fold = ' ';
        return { fold, offset };
    }
    const escapeCodes = {
        '0': '\0',
        a: '\x07',
        b: '\b',
        e: '\x1b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t',
        v: '\v',
        N: '\u0085',
        _: '\u00a0',
        L: '\u2028',
        P: '\u2029',
        ' ': ' ',
        '"': '"',
        '/': '/',
        '\\': '\\',
        '\t': '\t'
    };
    function parseCharCode(source, offset, length, onError) {
        const cc = source.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
            const raw = source.substr(offset - 2, length + 2);
            onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
            return raw;
        }
        return String.fromCodePoint(code);
    }

    function composeScalar(ctx, token, tagToken, onError) {
        const { value, type, comment, range } = token.type === 'block-scalar'
            ? resolveBlockScalar(token, ctx.options.strict, onError)
            : resolveFlowScalar(token, ctx.options.strict, onError);
        const tagName = tagToken
            ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
            : null;
        const tag = tagToken && tagName
            ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
            : findScalarTagByTest(ctx.schema, value, token.type === 'scalar');
        let scalar;
        try {
            const res = tag.resolve(value, msg => onError(tagToken || token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
            scalar = isScalar(res) ? res : new Scalar(res);
        }
        catch (error) {
            onError(tagToken || token, 'TAG_RESOLVE_FAILED', error.message);
            scalar = new Scalar(value);
        }
        scalar.range = range;
        scalar.source = value;
        if (type)
            scalar.type = type;
        if (tagName)
            scalar.tag = tagName;
        if (tag.format)
            scalar.format = tag.format;
        if (comment)
            scalar.comment = comment;
        return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
        var _a;
        if (tagName === '!')
            return schema[SCALAR$1]; // non-specific tag
        const matchWithTest = [];
        for (const tag of schema.tags) {
            if (!tag.collection && tag.tag === tagName) {
                if (tag.default && tag.test)
                    matchWithTest.push(tag);
                else
                    return tag;
            }
        }
        for (const tag of matchWithTest)
            if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
                return tag;
        const kt = schema.knownTags[tagName];
        if (kt && !kt.collection) {
            // Ensure that the known tag is available for stringifying,
            // but does not get used by default.
            schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
            return kt;
        }
        onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
        return schema[SCALAR$1];
    }
    function findScalarTagByTest(schema, value, apply) {
        var _a;
        if (apply) {
            for (const tag of schema.tags) {
                if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))
                    return tag;
            }
        }
        return schema[SCALAR$1];
    }

    function emptyScalarPosition(offset, before, pos) {
        if (before) {
            if (pos === null)
                pos = before.length;
            for (let i = pos - 1; i >= 0; --i) {
                let st = before[i];
                switch (st.type) {
                    case 'space':
                    case 'comment':
                    case 'newline':
                        offset -= st.source.length;
                        continue;
                }
                // Technically, an empty scalar is immediately after the last non-empty
                // node, but it's more useful to place it after any whitespace.
                st = before[++i];
                while ((st === null || st === void 0 ? void 0 : st.type) === 'space') {
                    offset += st.source.length;
                    st = before[++i];
                }
                break;
            }
        }
        return offset;
    }

    const CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
        const { spaceBefore, comment, anchor, tag } = props;
        let node;
        switch (token.type) {
            case 'alias':
                node = composeAlias(ctx, token, onError);
                if (anchor || tag)
                    onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
                break;
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
            case 'block-scalar':
                node = composeScalar(ctx, token, tag, onError);
                if (anchor)
                    node.anchor = anchor.source.substring(1);
                break;
            case 'block-map':
            case 'block-seq':
            case 'flow-collection':
                node = composeCollection(CN, ctx, token, tag, onError);
                if (anchor)
                    node.anchor = anchor.source.substring(1);
                break;
            default:
                console.log(token);
                throw new Error(`Unsupporten token type: ${token.type}`);
        }
        if (spaceBefore)
            node.spaceBefore = true;
        if (comment) {
            if (token.type === 'scalar' && token.source === '')
                node.comment = comment;
            else
                node.commentBefore = comment;
        }
        return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
        const token = {
            type: 'scalar',
            offset: emptyScalarPosition(offset, before, pos),
            indent: -1,
            source: ''
        };
        const node = composeScalar(ctx, token, tag, onError);
        if (anchor)
            node.anchor = anchor.source.substring(1);
        if (spaceBefore)
            node.spaceBefore = true;
        if (comment)
            node.comment = comment;
        return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
        const alias = new Alias(source.substring(1));
        const valueEnd = offset + source.length;
        const re = resolveEnd(end, valueEnd, options.strict, onError);
        alias.range = [offset, valueEnd, re.offset];
        if (re.comment)
            alias.comment = re.comment;
        return alias;
    }

    function composeDoc(options, directives, { offset, start, value, end }, onError) {
        const opts = Object.assign({ directives }, options);
        const doc = new Document$1(undefined, opts);
        const ctx = {
            directives: doc.directives,
            options: doc.options,
            schema: doc.schema
        };
        const props = resolveProps(start, {
            indicator: 'doc-start',
            next: value || (end === null || end === void 0 ? void 0 : end[0]),
            offset,
            onError,
            startOnNewline: true
        });
        if (props.found) {
            doc.directives.marker = true;
            if (value &&
                (value.type === 'block-map' || value.type === 'block-seq') &&
                !props.hasNewline)
                onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
        }
        doc.contents = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        const contentEnd = doc.contents.range[2];
        const re = resolveEnd(end, contentEnd, false, onError);
        if (re.comment)
            doc.comment = re.comment;
        doc.range = [offset, contentEnd, re.offset];
        return doc;
    }

    function getErrorPos(src) {
        if (typeof src === 'number')
            return [src, src + 1];
        if (Array.isArray(src))
            return src.length === 2 ? src : [src[0], src[1]];
        const { offset, source } = src;
        return [offset, offset + (typeof source === 'string' ? source.length : 1)];
    }
    function parsePrelude(prelude) {
        let comment = '';
        let atComment = false;
        let afterEmptyLine = false;
        for (let i = 0; i < prelude.length; ++i) {
            const source = prelude[i];
            switch (source[0]) {
                case '#':
                    comment +=
                        (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                            (source.substring(1) || ' ');
                    atComment = true;
                    afterEmptyLine = false;
                    break;
                case '%':
                    if (prelude[i + 1][0] !== '#')
                        i += 1;
                    atComment = false;
                    break;
                default:
                    // This may be wrong after doc-end, but in that case it doesn't matter
                    if (!atComment)
                        afterEmptyLine = true;
                    atComment = false;
            }
        }
        return { comment, afterEmptyLine };
    }
    /**
     * Compose a stream of CST nodes into a stream of YAML Documents.
     *
     * ```ts
     * import { Composer, Parser } from 'yaml'
     *
     * const src: string = ...
     * const tokens = new Parser().parse(src)
     * const docs = new Composer().compose(tokens)
     * ```
     */
    class Composer {
        constructor(options = {}) {
            this.doc = null;
            this.atDirectives = false;
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
            this.onError = (source, code, message, warning) => {
                const pos = getErrorPos(source);
                if (warning)
                    this.warnings.push(new YAMLWarning(pos, code, message));
                else
                    this.errors.push(new YAMLParseError(pos, code, message));
            };
            this.directives = new Directives({
                version: options.version || defaultOptions.version
            });
            this.options = options;
        }
        decorate(doc, afterDoc) {
            const { comment, afterEmptyLine } = parsePrelude(this.prelude);
            //console.log({ dc: doc.comment, prelude, comment })
            if (comment) {
                const dc = doc.contents;
                if (afterDoc) {
                    doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
                }
                else if (afterEmptyLine || doc.directives.marker || !dc) {
                    doc.commentBefore = comment;
                }
                else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
                    let it = dc.items[0];
                    if (isPair(it))
                        it = it.key;
                    const cb = it.commentBefore;
                    it.commentBefore = cb ? `${comment}\n${cb}` : comment;
                }
                else {
                    const cb = dc.commentBefore;
                    dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
                }
            }
            if (afterDoc) {
                Array.prototype.push.apply(doc.errors, this.errors);
                Array.prototype.push.apply(doc.warnings, this.warnings);
            }
            else {
                doc.errors = this.errors;
                doc.warnings = this.warnings;
            }
            this.prelude = [];
            this.errors = [];
            this.warnings = [];
        }
        /**
         * Current stream status information.
         *
         * Mostly useful at the end of input for an empty stream.
         */
        streamInfo() {
            return {
                comment: parsePrelude(this.prelude).comment,
                directives: this.directives,
                errors: this.errors,
                warnings: this.warnings
            };
        }
        /**
         * Compose tokens into documents.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
        *compose(tokens, forceDoc = false, endOffset = -1) {
            for (const token of tokens)
                yield* this.next(token);
            yield* this.end(forceDoc, endOffset);
        }
        /** Advance the composer by one CST token. */
        *next(token) {
            switch (token.type) {
                case 'directive':
                    this.directives.add(token.source, (offset, message, warning) => {
                        const pos = getErrorPos(token);
                        pos[0] += offset;
                        this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                    });
                    this.prelude.push(token.source);
                    this.atDirectives = true;
                    break;
                case 'document': {
                    const doc = composeDoc(this.options, this.directives, token, this.onError);
                    if (this.atDirectives && !doc.directives.marker)
                        this.onError(token, 'MISSING_CHAR', 'Missing directives-end indicator line');
                    this.decorate(doc, false);
                    if (this.doc)
                        yield this.doc;
                    this.doc = doc;
                    this.atDirectives = false;
                    break;
                }
                case 'byte-order-mark':
                case 'space':
                    break;
                case 'comment':
                case 'newline':
                    this.prelude.push(token.source);
                    break;
                case 'error': {
                    const msg = token.source
                        ? `${token.message}: ${JSON.stringify(token.source)}`
                        : token.message;
                    const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                    if (this.atDirectives || !this.doc)
                        this.errors.push(error);
                    else
                        this.doc.errors.push(error);
                    break;
                }
                case 'doc-end': {
                    if (!this.doc) {
                        const msg = 'Unexpected doc-end without preceding document';
                        this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                        break;
                    }
                    const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                    this.decorate(this.doc, true);
                    if (end.comment) {
                        const dc = this.doc.comment;
                        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                    }
                    this.doc.range[2] = end.offset;
                    break;
                }
                default:
                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
            }
        }
        /**
         * Call at end of input to yield any remaining document.
         *
         * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
         * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
         */
        *end(forceDoc = false, endOffset = -1) {
            if (this.doc) {
                this.decorate(this.doc, true);
                yield this.doc;
                this.doc = null;
            }
            else if (forceDoc) {
                const opts = Object.assign({ directives: this.directives }, this.options);
                const doc = new Document$1(undefined, opts);
                if (this.atDirectives)
                    this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
                doc.range = [0, endOffset, endOffset];
                this.decorate(doc, false);
                yield doc;
            }
        }
    }

    /** The byte order mark */
    const BOM = '\u{FEFF}';
    /** Start of doc-mode */
    const DOCUMENT = '\x02'; // C0: Start of Text
    /** Unexpected end of flow-mode */
    const FLOW_END = '\x18'; // C0: Cancel
    /** Next token is a scalar value */
    const SCALAR = '\x1f'; // C0: Unit Separator
    /** Identify the type of a lexer token. May return `null` for unknown tokens. */
    function tokenType(source) {
        switch (source) {
            case BOM:
                return 'byte-order-mark';
            case DOCUMENT:
                return 'doc-mode';
            case FLOW_END:
                return 'flow-error-end';
            case SCALAR:
                return 'scalar';
            case '---':
                return 'doc-start';
            case '...':
                return 'doc-end';
            case '':
            case '\n':
            case '\r\n':
                return 'newline';
            case '-':
                return 'seq-item-ind';
            case '?':
                return 'explicit-key-ind';
            case ':':
                return 'map-value-ind';
            case '{':
                return 'flow-map-start';
            case '}':
                return 'flow-map-end';
            case '[':
                return 'flow-seq-start';
            case ']':
                return 'flow-seq-end';
            case ',':
                return 'comma';
        }
        switch (source[0]) {
            case ' ':
            case '\t':
                return 'space';
            case '#':
                return 'comment';
            case '%':
                return 'directive-line';
            case '*':
                return 'alias';
            case '&':
                return 'anchor';
            case '!':
                return 'tag';
            case "'":
                return 'single-quoted-scalar';
            case '"':
                return 'double-quoted-scalar';
            case '|':
            case '>':
                return 'block-scalar-header';
        }
        return null;
    }

    /*
    START -> stream

    stream
      directive -> line-end -> stream
      indent + line-end -> stream
      [else] -> line-start

    line-end
      comment -> line-end
      newline -> .
      input-end -> END

    line-start
      doc-start -> doc
      doc-end -> stream
      [else] -> indent -> block-start

    block-start
      seq-item-start -> block-start
      explicit-key-start -> block-start
      map-value-start -> block-start
      [else] -> doc

    doc
      line-end -> line-start
      spaces -> doc
      anchor -> doc
      tag -> doc
      flow-start -> flow -> doc
      flow-end -> error -> doc
      seq-item-start -> error -> doc
      explicit-key-start -> error -> doc
      map-value-start -> doc
      alias -> doc
      quote-start -> quoted-scalar -> doc
      block-scalar-header -> line-end -> block-scalar(min) -> line-start
      [else] -> plain-scalar(false, min) -> doc

    flow
      line-end -> flow
      spaces -> flow
      anchor -> flow
      tag -> flow
      flow-start -> flow -> flow
      flow-end -> .
      seq-item-start -> error -> flow
      explicit-key-start -> flow
      map-value-start -> flow
      alias -> flow
      quote-start -> quoted-scalar -> flow
      comma -> flow
      [else] -> plain-scalar(true, 0) -> flow

    quoted-scalar
      quote-end -> .
      [else] -> quoted-scalar

    block-scalar(min)
      newline + peek(indent < min) -> .
      [else] -> block-scalar(min)

    plain-scalar(is-flow, min)
      scalar-end(is-flow) -> .
      peek(newline + (indent < min)) -> .
      [else] -> plain-scalar(min)
    */
    function isEmpty(ch) {
        switch (ch) {
            case undefined:
            case ' ':
            case '\n':
            case '\r':
            case '\t':
                return true;
            default:
                return false;
        }
    }
    const invalidFlowScalarChars = [',', '[', ']', '{', '}'];
    const invalidIdentifierChars = [' ', ',', '[', ']', '{', '}', '\n', '\r', '\t'];
    const isNotIdentifierChar = (ch) => !ch || invalidIdentifierChars.includes(ch);
    /**
     * Splits an input string into lexical tokens, i.e. smaller strings that are
     * easily identifiable by `tokens.tokenType()`.
     *
     * Lexing starts always in a "stream" context. Incomplete input may be buffered
     * until a complete token can be emitted.
     *
     * In addition to slices of the original input, the following control characters
     * may also be emitted:
     *
     * - `\x02` (Start of Text): A document starts with the next token
     * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
     * - `\x1f` (Unit Separator): Next token is a scalar value
     * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
     */
    class Lexer {
        constructor() {
            /**
             * Flag indicating whether the end of the current buffer marks the end of
             * all input
             */
            this.atEnd = false;
            /**
             * Explicit indent set in block scalar header, as an offset from the current
             * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
             * explicitly set.
             */
            this.blockScalarIndent = -1;
            /**
             * Block scalars that include a + (keep) chomping indicator in their header
             * include trailing empty lines, which are otherwise excluded from the
             * scalar's contents.
             */
            this.blockScalarKeep = false;
            /** Current input */
            this.buffer = '';
            /**
             * Flag noting whether the map value indicator : can immediately follow this
             * node within a flow context.
             */
            this.flowKey = false;
            /** Count of surrounding flow collection levels. */
            this.flowLevel = 0;
            /**
             * Minimum level of indentation required for next lines to be parsed as a
             * part of the current scalar value.
             */
            this.indentNext = 0;
            /** Indentation level of the current line. */
            this.indentValue = 0;
            /** Stores the state of the lexer if reaching the end of incpomplete input */
            this.next = null;
            /** A pointer to `buffer`; the current position of the lexer. */
            this.pos = 0;
        }
        /**
         * Generate YAML tokens from the `source` string. If `incomplete`,
         * a part of the last line may be left as a buffer for the next call.
         *
         * @returns A generator of lexical tokens
         */
        *lex(source, incomplete = false) {
            if (source)
                this.buffer = this.buffer ? this.buffer + source : source;
            this.atEnd = !incomplete;
            let next = this.next || 'stream';
            while (next && (incomplete || this.hasChars(1)))
                next = yield* this.parseNext(next);
        }
        atLineEnd() {
            let i = this.pos;
            let ch = this.buffer[i];
            while (ch === ' ' || ch === '\t')
                ch = this.buffer[++i];
            if (!ch || ch === '#' || ch === '\n')
                return true;
            if (ch === '\r')
                return this.buffer[i + 1] === '\n';
            return false;
        }
        charAt(n) {
            return this.buffer[this.pos + n];
        }
        continueScalar(offset) {
            let ch = this.buffer[offset];
            if (this.indentNext > 0) {
                let indent = 0;
                while (ch === ' ')
                    ch = this.buffer[++indent + offset];
                if (ch === '\r') {
                    const next = this.buffer[indent + offset + 1];
                    if (next === '\n' || (!next && !this.atEnd))
                        return offset + indent + 1;
                }
                return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                    ? offset + indent
                    : -1;
            }
            if (ch === '-' || ch === '.') {
                const dt = this.buffer.substr(offset, 3);
                if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                    return -1;
            }
            return offset;
        }
        getLine() {
            let end = this.buffer.indexOf('\n', this.pos);
            if (end === -1)
                return this.atEnd ? this.buffer.substring(this.pos) : null;
            if (this.buffer[end - 1] === '\r')
                end -= 1;
            return this.buffer.substring(this.pos, end);
        }
        hasChars(n) {
            return this.pos + n <= this.buffer.length;
        }
        setNext(state) {
            this.buffer = this.buffer.substring(this.pos);
            this.pos = 0;
            this.next = state;
            return null;
        }
        peek(n) {
            return this.buffer.substr(this.pos, n);
        }
        *parseNext(next) {
            switch (next) {
                case 'stream':
                    return yield* this.parseStream();
                case 'line-start':
                    return yield* this.parseLineStart();
                case 'block-start':
                    return yield* this.parseBlockStart();
                case 'doc':
                    return yield* this.parseDocument();
                case 'flow':
                    return yield* this.parseFlowCollection();
                case 'quoted-scalar':
                    return yield* this.parseQuotedScalar();
                case 'block-scalar':
                    return yield* this.parseBlockScalar();
                case 'plain-scalar':
                    return yield* this.parsePlainScalar();
            }
        }
        *parseStream() {
            let line = this.getLine();
            if (line === null)
                return this.setNext('stream');
            if (line[0] === BOM) {
                yield* this.pushCount(1);
                line = line.substring(1);
            }
            if (line[0] === '%') {
                let dirEnd = line.length;
                const cs = line.indexOf('#');
                if (cs !== -1) {
                    const ch = line[cs - 1];
                    if (ch === ' ' || ch === '\t')
                        dirEnd = cs - 1;
                }
                while (true) {
                    const ch = line[dirEnd - 1];
                    if (ch === ' ' || ch === '\t')
                        dirEnd -= 1;
                    else
                        break;
                }
                const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
                yield* this.pushCount(line.length - n); // possible comment
                this.pushNewline();
                return 'stream';
            }
            if (this.atLineEnd()) {
                const sp = yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - sp);
                yield* this.pushNewline();
                return 'stream';
            }
            yield DOCUMENT;
            return yield* this.parseLineStart();
        }
        *parseLineStart() {
            const ch = this.charAt(0);
            if (!ch && !this.atEnd)
                return this.setNext('line-start');
            if (ch === '-' || ch === '.') {
                if (!this.atEnd && !this.hasChars(4))
                    return this.setNext('line-start');
                const s = this.peek(3);
                if (s === '---' && isEmpty(this.charAt(3))) {
                    yield* this.pushCount(3);
                    this.indentValue = 0;
                    this.indentNext = 0;
                    return 'doc';
                }
                else if (s === '...' && isEmpty(this.charAt(3))) {
                    yield* this.pushCount(3);
                    return 'stream';
                }
            }
            this.indentValue = yield* this.pushSpaces(false);
            if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
                this.indentNext = this.indentValue;
            return yield* this.parseBlockStart();
        }
        *parseBlockStart() {
            const [ch0, ch1] = this.peek(2);
            if (!ch1 && !this.atEnd)
                return this.setNext('block-start');
            if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
                const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
                this.indentNext = this.indentValue + 1;
                this.indentValue += n;
                return yield* this.parseBlockStart();
            }
            return 'doc';
        }
        *parseDocument() {
            yield* this.pushSpaces(true);
            const line = this.getLine();
            if (line === null)
                return this.setNext('doc');
            let n = yield* this.pushIndicators();
            switch (line[n]) {
                case '#':
                    yield* this.pushCount(line.length - n);
                // fallthrough
                case undefined:
                    yield* this.pushNewline();
                    return yield* this.parseLineStart();
                case '{':
                case '[':
                    yield* this.pushCount(1);
                    this.flowKey = false;
                    this.flowLevel = 1;
                    return 'flow';
                case '}':
                case ']':
                    // this is an error
                    yield* this.pushCount(1);
                    return 'doc';
                case '*':
                    yield* this.pushUntil(isNotIdentifierChar);
                    return 'doc';
                case '"':
                case "'":
                    return yield* this.parseQuotedScalar();
                case '|':
                case '>':
                    n += yield* this.parseBlockScalarHeader();
                    n += yield* this.pushSpaces(true);
                    yield* this.pushCount(line.length - n);
                    yield* this.pushNewline();
                    return yield* this.parseBlockScalar();
                default:
                    return yield* this.parsePlainScalar();
            }
        }
        *parseFlowCollection() {
            let nl, sp;
            let indent = -1;
            do {
                nl = yield* this.pushNewline();
                sp = yield* this.pushSpaces(true);
                if (nl > 0)
                    this.indentValue = indent = sp;
            } while (nl + sp > 0);
            const line = this.getLine();
            if (line === null)
                return this.setNext('flow');
            if ((indent !== -1 && indent < this.indentNext) ||
                (indent === 0 &&
                    (line.startsWith('---') || line.startsWith('...')) &&
                    isEmpty(line[3]))) {
                // Allowing for the terminal ] or } at the same (rather than greater)
                // indent level as the initial [ or { is technically invalid, but
                // failing here would be surprising to users.
                const atFlowEndMarker = indent === this.indentNext - 1 &&
                    this.flowLevel === 1 &&
                    (line[0] === ']' || line[0] === '}');
                if (!atFlowEndMarker) {
                    // this is an error
                    this.flowLevel = 0;
                    yield FLOW_END;
                    return yield* this.parseLineStart();
                }
            }
            let n = 0;
            while (line[n] === ',')
                n += (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            n += yield* this.pushIndicators();
            switch (line[n]) {
                case undefined:
                    return 'flow';
                case '#':
                    yield* this.pushCount(line.length - n);
                    return 'flow';
                case '{':
                case '[':
                    yield* this.pushCount(1);
                    this.flowKey = false;
                    this.flowLevel += 1;
                    return 'flow';
                case '}':
                case ']':
                    yield* this.pushCount(1);
                    this.flowKey = true;
                    this.flowLevel -= 1;
                    return this.flowLevel ? 'flow' : 'doc';
                case '*':
                    yield* this.pushUntil(isNotIdentifierChar);
                    return 'flow';
                case '"':
                case "'":
                    this.flowKey = true;
                    return yield* this.parseQuotedScalar();
                case ':': {
                    const next = this.charAt(1);
                    if (this.flowKey || isEmpty(next) || next === ',') {
                        yield* this.pushCount(1);
                        yield* this.pushSpaces(true);
                        return 'flow';
                    }
                }
                // fallthrough
                default:
                    this.flowKey = false;
                    return yield* this.parsePlainScalar();
            }
        }
        *parseQuotedScalar() {
            const quote = this.charAt(0);
            let end = this.buffer.indexOf(quote, this.pos + 1);
            if (quote === "'") {
                while (end !== -1 && this.buffer[end + 1] === "'")
                    end = this.buffer.indexOf("'", end + 2);
            }
            else {
                // double-quote
                while (end !== -1) {
                    let n = 0;
                    while (this.buffer[end - 1 - n] === '\\')
                        n += 1;
                    if (n % 2 === 0)
                        break;
                    end = this.buffer.indexOf('"', end + 1);
                }
            }
            let nl = this.buffer.indexOf('\n', this.pos);
            if (nl !== -1 && nl < end) {
                while (nl !== -1 && nl < end) {
                    const cs = this.continueScalar(nl + 1);
                    if (cs === -1)
                        break;
                    nl = this.buffer.indexOf('\n', cs);
                }
                if (nl !== -1 && nl < end) {
                    // this is an error caused by an unexpected unindent
                    end = nl - 1;
                }
            }
            if (end === -1) {
                if (!this.atEnd)
                    return this.setNext('quoted-scalar');
                end = this.buffer.length;
            }
            yield* this.pushToIndex(end + 1, false);
            return this.flowLevel ? 'flow' : 'doc';
        }
        *parseBlockScalarHeader() {
            this.blockScalarIndent = -1;
            this.blockScalarKeep = false;
            let i = this.pos;
            while (true) {
                const ch = this.buffer[++i];
                if (ch === '+')
                    this.blockScalarKeep = true;
                else if (ch > '0' && ch <= '9')
                    this.blockScalarIndent = Number(ch) - 1;
                else if (ch !== '-')
                    break;
            }
            return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
        }
        *parseBlockScalar() {
            let nl = this.pos - 1; // may be -1 if this.pos === 0
            let indent = 0;
            let ch;
            loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
                switch (ch) {
                    case ' ':
                        indent += 1;
                        break;
                    case '\n':
                        nl = i;
                        indent = 0;
                        break;
                    case '\r': {
                        const next = this.buffer[i + 1];
                        if (!next && !this.atEnd)
                            return this.setNext('block-scalar');
                        if (next === '\n')
                            break;
                    } // fallthrough
                    default:
                        break loop;
                }
            }
            if (!ch && !this.atEnd)
                return this.setNext('block-scalar');
            if (indent >= this.indentNext) {
                if (this.blockScalarIndent === -1)
                    this.indentNext = indent;
                else
                    this.indentNext += this.blockScalarIndent;
                do {
                    const cs = this.continueScalar(nl + 1);
                    if (cs === -1)
                        break;
                    nl = this.buffer.indexOf('\n', cs);
                } while (nl !== -1);
                if (nl === -1) {
                    if (!this.atEnd)
                        return this.setNext('block-scalar');
                    nl = this.buffer.length;
                }
            }
            if (!this.blockScalarKeep) {
                do {
                    let i = nl - 1;
                    let ch = this.buffer[i];
                    if (ch === '\r')
                        ch = this.buffer[--i];
                    while (ch === ' ' || ch === '\t')
                        ch = this.buffer[--i];
                    if (ch === '\n' && i >= this.pos)
                        nl = i;
                    else
                        break;
                } while (true);
            }
            yield SCALAR;
            yield* this.pushToIndex(nl + 1, true);
            return yield* this.parseLineStart();
        }
        *parsePlainScalar() {
            const inFlow = this.flowLevel > 0;
            let end = this.pos - 1;
            let i = this.pos - 1;
            let ch;
            while ((ch = this.buffer[++i])) {
                if (ch === ':') {
                    const next = this.buffer[i + 1];
                    if (isEmpty(next) || (inFlow && next === ','))
                        break;
                    end = i;
                }
                else if (isEmpty(ch)) {
                    const next = this.buffer[i + 1];
                    if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                        break;
                    if (ch === '\r') {
                        if (next === '\n') {
                            i += 1;
                            ch = '\n';
                        }
                        else
                            end = i;
                    }
                    if (ch === '\n') {
                        const cs = this.continueScalar(i + 1);
                        if (cs === -1)
                            break;
                        i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                    }
                }
                else {
                    if (inFlow && invalidFlowScalarChars.includes(ch))
                        break;
                    end = i;
                }
            }
            if (!ch && !this.atEnd)
                return this.setNext('plain-scalar');
            yield SCALAR;
            yield* this.pushToIndex(end + 1, true);
            return inFlow ? 'flow' : 'doc';
        }
        *pushCount(n) {
            if (n > 0) {
                yield this.buffer.substr(this.pos, n);
                this.pos += n;
                return n;
            }
            return 0;
        }
        *pushToIndex(i, allowEmpty) {
            const s = this.buffer.slice(this.pos, i);
            if (s) {
                yield s;
                this.pos += s.length;
                return s.length;
            }
            else if (allowEmpty)
                yield '';
            return 0;
        }
        *pushIndicators() {
            switch (this.charAt(0)) {
                case '!':
                    if (this.charAt(1) === '<')
                        return ((yield* this.pushVerbatimTag()) +
                            (yield* this.pushSpaces(true)) +
                            (yield* this.pushIndicators()));
                // fallthrough
                case '&':
                    return ((yield* this.pushUntil(isNotIdentifierChar)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                case ':':
                case '?': // this is an error outside flow collections
                case '-': // this is an error
                    if (isEmpty(this.charAt(1))) {
                        if (this.flowLevel === 0)
                            this.indentNext = this.indentValue + 1;
                        return ((yield* this.pushCount(1)) +
                            (yield* this.pushSpaces(true)) +
                            (yield* this.pushIndicators()));
                    }
            }
            return 0;
        }
        *pushVerbatimTag() {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        *pushNewline() {
            const ch = this.buffer[this.pos];
            if (ch === '\n')
                return yield* this.pushCount(1);
            else if (ch === '\r' && this.charAt(1) === '\n')
                return yield* this.pushCount(2);
            else
                return 0;
        }
        *pushSpaces(allowTabs) {
            let i = this.pos - 1;
            let ch;
            do {
                ch = this.buffer[++i];
            } while (ch === ' ' || (allowTabs && ch === '\t'));
            const n = i - this.pos;
            if (n > 0) {
                yield this.buffer.substr(this.pos, n);
                this.pos = i;
            }
            return n;
        }
        *pushUntil(test) {
            let i = this.pos;
            let ch = this.buffer[i];
            while (!test(ch))
                ch = this.buffer[++i];
            return yield* this.pushToIndex(i, false);
        }
    }

    /**
     * Tracks newlines during parsing in order to provide an efficient API for
     * determining the one-indexed `{ line, col }` position for any offset
     * within the input.
     */
    class LineCounter {
        constructor() {
            this.lineStarts = [];
            /**
             * Should be called in ascending order. Otherwise, call
             * `lineCounter.lineStarts.sort()` before calling `linePos()`.
             */
            this.addNewLine = (offset) => this.lineStarts.push(offset);
            /**
             * Performs a binary search and returns the 1-indexed { line, col }
             * position of `offset`. If `line === 0`, `addNewLine` has never been
             * called or `offset` is before the first known newline.
             */
            this.linePos = (offset) => {
                let low = 0;
                let high = this.lineStarts.length;
                while (low < high) {
                    const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                    if (this.lineStarts[mid] < offset)
                        low = mid + 1;
                    else
                        high = mid;
                }
                if (this.lineStarts[low] === offset)
                    return { line: low + 1, col: 1 };
                if (low === 0)
                    return { line: 0, col: offset };
                const start = this.lineStarts[low - 1];
                return { line: low, col: offset - start + 1 };
            };
        }
    }

    function includesToken(list, type) {
        for (let i = 0; i < list.length; ++i)
            if (list[i].type === type)
                return true;
        return false;
    }
    function includesNonEmpty(list) {
        for (let i = 0; i < list.length; ++i) {
            switch (list[i].type) {
                case 'space':
                case 'comment':
                case 'newline':
                    break;
                default:
                    return true;
            }
        }
        return false;
    }
    function isFlowToken(token) {
        switch (token === null || token === void 0 ? void 0 : token.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
            case 'flow-collection':
                return true;
            default:
                return false;
        }
    }
    function getPrevProps(parent) {
        switch (parent.type) {
            case 'document':
                return parent.start;
            case 'block-map': {
                const it = parent.items[parent.items.length - 1];
                return it.sep || it.start;
            }
            case 'block-seq':
                return parent.items[parent.items.length - 1].start;
            /* istanbul ignore next should not happen */
            default:
                return [];
        }
    }
    /** Note: May modify input array */
    function getFirstKeyStartProps(prev) {
        var _a;
        if (prev.length === 0)
            return [];
        let i = prev.length;
        loop: while (--i >= 0) {
            switch (prev[i].type) {
                case 'doc-start':
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                case 'newline':
                    break loop;
            }
        }
        while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === 'space') {
            /* loop */
        }
        return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
        if (fc.start.type === 'flow-seq-start') {
            for (const it of fc.items) {
                if (it.sep &&
                    !it.value &&
                    !includesToken(it.start, 'explicit-key-ind') &&
                    !includesToken(it.sep, 'map-value-ind')) {
                    if (it.key)
                        it.value = it.key;
                    delete it.key;
                    if (isFlowToken(it.value)) {
                        if (it.value.end)
                            Array.prototype.push.apply(it.value.end, it.sep);
                        else
                            it.value.end = it.sep;
                    }
                    else
                        Array.prototype.push.apply(it.start, it.sep);
                    delete it.sep;
                }
            }
        }
    }
    /**
     * A YAML concrete syntax tree (CST) parser
     *
     * ```ts
     * const src: string = ...
     * for (const token of new Parser().parse(src)) {
     *   // token: Token
     * }
     * ```
     *
     * To use the parser with a user-provided lexer:
     *
     * ```ts
     * function* parse(source: string, lexer: Lexer) {
     *   const parser = new Parser()
     *   for (const lexeme of lexer.lex(source))
     *     yield* parser.next(lexeme)
     *   yield* parser.end()
     * }
     *
     * const src: string = ...
     * const lexer = new Lexer()
     * for (const token of parse(src, lexer)) {
     *   // token: Token
     * }
     * ```
     */
    class Parser {
        /**
         * @param onNewLine - If defined, called separately with the start position of
         *   each new line (in `parse()`, including the start of input).
         */
        constructor(onNewLine) {
            /** If true, space and sequence indicators count as indentation */
            this.atNewLine = true;
            /** If true, next token is a scalar value */
            this.atScalar = false;
            /** Current indentation level */
            this.indent = 0;
            /** Current offset since the start of parsing */
            this.offset = 0;
            /** On the same line with a block map key */
            this.onKeyLine = false;
            /** Top indicates the node that's currently being built */
            this.stack = [];
            /** The source of the current token, set in parse() */
            this.source = '';
            /** The type of the current token, set in parse() */
            this.type = '';
            // Must be defined after `next()`
            this.lexer = new Lexer();
            this.onNewLine = onNewLine;
        }
        /**
         * Parse `source` as a YAML stream.
         * If `incomplete`, a part of the last line may be left as a buffer for the next call.
         *
         * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
         *
         * @returns A generator of tokens representing each directive, document, and other structure.
         */
        *parse(source, incomplete = false) {
            if (this.onNewLine && this.offset === 0)
                this.onNewLine(0);
            for (const lexeme of this.lexer.lex(source, incomplete))
                yield* this.next(lexeme);
            if (!incomplete)
                yield* this.end();
        }
        /**
         * Advance the parser by the `source` of one lexical token.
         */
        *next(source) {
            this.source = source;
            if (this.atScalar) {
                this.atScalar = false;
                yield* this.step();
                this.offset += source.length;
                return;
            }
            const type = tokenType(source);
            if (!type) {
                const message = `Not a YAML token: ${source}`;
                yield* this.pop({ type: 'error', offset: this.offset, message, source });
                this.offset += source.length;
            }
            else if (type === 'scalar') {
                this.atNewLine = false;
                this.atScalar = true;
                this.type = 'scalar';
            }
            else {
                this.type = type;
                yield* this.step();
                switch (type) {
                    case 'newline':
                        this.atNewLine = true;
                        this.indent = 0;
                        if (this.onNewLine)
                            this.onNewLine(this.offset + source.length);
                        break;
                    case 'space':
                        if (this.atNewLine && source[0] === ' ')
                            this.indent += source.length;
                        break;
                    case 'explicit-key-ind':
                    case 'map-value-ind':
                    case 'seq-item-ind':
                        if (this.atNewLine)
                            this.indent += source.length;
                        break;
                    case 'doc-mode':
                        return;
                    default:
                        this.atNewLine = false;
                }
                this.offset += source.length;
            }
        }
        /** Call at end of input to push out any remaining constructions */
        *end() {
            while (this.stack.length > 0)
                yield* this.pop();
        }
        get sourceToken() {
            const st = {
                type: this.type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            };
            return st;
        }
        *step() {
            const top = this.peek(1);
            if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
                while (this.stack.length > 0)
                    yield* this.pop();
                this.stack.push({
                    type: 'doc-end',
                    offset: this.offset,
                    source: this.source
                });
                return;
            }
            if (!top)
                return yield* this.stream();
            switch (top.type) {
                case 'document':
                    return yield* this.document(top);
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar':
                    return yield* this.scalar(top);
                case 'block-scalar':
                    return yield* this.blockScalar(top);
                case 'block-map':
                    return yield* this.blockMap(top);
                case 'block-seq':
                    return yield* this.blockSequence(top);
                case 'flow-collection':
                    return yield* this.flowCollection(top);
                case 'doc-end':
                    return yield* this.documentEnd(top);
            }
            /* istanbul ignore next should not happen */
            yield* this.pop();
        }
        peek(n) {
            return this.stack[this.stack.length - n];
        }
        *pop(error) {
            const token = error || this.stack.pop();
            /* istanbul ignore if should not happen */
            if (!token) {
                const message = 'Tried to pop an empty stack';
                yield { type: 'error', offset: this.offset, source: '', message };
            }
            else if (this.stack.length === 0) {
                yield token;
            }
            else {
                const top = this.peek(1);
                // For these, parent indent is needed instead of own
                if (token.type === 'block-scalar' || token.type === 'flow-collection')
                    token.indent = 'indent' in top ? top.indent : -1;
                if (token.type === 'flow-collection')
                    fixFlowSeqItems(token);
                switch (top.type) {
                    case 'document':
                        top.value = token;
                        break;
                    case 'block-scalar':
                        top.props.push(token); // error
                        break;
                    case 'block-map': {
                        const it = top.items[top.items.length - 1];
                        if (it.value) {
                            top.items.push({ start: [], key: token, sep: [] });
                            this.onKeyLine = true;
                            return;
                        }
                        else if (it.sep) {
                            it.value = token;
                        }
                        else {
                            Object.assign(it, { key: token, sep: [] });
                            this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                            return;
                        }
                        break;
                    }
                    case 'block-seq': {
                        const it = top.items[top.items.length - 1];
                        if (it.value)
                            top.items.push({ start: [], value: token });
                        else
                            it.value = token;
                        break;
                    }
                    case 'flow-collection': {
                        const it = top.items[top.items.length - 1];
                        if (!it || it.value)
                            top.items.push({ start: [], key: token, sep: [] });
                        else if (it.sep)
                            it.value = token;
                        else
                            Object.assign(it, { key: token, sep: [] });
                        return;
                    }
                    /* istanbul ignore next should not happen */
                    default:
                        yield* this.pop();
                        yield* this.pop(token);
                }
                if ((top.type === 'document' ||
                    top.type === 'block-map' ||
                    top.type === 'block-seq') &&
                    (token.type === 'block-map' || token.type === 'block-seq')) {
                    const last = token.items[token.items.length - 1];
                    if (last &&
                        !last.sep &&
                        !last.value &&
                        last.start.length > 0 &&
                        !includesNonEmpty(last.start) &&
                        (token.indent === 0 ||
                            last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                        if (top.type === 'document')
                            top.end = last.start;
                        else
                            top.items.push({ start: last.start });
                        token.items.splice(-1, 1);
                    }
                }
            }
        }
        *stream() {
            switch (this.type) {
                case 'directive-line':
                    yield { type: 'directive', offset: this.offset, source: this.source };
                    return;
                case 'byte-order-mark':
                case 'space':
                case 'comment':
                case 'newline':
                    yield this.sourceToken;
                    return;
                case 'doc-mode':
                case 'doc-start': {
                    const doc = {
                        type: 'document',
                        offset: this.offset,
                        start: []
                    };
                    if (this.type === 'doc-start')
                        doc.start.push(this.sourceToken);
                    this.stack.push(doc);
                    return;
                }
            }
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML stream`,
                source: this.source
            };
        }
        *document(doc) {
            if (doc.value)
                return yield* this.lineEnd(doc);
            switch (this.type) {
                case 'doc-start': {
                    if (includesNonEmpty(doc.start)) {
                        yield* this.pop();
                        yield* this.step();
                    }
                    else
                        doc.start.push(this.sourceToken);
                    return;
                }
                case 'anchor':
                case 'tag':
                case 'space':
                case 'comment':
                case 'newline':
                    doc.start.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(doc);
            if (bv)
                this.stack.push(bv);
            else {
                yield {
                    type: 'error',
                    offset: this.offset,
                    message: `Unexpected ${this.type} token in YAML document`,
                    source: this.source
                };
            }
        }
        *scalar(scalar) {
            if (this.type === 'map-value-ind') {
                const prev = getPrevProps(this.peek(2));
                const start = getFirstKeyStartProps(prev);
                let sep;
                if (scalar.end) {
                    sep = scalar.end;
                    sep.push(this.sourceToken);
                    delete scalar.end;
                }
                else
                    sep = [this.sourceToken];
                const map = {
                    type: 'block-map',
                    offset: scalar.offset,
                    indent: scalar.indent,
                    items: [{ start, key: scalar, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else
                yield* this.lineEnd(scalar);
        }
        *blockScalar(scalar) {
            switch (this.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    scalar.props.push(this.sourceToken);
                    return;
                case 'scalar':
                    scalar.source = this.source;
                    // block-scalar source includes trailing newline
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine) {
                        let nl = this.source.indexOf('\n') + 1;
                        while (nl !== 0) {
                            this.onNewLine(this.offset + nl);
                            nl = this.source.indexOf('\n', nl) + 1;
                        }
                    }
                    yield* this.pop();
                    break;
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.step();
            }
        }
        *blockMap(map) {
            var _a;
            const it = map.items[map.items.length - 1];
            // it.sep is true-ish if pair already has key or : separator
            switch (this.type) {
                case 'newline':
                    this.onKeyLine = false;
                    if (it.value) {
                        const end = 'end' in it.value ? it.value.end : undefined;
                        const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                        if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')
                            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                        else
                            map.items.push({ start: [this.sourceToken] });
                    }
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'space':
                case 'comment':
                    if (it.value)
                        map.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else {
                        if (this.atIndentedComment(it.start, map.indent)) {
                            const prev = map.items[map.items.length - 2];
                            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                            if (Array.isArray(end)) {
                                Array.prototype.push.apply(end, it.start);
                                end.push(this.sourceToken);
                                map.items.pop();
                                return;
                            }
                        }
                        it.start.push(this.sourceToken);
                    }
                    return;
            }
            if (this.indent >= map.indent) {
                const atNextItem = !this.onKeyLine &&
                    this.indent === map.indent &&
                    (it.sep || includesNonEmpty(it.start));
                switch (this.type) {
                    case 'anchor':
                    case 'tag':
                        if (atNextItem || it.value) {
                            map.items.push({ start: [this.sourceToken] });
                            this.onKeyLine = true;
                        }
                        else if (it.sep)
                            it.sep.push(this.sourceToken);
                        else
                            it.start.push(this.sourceToken);
                        return;
                    case 'explicit-key-ind':
                        if (!it.sep && !includesToken(it.start, 'explicit-key-ind'))
                            it.start.push(this.sourceToken);
                        else if (atNextItem || it.value)
                            map.items.push({ start: [this.sourceToken] });
                        else
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [this.sourceToken] }]
                            });
                        this.onKeyLine = true;
                        return;
                    case 'map-value-ind':
                        if (!it.sep)
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        else if (it.value ||
                            (atNextItem && !includesToken(it.start, 'explicit-key-ind')))
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        else if (includesToken(it.sep, 'map-value-ind'))
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        else if (includesToken(it.start, 'explicit-key-ind') &&
                            isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-ignore type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else
                            it.sep.push(this.sourceToken);
                        this.onKeyLine = true;
                        return;
                    case 'alias':
                    case 'scalar':
                    case 'single-quoted-scalar':
                    case 'double-quoted-scalar': {
                        const fs = this.flowScalar(this.type);
                        if (atNextItem || it.value) {
                            map.items.push({ start: [], key: fs, sep: [] });
                            this.onKeyLine = true;
                        }
                        else if (it.sep) {
                            this.stack.push(fs);
                        }
                        else {
                            Object.assign(it, { key: fs, sep: [] });
                            this.onKeyLine = true;
                        }
                        return;
                    }
                    default: {
                        const bv = this.startBlockValue(map);
                        if (bv) {
                            if (atNextItem &&
                                bv.type !== 'block-seq' &&
                                includesToken(it.start, 'explicit-key-ind'))
                                map.items.push({ start: [] });
                            this.stack.push(bv);
                            return;
                        }
                    }
                }
            }
            yield* this.pop();
            yield* this.step();
        }
        *blockSequence(seq) {
            var _a;
            const it = seq.items[seq.items.length - 1];
            switch (this.type) {
                case 'newline':
                    if (it.value) {
                        const end = 'end' in it.value ? it.value.end : undefined;
                        const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                        if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')
                            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
                        else
                            seq.items.push({ start: [this.sourceToken] });
                    }
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'space':
                case 'comment':
                    if (it.value)
                        seq.items.push({ start: [this.sourceToken] });
                    else {
                        if (this.atIndentedComment(it.start, seq.indent)) {
                            const prev = seq.items[seq.items.length - 2];
                            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
                            if (Array.isArray(end)) {
                                Array.prototype.push.apply(end, it.start);
                                end.push(this.sourceToken);
                                seq.items.pop();
                                return;
                            }
                        }
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'anchor':
                case 'tag':
                    if (it.value || this.indent <= seq.indent)
                        break;
                    it.start.push(this.sourceToken);
                    return;
                case 'seq-item-ind':
                    if (this.indent !== seq.indent)
                        break;
                    if (it.value || includesToken(it.start, 'seq-item-ind'))
                        seq.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
            }
            if (this.indent > seq.indent) {
                const bv = this.startBlockValue(seq);
                if (bv) {
                    this.stack.push(bv);
                    return;
                }
            }
            yield* this.pop();
            yield* this.step();
        }
        *flowCollection(fc) {
            const it = fc.items[fc.items.length - 1];
            if (this.type === 'flow-error-end') {
                let top;
                do {
                    yield* this.pop();
                    top = this.peek(1);
                } while (top && top.type === 'flow-collection');
            }
            else if (fc.end.length === 0) {
                switch (this.type) {
                    case 'comma':
                    case 'explicit-key-ind':
                        if (!it || it.sep)
                            fc.items.push({ start: [this.sourceToken] });
                        else
                            it.start.push(this.sourceToken);
                        return;
                    case 'map-value-ind':
                        if (!it || it.value)
                            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        else if (it.sep)
                            it.sep.push(this.sourceToken);
                        else
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        return;
                    case 'space':
                    case 'comment':
                    case 'newline':
                    case 'anchor':
                    case 'tag':
                        if (!it || it.value)
                            fc.items.push({ start: [this.sourceToken] });
                        else if (it.sep)
                            it.sep.push(this.sourceToken);
                        else
                            it.start.push(this.sourceToken);
                        return;
                    case 'alias':
                    case 'scalar':
                    case 'single-quoted-scalar':
                    case 'double-quoted-scalar': {
                        const fs = this.flowScalar(this.type);
                        if (!it || it.value)
                            fc.items.push({ start: [], key: fs, sep: [] });
                        else if (it.sep)
                            this.stack.push(fs);
                        else
                            Object.assign(it, { key: fs, sep: [] });
                        return;
                    }
                    case 'flow-map-end':
                    case 'flow-seq-end':
                        fc.end.push(this.sourceToken);
                        return;
                }
                const bv = this.startBlockValue(fc);
                /* istanbul ignore else should not happen */
                if (bv)
                    this.stack.push(bv);
                else {
                    yield* this.pop();
                    yield* this.step();
                }
            }
            else {
                const parent = this.peek(2);
                if (parent.type === 'block-map' &&
                    (this.type === 'map-value-ind' ||
                        (this.type === 'newline' &&
                            !parent.items[parent.items.length - 1].sep))) {
                    yield* this.pop();
                    yield* this.step();
                }
                else if (this.type === 'map-value-ind' &&
                    parent.type !== 'flow-collection') {
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    fixFlowSeqItems(fc);
                    const sep = fc.end.splice(1, fc.end.length);
                    sep.push(this.sourceToken);
                    const map = {
                        type: 'block-map',
                        offset: fc.offset,
                        indent: fc.indent,
                        items: [{ start, key: fc, sep }]
                    };
                    this.onKeyLine = true;
                    this.stack[this.stack.length - 1] = map;
                }
                else {
                    yield* this.lineEnd(fc);
                }
            }
        }
        flowScalar(type) {
            if (this.onNewLine) {
                let nl = this.source.indexOf('\n') + 1;
                while (nl !== 0) {
                    this.onNewLine(this.offset + nl);
                    nl = this.source.indexOf('\n', nl) + 1;
                }
            }
            return {
                type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            };
        }
        startBlockValue(parent) {
            switch (this.type) {
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar':
                    return this.flowScalar(this.type);
                case 'block-scalar-header':
                    return {
                        type: 'block-scalar',
                        offset: this.offset,
                        indent: this.indent,
                        props: [this.sourceToken],
                        source: ''
                    };
                case 'flow-map-start':
                case 'flow-seq-start':
                    return {
                        type: 'flow-collection',
                        offset: this.offset,
                        indent: this.indent,
                        start: this.sourceToken,
                        items: [],
                        end: []
                    };
                case 'seq-item-ind':
                    return {
                        type: 'block-seq',
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start: [this.sourceToken] }]
                    };
                case 'explicit-key-ind': {
                    this.onKeyLine = true;
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    start.push(this.sourceToken);
                    return {
                        type: 'block-map',
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start }]
                    };
                }
                case 'map-value-ind': {
                    this.onKeyLine = true;
                    const prev = getPrevProps(parent);
                    const start = getFirstKeyStartProps(prev);
                    return {
                        type: 'block-map',
                        offset: this.offset,
                        indent: this.indent,
                        items: [{ start, key: null, sep: [this.sourceToken] }]
                    };
                }
            }
            return null;
        }
        atIndentedComment(start, indent) {
            if (this.type !== 'comment')
                return false;
            if (this.indent <= indent)
                return false;
            return start.every(st => st.type === 'newline' || st.type === 'space');
        }
        *documentEnd(docEnd) {
            if (this.type !== 'doc-mode') {
                if (docEnd.end)
                    docEnd.end.push(this.sourceToken);
                else
                    docEnd.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
            }
        }
        *lineEnd(token) {
            switch (this.type) {
                case 'comma':
                case 'doc-start':
                case 'doc-end':
                case 'flow-seq-end':
                case 'flow-map-end':
                case 'map-value-ind':
                    yield* this.pop();
                    yield* this.step();
                    break;
                case 'newline':
                    this.onKeyLine = false;
                // fallthrough
                case 'space':
                case 'comment':
                default:
                    // all other values are errors
                    if (token.end)
                        token.end.push(this.sourceToken);
                    else
                        token.end = [this.sourceToken];
                    if (this.type === 'newline')
                        yield* this.pop();
            }
        }
    }

    function parseOptions(options) {
        const prettyErrors = !options || options.prettyErrors !== false;
        const lineCounter = (options && options.lineCounter) ||
            (prettyErrors && new LineCounter()) ||
            null;
        return { lineCounter, prettyErrors };
    }
    /** Parse an input string into a single YAML.Document */
    function parseDocument(source, options = {}) {
        const { lineCounter, prettyErrors } = parseOptions(options);
        const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
        const composer = new Composer(options);
        // `doc` is always set by compose.end(true) at the very latest
        let doc = null;
        for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
            if (!doc)
                doc = _doc;
            else if (doc.options.logLevel !== 'silent') {
                doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
                break;
            }
        }
        if (prettyErrors && lineCounter) {
            doc.errors.forEach(prettifyError(source, lineCounter));
            doc.warnings.forEach(prettifyError(source, lineCounter));
        }
        return doc;
    }
    function parse(src, reviver, options) {
        let _reviver = undefined;
        if (typeof reviver === 'function') {
            _reviver = reviver;
        }
        else if (options === undefined && reviver && typeof reviver === 'object') {
            options = reviver;
        }
        const doc = parseDocument(src, options);
        if (!doc)
            return null;
        doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));
        if (doc.errors.length > 0) {
            if (doc.options.logLevel !== 'silent')
                throw doc.errors[0];
            else
                doc.errors = [];
        }
        return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }

    const PlanksConstant = 6.62607004e-34; // J.s
    const SpeedOfLight = 299792458; // m/s
    const boltzmanConstant = 1.38064852e-23; // in J.K-1
    const DebyeToCm = 3.336e-30; // C⋅m (for dipole moment)
    const VaccumPermitivity = 8.85418782e-12; // m-3 kg-1 s4 A2 or C2 J-1 m-1

    const amuToKG = 1.662E-27; // kg
     // C

    function balance_distribution({label, energyLevels, collisionalTemp=5, electronSpin=false, zeemanSplit=false, energyUnit="cm-1"}={}){
        // defined for excitation rate constants

        const boltzmanConstant = 1.38064852e-23; // in J.K-1
        const boltzmanConstantInWavenumber = boltzmanConstant/1.98630e-23; // in cm-1
        const KT = boltzmanConstantInWavenumber*collisionalTemp;
        
        const speedOfLight = 299792458; // in m/s
        const speedOfLightIn_cm = speedOfLight*100; // in cm/s

        try {
        
            if (energyUnit==="MHz") {
                energyLevels = energyLevels.map(({label, value, id})=>{
                    value = (value*1e6)/speedOfLightIn_cm;
                    return {label, value, id}
                });


            }

            const [initial, final] = label.split(" --> ").map(f=>f.trim());
            
            const {Gi, Gf} = computeStatisticalWeight({electronSpin, zeemanSplit, final, initial});
            const Gj = Gi/Gf;

            const energy_levels = {};
            energyLevels.forEach(f=>energy_levels[f.label]=f.value);

            const delE = Math.abs(energy_levels[initial] - energy_levels[final]);
            const energyTerm = Math.exp(-delE/KT);
            const rateConstant = Gj*energyTerm;
            // console.log(energyLevels)
            return rateConstant.toExponential(3)
        } catch (error) {
            console.error(error);
            window.createToast("Error occured", "danger");
            return null

        }

    }

    function computeStatisticalWeight({electronSpin=false, zeemanSplit=false, final, initial}={}) {

        let Gi, Gf;

        if (!zeemanSplit) {
            if (electronSpin) {

                Gi = 2*+initial.split("_")[1] + 1;
                Gf = 2*+final.split("_")[1] + 1;
            } else {
                Gi = 2*+initial + 1;
                Gf = 2*+final + 1;
            }
        } else {Gi=1, Gf=1;}
        return {Gi, Gf}

    }

    /* src\Pages\thz\components\EinsteinCoefficients.svelte generated by Svelte v3.42.1 */

    const { console: console_1$3 } = globals;
    const file$b = "src\\Pages\\thz\\components\\EinsteinCoefficients.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[16] = list[i].value;
    	child_ctx[17] = list[i].id;
    	child_ctx[18] = list;
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i].label;
    	child_ctx[16] = list[i].value;
    	child_ctx[17] = list[i].id;
    	child_ctx[20] = list;
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (105:4) {#if einsteinCoefficientA.length>0}
    function create_if_block_1$5(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value_1 = /*einsteinCoefficientA*/ ctx[0];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "content__div  svelte-1t65zux");
    			add_location(div, file$b, 106, 8, 3428);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*einsteinCoefficientA*/ 1) {
    				each_value_1 = /*einsteinCoefficientA*/ ctx[0];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$3, null, get_each_context_1$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(105:4) {#if einsteinCoefficientA.length>0}",
    		ctx
    	});

    	return block;
    }

    // (108:12) {#each einsteinCoefficientA as {label, value, id}
    function create_each_block_1$3(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[13](value, /*value*/ ctx[16], /*each_value_1*/ ctx[20], /*each_index_1*/ ctx[21]);
    	}

    	let textfield_props = { label: /*label*/ ctx[15] };

    	if (/*value*/ ctx[16] !== void 0) {
    		textfield_props.value = /*value*/ ctx[16];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*einsteinCoefficientA*/ 1) textfield_changes.label = /*label*/ ctx[15];

    			if (!updating_value && dirty & /*einsteinCoefficientA*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(108:12) {#each einsteinCoefficientA as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (120:4) {#if einsteinCoefficientB.length>0}
    function create_if_block$9(ctx) {
    	let hr;
    	let t0;
    	let div0;
    	let t2;
    	let div1;
    	let button;
    	let t4;
    	let div2;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*einsteinCoefficientB*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*id*/ ctx[17];
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Einstein B Co-efficients";
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Compute rate constants";
    			t4 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(hr, "class", "svelte-1t65zux");
    			add_location(hr, file$b, 121, 8, 3832);
    			attr_dev(div0, "class", "subtitle svelte-1t65zux");
    			add_location(div0, file$b, 122, 8, 3846);
    			attr_dev(button, "class", "button is-link ");
    			add_location(button, file$b, 125, 12, 3951);
    			attr_dev(div1, "class", "control__div  svelte-1t65zux");
    			add_location(div1, file$b, 124, 8, 3910);
    			attr_dev(div2, "class", "content__div  svelte-1t65zux");
    			add_location(div2, file$b, 128, 8, 4074);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*computeEinsteinBRate*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*einsteinCoefficientB*/ 2) {
    				each_value = /*einsteinCoefficientB*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div2, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(120:4) {#if einsteinCoefficientB.length>0}",
    		ctx
    	});

    	return block;
    }

    // (132:12) {#each einsteinCoefficientB as {label, value, id}
    function create_each_block$5(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[14](value, /*value*/ ctx[16], /*each_value*/ ctx[18], /*each_index*/ ctx[19]);
    	}

    	let textfield_props = { label: /*label*/ ctx[15] };

    	if (/*value*/ ctx[16] !== void 0) {
    		textfield_props.value = /*value*/ ctx[16];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*einsteinCoefficientB*/ 2) textfield_changes.label = /*label*/ ctx[15];

    			if (!updating_value && dirty & /*einsteinCoefficientB*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[16];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(132:12) {#each einsteinCoefficientB as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let hr;
    	let t2;
    	let div1;
    	let t4;
    	let t5;
    	let div2;
    	let button;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*einsteinCoefficientA*/ ctx[0].length > 0 && create_if_block_1$5(ctx);
    	let if_block1 = /*einsteinCoefficientB*/ ctx[1].length > 0 && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Einstein Co-efficients";
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = "Einstein A Co-efficients";
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Compute Einstein B";
    			t7 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "subtitle svelte-1t65zux");
    			add_location(div0, file$b, 101, 4, 3257);
    			attr_dev(hr, "class", "svelte-1t65zux");
    			add_location(hr, file$b, 102, 4, 3313);
    			attr_dev(div1, "class", "subtitle svelte-1t65zux");
    			add_location(div1, file$b, 103, 4, 3323);
    			attr_dev(button, "class", "button is-link ");
    			add_location(button, file$b, 116, 8, 3674);
    			attr_dev(div2, "class", "control__div  svelte-1t65zux");
    			add_location(div2, file$b, 114, 4, 3635);
    			attr_dev(div3, "class", "sub_container__div box svelte-1t65zux");
    			add_location(div3, file$b, 100, 0, 3215);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, hr);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div3, t4);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(div3, t7);
    			if (if_block1) if_block1.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*computeEinsteinB*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*einsteinCoefficientA*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*einsteinCoefficientA*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t5);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*einsteinCoefficientB*/ ctx[1].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*einsteinCoefficientB*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EinsteinCoefficients', slots, []);
    	let { einsteinCoefficientA = [], einsteinCoefficientB = [], einsteinB_rateComputed = false } = $$props;
    	let { energyLevels, electronSpin, zeemanSplit, energyUnit } = $$props;
    	let { lorrentz = 0.320, gaussian = 0.210, power = "2e-5", trapArea = "5e-5" } = $$props;

    	function computeEinsteinB() {
    		$$invalidate(4, einsteinB_rateComputed = false);

    		const einsteinCoefficientB_emission = einsteinCoefficientA.map(({ label, value }) => {
    			const [final, initial] = label.split("-->").map(l => l.trim());
    			const { value: v0 } = window._.find(energyLevels, e => e.label == initial);
    			const { value: v1 } = window._.find(energyLevels, e => e.label == final);
    			let freq = parseFloat(v1) - parseFloat(v0); // in Hz or s-1

    			energyUnit === "MHz"
    			? freq *= 1e6
    			: freq *= SpeedOfLight * 100;

    			const constTerm = SpeedOfLight ** 3 / (8 * Math.PI * PlanksConstant * freq ** 3);
    			const B = constTerm * value;

    			return {
    				label,
    				value: B.toExponential(3),
    				id: getID()
    			};
    		});

    		const einsteinCoefficientB_absorption = einsteinCoefficientB_emission.map(({ label, value }) => {
    			const [final, initial] = label.split("-->").map(l => l.trim());

    			const { Gi, Gf } = computeStatisticalWeight({
    				electronSpin,
    				zeemanSplit,
    				final,
    				initial
    			});

    			const weight = Gf / Gi;
    			const B = weight * parseFloat(value);
    			const newLabel = `${initial} --> ${final}`;

    			return {
    				label: newLabel,
    				value: B.toExponential(3),
    				id: getID()
    			};
    		});

    		$$invalidate(1, einsteinCoefficientB = [...einsteinCoefficientB_emission, ...einsteinCoefficientB_absorption]);
    	}

    	async function computeEinsteinBRate(e) {
    		const args = [JSON.stringify({ lorrentz, gaussian })];
    		console.log(args);
    		const pyfile = "ROSAA/voigt.py";

    		try {
    			const { linshape } = await computePy_func({ e, pyfile, args });
    			const constantTerm = power / (trapArea * SpeedOfLight);
    			const norm = constantTerm * linshape;
    			computeEinsteinB();

    			$$invalidate(1, einsteinCoefficientB = einsteinCoefficientB.map(e => {
    				e.value *= norm;
    				e.value = e.value.toExponential(3);
    				return e;
    			}));

    			$$invalidate(4, einsteinB_rateComputed = true);
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const writable_props = [
    		'einsteinCoefficientA',
    		'einsteinCoefficientB',
    		'einsteinB_rateComputed',
    		'energyLevels',
    		'electronSpin',
    		'zeemanSplit',
    		'energyUnit',
    		'lorrentz',
    		'gaussian',
    		'power',
    		'trapArea'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<EinsteinCoefficients> was created with unknown prop '${key}'`);
    	});

    	function textfield_value_binding(value$1, value, each_value_1, each_index_1) {
    		each_value_1[each_index_1].value = value$1;
    		$$invalidate(0, einsteinCoefficientA);
    	}

    	function textfield_value_binding_1(value$1, value, each_value, each_index) {
    		each_value[each_index].value = value$1;
    		$$invalidate(1, einsteinCoefficientB);
    	}

    	$$self.$$set = $$props => {
    		if ('einsteinCoefficientA' in $$props) $$invalidate(0, einsteinCoefficientA = $$props.einsteinCoefficientA);
    		if ('einsteinCoefficientB' in $$props) $$invalidate(1, einsteinCoefficientB = $$props.einsteinCoefficientB);
    		if ('einsteinB_rateComputed' in $$props) $$invalidate(4, einsteinB_rateComputed = $$props.einsteinB_rateComputed);
    		if ('energyLevels' in $$props) $$invalidate(5, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(6, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(7, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(8, energyUnit = $$props.energyUnit);
    		if ('lorrentz' in $$props) $$invalidate(9, lorrentz = $$props.lorrentz);
    		if ('gaussian' in $$props) $$invalidate(10, gaussian = $$props.gaussian);
    		if ('power' in $$props) $$invalidate(11, power = $$props.power);
    		if ('trapArea' in $$props) $$invalidate(12, trapArea = $$props.trapArea);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Textfield,
    		PlanksConstant,
    		SpeedOfLight,
    		computeStatisticalWeight,
    		einsteinCoefficientA,
    		einsteinCoefficientB,
    		einsteinB_rateComputed,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		lorrentz,
    		gaussian,
    		power,
    		trapArea,
    		computeEinsteinB,
    		computeEinsteinBRate
    	});

    	$$self.$inject_state = $$props => {
    		if ('einsteinCoefficientA' in $$props) $$invalidate(0, einsteinCoefficientA = $$props.einsteinCoefficientA);
    		if ('einsteinCoefficientB' in $$props) $$invalidate(1, einsteinCoefficientB = $$props.einsteinCoefficientB);
    		if ('einsteinB_rateComputed' in $$props) $$invalidate(4, einsteinB_rateComputed = $$props.einsteinB_rateComputed);
    		if ('energyLevels' in $$props) $$invalidate(5, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(6, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(7, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(8, energyUnit = $$props.energyUnit);
    		if ('lorrentz' in $$props) $$invalidate(9, lorrentz = $$props.lorrentz);
    		if ('gaussian' in $$props) $$invalidate(10, gaussian = $$props.gaussian);
    		if ('power' in $$props) $$invalidate(11, power = $$props.power);
    		if ('trapArea' in $$props) $$invalidate(12, trapArea = $$props.trapArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*einsteinCoefficientA*/ 1) {
    			if (einsteinCoefficientA) computeEinsteinB();
    		}
    	};

    	return [
    		einsteinCoefficientA,
    		einsteinCoefficientB,
    		computeEinsteinB,
    		computeEinsteinBRate,
    		einsteinB_rateComputed,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		lorrentz,
    		gaussian,
    		power,
    		trapArea,
    		textfield_value_binding,
    		textfield_value_binding_1
    	];
    }

    class EinsteinCoefficients extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			einsteinCoefficientA: 0,
    			einsteinCoefficientB: 1,
    			einsteinB_rateComputed: 4,
    			energyLevels: 5,
    			electronSpin: 6,
    			zeemanSplit: 7,
    			energyUnit: 8,
    			lorrentz: 9,
    			gaussian: 10,
    			power: 11,
    			trapArea: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EinsteinCoefficients",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*energyLevels*/ ctx[5] === undefined && !('energyLevels' in props)) {
    			console_1$3.warn("<EinsteinCoefficients> was created without expected prop 'energyLevels'");
    		}

    		if (/*electronSpin*/ ctx[6] === undefined && !('electronSpin' in props)) {
    			console_1$3.warn("<EinsteinCoefficients> was created without expected prop 'electronSpin'");
    		}

    		if (/*zeemanSplit*/ ctx[7] === undefined && !('zeemanSplit' in props)) {
    			console_1$3.warn("<EinsteinCoefficients> was created without expected prop 'zeemanSplit'");
    		}

    		if (/*energyUnit*/ ctx[8] === undefined && !('energyUnit' in props)) {
    			console_1$3.warn("<EinsteinCoefficients> was created without expected prop 'energyUnit'");
    		}
    	}

    	get einsteinCoefficientA() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set einsteinCoefficientA(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get einsteinCoefficientB() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set einsteinCoefficientB(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get einsteinB_rateComputed() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set einsteinB_rateComputed(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyLevels() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyLevels(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get electronSpin() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set electronSpin(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zeemanSplit() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zeemanSplit(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyUnit() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyUnit(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lorrentz() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lorrentz(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gaussian() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gaussian(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get power() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set power(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trapArea() {
    		throw new Error("<EinsteinCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trapArea(value) {
    		throw new Error("<EinsteinCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\thz\windows\CollisionalDistribution.svelte generated by Svelte v3.42.1 */
    const file$a = "src\\Pages\\thz\\windows\\CollisionalDistribution.svelte";

    // (79:4) <svelte:fragment slot="header_content__slot" >
    function create_header_content__slot_slot$1(ctx) {
    	let div;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let textfield2;
    	let updating_value_2;
    	let t2;
    	let textfield3;
    	let updating_value_3;
    	let t3;
    	let textfield4;
    	let updating_value_4;
    	let t4;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[14](value);
    	}

    	let textfield0_props = { label: "stepSize" };

    	if (/*stepSize*/ ctx[7] !== void 0) {
    		textfield0_props.value = /*stepSize*/ ctx[7];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[15](value);
    	}

    	let textfield1_props = {
    		label: "Initial temp (K)",
    		input$type: "number",
    		input$step: /*stepSize*/ ctx[7],
    		input$min: "0"
    	};

    	if (/*initialTemp*/ ctx[4] !== void 0) {
    		textfield1_props.value = /*initialTemp*/ ctx[4];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[16](value);
    	}

    	let textfield2_props = {
    		label: "Coll. temp (K)",
    		input$type: "number",
    		input$step: /*stepSize*/ ctx[7],
    		input$min: "0.1"
    	};

    	if (/*collisionalTemp*/ ctx[1] !== void 0) {
    		textfield2_props.value = /*collisionalTemp*/ ctx[1];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[17](value);
    	}

    	let textfield3_props = { label: "duration (in ms)" };

    	if (/*duration*/ ctx[5] !== void 0) {
    		textfield3_props.value = /*duration*/ ctx[5];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[18](value);
    	}

    	let textfield4_props = { label: "Number density (cm-3)" };

    	if (/*numberDensity*/ ctx[6] !== void 0) {
    		textfield4_props.value = /*numberDensity*/ ctx[6];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			create_component(textfield2.$$.fragment);
    			t2 = space();
    			create_component(textfield3.$$.fragment);
    			t3 = space();
    			create_component(textfield4.$$.fragment);
    			t4 = space();
    			button = element("button");
    			button.textContent = "Compute";
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$a, 86, 12, 3625);
    			attr_dev(div, "class", "header svelte-1mhcgqd");
    			add_location(div, file$a, 79, 8, 3102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(textfield0, div, null);
    			append_dev(div, t0);
    			mount_component(textfield1, div, null);
    			append_dev(div, t1);
    			mount_component(textfield2, div, null);
    			append_dev(div, t2);
    			mount_component(textfield3, div, null);
    			append_dev(div, t3);
    			mount_component(textfield4, div, null);
    			append_dev(div, t4);
    			append_dev(div, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*computeCollisionalProcess*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*stepSize*/ 128) {
    				updating_value = true;
    				textfield0_changes.value = /*stepSize*/ ctx[7];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*stepSize*/ 128) textfield1_changes.input$step = /*stepSize*/ ctx[7];

    			if (!updating_value_1 && dirty & /*initialTemp*/ 16) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*initialTemp*/ ctx[4];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};
    			if (dirty & /*stepSize*/ 128) textfield2_changes.input$step = /*stepSize*/ ctx[7];

    			if (!updating_value_2 && dirty & /*collisionalTemp*/ 2) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*collisionalTemp*/ ctx[1];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty & /*duration*/ 32) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*duration*/ ctx[5];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty & /*numberDensity*/ 64) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*numberDensity*/ ctx[6];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_content__slot_slot$1.name,
    		type: "slot",
    		source: "(79:4) <svelte:fragment slot=\\\"header_content__slot\\\" >",
    		ctx
    	});

    	return block;
    }

    // (91:4) <svelte:fragment slot="main_content__slot">
    function create_main_content__slot_slot$1(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			attr_dev(div0, "id", plotID);
    			attr_dev(div0, "class", "graph__div");
    			add_location(div0, file$a, 92, 12, 3854);
    			attr_dev(div1, "id", "" + (plotID + "_collisionalBoltzman"));
    			attr_dev(div1, "class", "graph__div");
    			add_location(div1, file$a, 94, 12, 3914);
    			attr_dev(div2, "id", "" + (plotID + "_collisionalBoltzman_difference"));
    			attr_dev(div2, "class", "graph__div");
    			add_location(div2, file$a, 96, 12, 4006);
    			attr_dev(div3, "class", "graph__container svelte-1mhcgqd");
    			add_location(div3, file$a, 91, 8, 3810);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_main_content__slot_slot$1.name,
    		type: "slot",
    		source: "(91:4) <svelte:fragment slot=\\\"main_content__slot\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let separatewindow;
    	let updating_active;
    	let updating_windowReady;
    	let updating_graphWindow;
    	let current;

    	function separatewindow_active_binding(value) {
    		/*separatewindow_active_binding*/ ctx[19](value);
    	}

    	function separatewindow_windowReady_binding(value) {
    		/*separatewindow_windowReady_binding*/ ctx[20](value);
    	}

    	function separatewindow_graphWindow_binding(value) {
    		/*separatewindow_graphWindow_binding*/ ctx[21](value);
    	}

    	let separatewindow_props = {
    		title,
    		maximize: false,
    		$$slots: {
    			main_content__slot: [create_main_content__slot_slot$1],
    			header_content__slot: [create_header_content__slot_slot$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		separatewindow_props.active = /*active*/ ctx[0];
    	}

    	if (/*windowReady*/ ctx[3] !== void 0) {
    		separatewindow_props.windowReady = /*windowReady*/ ctx[3];
    	}

    	if (/*graphWindow*/ ctx[2] !== void 0) {
    		separatewindow_props.graphWindow = /*graphWindow*/ ctx[2];
    	}

    	separatewindow = new SeparateWindow({
    			props: separatewindow_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(separatewindow, 'active', separatewindow_active_binding));
    	binding_callbacks.push(() => bind(separatewindow, 'windowReady', separatewindow_windowReady_binding));
    	binding_callbacks.push(() => bind(separatewindow, 'graphWindow', separatewindow_graphWindow_binding));

    	const block = {
    		c: function create() {
    			create_component(separatewindow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(separatewindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const separatewindow_changes = {};

    			if (dirty & /*$$scope, numberDensity, duration, stepSize, collisionalTemp, initialTemp*/ 4194546) {
    				separatewindow_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				separatewindow_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			if (!updating_windowReady && dirty & /*windowReady*/ 8) {
    				updating_windowReady = true;
    				separatewindow_changes.windowReady = /*windowReady*/ ctx[3];
    				add_flush_callback(() => updating_windowReady = false);
    			}

    			if (!updating_graphWindow && dirty & /*graphWindow*/ 4) {
    				updating_graphWindow = true;
    				separatewindow_changes.graphWindow = /*graphWindow*/ ctx[2];
    				add_flush_callback(() => updating_graphWindow = false);
    			}

    			separatewindow.$set(separatewindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(separatewindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(separatewindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(separatewindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const title = "Collisional cooling";
    const plotID = "collisionalDistributionPlot";

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollisionalDistribution', slots, []);
    	let { active, collisionalTemp = 10 } = $$props;
    	let { collisionalRateConstants, energyLevels, electronSpin, zeemanSplit, energyUnit } = $$props;
    	let initialTemp = 300, duration = 600;
    	let numberDensity = "2e14";
    	let graphWindow = null, windowReady = false;
    	let stepSize = 0.1;

    	async function computeCollisionalProcess(e) {
    		try {
    			const boltzmanDistribution = boltzman_distribution({
    				energyLevels,
    				trapTemp: initialTemp,
    				electronSpin,
    				zeemanSplit,
    				energyUnit
    			});

    			const boltzmanDistributionValues = {};
    			boltzmanDistribution.forEach(f => boltzmanDistributionValues[f.label] = f.value);
    			const collisionalRateConstantValues = {};
    			collisionalRateConstants.forEach(f => collisionalRateConstantValues[f.label] = f.value);
    			const pyfile = "collisionalSimulation.py";

    			const boltzmanDistributionCold = boltzman_distribution({
    				energyLevels,
    				trapTemp: collisionalTemp,
    				electronSpin,
    				zeemanSplit,
    				energyUnit
    			});

    			const boltzmanData = {
    				x: boltzmanDistributionCold.map(f => f.label),
    				y: boltzmanDistributionCold.map(f => f.value),
    				name: "boltzman"
    			};

    			const boltzmanPlotData = { boltzmanData };

    			const args = [
    				JSON.stringify({
    					numberDensity,
    					boltzmanDistributionValues,
    					boltzmanDistributionCold: boltzmanData,
    					duration,
    					collisionalRateConstantValues
    				})
    			];

    			const { data, collisionalBoltzmanPlotData, differenceFromBoltzman } = await computePy_func({ e, pyfile, args });
    			plot(`${title}: ${initialTemp}K --> ${collisionalTemp}K (${numberDensity}/cm3)`, "Time (s)", "Population", data, plotID);

    			const combinedData = {
    				...collisionalBoltzmanPlotData,
    				...boltzmanPlotData
    			};

    			plot(` Distribution: ${collisionalTemp}K`, "Energy Levels", "Population", combinedData, `${plotID}_collisionalBoltzman`);
    			plot(`Difference: Collisional - Boltzmann`, "Energy Levels", "Difference", differenceFromBoltzman, `${plotID}_collisionalBoltzman_difference`);
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const writable_props = [
    		'active',
    		'collisionalTemp',
    		'collisionalRateConstants',
    		'energyLevels',
    		'electronSpin',
    		'zeemanSplit',
    		'energyUnit'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollisionalDistribution> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		stepSize = value;
    		$$invalidate(7, stepSize);
    	}

    	function textfield1_value_binding(value) {
    		initialTemp = value;
    		$$invalidate(4, initialTemp);
    	}

    	function textfield2_value_binding(value) {
    		collisionalTemp = value;
    		$$invalidate(1, collisionalTemp);
    	}

    	function textfield3_value_binding(value) {
    		duration = value;
    		$$invalidate(5, duration);
    	}

    	function textfield4_value_binding(value) {
    		numberDensity = value;
    		$$invalidate(6, numberDensity);
    	}

    	function separatewindow_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	function separatewindow_windowReady_binding(value) {
    		windowReady = value;
    		$$invalidate(3, windowReady);
    	}

    	function separatewindow_graphWindow_binding(value) {
    		graphWindow = value;
    		$$invalidate(2, graphWindow);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('collisionalTemp' in $$props) $$invalidate(1, collisionalTemp = $$props.collisionalTemp);
    		if ('collisionalRateConstants' in $$props) $$invalidate(9, collisionalRateConstants = $$props.collisionalRateConstants);
    		if ('energyLevels' in $$props) $$invalidate(10, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(11, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(12, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(13, energyUnit = $$props.energyUnit);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		SeparateWindow,
    		plot,
    		boltzman_distribution,
    		Textfield,
    		active,
    		collisionalTemp,
    		collisionalRateConstants,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		initialTemp,
    		duration,
    		numberDensity,
    		title,
    		plotID,
    		graphWindow,
    		windowReady,
    		stepSize,
    		computeCollisionalProcess
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('collisionalTemp' in $$props) $$invalidate(1, collisionalTemp = $$props.collisionalTemp);
    		if ('collisionalRateConstants' in $$props) $$invalidate(9, collisionalRateConstants = $$props.collisionalRateConstants);
    		if ('energyLevels' in $$props) $$invalidate(10, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(11, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(12, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(13, energyUnit = $$props.energyUnit);
    		if ('initialTemp' in $$props) $$invalidate(4, initialTemp = $$props.initialTemp);
    		if ('duration' in $$props) $$invalidate(5, duration = $$props.duration);
    		if ('numberDensity' in $$props) $$invalidate(6, numberDensity = $$props.numberDensity);
    		if ('graphWindow' in $$props) $$invalidate(2, graphWindow = $$props.graphWindow);
    		if ('windowReady' in $$props) $$invalidate(3, windowReady = $$props.windowReady);
    		if ('stepSize' in $$props) $$invalidate(7, stepSize = $$props.stepSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*windowReady, graphWindow*/ 12) {
    			if (windowReady) {
    				setTimeout(() => graphWindow.focus(), 100);
    			}
    		}
    	};

    	return [
    		active,
    		collisionalTemp,
    		graphWindow,
    		windowReady,
    		initialTemp,
    		duration,
    		numberDensity,
    		stepSize,
    		computeCollisionalProcess,
    		collisionalRateConstants,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield2_value_binding,
    		textfield3_value_binding,
    		textfield4_value_binding,
    		separatewindow_active_binding,
    		separatewindow_windowReady_binding,
    		separatewindow_graphWindow_binding
    	];
    }

    class CollisionalDistribution extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			active: 0,
    			collisionalTemp: 1,
    			collisionalRateConstants: 9,
    			energyLevels: 10,
    			electronSpin: 11,
    			zeemanSplit: 12,
    			energyUnit: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollisionalDistribution",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*active*/ ctx[0] === undefined && !('active' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'active'");
    		}

    		if (/*collisionalRateConstants*/ ctx[9] === undefined && !('collisionalRateConstants' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'collisionalRateConstants'");
    		}

    		if (/*energyLevels*/ ctx[10] === undefined && !('energyLevels' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'energyLevels'");
    		}

    		if (/*electronSpin*/ ctx[11] === undefined && !('electronSpin' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'electronSpin'");
    		}

    		if (/*zeemanSplit*/ ctx[12] === undefined && !('zeemanSplit' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'zeemanSplit'");
    		}

    		if (/*energyUnit*/ ctx[13] === undefined && !('energyUnit' in props)) {
    			console.warn("<CollisionalDistribution> was created without expected prop 'energyUnit'");
    		}
    	}

    	get active() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalTemp() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalTemp(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalRateConstants() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalRateConstants(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyLevels() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyLevels(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get electronSpin() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set electronSpin(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zeemanSplit() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zeemanSplit(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyUnit() {
    		throw new Error("<CollisionalDistribution>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyUnit(value) {
    		throw new Error("<CollisionalDistribution>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\thz\components\CollisionalCoefficients.svelte generated by Svelte v3.42.1 */
    const file$9 = "src\\Pages\\thz\\components\\CollisionalCoefficients.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i].label;
    	child_ctx[29] = list[i].value;
    	child_ctx[30] = list[i].id;
    	child_ctx[31] = list;
    	child_ctx[32] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i].label;
    	child_ctx[29] = list[i].value;
    	child_ctx[30] = list[i].id;
    	child_ctx[33] = list;
    	child_ctx[34] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i].label;
    	child_ctx[29] = list[i].value;
    	child_ctx[30] = list[i].id;
    	child_ctx[35] = list;
    	child_ctx[36] = i;
    	return child_ctx;
    }

    // (130:4) {#if collisionalCoefficient.length>0}
    function create_if_block_1$4(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value_2 = /*collisionalCoefficient*/ ctx[0];
    	validate_each_argument(each_value_2);
    	const get_key = ctx => /*id*/ ctx[30];
    	validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "content__div  svelte-cz3hcg");
    			add_location(div, file$9, 131, 8, 4855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collisionalCoefficient*/ 1) {
    				each_value_2 = /*collisionalCoefficient*/ ctx[0];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, div, outro_and_destroy_block, create_each_block_2$2, null, get_each_context_2$2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(130:4) {#if collisionalCoefficient.length>0}",
    		ctx
    	});

    	return block;
    }

    // (136:8) {#each collisionalCoefficient as {label, value, id}
    function create_each_block_2$2(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[20](value, /*value*/ ctx[29], /*each_value_2*/ ctx[35], /*each_index_2*/ ctx[36]);
    	}

    	let textfield_props = { label: /*label*/ ctx[28] };

    	if (/*value*/ ctx[29] !== void 0) {
    		textfield_props.value = /*value*/ ctx[29];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*collisionalCoefficient*/ 1) textfield_changes.label = /*label*/ ctx[28];

    			if (!updating_value && dirty[0] & /*collisionalCoefficient*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[29];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(136:8) {#each collisionalCoefficient as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (143:4) {#if collisionalCoefficient_balance.length>0}
    function create_if_block$8(ctx) {
    	let hr;
    	let t;
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value_1 = /*collisionalCoefficient_balance*/ ctx[1];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*id*/ ctx[30];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(hr, "class", "svelte-cz3hcg");
    			add_location(hr, file$9, 144, 8, 5110);
    			attr_dev(div, "class", "content__div  svelte-cz3hcg");
    			add_location(div, file$9, 145, 8, 5124);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*collisionalCoefficient_balance*/ 2) {
    				each_value_1 = /*collisionalCoefficient_balance*/ ctx[1];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$2, null, get_each_context_1$2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(143:4) {#if collisionalCoefficient_balance.length>0}",
    		ctx
    	});

    	return block;
    }

    // (147:12) {#each collisionalCoefficient_balance as {label, value, id}
    function create_each_block_1$2(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[21](value, /*value*/ ctx[29], /*each_value_1*/ ctx[33], /*each_index_1*/ ctx[34]);
    	}

    	let textfield_props = { label: /*label*/ ctx[28] };

    	if (/*value*/ ctx[29] !== void 0) {
    		textfield_props.value = /*value*/ ctx[29];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*collisionalCoefficient_balance*/ 2) textfield_changes.label = /*label*/ ctx[28];

    			if (!updating_value && dirty[0] & /*collisionalCoefficient_balance*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[29];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(147:12) {#each collisionalCoefficient_balance as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (161:8) {#each collisionalRates as {label, value, id}
    function create_each_block$4(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_2(value) {
    		/*textfield_value_binding_2*/ ctx[23](value, /*value*/ ctx[29], /*each_value*/ ctx[31], /*each_index*/ ctx[32]);
    	}

    	let textfield_props = { label: /*label*/ ctx[28] };

    	if (/*value*/ ctx[29] !== void 0) {
    		textfield_props.value = /*value*/ ctx[29];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_2));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*collisionalRates*/ 16) textfield_changes.label = /*label*/ ctx[28];

    			if (!updating_value && dirty[0] & /*collisionalRates*/ 16) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[29];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(161:8) {#each collisionalRates as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let collisionaldistribution;
    	let updating_active;
    	let t0;
    	let div6;
    	let div0;
    	let t2;
    	let div2;
    	let button0;
    	let t4;
    	let button1;
    	let t6;
    	let div1;
    	let textfield0;
    	let updating_value;
    	let t7;
    	let button2;
    	let t9;
    	let button3;
    	let t11;
    	let t12;
    	let t13;
    	let hr;
    	let t14;
    	let div3;
    	let t16;
    	let div4;
    	let textfield1;
    	let updating_value_1;
    	let t17;
    	let div5;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;
    	const collisionaldistribution_spread_levels = [/*collisionalArgs*/ ctx[6]];

    	function collisionaldistribution_active_binding(value) {
    		/*collisionaldistribution_active_binding*/ ctx[17](value);
    	}

    	let collisionaldistribution_props = {};

    	for (let i = 0; i < collisionaldistribution_spread_levels.length; i += 1) {
    		collisionaldistribution_props = assign(collisionaldistribution_props, collisionaldistribution_spread_levels[i]);
    	}

    	if (/*collisionalWindow*/ ctx[5] !== void 0) {
    		collisionaldistribution_props.active = /*collisionalWindow*/ ctx[5];
    	}

    	collisionaldistribution = new CollisionalDistribution({
    			props: collisionaldistribution_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(collisionaldistribution, 'active', collisionaldistribution_active_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[19](value);
    	}

    	let textfield0_props = { label: "collisionalTemp" };

    	if (/*collisionalTemp*/ ctx[3] !== void 0) {
    		textfield0_props.value = /*collisionalTemp*/ ctx[3];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));
    	let if_block0 = /*collisionalCoefficient*/ ctx[0].length > 0 && create_if_block_1$4(ctx);
    	let if_block1 = /*collisionalCoefficient_balance*/ ctx[1].length > 0 && create_if_block$8(ctx);

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[22](value);
    	}

    	let textfield1_props = { label: "numberDensity (cm-3)" };

    	if (/*numberDensity*/ ctx[2] !== void 0) {
    		textfield1_props.value = /*numberDensity*/ ctx[2];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	let each_value = /*collisionalRates*/ ctx[4];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*id*/ ctx[30];
    	validate_each_keys(ctx, each_value, get_each_context$4, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$4(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			create_component(collisionaldistribution.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			div0 = element("div");
    			div0.textContent = "Collisional rate constants";
    			t2 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "Compute balance rate";
    			t4 = space();
    			button1 = element("button");
    			button1.textContent = "Compute Collisional Cooling";
    			t6 = space();
    			div1 = element("div");
    			create_component(textfield0.$$.fragment);
    			t7 = space();
    			button2 = element("button");
    			button2.textContent = "Browse";
    			t9 = space();
    			button3 = element("button");
    			button3.textContent = "Compute";
    			t11 = space();
    			if (if_block0) if_block0.c();
    			t12 = space();
    			if (if_block1) if_block1.c();
    			t13 = space();
    			hr = element("hr");
    			t14 = space();
    			div3 = element("div");
    			div3.textContent = "Collisional Rates (per sec)";
    			t16 = space();
    			div4 = element("div");
    			create_component(textfield1.$$.fragment);
    			t17 = space();
    			div5 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "subtitle svelte-cz3hcg");
    			add_location(div0, file$9, 115, 4, 3946);
    			attr_dev(button0, "class", "button is-link ");
    			add_location(button0, file$9, 117, 8, 4043);
    			attr_dev(button1, "class", "button is-link ");
    			add_location(button1, file$9, 118, 8, 4159);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$9, 121, 12, 4396);
    			attr_dev(button3, "class", "button is-link");
    			add_location(button3, file$9, 122, 12, 4491);
    			attr_dev(div1, "class", "align h-center");
    			add_location(div1, file$9, 119, 8, 4275);
    			attr_dev(div2, "class", "control__div  svelte-cz3hcg");
    			add_location(div2, file$9, 116, 4, 4006);
    			attr_dev(hr, "class", "svelte-cz3hcg");
    			add_location(hr, file$9, 153, 4, 5340);
    			attr_dev(div3, "class", "subtitle svelte-cz3hcg");
    			add_location(div3, file$9, 154, 4, 5350);
    			attr_dev(div4, "class", "control__div svelte-cz3hcg");
    			add_location(div4, file$9, 155, 4, 5412);
    			attr_dev(div5, "class", "content__div  svelte-cz3hcg");
    			add_location(div5, file$9, 159, 4, 5536);
    			attr_dev(div6, "class", "sub_container__div box svelte-cz3hcg");
    			add_location(div6, file$9, 114, 0, 3904);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(collisionaldistribution, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			append_dev(div6, t2);
    			append_dev(div6, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t4);
    			append_dev(div2, button1);
    			append_dev(div2, t6);
    			append_dev(div2, div1);
    			mount_component(textfield0, div1, null);
    			append_dev(div1, t7);
    			append_dev(div1, button2);
    			append_dev(div1, t9);
    			append_dev(div1, button3);
    			append_dev(div6, t11);
    			if (if_block0) if_block0.m(div6, null);
    			append_dev(div6, t12);
    			if (if_block1) if_block1.m(div6, null);
    			append_dev(div6, t13);
    			append_dev(div6, hr);
    			append_dev(div6, t14);
    			append_dev(div6, div3);
    			append_dev(div6, t16);
    			append_dev(div6, div4);
    			mount_component(textfield1, div4, null);
    			append_dev(div6, t17);
    			append_dev(div6, div5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*compteCollisionalBalanceConstants*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[18], false, false, false),
    					listen_dev(button2, "click", /*browse_collisional_file*/ ctx[8], false, false, false),
    					listen_dev(button3, "click", /*computeCollisionalFit*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const collisionaldistribution_changes = (dirty[0] & /*collisionalArgs*/ 64)
    			? get_spread_update(collisionaldistribution_spread_levels, [get_spread_object(/*collisionalArgs*/ ctx[6])])
    			: {};

    			if (!updating_active && dirty[0] & /*collisionalWindow*/ 32) {
    				updating_active = true;
    				collisionaldistribution_changes.active = /*collisionalWindow*/ ctx[5];
    				add_flush_callback(() => updating_active = false);
    			}

    			collisionaldistribution.$set(collisionaldistribution_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*collisionalTemp*/ 8) {
    				updating_value = true;
    				textfield0_changes.value = /*collisionalTemp*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);

    			if (/*collisionalCoefficient*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*collisionalCoefficient*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div6, t12);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*collisionalCoefficient_balance*/ ctx[1].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*collisionalCoefficient_balance*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div6, t13);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*numberDensity*/ 4) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*numberDensity*/ ctx[2];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);

    			if (dirty[0] & /*collisionalRates*/ 16) {
    				each_value = /*collisionalRates*/ ctx[4];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$4, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div5, outro_and_destroy_block, create_each_block$4, null, get_each_context$4);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collisionaldistribution.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collisionaldistribution.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(collisionaldistribution, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div6);
    			destroy_component(textfield0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(textfield1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let collisionalRateConstants;
    	let collisionalArgs;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CollisionalCoefficients', slots, []);
    	let { collisionalCoefficient = [], collisionalCoefficient_balance = [], collisionalRateType = "both", collisionalRates = [] } = $$props;
    	let { energyLevels, electronSpin, zeemanSplit, energyUnit, numberDensity = "2e14", collisionalFilename, collisionalTemp } = $$props;
    	let collisionalWindow = false;

    	const compteCollisionalBalanceConstants = () => {
    		const balanceArgs = {
    			energyLevels,
    			collisionalTemp,
    			electronSpin,
    			zeemanSplit,
    			energyUnit
    		};

    		$$invalidate(1, collisionalCoefficient_balance = []);

    		collisionalCoefficient.forEach(coefficient => {
    			const { label, value } = coefficient;
    			const levelLabels = label.split(" --> ").map(f => f.trim());
    			let newLabel, newValue;
    			newValue = value * balance_distribution({ ...balanceArgs, label });
    			newLabel = `${levelLabels[1]} --> ${levelLabels[0]}`;
    			const alreadyComputed = _.find(collisionalCoefficient, rate => rate.label == newLabel);

    			if (!alreadyComputed) {
    				$$invalidate(1, collisionalCoefficient_balance = [
    					...collisionalCoefficient_balance,
    					{
    						label: newLabel,
    						value: newValue.toExponential(3),
    						id: getID()
    					}
    				]);
    			}
    		});
    	};

    	const computeRate = rate => {
    		rate.value *= numberDensity;
    		rate.value = rate.value.toExponential(3);
    		return rate;
    	};

    	async function browse_collisional_file() {
    		const result = await browse({ dir: false });

    		if (result) {
    			$$invalidate(10, collisionalFilename = result[0]);
    		}
    	}

    	// let collisionlFile = ""
    	let saveFilename = "collisional_rate_constants";

    	// let collisionalTemp = 5
    	const setID = obj => {
    		obj.id = window.getID();
    		return obj;
    	};

    	const correctObjValue = obj => {
    		obj.value = obj.value.toExponential(3);
    		return obj;
    	};

    	async function computeCollisionalFit(e) {
    		try {
    			if (collisionalFilename) {
    				const pyfile = "ROSAA/collisionalFit.py";

    				const args = [
    					JSON.stringify({
    						collisionalFilename,
    						collisionalTemp,
    						saveFilename,
    						collisionalRateType
    					})
    				];

    				const dataFromPython = await computePy_func({ e, pyfile, args });
    				const { rateConstants } = dataFromPython;
    				$$invalidate(0, collisionalCoefficient = rateConstants.map(setID).map(correctObjValue));
    			} else {
    				browse_collisional_file();
    			}
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const writable_props = [
    		'collisionalCoefficient',
    		'collisionalCoefficient_balance',
    		'collisionalRateType',
    		'collisionalRates',
    		'energyLevels',
    		'electronSpin',
    		'zeemanSplit',
    		'energyUnit',
    		'numberDensity',
    		'collisionalFilename',
    		'collisionalTemp'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CollisionalCoefficients> was created with unknown prop '${key}'`);
    	});

    	function collisionaldistribution_active_binding(value) {
    		collisionalWindow = value;
    		$$invalidate(5, collisionalWindow);
    	}

    	const click_handler = () => $$invalidate(5, collisionalWindow = true);

    	function textfield0_value_binding(value) {
    		collisionalTemp = value;
    		$$invalidate(3, collisionalTemp);
    	}

    	function textfield_value_binding(value$1, value, each_value_2, each_index_2) {
    		each_value_2[each_index_2].value = value$1;
    		$$invalidate(0, collisionalCoefficient);
    	}

    	function textfield_value_binding_1(value$1, value, each_value_1, each_index_1) {
    		each_value_1[each_index_1].value = value$1;
    		$$invalidate(1, collisionalCoefficient_balance);
    	}

    	function textfield1_value_binding(value) {
    		numberDensity = value;
    		$$invalidate(2, numberDensity);
    	}

    	function textfield_value_binding_2(value$1, value, each_value, each_index) {
    		each_value[each_index].value = value$1;
    		(((($$invalidate(4, collisionalRates), $$invalidate(16, collisionalRateConstants)), $$invalidate(2, numberDensity)), $$invalidate(0, collisionalCoefficient)), $$invalidate(1, collisionalCoefficient_balance));
    	}

    	$$self.$$set = $$props => {
    		if ('collisionalCoefficient' in $$props) $$invalidate(0, collisionalCoefficient = $$props.collisionalCoefficient);
    		if ('collisionalCoefficient_balance' in $$props) $$invalidate(1, collisionalCoefficient_balance = $$props.collisionalCoefficient_balance);
    		if ('collisionalRateType' in $$props) $$invalidate(11, collisionalRateType = $$props.collisionalRateType);
    		if ('collisionalRates' in $$props) $$invalidate(4, collisionalRates = $$props.collisionalRates);
    		if ('energyLevels' in $$props) $$invalidate(12, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(13, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(14, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(15, energyUnit = $$props.energyUnit);
    		if ('numberDensity' in $$props) $$invalidate(2, numberDensity = $$props.numberDensity);
    		if ('collisionalFilename' in $$props) $$invalidate(10, collisionalFilename = $$props.collisionalFilename);
    		if ('collisionalTemp' in $$props) $$invalidate(3, collisionalTemp = $$props.collisionalTemp);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		CollisionalDistribution,
    		browse,
    		Textfield,
    		balance_distribution,
    		collisionalCoefficient,
    		collisionalCoefficient_balance,
    		collisionalRateType,
    		collisionalRates,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		numberDensity,
    		collisionalFilename,
    		collisionalTemp,
    		collisionalWindow,
    		compteCollisionalBalanceConstants,
    		computeRate,
    		browse_collisional_file,
    		saveFilename,
    		setID,
    		correctObjValue,
    		computeCollisionalFit,
    		collisionalRateConstants,
    		collisionalArgs
    	});

    	$$self.$inject_state = $$props => {
    		if ('collisionalCoefficient' in $$props) $$invalidate(0, collisionalCoefficient = $$props.collisionalCoefficient);
    		if ('collisionalCoefficient_balance' in $$props) $$invalidate(1, collisionalCoefficient_balance = $$props.collisionalCoefficient_balance);
    		if ('collisionalRateType' in $$props) $$invalidate(11, collisionalRateType = $$props.collisionalRateType);
    		if ('collisionalRates' in $$props) $$invalidate(4, collisionalRates = $$props.collisionalRates);
    		if ('energyLevels' in $$props) $$invalidate(12, energyLevels = $$props.energyLevels);
    		if ('electronSpin' in $$props) $$invalidate(13, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(14, zeemanSplit = $$props.zeemanSplit);
    		if ('energyUnit' in $$props) $$invalidate(15, energyUnit = $$props.energyUnit);
    		if ('numberDensity' in $$props) $$invalidate(2, numberDensity = $$props.numberDensity);
    		if ('collisionalFilename' in $$props) $$invalidate(10, collisionalFilename = $$props.collisionalFilename);
    		if ('collisionalTemp' in $$props) $$invalidate(3, collisionalTemp = $$props.collisionalTemp);
    		if ('collisionalWindow' in $$props) $$invalidate(5, collisionalWindow = $$props.collisionalWindow);
    		if ('saveFilename' in $$props) saveFilename = $$props.saveFilename;
    		if ('collisionalRateConstants' in $$props) $$invalidate(16, collisionalRateConstants = $$props.collisionalRateConstants);
    		if ('collisionalArgs' in $$props) $$invalidate(6, collisionalArgs = $$props.collisionalArgs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*collisionalCoefficient, collisionalCoefficient_balance*/ 3) {
    			$$invalidate(16, collisionalRateConstants = [...collisionalCoefficient, ...collisionalCoefficient_balance]);
    		}

    		if ($$self.$$.dirty[0] & /*collisionalRateConstants, energyLevels, electronSpin, zeemanSplit, energyUnit, collisionalTemp*/ 126984) {
    			$$invalidate(6, collisionalArgs = {
    				collisionalRateConstants,
    				energyLevels,
    				electronSpin,
    				zeemanSplit,
    				energyUnit,
    				collisionalTemp
    			});
    		}

    		if ($$self.$$.dirty[0] & /*collisionalRateConstants, numberDensity*/ 65540) {
    			if (collisionalRateConstants.length > 0 && numberDensity) {
    				$$invalidate(4, collisionalRates = _.cloneDeep(collisionalRateConstants).map(computeRate));
    			}
    		}
    	};

    	return [
    		collisionalCoefficient,
    		collisionalCoefficient_balance,
    		numberDensity,
    		collisionalTemp,
    		collisionalRates,
    		collisionalWindow,
    		collisionalArgs,
    		compteCollisionalBalanceConstants,
    		browse_collisional_file,
    		computeCollisionalFit,
    		collisionalFilename,
    		collisionalRateType,
    		energyLevels,
    		electronSpin,
    		zeemanSplit,
    		energyUnit,
    		collisionalRateConstants,
    		collisionaldistribution_active_binding,
    		click_handler,
    		textfield0_value_binding,
    		textfield_value_binding,
    		textfield_value_binding_1,
    		textfield1_value_binding,
    		textfield_value_binding_2
    	];
    }

    class CollisionalCoefficients extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$9,
    			create_fragment$9,
    			safe_not_equal,
    			{
    				collisionalCoefficient: 0,
    				collisionalCoefficient_balance: 1,
    				collisionalRateType: 11,
    				collisionalRates: 4,
    				energyLevels: 12,
    				electronSpin: 13,
    				zeemanSplit: 14,
    				energyUnit: 15,
    				numberDensity: 2,
    				collisionalFilename: 10,
    				collisionalTemp: 3
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CollisionalCoefficients",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*energyLevels*/ ctx[12] === undefined && !('energyLevels' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'energyLevels'");
    		}

    		if (/*electronSpin*/ ctx[13] === undefined && !('electronSpin' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'electronSpin'");
    		}

    		if (/*zeemanSplit*/ ctx[14] === undefined && !('zeemanSplit' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'zeemanSplit'");
    		}

    		if (/*energyUnit*/ ctx[15] === undefined && !('energyUnit' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'energyUnit'");
    		}

    		if (/*collisionalFilename*/ ctx[10] === undefined && !('collisionalFilename' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'collisionalFilename'");
    		}

    		if (/*collisionalTemp*/ ctx[3] === undefined && !('collisionalTemp' in props)) {
    			console.warn("<CollisionalCoefficients> was created without expected prop 'collisionalTemp'");
    		}
    	}

    	get collisionalCoefficient() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalCoefficient(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalCoefficient_balance() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalCoefficient_balance(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalRateType() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalRateType(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalRates() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalRates(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyLevels() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyLevels(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get electronSpin() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set electronSpin(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zeemanSplit() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zeemanSplit(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get energyUnit() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set energyUnit(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get numberDensity() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numberDensity(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalFilename() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalFilename(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collisionalTemp() {
    		throw new Error("<CollisionalCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collisionalTemp(value) {
    		throw new Error("<CollisionalCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\thz\components\AttachmentCoefficients.svelte generated by Svelte v3.42.1 */
    const file$8 = "src\\Pages\\thz\\components\\AttachmentCoefficients.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].label;
    	child_ctx[14] = list[i].value;
    	child_ctx[15] = list[i].id;
    	child_ctx[16] = list;
    	child_ctx[17] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].label;
    	child_ctx[14] = list[i].value;
    	child_ctx[15] = list[i].id;
    	child_ctx[18] = list;
    	child_ctx[19] = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].label;
    	child_ctx[14] = list[i].value;
    	child_ctx[15] = list[i].id;
    	child_ctx[20] = list;
    	child_ctx[21] = i;
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].label;
    	child_ctx[14] = list[i].value;
    	child_ctx[15] = list[i].id;
    	child_ctx[22] = list;
    	child_ctx[23] = i;
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].label;
    	child_ctx[14] = list[i].value;
    	child_ctx[15] = list[i].id;
    	child_ctx[24] = list;
    	child_ctx[25] = i;
    	return child_ctx;
    }

    // (63:8) {#each attachmentCoefficients as {label, value, id}
    function create_each_block_4$1(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[5](value, /*value*/ ctx[14], /*each_value_4*/ ctx[24], /*each_index_4*/ ctx[25]);
    	}

    	let textfield_props = { label: /*label*/ ctx[13] };

    	if (/*value*/ ctx[14] !== void 0) {
    		textfield_props.value = /*value*/ ctx[14];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*attachmentCoefficients*/ 8) textfield_changes.label = /*label*/ ctx[13];

    			if (!updating_value && dirty & /*attachmentCoefficients*/ 8) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[14];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(63:8) {#each attachmentCoefficients as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (73:16) {#each k3.constant as {label, value, id}
    function create_each_block_3$1(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_2(value) {
    		/*textfield_value_binding_2*/ ctx[7](value, /*value*/ ctx[14], /*each_value_3*/ ctx[22], /*each_index_3*/ ctx[23]);
    	}

    	let textfield_props = { label: /*label*/ ctx[13] };

    	if (/*value*/ ctx[14] !== void 0) {
    		textfield_props.value = /*value*/ ctx[14];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_2));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*k3*/ 2) textfield_changes.label = /*label*/ ctx[13];

    			if (!updating_value && dirty & /*k3*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[14];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(73:16) {#each k3.constant as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (83:16) {#each kCID.constant as {label, value, id}
    function create_each_block_2$1(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_3(value) {
    		/*textfield_value_binding_3*/ ctx[8](value, /*value*/ ctx[14], /*each_value_2*/ ctx[20], /*each_index_2*/ ctx[21]);
    	}

    	let textfield_props = { label: /*label*/ ctx[13] };

    	if (/*value*/ ctx[14] !== void 0) {
    		textfield_props.value = /*value*/ ctx[14];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_3));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*kCID*/ 4) textfield_changes.label = /*label*/ ctx[13];

    			if (!updating_value && dirty & /*kCID*/ 4) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[14];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(83:16) {#each kCID.constant as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (94:16) {#each k3.rate as {label, value, id}
    function create_each_block_1$1(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_4(value) {
    		/*textfield_value_binding_4*/ ctx[9](value, /*value*/ ctx[14], /*each_value_1*/ ctx[18], /*each_index_1*/ ctx[19]);
    	}

    	let textfield_props = { label: /*label*/ ctx[13] };

    	if (/*value*/ ctx[14] !== void 0) {
    		textfield_props.value = /*value*/ ctx[14];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_4));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*k3*/ 2) textfield_changes.label = /*label*/ ctx[13];

    			if (!updating_value && dirty & /*k3*/ 2) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[14];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(94:16) {#each k3.rate as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (102:16) {#each kCID.rate as {label, value, id}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_5(value) {
    		/*textfield_value_binding_5*/ ctx[10](value, /*value*/ ctx[14], /*each_value*/ ctx[16], /*each_index*/ ctx[17]);
    	}

    	let textfield_props = { label: /*label*/ ctx[13] };

    	if (/*value*/ ctx[14] !== void 0) {
    		textfield_props.value = /*value*/ ctx[14];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_5));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty & /*kCID*/ 4) textfield_changes.label = /*label*/ ctx[13];

    			if (!updating_value && dirty & /*kCID*/ 4) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[14];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(102:16) {#each kCID.rate as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div11;
    	let div0;
    	let t1;
    	let div10;
    	let each_blocks_4 = [];
    	let each0_lookup = new Map();
    	let t2;
    	let div9;
    	let textfield;
    	let updating_value;
    	let t3;
    	let button;
    	let t5;
    	let div2;
    	let div1;
    	let t7;
    	let each_blocks_3 = [];
    	let each1_lookup = new Map();
    	let t8;
    	let div4;
    	let div3;
    	let t10;
    	let each_blocks_2 = [];
    	let each2_lookup = new Map();
    	let t11;
    	let hr;
    	let t12;
    	let div6;
    	let div5;
    	let t14;
    	let each_blocks_1 = [];
    	let each3_lookup = new Map();
    	let t15;
    	let div8;
    	let div7;
    	let t17;
    	let each_blocks = [];
    	let each4_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_4 = /*attachmentCoefficients*/ ctx[3];
    	validate_each_argument(each_value_4);
    	const get_key = ctx => /*id*/ ctx[15];
    	validate_each_keys(ctx, each_value_4, get_each_context_4$1, get_key);

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		let child_ctx = get_each_context_4$1(ctx, each_value_4, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_4[i] = create_each_block_4$1(key, child_ctx));
    	}

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[6](value);
    	}

    	let textfield_props = { label: "numberDensity (cm-3)" };

    	if (/*numberDensity*/ ctx[0] !== void 0) {
    		textfield_props.value = /*numberDensity*/ ctx[0];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));
    	let each_value_3 = /*k3*/ ctx[1].constant;
    	validate_each_argument(each_value_3);
    	const get_key_1 = ctx => /*id*/ ctx[15];
    	validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key_1);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3$1(ctx, each_value_3, i);
    		let key = get_key_1(child_ctx);
    		each1_lookup.set(key, each_blocks_3[i] = create_each_block_3$1(key, child_ctx));
    	}

    	let each_value_2 = /*kCID*/ ctx[2].constant;
    	validate_each_argument(each_value_2);
    	const get_key_2 = ctx => /*id*/ ctx[15];
    	validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key_2);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
    		let key = get_key_2(child_ctx);
    		each2_lookup.set(key, each_blocks_2[i] = create_each_block_2$1(key, child_ctx));
    	}

    	let each_value_1 = /*k3*/ ctx[1].rate;
    	validate_each_argument(each_value_1);
    	const get_key_3 = ctx => /*id*/ ctx[15];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key_3);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key_3(child_ctx);
    		each3_lookup.set(key, each_blocks_1[i] = create_each_block_1$1(key, child_ctx));
    	}

    	let each_value = /*kCID*/ ctx[2].rate;
    	validate_each_argument(each_value);
    	const get_key_4 = ctx => /*id*/ ctx[15];
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key_4);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key_4(child_ctx);
    		each4_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div0 = element("div");
    			div0.textContent = "Rare-gas attachment (K3) and dissociation (kCID) constants";
    			t1 = space();
    			div10 = element("div");

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t2 = space();
    			div9 = element("div");
    			create_component(textfield.$$.fragment);
    			t3 = space();
    			button = element("button");
    			button.textContent = "Compute rate constants";
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div1.textContent = "k3 (cm6/s):";
    			t7 = space();

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t8 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div3.textContent = "kCID  (cm3/s):";
    			t10 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t11 = space();
    			hr = element("hr");
    			t12 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div5.textContent = "k3 (per sec):";
    			t14 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t15 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div7.textContent = "kCID (per sec):";
    			t17 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "subtitle svelte-1t65zux");
    			add_location(div0, file$8, 59, 4, 1362);
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$8, 68, 12, 1748);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$8, 71, 16, 1906);
    			attr_dev(div2, "class", "align h-center");
    			add_location(div2, file$8, 70, 12, 1859);
    			attr_dev(div3, "class", "");
    			add_location(div3, file$8, 81, 16, 2186);
    			attr_dev(div4, "class", "align h-center");
    			add_location(div4, file$8, 79, 12, 2138);
    			attr_dev(hr, "class", "svelte-1t65zux");
    			add_location(hr, file$8, 88, 12, 2405);
    			attr_dev(div5, "class", "");
    			add_location(div5, file$8, 91, 16, 2471);
    			attr_dev(div6, "class", "align h-center");
    			add_location(div6, file$8, 90, 12, 2425);
    			attr_dev(div7, "class", "");
    			add_location(div7, file$8, 100, 16, 2730);
    			attr_dev(div8, "class", "align h-center");
    			add_location(div8, file$8, 98, 12, 2682);
    			attr_dev(div9, "class", "align h-center");
    			add_location(div9, file$8, 66, 8, 1624);
    			attr_dev(div10, "class", "content__div svelte-1t65zux");
    			add_location(div10, file$8, 61, 4, 1456);
    			attr_dev(div11, "class", "sub_container__div box svelte-1t65zux");
    			add_location(div11, file$8, 57, 0, 1318);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div0);
    			append_dev(div11, t1);
    			append_dev(div11, div10);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(div10, null);
    			}

    			append_dev(div10, t2);
    			append_dev(div10, div9);
    			mount_component(textfield, div9, null);
    			append_dev(div9, t3);
    			append_dev(div9, button);
    			append_dev(div9, t5);
    			append_dev(div9, div2);
    			append_dev(div2, div1);
    			append_dev(div2, t7);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div2, null);
    			}

    			append_dev(div9, t8);
    			append_dev(div9, div4);
    			append_dev(div4, div3);
    			append_dev(div4, t10);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div4, null);
    			}

    			append_dev(div9, t11);
    			append_dev(div9, hr);
    			append_dev(div9, t12);
    			append_dev(div9, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t14);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div6, null);
    			}

    			append_dev(div9, t15);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div8, t17);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*computeAttachmentRate*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*attachmentCoefficients*/ 8) {
    				each_value_4 = /*attachmentCoefficients*/ ctx[3];
    				validate_each_argument(each_value_4);
    				group_outros();
    				validate_each_keys(ctx, each_value_4, get_each_context_4$1, get_key);
    				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key, 1, ctx, each_value_4, each0_lookup, div10, outro_and_destroy_block, create_each_block_4$1, t2, get_each_context_4$1);
    				check_outros();
    			}

    			const textfield_changes = {};

    			if (!updating_value && dirty & /*numberDensity*/ 1) {
    				updating_value = true;
    				textfield_changes.value = /*numberDensity*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);

    			if (dirty & /*k3*/ 2) {
    				each_value_3 = /*k3*/ ctx[1].constant;
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key_1);
    				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_1, 1, ctx, each_value_3, each1_lookup, div2, outro_and_destroy_block, create_each_block_3$1, null, get_each_context_3$1);
    				check_outros();
    			}

    			if (dirty & /*kCID*/ 4) {
    				each_value_2 = /*kCID*/ ctx[2].constant;
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key_2);
    				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_2, 1, ctx, each_value_2, each2_lookup, div4, outro_and_destroy_block, create_each_block_2$1, null, get_each_context_2$1);
    				check_outros();
    			}

    			if (dirty & /*k3*/ 2) {
    				each_value_1 = /*k3*/ ctx[1].rate;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key_3);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_3, 1, ctx, each_value_1, each3_lookup, div6, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
    				check_outros();
    			}

    			if (dirty & /*kCID*/ 4) {
    				each_value = /*kCID*/ ctx[2].rate;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key_4);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key_4, 1, ctx, each_value, each4_lookup, div8, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks_4[i]);
    			}

    			transition_in(textfield.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				transition_out(each_blocks_4[i]);
    			}

    			transition_out(textfield.$$.fragment, local);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].d();
    			}

    			destroy_component(textfield);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].d();
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].d();
    			}

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AttachmentCoefficients', slots, []);
    	let { k3 = { constant: [], rate: [] }, kCID = { constant: [], rate: [] }, attachmentCoefficients = [] } = $$props;
    	let { numberDensity } = $$props;

    	const setID = obj => {
    		obj.id = window.getID();
    		return obj;
    	};

    	const correctObjValue = obj => {
    		obj.value = obj.value.toFixed(3);
    		return obj;
    	};

    	const computeAttachmentRate = () => {
    		$$invalidate(
    			1,
    			k3.rate = _.cloneDeep(k3.constant).map(rate => {
    				rate.value *= numberDensity ** 2;
    				return rate;
    			}).map(setID).map(correctObjValue),
    			k3
    		);

    		$$invalidate(
    			2,
    			kCID.rate = _.cloneDeep(kCID.constant).map(rate => {
    				rate.value *= numberDensity;
    				return rate;
    			}).map(setID).map(correctObjValue),
    			kCID
    		);
    	};

    	const writable_props = ['k3', 'kCID', 'attachmentCoefficients', 'numberDensity'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AttachmentCoefficients> was created with unknown prop '${key}'`);
    	});

    	function textfield_value_binding(value$1, value, each_value_4, each_index_4) {
    		each_value_4[each_index_4].value = value$1;
    		$$invalidate(3, attachmentCoefficients);
    	}

    	function textfield_value_binding_1(value) {
    		numberDensity = value;
    		$$invalidate(0, numberDensity);
    	}

    	function textfield_value_binding_2(value$1, value, each_value_3, each_index_3) {
    		each_value_3[each_index_3].value = value$1;
    		$$invalidate(1, k3);
    	}

    	function textfield_value_binding_3(value$1, value, each_value_2, each_index_2) {
    		each_value_2[each_index_2].value = value$1;
    		$$invalidate(2, kCID);
    	}

    	function textfield_value_binding_4(value$1, value, each_value_1, each_index_1) {
    		each_value_1[each_index_1].value = value$1;
    		$$invalidate(1, k3);
    	}

    	function textfield_value_binding_5(value$1, value, each_value, each_index) {
    		each_value[each_index].value = value$1;
    		$$invalidate(2, kCID);
    	}

    	$$self.$$set = $$props => {
    		if ('k3' in $$props) $$invalidate(1, k3 = $$props.k3);
    		if ('kCID' in $$props) $$invalidate(2, kCID = $$props.kCID);
    		if ('attachmentCoefficients' in $$props) $$invalidate(3, attachmentCoefficients = $$props.attachmentCoefficients);
    		if ('numberDensity' in $$props) $$invalidate(0, numberDensity = $$props.numberDensity);
    	};

    	$$self.$capture_state = () => ({
    		Textfield,
    		k3,
    		kCID,
    		attachmentCoefficients,
    		numberDensity,
    		setID,
    		correctObjValue,
    		computeAttachmentRate
    	});

    	$$self.$inject_state = $$props => {
    		if ('k3' in $$props) $$invalidate(1, k3 = $$props.k3);
    		if ('kCID' in $$props) $$invalidate(2, kCID = $$props.kCID);
    		if ('attachmentCoefficients' in $$props) $$invalidate(3, attachmentCoefficients = $$props.attachmentCoefficients);
    		if ('numberDensity' in $$props) $$invalidate(0, numberDensity = $$props.numberDensity);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*numberDensity*/ 1) {
    			if (numberDensity) computeAttachmentRate();
    		}
    	};

    	return [
    		numberDensity,
    		k3,
    		kCID,
    		attachmentCoefficients,
    		computeAttachmentRate,
    		textfield_value_binding,
    		textfield_value_binding_1,
    		textfield_value_binding_2,
    		textfield_value_binding_3,
    		textfield_value_binding_4,
    		textfield_value_binding_5
    	];
    }

    class AttachmentCoefficients extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			k3: 1,
    			kCID: 2,
    			attachmentCoefficients: 3,
    			numberDensity: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AttachmentCoefficients",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*numberDensity*/ ctx[0] === undefined && !('numberDensity' in props)) {
    			console.warn("<AttachmentCoefficients> was created without expected prop 'numberDensity'");
    		}
    	}

    	get k3() {
    		throw new Error("<AttachmentCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set k3(value) {
    		throw new Error("<AttachmentCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get kCID() {
    		throw new Error("<AttachmentCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kCID(value) {
    		throw new Error("<AttachmentCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get attachmentCoefficients() {
    		throw new Error("<AttachmentCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attachmentCoefficients(value) {
    		throw new Error("<AttachmentCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get numberDensity() {
    		throw new Error("<AttachmentCoefficients>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numberDensity(value) {
    		throw new Error("<AttachmentCoefficients>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const findAndGetValue = (arr, label) => {
        let values=[];
        if (typeof label === "object") {
            label.forEach(l=>{
                const {value} = _.find(arr, (f)=>f.label==l);
                values = [...values, value];

            });
            return values

        } else {

            const {value} = _.find(arr, (f)=>f.label==label);
            return value
        }
        
    };

    /* src\Pages\thz\ROSAA.svelte generated by Svelte v3.42.1 */

    const { console: console_1$2 } = globals;
    const file$7 = "src\\Pages\\thz\\ROSAA.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[112] = list[i].label;
    	child_ctx[113] = list[i].value;
    	child_ctx[114] = list[i].id;
    	child_ctx[115] = list;
    	child_ctx[116] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[112] = list[i].label;
    	child_ctx[113] = list[i].value;
    	child_ctx[117] = list[i].type;
    	child_ctx[118] = list[i].step;
    	child_ctx[114] = list[i].id;
    	child_ctx[119] = list;
    	child_ctx[120] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[112] = list[i].label;
    	child_ctx[113] = list[i].value;
    	child_ctx[114] = list[i].id;
    	child_ctx[121] = list;
    	child_ctx[122] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[112] = list[i].label;
    	child_ctx[113] = list[i].value;
    	child_ctx[114] = list[i].id;
    	child_ctx[123] = list;
    	child_ctx[124] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[112] = list[i].label;
    	child_ctx[113] = list[i].value;
    	child_ctx[114] = list[i].id;
    	child_ctx[125] = list;
    	child_ctx[126] = i;
    	return child_ctx;
    }

    // (363:0) {#if active}
    function create_if_block$7(ctx) {
    	let boltzmandistribution;
    	let updating_active;
    	let t;
    	let separatewindow;
    	let updating_active_1;
    	let current;
    	const boltzmandistribution_spread_levels = [/*boltzmanArgs*/ ctx[43], { maximize: false }];

    	function boltzmandistribution_active_binding(value) {
    		/*boltzmandistribution_active_binding*/ ctx[60](value);
    	}

    	let boltzmandistribution_props = {};

    	for (let i = 0; i < boltzmandistribution_spread_levels.length; i += 1) {
    		boltzmandistribution_props = assign(boltzmandistribution_props, boltzmandistribution_spread_levels[i]);
    	}

    	if (/*boltzmanWindow*/ ctx[36] !== void 0) {
    		boltzmandistribution_props.active = /*boltzmanWindow*/ ctx[36];
    	}

    	boltzmandistribution = new BoltzmanDistribution({
    			props: boltzmandistribution_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(boltzmandistribution, 'active', boltzmandistribution_active_binding));

    	function separatewindow_active_binding(value) {
    		/*separatewindow_active_binding*/ ctx[100](value);
    	}

    	let separatewindow_props = {
    		id: "ROSAA__modal",
    		title: "ROSAA modal",
    		$$slots: {
    			footer_content__slot: [create_footer_content__slot_slot],
    			main_content__slot: [create_main_content__slot_slot],
    			header_content__slot: [create_header_content__slot_slot]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		separatewindow_props.active = /*active*/ ctx[0];
    	}

    	separatewindow = new SeparateWindow({
    			props: separatewindow_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(separatewindow, 'active', separatewindow_active_binding));

    	const block = {
    		c: function create() {
    			create_component(boltzmandistribution.$$.fragment);
    			t = space();
    			create_component(separatewindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(boltzmandistribution, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(separatewindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const boltzmandistribution_changes = (dirty[1] & /*boltzmanArgs*/ 4096)
    			? get_spread_update(boltzmandistribution_spread_levels, [
    					get_spread_object(/*boltzmanArgs*/ ctx[43]),
    					boltzmandistribution_spread_levels[1]
    				])
    			: {};

    			if (!updating_active && dirty[1] & /*boltzmanWindow*/ 32) {
    				updating_active = true;
    				boltzmandistribution_changes.active = /*boltzmanWindow*/ ctx[36];
    				add_flush_callback(() => updating_active = false);
    			}

    			boltzmandistribution.$set(boltzmandistribution_changes);
    			const separatewindow_changes = {};

    			if (dirty[0] & /*showreport, statusReport, pyProcesses, attachmentCoefficients, k3, kCID, includeAttachmentRate, energyLevels, electronSpin, zeemanSplit, energyUnit, collisionalRateType, collisionalRates, includeCollision, trapArea, power, einsteinB_rateComputed, powerBroadening, dopplerLineshape, transitionFrequency, excitedTo, excitedFrom, simulationParameters, mainParameters, variableRange, variable, includeSpontaneousEmission, writefile, savefilename, currentLocation*/ 2147483646 | dirty[1] & /*numberDensity, collisionalFilename, collisionalTemp, collisionalCoefficient, collisionalCoefficient_balance, gaussian, lorrentz, einsteinCoefficientA, einsteinCoefficientB, boltzmanWindow, numberOfLevels, configFile*/ 4095 | dirty[4] & /*$$scope*/ 8) {
    				separatewindow_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active_1 && dirty[0] & /*active*/ 1) {
    				updating_active_1 = true;
    				separatewindow_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active_1 = false);
    			}

    			separatewindow.$set(separatewindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(boltzmandistribution.$$.fragment, local);
    			transition_in(separatewindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(boltzmandistribution.$$.fragment, local);
    			transition_out(separatewindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(boltzmandistribution, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(separatewindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(363:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (391:20) {#if variable !== "time"}
    function create_if_block_6(ctx) {
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_5(value) {
    		/*textfield_value_binding_5*/ ctx[98](value);
    	}

    	let textfield_props = {
    		label: "Range (min, max, totalsteps)",
    		style: "width: auto;"
    	};

    	if (/*variableRange*/ ctx[30] !== void 0) {
    		textfield_props.value = /*variableRange*/ ctx[30];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_5));

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty[0] & /*variableRange*/ 1073741824) {
    				updating_value = true;
    				textfield_changes.value = /*variableRange*/ ctx[30];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(391:20) {#if variable !== \\\"time\\\"}",
    		ctx
    	});

    	return block;
    }

    // (368:8) <svelte:fragment slot="header_content__slot" >
    function create_header_content__slot_slot(ctx) {
    	let div0;
    	let button0;
    	let t1;
    	let textfield0;
    	let updating_value;
    	let t2;
    	let textfield1;
    	let updating_value_1;
    	let t3;
    	let div1;
    	let customcheckbox0;
    	let updating_selected;
    	let t4;
    	let customcheckbox1;
    	let updating_selected_1;
    	let t5;
    	let customcheckbox2;
    	let updating_selected_2;
    	let t6;
    	let customcheckbox3;
    	let updating_selected_3;
    	let t7;
    	let customcheckbox4;
    	let updating_selected_4;
    	let t8;
    	let customcheckbox5;
    	let updating_selected_5;
    	let t9;
    	let div4;
    	let div2;
    	let t10;
    	let t11;
    	let t12;
    	let div3;
    	let customselect;
    	let updating_picked;
    	let t13;
    	let t14;
    	let button1;
    	let t16;
    	let button2;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding_1(value) {
    		/*textfield0_value_binding_1*/ ctx[89](value);
    	}

    	let textfield0_props = { label: "Current location" };

    	if (/*currentLocation*/ ctx[7] !== void 0) {
    		textfield0_props.value = /*currentLocation*/ ctx[7];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding_1));

    	function textfield1_value_binding_1(value) {
    		/*textfield1_value_binding_1*/ ctx[90](value);
    	}

    	let textfield1_props = { label: "savefilename" };

    	if (/*savefilename*/ ctx[24] !== void 0) {
    		textfield1_props.value = /*savefilename*/ ctx[24];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding_1));

    	function customcheckbox0_selected_binding(value) {
    		/*customcheckbox0_selected_binding*/ ctx[91](value);
    	}

    	let customcheckbox0_props = { label: "writefile" };

    	if (/*writefile*/ ctx[25] !== void 0) {
    		customcheckbox0_props.selected = /*writefile*/ ctx[25];
    	}

    	customcheckbox0 = new CustomCheckbox$1({
    			props: customcheckbox0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox0, 'selected', customcheckbox0_selected_binding));

    	function customcheckbox1_selected_binding(value) {
    		/*customcheckbox1_selected_binding*/ ctx[92](value);
    	}

    	let customcheckbox1_props = { label: "includeCollision" };

    	if (/*includeCollision*/ ctx[26] !== void 0) {
    		customcheckbox1_props.selected = /*includeCollision*/ ctx[26];
    	}

    	customcheckbox1 = new CustomCheckbox$1({
    			props: customcheckbox1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox1, 'selected', customcheckbox1_selected_binding));

    	function customcheckbox2_selected_binding(value) {
    		/*customcheckbox2_selected_binding*/ ctx[93](value);
    	}

    	let customcheckbox2_props = { label: "includeAttachmentRate" };

    	if (/*includeAttachmentRate*/ ctx[28] !== void 0) {
    		customcheckbox2_props.selected = /*includeAttachmentRate*/ ctx[28];
    	}

    	customcheckbox2 = new CustomCheckbox$1({
    			props: customcheckbox2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox2, 'selected', customcheckbox2_selected_binding));

    	function customcheckbox3_selected_binding(value) {
    		/*customcheckbox3_selected_binding*/ ctx[94](value);
    	}

    	let customcheckbox3_props = { label: "includeSpontaneousEmission" };

    	if (/*includeSpontaneousEmission*/ ctx[27] !== void 0) {
    		customcheckbox3_props.selected = /*includeSpontaneousEmission*/ ctx[27];
    	}

    	customcheckbox3 = new CustomCheckbox$1({
    			props: customcheckbox3_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox3, 'selected', customcheckbox3_selected_binding));

    	function customcheckbox4_selected_binding(value) {
    		/*customcheckbox4_selected_binding*/ ctx[95](value);
    	}

    	let customcheckbox4_props = { label: "Electron Spin" };

    	if (/*electronSpin*/ ctx[1] !== void 0) {
    		customcheckbox4_props.selected = /*electronSpin*/ ctx[1];
    	}

    	customcheckbox4 = new CustomCheckbox$1({
    			props: customcheckbox4_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox4, 'selected', customcheckbox4_selected_binding));

    	function customcheckbox5_selected_binding(value) {
    		/*customcheckbox5_selected_binding*/ ctx[96](value);
    	}

    	let customcheckbox5_props = { label: "Zeeman" };

    	if (/*zeemanSplit*/ ctx[2] !== void 0) {
    		customcheckbox5_props.selected = /*zeemanSplit*/ ctx[2];
    	}

    	customcheckbox5 = new CustomCheckbox$1({
    			props: customcheckbox5_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox5, 'selected', customcheckbox5_selected_binding));

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[97](value);
    	}

    	let customselect_props = { options: /*variablesList*/ ctx[50] };

    	if (/*variable*/ ctx[29] !== void 0) {
    		customselect_props.picked = /*variable*/ ctx[29];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));
    	let if_block = /*variable*/ ctx[29] !== "time" && create_if_block_6(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Browse";
    			t1 = space();
    			create_component(textfield0.$$.fragment);
    			t2 = space();
    			create_component(textfield1.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(customcheckbox0.$$.fragment);
    			t4 = space();
    			create_component(customcheckbox1.$$.fragment);
    			t5 = space();
    			create_component(customcheckbox2.$$.fragment);
    			t6 = space();
    			create_component(customcheckbox3.$$.fragment);
    			t7 = space();
    			create_component(customcheckbox4.$$.fragment);
    			t8 = space();
    			create_component(customcheckbox5.$$.fragment);
    			t9 = space();
    			div4 = element("div");
    			div2 = element("div");
    			t10 = text("Simulate signal(%) as a function of ");
    			t11 = text(/*variable*/ ctx[29]);
    			t12 = space();
    			div3 = element("div");
    			create_component(customselect.$$.fragment);
    			t13 = space();
    			if (if_block) if_block.c();
    			t14 = space();
    			button1 = element("button");
    			button1.textContent = "Load config";
    			t16 = space();
    			button2 = element("button");
    			button2.textContent = "Reset Config";
    			attr_dev(button0, "class", "button is-link svelte-1gffrzh");
    			attr_dev(button0, "id", "thz_modal_filebrowser_btn");
    			add_location(button0, file$7, 369, 16, 13495);
    			attr_dev(div0, "class", "locationColumn svelte-1gffrzh");
    			add_location(div0, file$7, 368, 12, 13448);
    			attr_dev(div1, "class", "writefileCheck svelte-1gffrzh");
    			add_location(div1, file$7, 375, 12, 13798);
    			attr_dev(div2, "class", "subtitle svelte-1gffrzh");
    			add_location(div2, file$7, 386, 16, 14468);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$7, 393, 20, 14924);
    			attr_dev(button2, "class", "button is-link");
    			add_location(button2, file$7, 394, 20, 15019);
    			attr_dev(div3, "class", "variableColumn__dropdown svelte-1gffrzh");
    			add_location(div3, file$7, 387, 16, 14560);
    			attr_dev(div4, "class", "variableColumn svelte-1gffrzh");
    			add_location(div4, file$7, 385, 12, 14422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t2);
    			mount_component(textfield1, div0, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(customcheckbox0, div1, null);
    			append_dev(div1, t4);
    			mount_component(customcheckbox1, div1, null);
    			append_dev(div1, t5);
    			mount_component(customcheckbox2, div1, null);
    			append_dev(div1, t6);
    			mount_component(customcheckbox3, div1, null);
    			append_dev(div1, t7);
    			mount_component(customcheckbox4, div1, null);
    			append_dev(div1, t8);
    			mount_component(customcheckbox5, div1, null);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, t10);
    			append_dev(div2, t11);
    			append_dev(div4, t12);
    			append_dev(div4, div3);
    			mount_component(customselect, div3, null);
    			append_dev(div3, t13);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div3, t14);
    			append_dev(div3, button1);
    			append_dev(div3, t16);
    			append_dev(div3, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*browse_folder*/ ctx[49], false, false, false),
    					listen_dev(button1, "click", /*loadConfig*/ ctx[51], false, false, false),
    					listen_dev(button2, "click", /*click_handler_3*/ ctx[99], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*currentLocation*/ 128) {
    				updating_value = true;
    				textfield0_changes.value = /*currentLocation*/ ctx[7];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*savefilename*/ 16777216) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*savefilename*/ ctx[24];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const customcheckbox0_changes = {};

    			if (!updating_selected && dirty[0] & /*writefile*/ 33554432) {
    				updating_selected = true;
    				customcheckbox0_changes.selected = /*writefile*/ ctx[25];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customcheckbox0.$set(customcheckbox0_changes);
    			const customcheckbox1_changes = {};

    			if (!updating_selected_1 && dirty[0] & /*includeCollision*/ 67108864) {
    				updating_selected_1 = true;
    				customcheckbox1_changes.selected = /*includeCollision*/ ctx[26];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customcheckbox1.$set(customcheckbox1_changes);
    			const customcheckbox2_changes = {};

    			if (!updating_selected_2 && dirty[0] & /*includeAttachmentRate*/ 268435456) {
    				updating_selected_2 = true;
    				customcheckbox2_changes.selected = /*includeAttachmentRate*/ ctx[28];
    				add_flush_callback(() => updating_selected_2 = false);
    			}

    			customcheckbox2.$set(customcheckbox2_changes);
    			const customcheckbox3_changes = {};

    			if (!updating_selected_3 && dirty[0] & /*includeSpontaneousEmission*/ 134217728) {
    				updating_selected_3 = true;
    				customcheckbox3_changes.selected = /*includeSpontaneousEmission*/ ctx[27];
    				add_flush_callback(() => updating_selected_3 = false);
    			}

    			customcheckbox3.$set(customcheckbox3_changes);
    			const customcheckbox4_changes = {};

    			if (!updating_selected_4 && dirty[0] & /*electronSpin*/ 2) {
    				updating_selected_4 = true;
    				customcheckbox4_changes.selected = /*electronSpin*/ ctx[1];
    				add_flush_callback(() => updating_selected_4 = false);
    			}

    			customcheckbox4.$set(customcheckbox4_changes);
    			const customcheckbox5_changes = {};

    			if (!updating_selected_5 && dirty[0] & /*zeemanSplit*/ 4) {
    				updating_selected_5 = true;
    				customcheckbox5_changes.selected = /*zeemanSplit*/ ctx[2];
    				add_flush_callback(() => updating_selected_5 = false);
    			}

    			customcheckbox5.$set(customcheckbox5_changes);
    			if (!current || dirty[0] & /*variable*/ 536870912) set_data_dev(t11, /*variable*/ ctx[29]);
    			const customselect_changes = {};

    			if (!updating_picked && dirty[0] & /*variable*/ 536870912) {
    				updating_picked = true;
    				customselect_changes.picked = /*variable*/ ctx[29];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);

    			if (/*variable*/ ctx[29] !== "time") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*variable*/ 536870912) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, t14);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(customcheckbox0.$$.fragment, local);
    			transition_in(customcheckbox1.$$.fragment, local);
    			transition_in(customcheckbox2.$$.fragment, local);
    			transition_in(customcheckbox3.$$.fragment, local);
    			transition_in(customcheckbox4.$$.fragment, local);
    			transition_in(customcheckbox5.$$.fragment, local);
    			transition_in(customselect.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(customcheckbox0.$$.fragment, local);
    			transition_out(customcheckbox1.$$.fragment, local);
    			transition_out(customcheckbox2.$$.fragment, local);
    			transition_out(customcheckbox3.$$.fragment, local);
    			transition_out(customcheckbox4.$$.fragment, local);
    			transition_out(customcheckbox5.$$.fragment, local);
    			transition_out(customselect.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(customcheckbox0);
    			destroy_component(customcheckbox1);
    			destroy_component(customcheckbox2);
    			destroy_component(customcheckbox3);
    			destroy_component(customcheckbox4);
    			destroy_component(customcheckbox5);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div4);
    			destroy_component(customselect);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_content__slot_slot.name,
    		type: "slot",
    		source: "(368:8) <svelte:fragment slot=\\\"header_content__slot\\\" >",
    		ctx
    	});

    	return block;
    }

    // (412:24) {#each mainParameters as {label, value, id}
    function create_each_block_4(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[63](value, /*value*/ ctx[113], /*each_value_4*/ ctx[125], /*each_index_4*/ ctx[126]);
    	}

    	let textfield_props = { label: /*label*/ ctx[112] };

    	if (/*value*/ ctx[113] !== void 0) {
    		textfield_props.value = /*value*/ ctx[113];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*mainParameters*/ 16) textfield_changes.label = /*label*/ ctx[112];

    			if (!updating_value && dirty[0] & /*mainParameters*/ 16) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[113];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(412:24) {#each mainParameters as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (430:24) {#each energyLevels as {label, value, id}
    function create_each_block_3(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[67](value, /*value*/ ctx[113], /*each_value_3*/ ctx[123], /*each_index_3*/ ctx[124]);
    	}

    	let textfield_props = { label: /*label*/ ctx[112] };

    	if (/*value*/ ctx[113] !== void 0) {
    		textfield_props.value = /*value*/ ctx[113];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*energyLevels*/ 512) textfield_changes.label = /*label*/ ctx[112];

    			if (!updating_value && dirty[0] & /*energyLevels*/ 512) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[113];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(430:24) {#each energyLevels as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (442:24) {#each simulationParameters as {label, value, id}
    function create_each_block_2(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_2(value) {
    		/*textfield_value_binding_2*/ ctx[68](value, /*value*/ ctx[113], /*each_value_2*/ ctx[121], /*each_index_2*/ ctx[122]);
    	}

    	let textfield_props = { label: /*label*/ ctx[112] };

    	if (/*value*/ ctx[113] !== void 0) {
    		textfield_props.value = /*value*/ ctx[113];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_2));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*simulationParameters*/ 32768) textfield_changes.label = /*label*/ ctx[112];

    			if (!updating_value && dirty[0] & /*simulationParameters*/ 32768) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[113];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(442:24) {#each simulationParameters as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (462:24) {#each dopplerLineshape as {label, value, type, step, id}
    function create_each_block_1(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_3(value) {
    		/*textfield_value_binding_3*/ ctx[72](value, /*value*/ ctx[113], /*each_value_1*/ ctx[119], /*each_index_1*/ ctx[120]);
    	}

    	let textfield_props = {
    		label: /*label*/ ctx[112],
    		input$type: /*type*/ ctx[117],
    		input$step: /*step*/ ctx[118]
    	};

    	if (/*value*/ ctx[113] !== void 0) {
    		textfield_props.value = /*value*/ ctx[113];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_3));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*dopplerLineshape*/ 32) textfield_changes.label = /*label*/ ctx[112];
    			if (dirty[0] & /*dopplerLineshape*/ 32) textfield_changes.input$type = /*type*/ ctx[117];
    			if (dirty[0] & /*dopplerLineshape*/ 32) textfield_changes.input$step = /*step*/ ctx[118];

    			if (!updating_value && dirty[0] & /*dopplerLineshape*/ 32) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[113];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(462:24) {#each dopplerLineshape as {label, value, type, step, id}",
    		ctx
    	});

    	return block;
    }

    // (476:24) {#each powerBroadening as {label, value, id}
    function create_each_block$2(key_1, ctx) {
    	let first;
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding_4(value) {
    		/*textfield_value_binding_4*/ ctx[75](value, /*value*/ ctx[113], /*each_value*/ ctx[115], /*each_index*/ ctx[116]);
    	}

    	let textfield_props = { label: /*label*/ ctx[112] };

    	if (/*value*/ ctx[113] !== void 0) {
    		textfield_props.value = /*value*/ ctx[113];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_4));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(textfield.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const textfield_changes = {};
    			if (dirty[0] & /*powerBroadening*/ 64) textfield_changes.label = /*label*/ ctx[112];

    			if (!updating_value && dirty[0] & /*powerBroadening*/ 64) {
    				updating_value = true;
    				textfield_changes.value = /*value*/ ctx[113];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(476:24) {#each powerBroadening as {label, value, id}",
    		ctx
    	});

    	return block;
    }

    // (486:16) {#if includeCollision}
    function create_if_block_5(ctx) {
    	let collisionalcoefficients;
    	let updating_collisionalCoefficient;
    	let updating_collisionalCoefficient_balance;
    	let updating_collisionalRateType;
    	let updating_collisionalRates;
    	let updating_numberDensity;
    	let current;

    	const collisionalcoefficients_spread_levels = [
    		{
    			energyLevels: /*energyLevels*/ ctx[9],
    			electronSpin: /*electronSpin*/ ctx[1],
    			zeemanSplit: /*zeemanSplit*/ ctx[2],
    			energyUnit: /*energyUnit*/ ctx[8],
    			collisionalFilename: /*collisionalFilename*/ ctx[37],
    			collisionalTemp: /*collisionalTemp*/ ctx[41]
    		}
    	];

    	function collisionalcoefficients_collisionalCoefficient_binding(value) {
    		/*collisionalcoefficients_collisionalCoefficient_binding*/ ctx[80](value);
    	}

    	function collisionalcoefficients_collisionalCoefficient_balance_binding(value) {
    		/*collisionalcoefficients_collisionalCoefficient_balance_binding*/ ctx[81](value);
    	}

    	function collisionalcoefficients_collisionalRateType_binding(value) {
    		/*collisionalcoefficients_collisionalRateType_binding*/ ctx[82](value);
    	}

    	function collisionalcoefficients_collisionalRates_binding(value) {
    		/*collisionalcoefficients_collisionalRates_binding*/ ctx[83](value);
    	}

    	function collisionalcoefficients_numberDensity_binding(value) {
    		/*collisionalcoefficients_numberDensity_binding*/ ctx[84](value);
    	}

    	let collisionalcoefficients_props = {};

    	for (let i = 0; i < collisionalcoefficients_spread_levels.length; i += 1) {
    		collisionalcoefficients_props = assign(collisionalcoefficients_props, collisionalcoefficients_spread_levels[i]);
    	}

    	if (/*collisionalCoefficient*/ ctx[31] !== void 0) {
    		collisionalcoefficients_props.collisionalCoefficient = /*collisionalCoefficient*/ ctx[31];
    	}

    	if (/*collisionalCoefficient_balance*/ ctx[38] !== void 0) {
    		collisionalcoefficients_props.collisionalCoefficient_balance = /*collisionalCoefficient_balance*/ ctx[38];
    	}

    	if (/*collisionalRateType*/ ctx[3] !== void 0) {
    		collisionalcoefficients_props.collisionalRateType = /*collisionalRateType*/ ctx[3];
    	}

    	if (/*collisionalRates*/ ctx[22] !== void 0) {
    		collisionalcoefficients_props.collisionalRates = /*collisionalRates*/ ctx[22];
    	}

    	if (/*numberDensity*/ ctx[34] !== void 0) {
    		collisionalcoefficients_props.numberDensity = /*numberDensity*/ ctx[34];
    	}

    	collisionalcoefficients = new CollisionalCoefficients({
    			props: collisionalcoefficients_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(collisionalcoefficients, 'collisionalCoefficient', collisionalcoefficients_collisionalCoefficient_binding));
    	binding_callbacks.push(() => bind(collisionalcoefficients, 'collisionalCoefficient_balance', collisionalcoefficients_collisionalCoefficient_balance_binding));
    	binding_callbacks.push(() => bind(collisionalcoefficients, 'collisionalRateType', collisionalcoefficients_collisionalRateType_binding));
    	binding_callbacks.push(() => bind(collisionalcoefficients, 'collisionalRates', collisionalcoefficients_collisionalRates_binding));
    	binding_callbacks.push(() => bind(collisionalcoefficients, 'numberDensity', collisionalcoefficients_numberDensity_binding));

    	const block = {
    		c: function create() {
    			create_component(collisionalcoefficients.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(collisionalcoefficients, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const collisionalcoefficients_changes = (dirty[0] & /*energyLevels, electronSpin, zeemanSplit, energyUnit*/ 774 | dirty[1] & /*collisionalFilename, collisionalTemp*/ 1088)
    			? get_spread_update(collisionalcoefficients_spread_levels, [
    					{
    						energyLevels: /*energyLevels*/ ctx[9],
    						electronSpin: /*electronSpin*/ ctx[1],
    						zeemanSplit: /*zeemanSplit*/ ctx[2],
    						energyUnit: /*energyUnit*/ ctx[8],
    						collisionalFilename: /*collisionalFilename*/ ctx[37],
    						collisionalTemp: /*collisionalTemp*/ ctx[41]
    					}
    				])
    			: {};

    			if (!updating_collisionalCoefficient && dirty[1] & /*collisionalCoefficient*/ 1) {
    				updating_collisionalCoefficient = true;
    				collisionalcoefficients_changes.collisionalCoefficient = /*collisionalCoefficient*/ ctx[31];
    				add_flush_callback(() => updating_collisionalCoefficient = false);
    			}

    			if (!updating_collisionalCoefficient_balance && dirty[1] & /*collisionalCoefficient_balance*/ 128) {
    				updating_collisionalCoefficient_balance = true;
    				collisionalcoefficients_changes.collisionalCoefficient_balance = /*collisionalCoefficient_balance*/ ctx[38];
    				add_flush_callback(() => updating_collisionalCoefficient_balance = false);
    			}

    			if (!updating_collisionalRateType && dirty[0] & /*collisionalRateType*/ 8) {
    				updating_collisionalRateType = true;
    				collisionalcoefficients_changes.collisionalRateType = /*collisionalRateType*/ ctx[3];
    				add_flush_callback(() => updating_collisionalRateType = false);
    			}

    			if (!updating_collisionalRates && dirty[0] & /*collisionalRates*/ 4194304) {
    				updating_collisionalRates = true;
    				collisionalcoefficients_changes.collisionalRates = /*collisionalRates*/ ctx[22];
    				add_flush_callback(() => updating_collisionalRates = false);
    			}

    			if (!updating_numberDensity && dirty[1] & /*numberDensity*/ 8) {
    				updating_numberDensity = true;
    				collisionalcoefficients_changes.numberDensity = /*numberDensity*/ ctx[34];
    				add_flush_callback(() => updating_numberDensity = false);
    			}

    			collisionalcoefficients.$set(collisionalcoefficients_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(collisionalcoefficients.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(collisionalcoefficients.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(collisionalcoefficients, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(486:16) {#if includeCollision}",
    		ctx
    	});

    	return block;
    }

    // (491:16) {#if includeAttachmentRate}
    function create_if_block_4(ctx) {
    	let attachmentcoefficients;
    	let updating_attachmentCoefficients;
    	let updating_k3;
    	let updating_kCID;
    	let updating_numberDensity;
    	let current;

    	function attachmentcoefficients_attachmentCoefficients_binding(value) {
    		/*attachmentcoefficients_attachmentCoefficients_binding*/ ctx[85](value);
    	}

    	function attachmentcoefficients_k3_binding(value) {
    		/*attachmentcoefficients_k3_binding*/ ctx[86](value);
    	}

    	function attachmentcoefficients_kCID_binding(value) {
    		/*attachmentcoefficients_kCID_binding*/ ctx[87](value);
    	}

    	function attachmentcoefficients_numberDensity_binding(value) {
    		/*attachmentcoefficients_numberDensity_binding*/ ctx[88](value);
    	}

    	let attachmentcoefficients_props = {};

    	if (/*attachmentCoefficients*/ ctx[16] !== void 0) {
    		attachmentcoefficients_props.attachmentCoefficients = /*attachmentCoefficients*/ ctx[16];
    	}

    	if (/*k3*/ ctx[17] !== void 0) {
    		attachmentcoefficients_props.k3 = /*k3*/ ctx[17];
    	}

    	if (/*kCID*/ ctx[18] !== void 0) {
    		attachmentcoefficients_props.kCID = /*kCID*/ ctx[18];
    	}

    	if (/*numberDensity*/ ctx[34] !== void 0) {
    		attachmentcoefficients_props.numberDensity = /*numberDensity*/ ctx[34];
    	}

    	attachmentcoefficients = new AttachmentCoefficients({
    			props: attachmentcoefficients_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(attachmentcoefficients, 'attachmentCoefficients', attachmentcoefficients_attachmentCoefficients_binding));
    	binding_callbacks.push(() => bind(attachmentcoefficients, 'k3', attachmentcoefficients_k3_binding));
    	binding_callbacks.push(() => bind(attachmentcoefficients, 'kCID', attachmentcoefficients_kCID_binding));
    	binding_callbacks.push(() => bind(attachmentcoefficients, 'numberDensity', attachmentcoefficients_numberDensity_binding));

    	const block = {
    		c: function create() {
    			create_component(attachmentcoefficients.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(attachmentcoefficients, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const attachmentcoefficients_changes = {};

    			if (!updating_attachmentCoefficients && dirty[0] & /*attachmentCoefficients*/ 65536) {
    				updating_attachmentCoefficients = true;
    				attachmentcoefficients_changes.attachmentCoefficients = /*attachmentCoefficients*/ ctx[16];
    				add_flush_callback(() => updating_attachmentCoefficients = false);
    			}

    			if (!updating_k3 && dirty[0] & /*k3*/ 131072) {
    				updating_k3 = true;
    				attachmentcoefficients_changes.k3 = /*k3*/ ctx[17];
    				add_flush_callback(() => updating_k3 = false);
    			}

    			if (!updating_kCID && dirty[0] & /*kCID*/ 262144) {
    				updating_kCID = true;
    				attachmentcoefficients_changes.kCID = /*kCID*/ ctx[18];
    				add_flush_callback(() => updating_kCID = false);
    			}

    			if (!updating_numberDensity && dirty[1] & /*numberDensity*/ 8) {
    				updating_numberDensity = true;
    				attachmentcoefficients_changes.numberDensity = /*numberDensity*/ ctx[34];
    				add_flush_callback(() => updating_numberDensity = false);
    			}

    			attachmentcoefficients.$set(attachmentcoefficients_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(attachmentcoefficients.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(attachmentcoefficients.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(attachmentcoefficients, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(491:16) {#if includeAttachmentRate}",
    		ctx
    	});

    	return block;
    }

    // (402:8) <svelte:fragment slot="main_content__slot">
    function create_main_content__slot_slot(ctx) {
    	let div0;
    	let hr0;
    	let t0_value = (/*statusReport*/ ctx[20] || "Status report") + "";
    	let t0;
    	let hr1;
    	let t1;
    	let div19;
    	let div3;
    	let div1;
    	let t3;
    	let div2;
    	let each_blocks_4 = [];
    	let each0_lookup = new Map();
    	let t4;
    	let div7;
    	let div4;
    	let t6;
    	let div5;
    	let textfield0;
    	let updating_value;
    	let t7;
    	let customselect0;
    	let updating_picked;
    	let t8;
    	let button;
    	let t10;
    	let div6;
    	let each_blocks_3 = [];
    	let each1_lookup = new Map();
    	let t11;
    	let div12;
    	let div8;
    	let t13;
    	let div11;
    	let each_blocks_2 = [];
    	let each2_lookup = new Map();
    	let t14;
    	let hr2;
    	let t15;
    	let div9;
    	let t17;
    	let hr3;
    	let t18;
    	let div10;
    	let customselect1;
    	let updating_picked_1;
    	let t19;
    	let customselect2;
    	let updating_picked_2;
    	let t20;
    	let textfield1;
    	let updating_value_1;
    	let t21;
    	let div15;
    	let div13;
    	let t23;
    	let div14;
    	let each_blocks_1 = [];
    	let each3_lookup = new Map();
    	let t24;
    	let textfield2;
    	let updating_value_2;
    	let t25;
    	let textfield3;
    	let updating_value_3;
    	let t26;
    	let div18;
    	let div16;
    	let t28;
    	let div17;
    	let each_blocks = [];
    	let each4_lookup = new Map();
    	let t29;
    	let textfield4;
    	let updating_value_4;
    	let t30;
    	let einsteincoefficients;
    	let updating_einsteinCoefficientA;
    	let updating_einsteinCoefficientB;
    	let updating_einsteinB_rateComputed;
    	let t31;
    	let t32;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_4 = /*mainParameters*/ ctx[4];
    	validate_each_argument(each_value_4);
    	const get_key = ctx => /*id*/ ctx[114];
    	validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		let child_ctx = get_each_context_4(ctx, each_value_4, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_4[i] = create_each_block_4(key, child_ctx));
    	}

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[64](value);
    	}

    	let textfield0_props = {
    		label: "numberOfLevels (J levels)",
    		input$step: 1,
    		input$min: 0,
    		input$type: "number"
    	};

    	if (/*numberOfLevels*/ ctx[35] !== void 0) {
    		textfield0_props.value = /*numberOfLevels*/ ctx[35];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function customselect0_picked_binding(value) {
    		/*customselect0_picked_binding*/ ctx[65](value);
    	}

    	let customselect0_props = { options: ["MHz", "cm-1"] };

    	if (/*energyUnit*/ ctx[8] !== void 0) {
    		customselect0_props.picked = /*energyUnit*/ ctx[8];
    	}

    	customselect0 = new CustomSelect$1({
    			props: customselect0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect0, 'picked', customselect0_picked_binding));
    	let each_value_3 = /*energyLevels*/ ctx[9];
    	validate_each_argument(each_value_3);
    	const get_key_1 = ctx => /*id*/ ctx[114];
    	validate_each_keys(ctx, each_value_3, get_each_context_3, get_key_1);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3(ctx, each_value_3, i);
    		let key = get_key_1(child_ctx);
    		each1_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
    	}

    	let each_value_2 = /*simulationParameters*/ ctx[15];
    	validate_each_argument(each_value_2);
    	const get_key_2 = ctx => /*id*/ ctx[114];
    	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key_2);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key_2(child_ctx);
    		each2_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
    	}

    	function customselect1_picked_binding(value) {
    		/*customselect1_picked_binding*/ ctx[69](value);
    	}

    	let customselect1_props = {
    		options: ["", .../*energyLevels*/ ctx[9].map(func)],
    		label: "excitedFrom",
    		style: "min-width: 7em;"
    	};

    	if (/*excitedFrom*/ ctx[12] !== void 0) {
    		customselect1_props.picked = /*excitedFrom*/ ctx[12];
    	}

    	customselect1 = new CustomSelect$1({
    			props: customselect1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect1, 'picked', customselect1_picked_binding));

    	function customselect2_picked_binding(value) {
    		/*customselect2_picked_binding*/ ctx[70](value);
    	}

    	let customselect2_props = {
    		options: ["", .../*energyLevels*/ ctx[9].map(func_1)],
    		label: "excitedTo",
    		style: "min-width: 7em;"
    	};

    	if (/*excitedTo*/ ctx[11] !== void 0) {
    		customselect2_props.picked = /*excitedTo*/ ctx[11];
    	}

    	customselect2 = new CustomSelect$1({
    			props: customselect2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect2, 'picked', customselect2_picked_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[71](value);
    	}

    	let textfield1_props = {
    		label: "transitionFrequency (" + /*energyUnit*/ ctx[8] + ")"
    	};

    	if (/*transitionFrequency*/ ctx[13] !== void 0) {
    		textfield1_props.value = /*transitionFrequency*/ ctx[13];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	let each_value_1 = /*dopplerLineshape*/ ctx[5];
    	validate_each_argument(each_value_1);
    	const get_key_3 = ctx => /*id*/ ctx[114];
    	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key_3);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1(ctx, each_value_1, i);
    		let key = get_key_3(child_ctx);
    		each3_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
    	}

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[73](value);
    	}

    	let textfield2_props = {
    		label: "collisionalTemp(K)",
    		disabled: true
    	};

    	if (/*collisionalTemp*/ ctx[41] !== void 0) {
    		textfield2_props.value = /*collisionalTemp*/ ctx[41];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[74](value);
    	}

    	let textfield3_props = { label: "gaussian(MHz)", disabled: true };

    	if (/*gaussian*/ ctx[40] !== void 0) {
    		textfield3_props.value = /*gaussian*/ ctx[40];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));
    	let each_value = /*powerBroadening*/ ctx[6];
    	validate_each_argument(each_value);
    	const get_key_4 = ctx => /*id*/ ctx[114];
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key_4);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key_4(child_ctx);
    		each4_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[76](value);
    	}

    	let textfield4_props = { label: "lorrentz(MHz)", disabled: true };

    	if (/*lorrentz*/ ctx[42] !== void 0) {
    		textfield4_props.value = /*lorrentz*/ ctx[42];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));

    	function einsteincoefficients_einsteinCoefficientA_binding(value) {
    		/*einsteincoefficients_einsteinCoefficientA_binding*/ ctx[77](value);
    	}

    	function einsteincoefficients_einsteinCoefficientB_binding(value) {
    		/*einsteincoefficients_einsteinCoefficientB_binding*/ ctx[78](value);
    	}

    	function einsteincoefficients_einsteinB_rateComputed_binding(value) {
    		/*einsteincoefficients_einsteinB_rateComputed_binding*/ ctx[79](value);
    	}

    	let einsteincoefficients_props = {
    		energyLevels: /*energyLevels*/ ctx[9],
    		electronSpin: /*electronSpin*/ ctx[1],
    		zeemanSplit: /*zeemanSplit*/ ctx[2],
    		energyUnit: /*energyUnit*/ ctx[8],
    		gaussian: /*gaussian*/ ctx[40],
    		trapArea: /*trapArea*/ ctx[10],
    		lorrentz: /*lorrentz*/ ctx[42],
    		power: /*power*/ ctx[14]
    	};

    	if (/*einsteinCoefficientA*/ ctx[32] !== void 0) {
    		einsteincoefficients_props.einsteinCoefficientA = /*einsteinCoefficientA*/ ctx[32];
    	}

    	if (/*einsteinCoefficientB*/ ctx[33] !== void 0) {
    		einsteincoefficients_props.einsteinCoefficientB = /*einsteinCoefficientB*/ ctx[33];
    	}

    	if (/*einsteinB_rateComputed*/ ctx[23] !== void 0) {
    		einsteincoefficients_props.einsteinB_rateComputed = /*einsteinB_rateComputed*/ ctx[23];
    	}

    	einsteincoefficients = new EinsteinCoefficients({
    			props: einsteincoefficients_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(einsteincoefficients, 'einsteinCoefficientA', einsteincoefficients_einsteinCoefficientA_binding));
    	binding_callbacks.push(() => bind(einsteincoefficients, 'einsteinCoefficientB', einsteincoefficients_einsteinCoefficientB_binding));
    	binding_callbacks.push(() => bind(einsteincoefficients, 'einsteinB_rateComputed', einsteincoefficients_einsteinB_rateComputed_binding));
    	let if_block0 = /*includeCollision*/ ctx[26] && create_if_block_5(ctx);
    	let if_block1 = /*includeAttachmentRate*/ ctx[28] && create_if_block_4(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			hr0 = element("hr");
    			t0 = text(t0_value);
    			hr1 = element("hr");
    			t1 = space();
    			div19 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div1.textContent = "Main Parameters";
    			t3 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			t4 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Energy levels";
    			t6 = space();
    			div5 = element("div");
    			create_component(textfield0.$$.fragment);
    			t7 = space();
    			create_component(customselect0.$$.fragment);
    			t8 = space();
    			button = element("button");
    			button.textContent = "Show Boltzman distribution";
    			t10 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t11 = space();
    			div12 = element("div");
    			div8 = element("div");
    			div8.textContent = "Simulation parameters";
    			t13 = space();
    			div11 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t14 = space();
    			hr2 = element("hr");
    			t15 = space();
    			div9 = element("div");
    			div9.textContent = "Transition levels";
    			t17 = space();
    			hr3 = element("hr");
    			t18 = space();
    			div10 = element("div");
    			create_component(customselect1.$$.fragment);
    			t19 = space();
    			create_component(customselect2.$$.fragment);
    			t20 = space();
    			create_component(textfield1.$$.fragment);
    			t21 = space();
    			div15 = element("div");
    			div13 = element("div");
    			div13.textContent = "Doppler lineshape";
    			t23 = space();
    			div14 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t24 = space();
    			create_component(textfield2.$$.fragment);
    			t25 = space();
    			create_component(textfield3.$$.fragment);
    			t26 = space();
    			div18 = element("div");
    			div16 = element("div");
    			div16.textContent = "Lorrentz lineshape";
    			t28 = space();
    			div17 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t29 = space();
    			create_component(textfield4.$$.fragment);
    			t30 = space();
    			create_component(einsteincoefficients.$$.fragment);
    			t31 = space();
    			if (if_block0) if_block0.c();
    			t32 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(hr0, "class", "svelte-1gffrzh");
    			add_location(hr0, file$7, 402, 78, 15367);
    			attr_dev(hr1, "class", "svelte-1gffrzh");
    			add_location(hr1, file$7, 402, 115, 15404);
    			attr_dev(div0, "class", "content status_report__div svelte-1gffrzh");
    			toggle_class(div0, "hide", !/*showreport*/ ctx[21]);
    			add_location(div0, file$7, 402, 12, 15301);
    			attr_dev(div1, "class", "subtitle svelte-1gffrzh");
    			add_location(div1, file$7, 409, 20, 15605);
    			attr_dev(div2, "class", "content__div  svelte-1gffrzh");
    			add_location(div2, file$7, 410, 20, 15670);
    			attr_dev(div3, "class", "sub_container__div box svelte-1gffrzh");
    			add_location(div3, file$7, 407, 16, 15545);
    			attr_dev(div4, "class", "subtitle svelte-1gffrzh");
    			add_location(div4, file$7, 420, 20, 16038);
    			attr_dev(button, "class", "button is-link ");
    			add_location(button, file$7, 425, 24, 16401);
    			attr_dev(div5, "class", "control__div  svelte-1gffrzh");
    			add_location(div5, file$7, 421, 20, 16101);
    			attr_dev(div6, "class", "content__div  svelte-1gffrzh");
    			add_location(div6, file$7, 428, 20, 16555);
    			attr_dev(div7, "class", "sub_container__div box svelte-1gffrzh");
    			add_location(div7, file$7, 419, 16, 15979);
    			attr_dev(div8, "class", "subtitle svelte-1gffrzh");
    			add_location(div8, file$7, 438, 20, 16929);
    			attr_dev(hr2, "class", "svelte-1gffrzh");
    			add_location(hr2, file$7, 444, 24, 17230);
    			attr_dev(div9, "class", "subtitle svelte-1gffrzh");
    			set_style(div9, "width", "100%");
    			set_style(div9, "display", "grid");
    			set_style(div9, "place-items", "center");
    			add_location(div9, file$7, 444, 29, 17235);
    			attr_dev(hr3, "class", "svelte-1gffrzh");
    			add_location(hr3, file$7, 444, 131, 17337);
    			attr_dev(div10, "class", "align h-center");
    			add_location(div10, file$7, 446, 24, 17369);
    			attr_dev(div11, "class", "content__div  svelte-1gffrzh");
    			add_location(div11, file$7, 439, 20, 17000);
    			attr_dev(div12, "class", "sub_container__div box svelte-1gffrzh");
    			add_location(div12, file$7, 437, 16, 16871);
    			attr_dev(div13, "class", "subtitle svelte-1gffrzh");
    			add_location(div13, file$7, 459, 20, 18050);
    			attr_dev(div14, "class", "content__div  svelte-1gffrzh");
    			add_location(div14, file$7, 460, 20, 18117);
    			attr_dev(div15, "class", "sub_container__div box svelte-1gffrzh");
    			add_location(div15, file$7, 457, 16, 17990);
    			attr_dev(div16, "class", "subtitle svelte-1gffrzh");
    			add_location(div16, file$7, 473, 20, 18753);
    			attr_dev(div17, "class", "content__div  svelte-1gffrzh");
    			add_location(div17, file$7, 474, 20, 18821);
    			attr_dev(div18, "class", "sub_container__div box svelte-1gffrzh");
    			add_location(div18, file$7, 472, 16, 18695);
    			attr_dev(div19, "class", "main_container__div svelte-1gffrzh");
    			toggle_class(div19, "hide", /*showreport*/ ctx[21]);
    			add_location(div19, file$7, 406, 12, 15470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, hr0);
    			append_dev(div0, t0);
    			append_dev(div0, hr1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div19, anchor);
    			append_dev(div19, div3);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(div2, null);
    			}

    			append_dev(div19, t4);
    			append_dev(div19, div7);
    			append_dev(div7, div4);
    			append_dev(div7, t6);
    			append_dev(div7, div5);
    			mount_component(textfield0, div5, null);
    			append_dev(div5, t7);
    			mount_component(customselect0, div5, null);
    			append_dev(div5, t8);
    			append_dev(div5, button);
    			append_dev(div7, t10);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div6, null);
    			}

    			append_dev(div19, t11);
    			append_dev(div19, div12);
    			append_dev(div12, div8);
    			append_dev(div12, t13);
    			append_dev(div12, div11);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div11, null);
    			}

    			append_dev(div11, t14);
    			append_dev(div11, hr2);
    			append_dev(div11, t15);
    			append_dev(div11, div9);
    			append_dev(div11, t17);
    			append_dev(div11, hr3);
    			append_dev(div11, t18);
    			append_dev(div11, div10);
    			mount_component(customselect1, div10, null);
    			append_dev(div10, t19);
    			mount_component(customselect2, div10, null);
    			append_dev(div10, t20);
    			mount_component(textfield1, div10, null);
    			append_dev(div19, t21);
    			append_dev(div19, div15);
    			append_dev(div15, div13);
    			append_dev(div15, t23);
    			append_dev(div15, div14);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div14, null);
    			}

    			append_dev(div14, t24);
    			mount_component(textfield2, div14, null);
    			append_dev(div14, t25);
    			mount_component(textfield3, div14, null);
    			append_dev(div19, t26);
    			append_dev(div19, div18);
    			append_dev(div18, div16);
    			append_dev(div18, t28);
    			append_dev(div18, div17);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div17, null);
    			}

    			append_dev(div17, t29);
    			mount_component(textfield4, div17, null);
    			append_dev(div19, t30);
    			mount_component(einsteincoefficients, div19, null);
    			append_dev(div19, t31);
    			if (if_block0) if_block0.m(div19, null);
    			append_dev(div19, t32);
    			if (if_block1) if_block1.m(div19, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[66], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*statusReport*/ 1048576) && t0_value !== (t0_value = (/*statusReport*/ ctx[20] || "Status report") + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*showreport*/ 2097152) {
    				toggle_class(div0, "hide", !/*showreport*/ ctx[21]);
    			}

    			if (dirty[0] & /*mainParameters*/ 16) {
    				each_value_4 = /*mainParameters*/ ctx[4];
    				validate_each_argument(each_value_4);
    				group_outros();
    				validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);
    				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key, 1, ctx, each_value_4, each0_lookup, div2, outro_and_destroy_block, create_each_block_4, null, get_each_context_4);
    				check_outros();
    			}

    			const textfield0_changes = {};

    			if (!updating_value && dirty[1] & /*numberOfLevels*/ 16) {
    				updating_value = true;
    				textfield0_changes.value = /*numberOfLevels*/ ctx[35];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const customselect0_changes = {};

    			if (!updating_picked && dirty[0] & /*energyUnit*/ 256) {
    				updating_picked = true;
    				customselect0_changes.picked = /*energyUnit*/ ctx[8];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect0.$set(customselect0_changes);

    			if (dirty[0] & /*energyLevels*/ 512) {
    				each_value_3 = /*energyLevels*/ ctx[9];
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3, get_key_1);
    				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_1, 1, ctx, each_value_3, each1_lookup, div6, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
    				check_outros();
    			}

    			if (dirty[0] & /*simulationParameters*/ 32768) {
    				each_value_2 = /*simulationParameters*/ ctx[15];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key_2);
    				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_2, 1, ctx, each_value_2, each2_lookup, div11, outro_and_destroy_block, create_each_block_2, t14, get_each_context_2);
    				check_outros();
    			}

    			const customselect1_changes = {};
    			if (dirty[0] & /*energyLevels*/ 512) customselect1_changes.options = ["", .../*energyLevels*/ ctx[9].map(func)];

    			if (!updating_picked_1 && dirty[0] & /*excitedFrom*/ 4096) {
    				updating_picked_1 = true;
    				customselect1_changes.picked = /*excitedFrom*/ ctx[12];
    				add_flush_callback(() => updating_picked_1 = false);
    			}

    			customselect1.$set(customselect1_changes);
    			const customselect2_changes = {};
    			if (dirty[0] & /*energyLevels*/ 512) customselect2_changes.options = ["", .../*energyLevels*/ ctx[9].map(func_1)];

    			if (!updating_picked_2 && dirty[0] & /*excitedTo*/ 2048) {
    				updating_picked_2 = true;
    				customselect2_changes.picked = /*excitedTo*/ ctx[11];
    				add_flush_callback(() => updating_picked_2 = false);
    			}

    			customselect2.$set(customselect2_changes);
    			const textfield1_changes = {};
    			if (dirty[0] & /*energyUnit*/ 256) textfield1_changes.label = "transitionFrequency (" + /*energyUnit*/ ctx[8] + ")";

    			if (!updating_value_1 && dirty[0] & /*transitionFrequency*/ 8192) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*transitionFrequency*/ ctx[13];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);

    			if (dirty[0] & /*dopplerLineshape*/ 32) {
    				each_value_1 = /*dopplerLineshape*/ ctx[5];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key_3);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_3, 1, ctx, each_value_1, each3_lookup, div14, outro_and_destroy_block, create_each_block_1, t24, get_each_context_1);
    				check_outros();
    			}

    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[1] & /*collisionalTemp*/ 1024) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*collisionalTemp*/ ctx[41];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty[1] & /*gaussian*/ 512) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*gaussian*/ ctx[40];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);

    			if (dirty[0] & /*powerBroadening*/ 64) {
    				each_value = /*powerBroadening*/ ctx[6];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key_4);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key_4, 1, ctx, each_value, each4_lookup, div17, outro_and_destroy_block, create_each_block$2, t29, get_each_context$2);
    				check_outros();
    			}

    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty[1] & /*lorrentz*/ 2048) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*lorrentz*/ ctx[42];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const einsteincoefficients_changes = {};
    			if (dirty[0] & /*energyLevels*/ 512) einsteincoefficients_changes.energyLevels = /*energyLevels*/ ctx[9];
    			if (dirty[0] & /*electronSpin*/ 2) einsteincoefficients_changes.electronSpin = /*electronSpin*/ ctx[1];
    			if (dirty[0] & /*zeemanSplit*/ 4) einsteincoefficients_changes.zeemanSplit = /*zeemanSplit*/ ctx[2];
    			if (dirty[0] & /*energyUnit*/ 256) einsteincoefficients_changes.energyUnit = /*energyUnit*/ ctx[8];
    			if (dirty[1] & /*gaussian*/ 512) einsteincoefficients_changes.gaussian = /*gaussian*/ ctx[40];
    			if (dirty[0] & /*trapArea*/ 1024) einsteincoefficients_changes.trapArea = /*trapArea*/ ctx[10];
    			if (dirty[1] & /*lorrentz*/ 2048) einsteincoefficients_changes.lorrentz = /*lorrentz*/ ctx[42];
    			if (dirty[0] & /*power*/ 16384) einsteincoefficients_changes.power = /*power*/ ctx[14];

    			if (!updating_einsteinCoefficientA && dirty[1] & /*einsteinCoefficientA*/ 2) {
    				updating_einsteinCoefficientA = true;
    				einsteincoefficients_changes.einsteinCoefficientA = /*einsteinCoefficientA*/ ctx[32];
    				add_flush_callback(() => updating_einsteinCoefficientA = false);
    			}

    			if (!updating_einsteinCoefficientB && dirty[1] & /*einsteinCoefficientB*/ 4) {
    				updating_einsteinCoefficientB = true;
    				einsteincoefficients_changes.einsteinCoefficientB = /*einsteinCoefficientB*/ ctx[33];
    				add_flush_callback(() => updating_einsteinCoefficientB = false);
    			}

    			if (!updating_einsteinB_rateComputed && dirty[0] & /*einsteinB_rateComputed*/ 8388608) {
    				updating_einsteinB_rateComputed = true;
    				einsteincoefficients_changes.einsteinB_rateComputed = /*einsteinB_rateComputed*/ ctx[23];
    				add_flush_callback(() => updating_einsteinB_rateComputed = false);
    			}

    			einsteincoefficients.$set(einsteincoefficients_changes);

    			if (/*includeCollision*/ ctx[26]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*includeCollision*/ 67108864) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div19, t32);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*includeAttachmentRate*/ ctx[28]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*includeAttachmentRate*/ 268435456) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div19, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*showreport*/ 2097152) {
    				toggle_class(div19, "hide", /*showreport*/ ctx[21]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks_4[i]);
    			}

    			transition_in(textfield0.$$.fragment, local);
    			transition_in(customselect0.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			transition_in(customselect1.$$.fragment, local);
    			transition_in(customselect2.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(textfield4.$$.fragment, local);
    			transition_in(einsteincoefficients.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				transition_out(each_blocks_4[i]);
    			}

    			transition_out(textfield0.$$.fragment, local);
    			transition_out(customselect0.$$.fragment, local);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			transition_out(customselect1.$$.fragment, local);
    			transition_out(customselect2.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(textfield4.$$.fragment, local);
    			transition_out(einsteincoefficients.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div19);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].d();
    			}

    			destroy_component(textfield0);
    			destroy_component(customselect0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].d();
    			}

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].d();
    			}

    			destroy_component(customselect1);
    			destroy_component(customselect2);
    			destroy_component(textfield1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			destroy_component(textfield2);
    			destroy_component(textfield3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(textfield4);
    			destroy_component(einsteincoefficients);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_main_content__slot_slot.name,
    		type: "slot",
    		source: "(402:8) <svelte:fragment slot=\\\"main_content__slot\\\">",
    		ctx
    	});

    	return block;
    }

    // (501:16) {#if pyProcesses.length>0}
    function create_if_block_3(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*pyProcesses*/ ctx[19].length + "";
    	let t1;
    	let t2;

    	let t3_value = (/*pyProcesses*/ ctx[19].length > 1
    	? "simulations"
    	: "simulation") + "";

    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Running: ");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			add_location(div, file$7, 501, 20, 20181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pyProcesses*/ 524288 && t1_value !== (t1_value = /*pyProcesses*/ ctx[19].length + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*pyProcesses*/ 524288 && t3_value !== (t3_value = (/*pyProcesses*/ ctx[19].length > 1
    			? "simulations"
    			: "simulation") + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(501:16) {#if pyProcesses.length>0}",
    		ctx
    	});

    	return block;
    }

    // (505:16) {#if pyProcesses.length>0}
    function create_if_block_2$1(ctx) {
    	let button;
    	let button_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Stop";
    			attr_dev(button, "class", "button is-danger");
    			add_location(button, file$7, 505, 20, 20383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*pyKillProcess*/ ctx[47], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!button_transition) button_transition = create_bidirectional_transition(button, fade, {}, true);
    				button_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!button_transition) button_transition = create_bidirectional_transition(button, fade, {}, false);
    			button_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching && button_transition) button_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(505:16) {#if pyProcesses.length>0}",
    		ctx
    	});

    	return block;
    }

    // (508:16) {#if showreport}
    function create_if_block_1$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Clear";
    			attr_dev(button, "class", "button is-warning");
    			add_location(button, file$7, 508, 20, 20552);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[61], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(508:16) {#if showreport}",
    		ctx
    	});

    	return block;
    }

    // (498:8) <svelte:fragment slot="footer_content__slot">
    function create_footer_content__slot_slot(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let button0;
    	let t3_value = (/*showreport*/ ctx[21] ? "Go Back" : "Status report") + "";
    	let t3;
    	let t4;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*pyProcesses*/ ctx[19].length > 0 && create_if_block_3(ctx);
    	let if_block1 = /*pyProcesses*/ ctx[19].length > 0 && create_if_block_2$1(ctx);
    	let if_block2 = /*showreport*/ ctx[21] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			button0 = element("button");
    			t3 = text(t3_value);
    			t4 = space();
    			button1 = element("button");
    			button1.textContent = "Submit";
    			attr_dev(button0, "class", "button is-link");
    			add_location(button0, file$7, 510, 16, 20681);
    			attr_dev(button1, "class", "button is-link");
    			add_location(button1, file$7, 512, 16, 20830);
    			attr_dev(div, "class", "align");
    			add_location(div, file$7, 499, 12, 20096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			append_dev(div, button0);
    			append_dev(button0, t3);
    			append_dev(div, t4);
    			append_dev(div, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[62], false, false, false),
    					listen_dev(button1, "click", /*simulation*/ ctx[48], false, false, false),
    					listen_dev(button1, "pyEvent", /*pyEventHandle*/ ctx[44], false, false, false),
    					listen_dev(button1, "pyEventClosed", /*pyEventClosedHandle*/ ctx[46], false, false, false),
    					listen_dev(button1, "pyEventData", /*pyEventDataReceivedHandle*/ ctx[45], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*pyProcesses*/ ctx[19].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*pyProcesses*/ ctx[19].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*pyProcesses*/ 524288) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showreport*/ ctx[21]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$3(ctx);
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((!current || dirty[0] & /*showreport*/ 2097152) && t3_value !== (t3_value = (/*showreport*/ ctx[21] ? "Go Back" : "Status report") + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_content__slot_slot.name,
    		type: "slot",
    		source: "(498:8) <svelte:fragment slot=\\\"footer_content__slot\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = f => f.label;
    const func_1 = f => f.label;

    function instance$7($$self, $$props, $$invalidate) {
    	let deexcitation;
    	let boltzmanArgs;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ROSAA', slots, []);
    	let { active = false } = $$props;

    	// const dispatch = createEventDispatcher();
    	let electronSpin = false, zeemanSplit = false;

    	let collisionalRateType = "excitation";

    	// let trapTemp = 5.7
    	let [mainParameters, simulationParameters, dopplerLineshape, powerBroadening] = Array(4).fill([]);

    	let attachmentCoefficients = [],
    		k3 = { constant: [], rate: [] },
    		kCID = { constant: [], rate: [] };

    	let py, pyProcesses = [], running = false;

    	const pyEventHandle = e => {
    		$$invalidate(20, statusReport = "");
    		const events = e.detail;
    		py = events.py;
    		console.log(py);
    		$$invalidate(19, pyProcesses = [...pyProcesses, py]);
    	};

    	let statusReport = "";
    	let showreport = false;

    	const pyEventDataReceivedHandle = e => {
    		const { dataReceived } = e.detail;
    		console.log(dataReceived);
    		$$invalidate(20, statusReport += `${dataReceived}\n`);
    	};

    	const pyEventClosedHandle = e => {
    		running = false;
    		$$invalidate(19, pyProcesses = _.difference(pyProcesses, [e.detail.py]));
    		window.createToast("Terminated", "danger");
    		$$invalidate(20, statusReport += "\n######## TERMINATED ########");
    	};

    	const pyKillProcess = () => {
    		const lastInvokedPyProcess = _.last(pyProcesses);

    		if (lastInvokedPyProcess) {
    			lastInvokedPyProcess.kill();
    			pyProcesses.pop();
    		}
    	};

    	let collisionalRates = [];
    	let collisionalRateConstants = [];
    	let einsteinB_rateComputed = false;

    	const simulation = e => {
    		if (!fs.existsSync(currentLocation)) return window.createToast("Location doesn't exist", "danger");
    		if (!configLoaded) return window.createToast("Config file not loaded", "danger");
    		if (!transitionFrequency) return window.createToast("Transition frequency is not defined", "danger");
    		if (!einsteinB_rateComputed) return window.createToast("Compute einsteinB rate constants", "danger");

    		if (includeCollision) {
    			collisionalRateConstants = [...collisionalCoefficient, ...collisionalCoefficient_balance];
    			if (collisionalRateConstants.length < 1) return window.createToast("Compute collisional rate constants", "danger");
    		}

    		if (includeAttachmentRate) {
    			if (k3.constant.length < 1) return window.createToast("Compute attachment rate constants", "danger");
    		}

    		const collisional_rates = {};
    		collisionalRateConstants.forEach(f => collisional_rates[f.label] = f.value);
    		const main_parameters = {};
    		mainParameters.forEach(f => main_parameters[f.label] = f.value);
    		const simulation_parameters = {};
    		simulationParameters.forEach(f => simulation_parameters[f.label] = f.value);
    		const lineshape_conditions = {};
    		dopplerLineshape.forEach(f => lineshape_conditions[f.label] = f.value);
    		const power_broadening = {};
    		powerBroadening.forEach(f => power_broadening[f.label] = f.value);
    		const einstein_coefficient = { A: {}, B: {} };
    		einsteinCoefficientA.forEach(f => einstein_coefficient.A[f.label] = f.value);
    		einsteinCoefficientB.forEach(f => einstein_coefficient.B[f.label] = f.value);

    		const attachment_rate_coefficients = {
    			rateConstants: {
    				k3: k3.constant.map(rate => rate.value),
    				kCID: kCID.constant.map(rate => rate.value)
    			}
    		};

    		attachmentCoefficients.forEach(f => attachment_rate_coefficients[f.label] = f.value);
    		const energy_levels = {};
    		energyLevels.forEach(f => energy_levels[f.label] = f.value);

    		const conditions = {
    			trapTemp,
    			variable,
    			variableRange,
    			numberOfLevels,
    			includeCollision,
    			includeAttachmentRate,
    			includeSpontaneousEmission,
    			writefile,
    			savefilename,
    			currentLocation,
    			deexcitation,
    			collisional_rates,
    			main_parameters,
    			simulation_parameters,
    			einstein_coefficient,
    			energy_levels,
    			energyUnit,
    			power_broadening,
    			lineshape_conditions,
    			attachment_rate_coefficients,
    			electronSpin,
    			zeemanSplit,
    			excitedFrom,
    			excitedTo,
    			numberDensity,
    			collisionalTemp
    		};

    		// const pyfile = "ROSAA/ROSAA_simulation.py"
    		const pyfile = "ROSAA/ROSAA_simulation_newTest.py";

    		const args = [JSON.stringify(conditions)];

    		computePy_func({ e, pyfile, args, general: true }).catch(error => {
    			window.handleError(error);
    		});

    		running = true;
    	};

    	let currentLocation = fs.existsSync(db.get("thz_modal_location"))
    	? db.get("thz_modal_location")
    	: "";

    	let savefilename = "";

    	async function browse_folder() {
    		const result = await browse({ dir: true });

    		if (result) {
    			$$invalidate(7, currentLocation = result[0]);
    		}
    	}

    	let writefile = true,
    		includeCollision = true,
    		includeSpontaneousEmission = true,
    		includeAttachmentRate = true;

    	let variable = "time", variableRange = "1e12, 1e16, 10";
    	const variablesList = ["time", "He density(cm3)", "Power(W)"];

    	let collisionalCoefficient = [],
    		einsteinCoefficientA = [],
    		einsteinCoefficientB = [];

    	let energyUnit = "cm-1", numberDensity = "2e14";
    	let numberOfLevels = 3;
    	let energyLevels = [];
    	let boltzmanWindow = false;
    	let energyFilename, collisionalFilename, einsteinFilename;
    	let collisionalCoefficient_balance = [];
    	let configFile = db.get("ROSAA_config_file") || "";
    	let configLoaded = false;

    	async function loadConfig() {
    		try {
    			if (fs.existsSync(configFile)) return setConfig();
    			const congFilePath = await browse({ dir: false, multiple: false });
    			if (!congFilePath) return window.createToast("No files selected", "danger");
    			$$invalidate(39, configFile = congFilePath[0]);
    			db.set("ROSAA_config_file", configFile);
    			setConfig();
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const getYMLFileContents = filename => {
    		if (fs.existsSync(filename)) {
    			const fileContent = fs.readFileSync(filename);
    			const YMLcontent = parse(fileContent);
    			return Promise.resolve(YMLcontent);
    		} else return Promise.reject(filename + " file doesn't exist");
    	};

    	const setID = obj => {
    		obj.id = window.getID();
    		return obj;
    	};

    	const correctObjValue = obj => {
    		obj.value = obj.value.toExponential(3);
    		return obj;
    	};

    	let trapArea;

    	// Transition freq.
    	let excitedTo = 1, excitedFrom = 0;

    	let transitionFrequency = 0, transitionFrequencyInHz;

    	// Doppler linewidth parameters
    	let ionMass = 14,
    		RGmass = 4,
    		ionTemp = 12,
    		trapTemp = 5,
    		gaussian = 0,
    		collisionalTemp = 0;

    	let Cg = 0; // doppler-broadening proportionality constant

    	// Lorrentz linewidth parameters
    	let lorrentz = 0, power = "2e-5", dipole = 1;

    	let Cp = 0; // power-broadening proportionality constant

    	async function setConfig() {
    		try {
    			const configFileLocation = dirname(configFile);
    			const CONFIG = parse(fs.readFileSync(configFile));
    			let attachmentRateConstants = {};
    			$$invalidate(4, { mainParameters, simulationParameters, dopplerLineshape, powerBroadening, attachmentCoefficients, attachmentRateConstants } = CONFIG, mainParameters, $$invalidate(15, simulationParameters), $$invalidate(5, dopplerLineshape), $$invalidate(6, powerBroadening), $$invalidate(16, attachmentCoefficients));
    			$$invalidate(4, mainParameters = mainParameters.map(setID));
    			$$invalidate(15, simulationParameters = simulationParameters.map(setID));
    			$$invalidate(5, dopplerLineshape = dopplerLineshape.map(setID));
    			$$invalidate(6, powerBroadening = powerBroadening.map(setID));
    			$$invalidate(16, attachmentCoefficients = attachmentCoefficients.map(setID));
    			$$invalidate(17, k3.constant = attachmentRateConstants.k3.map(setID).map(correctObjValue), k3);
    			$$invalidate(18, kCID.constant = attachmentRateConstants.kCID.map(setID).map(correctObjValue), kCID);
    			$$invalidate(56, { trapTemp, electronSpin, zeemanSplit, numberDensity } = CONFIG, trapTemp, $$invalidate(1, electronSpin), $$invalidate(2, zeemanSplit), $$invalidate(34, numberDensity));
    			$$invalidate(24, { savefilename } = CONFIG.saveFile, savefilename);
    			const { savelocation } = CONFIG.saveFile;

    			if (fs.existsSync(savelocation)) {
    				$$invalidate(7, currentLocation = savelocation);
    			}

    			
    			$$invalidate(37, { energy: energyFilename, collision: collisionalFilename, einsteinA: einsteinFilename } = CONFIG.filenames, collisionalFilename);
    			energyFilename = window.pathJoin(configFileLocation, energyFilename);
    			$$invalidate(37, collisionalFilename = window.pathJoin(configFileLocation, collisionalFilename));
    			einsteinFilename = window.pathJoin(configFileLocation, einsteinFilename);
    			$$invalidate(9, { levels: energyLevels, unit: energyUnit } = await getYMLFileContents(energyFilename), energyLevels, $$invalidate(8, energyUnit));
    			$$invalidate(9, energyLevels = energyLevels.map(setID));
    			$$invalidate(35, numberOfLevels = energyLevels.length);
    			$$invalidate(32, { rateConstants: einsteinCoefficientA } = await getYMLFileContents(einsteinFilename), einsteinCoefficientA);
    			$$invalidate(32, einsteinCoefficientA = einsteinCoefficientA.map(setID).map(correctObjValue));
    			console.log(energyLevels, collisionalCoefficient, einsteinCoefficientA);
    			window.createToast("CONFIG loaded");
    			configLoaded = true;
    		} catch(error) {
    			window.handleError(error);
    		}
    	}

    	const writable_props = ['active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<ROSAA> was created with unknown prop '${key}'`);
    	});

    	function boltzmandistribution_active_binding(value) {
    		boltzmanWindow = value;
    		$$invalidate(36, boltzmanWindow);
    	}

    	const click_handler = e => {
    		$$invalidate(20, statusReport = "");
    	};

    	const click_handler_1 = e => {
    		$$invalidate(21, showreport = !showreport);
    	};

    	function textfield_value_binding(value$1, value, each_value_4, each_index_4) {
    		each_value_4[each_index_4].value = value$1;
    		$$invalidate(4, mainParameters);
    	}

    	function textfield0_value_binding(value) {
    		numberOfLevels = value;
    		$$invalidate(35, numberOfLevels);
    	}

    	function customselect0_picked_binding(value) {
    		energyUnit = value;
    		$$invalidate(8, energyUnit);
    	}

    	const click_handler_2 = () => $$invalidate(36, boltzmanWindow = true);

    	function textfield_value_binding_1(value$1, value, each_value_3, each_index_3) {
    		each_value_3[each_index_3].value = value$1;
    		$$invalidate(9, energyLevels);
    	}

    	function textfield_value_binding_2(value$1, value, each_value_2, each_index_2) {
    		each_value_2[each_index_2].value = value$1;
    		$$invalidate(15, simulationParameters);
    	}

    	function customselect1_picked_binding(value) {
    		excitedFrom = value;
    		$$invalidate(12, excitedFrom);
    	}

    	function customselect2_picked_binding(value) {
    		excitedTo = value;
    		$$invalidate(11, excitedTo);
    	}

    	function textfield1_value_binding(value) {
    		transitionFrequency = value;
    		((((((((((((((((($$invalidate(13, transitionFrequency), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power));
    	}

    	function textfield_value_binding_3(value$1, value, each_value_1, each_index_1) {
    		each_value_1[each_index_1].value = value$1;
    		$$invalidate(5, dopplerLineshape);
    	}

    	function textfield2_value_binding(value) {
    		collisionalTemp = value;
    		(((((((((((((((((($$invalidate(41, collisionalTemp), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power));
    	}

    	function textfield3_value_binding(value) {
    		gaussian = value;
    		(((((((((((((((((($$invalidate(40, gaussian), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power));
    	}

    	function textfield_value_binding_4(value$1, value, each_value, each_index) {
    		each_value[each_index].value = value$1;
    		$$invalidate(6, powerBroadening);
    	}

    	function textfield4_value_binding(value) {
    		lorrentz = value;
    		(((((((((((((((((($$invalidate(42, lorrentz), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power));
    	}

    	function einsteincoefficients_einsteinCoefficientA_binding(value) {
    		einsteinCoefficientA = value;
    		$$invalidate(32, einsteinCoefficientA);
    	}

    	function einsteincoefficients_einsteinCoefficientB_binding(value) {
    		einsteinCoefficientB = value;
    		$$invalidate(33, einsteinCoefficientB);
    	}

    	function einsteincoefficients_einsteinB_rateComputed_binding(value) {
    		einsteinB_rateComputed = value;
    		$$invalidate(23, einsteinB_rateComputed);
    	}

    	function collisionalcoefficients_collisionalCoefficient_binding(value) {
    		collisionalCoefficient = value;
    		$$invalidate(31, collisionalCoefficient);
    	}

    	function collisionalcoefficients_collisionalCoefficient_balance_binding(value) {
    		collisionalCoefficient_balance = value;
    		$$invalidate(38, collisionalCoefficient_balance);
    	}

    	function collisionalcoefficients_collisionalRateType_binding(value) {
    		collisionalRateType = value;
    		$$invalidate(3, collisionalRateType);
    	}

    	function collisionalcoefficients_collisionalRates_binding(value) {
    		collisionalRates = value;
    		$$invalidate(22, collisionalRates);
    	}

    	function collisionalcoefficients_numberDensity_binding(value) {
    		numberDensity = value;
    		$$invalidate(34, numberDensity);
    	}

    	function attachmentcoefficients_attachmentCoefficients_binding(value) {
    		attachmentCoefficients = value;
    		$$invalidate(16, attachmentCoefficients);
    	}

    	function attachmentcoefficients_k3_binding(value) {
    		k3 = value;
    		$$invalidate(17, k3);
    	}

    	function attachmentcoefficients_kCID_binding(value) {
    		kCID = value;
    		$$invalidate(18, kCID);
    	}

    	function attachmentcoefficients_numberDensity_binding(value) {
    		numberDensity = value;
    		$$invalidate(34, numberDensity);
    	}

    	function textfield0_value_binding_1(value) {
    		currentLocation = value;
    		$$invalidate(7, currentLocation);
    	}

    	function textfield1_value_binding_1(value) {
    		savefilename = value;
    		$$invalidate(24, savefilename);
    	}

    	function customcheckbox0_selected_binding(value) {
    		writefile = value;
    		$$invalidate(25, writefile);
    	}

    	function customcheckbox1_selected_binding(value) {
    		includeCollision = value;
    		$$invalidate(26, includeCollision);
    	}

    	function customcheckbox2_selected_binding(value) {
    		includeAttachmentRate = value;
    		$$invalidate(28, includeAttachmentRate);
    	}

    	function customcheckbox3_selected_binding(value) {
    		includeSpontaneousEmission = value;
    		$$invalidate(27, includeSpontaneousEmission);
    	}

    	function customcheckbox4_selected_binding(value) {
    		electronSpin = value;
    		$$invalidate(1, electronSpin);
    	}

    	function customcheckbox5_selected_binding(value) {
    		zeemanSplit = value;
    		$$invalidate(2, zeemanSplit);
    	}

    	function customselect_picked_binding(value) {
    		variable = value;
    		$$invalidate(29, variable);
    	}

    	function textfield_value_binding_5(value) {
    		variableRange = value;
    		$$invalidate(30, variableRange);
    	}

    	const click_handler_3 = () => {
    		$$invalidate(39, configFile = "");
    		window.createToast("Config file cleared", "warning");
    	};

    	function separatewindow_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    	};

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		browse,
    		Textfield,
    		fade,
    		SeparateWindow,
    		CustomCheckbox: CustomCheckbox$1,
    		CustomSelect: CustomSelect$1,
    		BoltzmanDistribution,
    		Yml: parse,
    		EinsteinCoefficients,
    		CollisionalCoefficients,
    		AttachmentCoefficients,
    		PlanksConstant,
    		SpeedOfLight,
    		boltzmanConstant,
    		DebyeToCm,
    		VaccumPermitivity,
    		amuToKG,
    		findAndGetValue,
    		active,
    		electronSpin,
    		zeemanSplit,
    		collisionalRateType,
    		mainParameters,
    		simulationParameters,
    		dopplerLineshape,
    		powerBroadening,
    		attachmentCoefficients,
    		k3,
    		kCID,
    		py,
    		pyProcesses,
    		running,
    		pyEventHandle,
    		statusReport,
    		showreport,
    		pyEventDataReceivedHandle,
    		pyEventClosedHandle,
    		pyKillProcess,
    		collisionalRates,
    		collisionalRateConstants,
    		einsteinB_rateComputed,
    		simulation,
    		currentLocation,
    		savefilename,
    		browse_folder,
    		writefile,
    		includeCollision,
    		includeSpontaneousEmission,
    		includeAttachmentRate,
    		variable,
    		variableRange,
    		variablesList,
    		collisionalCoefficient,
    		einsteinCoefficientA,
    		einsteinCoefficientB,
    		energyUnit,
    		numberDensity,
    		numberOfLevels,
    		energyLevels,
    		boltzmanWindow,
    		energyFilename,
    		collisionalFilename,
    		einsteinFilename,
    		collisionalCoefficient_balance,
    		configFile,
    		configLoaded,
    		loadConfig,
    		getYMLFileContents,
    		setID,
    		correctObjValue,
    		trapArea,
    		excitedTo,
    		excitedFrom,
    		transitionFrequency,
    		transitionFrequencyInHz,
    		ionMass,
    		RGmass,
    		ionTemp,
    		trapTemp,
    		gaussian,
    		collisionalTemp,
    		Cg,
    		lorrentz,
    		power,
    		dipole,
    		Cp,
    		setConfig,
    		boltzmanArgs,
    		deexcitation
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('electronSpin' in $$props) $$invalidate(1, electronSpin = $$props.electronSpin);
    		if ('zeemanSplit' in $$props) $$invalidate(2, zeemanSplit = $$props.zeemanSplit);
    		if ('collisionalRateType' in $$props) $$invalidate(3, collisionalRateType = $$props.collisionalRateType);
    		if ('mainParameters' in $$props) $$invalidate(4, mainParameters = $$props.mainParameters);
    		if ('simulationParameters' in $$props) $$invalidate(15, simulationParameters = $$props.simulationParameters);
    		if ('dopplerLineshape' in $$props) $$invalidate(5, dopplerLineshape = $$props.dopplerLineshape);
    		if ('powerBroadening' in $$props) $$invalidate(6, powerBroadening = $$props.powerBroadening);
    		if ('attachmentCoefficients' in $$props) $$invalidate(16, attachmentCoefficients = $$props.attachmentCoefficients);
    		if ('k3' in $$props) $$invalidate(17, k3 = $$props.k3);
    		if ('kCID' in $$props) $$invalidate(18, kCID = $$props.kCID);
    		if ('py' in $$props) py = $$props.py;
    		if ('pyProcesses' in $$props) $$invalidate(19, pyProcesses = $$props.pyProcesses);
    		if ('running' in $$props) running = $$props.running;
    		if ('statusReport' in $$props) $$invalidate(20, statusReport = $$props.statusReport);
    		if ('showreport' in $$props) $$invalidate(21, showreport = $$props.showreport);
    		if ('collisionalRates' in $$props) $$invalidate(22, collisionalRates = $$props.collisionalRates);
    		if ('collisionalRateConstants' in $$props) collisionalRateConstants = $$props.collisionalRateConstants;
    		if ('einsteinB_rateComputed' in $$props) $$invalidate(23, einsteinB_rateComputed = $$props.einsteinB_rateComputed);
    		if ('currentLocation' in $$props) $$invalidate(7, currentLocation = $$props.currentLocation);
    		if ('savefilename' in $$props) $$invalidate(24, savefilename = $$props.savefilename);
    		if ('writefile' in $$props) $$invalidate(25, writefile = $$props.writefile);
    		if ('includeCollision' in $$props) $$invalidate(26, includeCollision = $$props.includeCollision);
    		if ('includeSpontaneousEmission' in $$props) $$invalidate(27, includeSpontaneousEmission = $$props.includeSpontaneousEmission);
    		if ('includeAttachmentRate' in $$props) $$invalidate(28, includeAttachmentRate = $$props.includeAttachmentRate);
    		if ('variable' in $$props) $$invalidate(29, variable = $$props.variable);
    		if ('variableRange' in $$props) $$invalidate(30, variableRange = $$props.variableRange);
    		if ('collisionalCoefficient' in $$props) $$invalidate(31, collisionalCoefficient = $$props.collisionalCoefficient);
    		if ('einsteinCoefficientA' in $$props) $$invalidate(32, einsteinCoefficientA = $$props.einsteinCoefficientA);
    		if ('einsteinCoefficientB' in $$props) $$invalidate(33, einsteinCoefficientB = $$props.einsteinCoefficientB);
    		if ('energyUnit' in $$props) $$invalidate(8, energyUnit = $$props.energyUnit);
    		if ('numberDensity' in $$props) $$invalidate(34, numberDensity = $$props.numberDensity);
    		if ('numberOfLevels' in $$props) $$invalidate(35, numberOfLevels = $$props.numberOfLevels);
    		if ('energyLevels' in $$props) $$invalidate(9, energyLevels = $$props.energyLevels);
    		if ('boltzmanWindow' in $$props) $$invalidate(36, boltzmanWindow = $$props.boltzmanWindow);
    		if ('energyFilename' in $$props) energyFilename = $$props.energyFilename;
    		if ('collisionalFilename' in $$props) $$invalidate(37, collisionalFilename = $$props.collisionalFilename);
    		if ('einsteinFilename' in $$props) einsteinFilename = $$props.einsteinFilename;
    		if ('collisionalCoefficient_balance' in $$props) $$invalidate(38, collisionalCoefficient_balance = $$props.collisionalCoefficient_balance);
    		if ('configFile' in $$props) $$invalidate(39, configFile = $$props.configFile);
    		if ('configLoaded' in $$props) configLoaded = $$props.configLoaded;
    		if ('trapArea' in $$props) $$invalidate(10, trapArea = $$props.trapArea);
    		if ('excitedTo' in $$props) $$invalidate(11, excitedTo = $$props.excitedTo);
    		if ('excitedFrom' in $$props) $$invalidate(12, excitedFrom = $$props.excitedFrom);
    		if ('transitionFrequency' in $$props) $$invalidate(13, transitionFrequency = $$props.transitionFrequency);
    		if ('transitionFrequencyInHz' in $$props) $$invalidate(52, transitionFrequencyInHz = $$props.transitionFrequencyInHz);
    		if ('ionMass' in $$props) $$invalidate(53, ionMass = $$props.ionMass);
    		if ('RGmass' in $$props) $$invalidate(54, RGmass = $$props.RGmass);
    		if ('ionTemp' in $$props) $$invalidate(55, ionTemp = $$props.ionTemp);
    		if ('trapTemp' in $$props) $$invalidate(56, trapTemp = $$props.trapTemp);
    		if ('gaussian' in $$props) $$invalidate(40, gaussian = $$props.gaussian);
    		if ('collisionalTemp' in $$props) $$invalidate(41, collisionalTemp = $$props.collisionalTemp);
    		if ('Cg' in $$props) $$invalidate(57, Cg = $$props.Cg);
    		if ('lorrentz' in $$props) $$invalidate(42, lorrentz = $$props.lorrentz);
    		if ('power' in $$props) $$invalidate(14, power = $$props.power);
    		if ('dipole' in $$props) $$invalidate(58, dipole = $$props.dipole);
    		if ('Cp' in $$props) $$invalidate(59, Cp = $$props.Cp);
    		if ('boltzmanArgs' in $$props) $$invalidate(43, boltzmanArgs = $$props.boltzmanArgs);
    		if ('deexcitation' in $$props) deexcitation = $$props.deexcitation;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*collisionalRateType*/ 8) {
    			deexcitation = collisionalRateType === "deexcitation";
    		}

    		if ($$self.$$.dirty[0] & /*currentLocation*/ 128) {
    			if (currentLocation && fs.existsSync(currentLocation)) {
    				db.set("thz_modal_location", currentLocation);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*energyLevels, excitedFrom, excitedTo, energyUnit, transitionFrequency, dopplerLineshape, powerBroadening, mainParameters, trapArea, power*/ 32624 | $$self.$$.dirty[1] & /*RGmass, ionTemp, ionMass, trapTemp, transitionFrequencyInHz, Cg, dipole, Cp*/ 534773760) {
    			// $: console.log({Cg, Cp});
    			{
    				if (energyLevels.length > 1) {
    					const { value: lowerLevelEnergy } = _.find(energyLevels, energy => energy.label == excitedFrom);
    					const { value: upperLevelEnergy } = _.find(energyLevels, energy => energy.label == excitedTo);
    					$$invalidate(13, transitionFrequency = upperLevelEnergy - lowerLevelEnergy);

    					$$invalidate(52, transitionFrequencyInHz = energyUnit == "cm-1"
    					? transitionFrequency * SpeedOfLight * 1e2
    					: transitionFrequency * 1e6);
    				} // console.log({transitionFrequency, transitionFrequencyInHz})

    				if (dopplerLineshape.length) {
    					console.log("Changing doppler parameters");
    					$$invalidate(53, [ionMass, RGmass, ionTemp, trapTemp] = dopplerLineshape.map(f => f.value), ionMass, ((((((((((((((((($$invalidate(54, RGmass), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power)), ((((((((((((((((($$invalidate(55, ionTemp), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power)), ((((((((((((((((($$invalidate(56, trapTemp), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)), $$invalidate(14, power)));
    					$$invalidate(41, collisionalTemp = Number((RGmass * ionTemp + ionMass * trapTemp) / (ionMass + RGmass)).toFixed(1));
    					const sqrtTerm = 8 * boltzmanConstant * Math.log(2) / (ionMass * amuToKG * SpeedOfLight ** 2);
    					$$invalidate(57, Cg = transitionFrequencyInHz * Math.sqrt(sqrtTerm));
    					$$invalidate(40, gaussian = Number(Cg * Math.sqrt(ionTemp) * 1e-6).toFixed(3));
    				}

    				

    				if (powerBroadening.length) {
    					$$invalidate(58, [dipole, power] = powerBroadening.map(f => f.value), dipole, ((((((((((((((((($$invalidate(14, power), $$invalidate(9, energyLevels)), $$invalidate(12, excitedFrom)), $$invalidate(11, excitedTo)), $$invalidate(8, energyUnit)), $$invalidate(13, transitionFrequency)), $$invalidate(5, dopplerLineshape)), $$invalidate(54, RGmass)), $$invalidate(55, ionTemp)), $$invalidate(53, ionMass)), $$invalidate(56, trapTemp)), $$invalidate(52, transitionFrequencyInHz)), $$invalidate(57, Cg)), $$invalidate(6, powerBroadening)), $$invalidate(4, mainParameters)), $$invalidate(58, dipole)), $$invalidate(10, trapArea)), $$invalidate(59, Cp)));
    					$$invalidate(10, trapArea = findAndGetValue(mainParameters, "trap_area (sq-meter)"));
    					$$invalidate(59, Cp = 2 * dipole * DebyeToCm / PlanksConstant * Math.sqrt(1 / (trapArea * SpeedOfLight * VaccumPermitivity)));
    					$$invalidate(42, lorrentz = Number(Cp * Math.sqrt(power) * 1e-6).toFixed(3));
    				}

    				
    			}
    		}

    		if ($$self.$$.dirty[0] & /*energyLevels, electronSpin, zeemanSplit, energyUnit*/ 774 | $$self.$$.dirty[1] & /*trapTemp*/ 33554432) {
    			$$invalidate(43, boltzmanArgs = {
    				energyLevels,
    				trapTemp,
    				electronSpin,
    				zeemanSplit,
    				energyUnit
    			});
    		}
    	};

    	return [
    		active,
    		electronSpin,
    		zeemanSplit,
    		collisionalRateType,
    		mainParameters,
    		dopplerLineshape,
    		powerBroadening,
    		currentLocation,
    		energyUnit,
    		energyLevels,
    		trapArea,
    		excitedTo,
    		excitedFrom,
    		transitionFrequency,
    		power,
    		simulationParameters,
    		attachmentCoefficients,
    		k3,
    		kCID,
    		pyProcesses,
    		statusReport,
    		showreport,
    		collisionalRates,
    		einsteinB_rateComputed,
    		savefilename,
    		writefile,
    		includeCollision,
    		includeSpontaneousEmission,
    		includeAttachmentRate,
    		variable,
    		variableRange,
    		collisionalCoefficient,
    		einsteinCoefficientA,
    		einsteinCoefficientB,
    		numberDensity,
    		numberOfLevels,
    		boltzmanWindow,
    		collisionalFilename,
    		collisionalCoefficient_balance,
    		configFile,
    		gaussian,
    		collisionalTemp,
    		lorrentz,
    		boltzmanArgs,
    		pyEventHandle,
    		pyEventDataReceivedHandle,
    		pyEventClosedHandle,
    		pyKillProcess,
    		simulation,
    		browse_folder,
    		variablesList,
    		loadConfig,
    		transitionFrequencyInHz,
    		ionMass,
    		RGmass,
    		ionTemp,
    		trapTemp,
    		Cg,
    		dipole,
    		Cp,
    		boltzmandistribution_active_binding,
    		click_handler,
    		click_handler_1,
    		textfield_value_binding,
    		textfield0_value_binding,
    		customselect0_picked_binding,
    		click_handler_2,
    		textfield_value_binding_1,
    		textfield_value_binding_2,
    		customselect1_picked_binding,
    		customselect2_picked_binding,
    		textfield1_value_binding,
    		textfield_value_binding_3,
    		textfield2_value_binding,
    		textfield3_value_binding,
    		textfield_value_binding_4,
    		textfield4_value_binding,
    		einsteincoefficients_einsteinCoefficientA_binding,
    		einsteincoefficients_einsteinCoefficientB_binding,
    		einsteincoefficients_einsteinB_rateComputed_binding,
    		collisionalcoefficients_collisionalCoefficient_binding,
    		collisionalcoefficients_collisionalCoefficient_balance_binding,
    		collisionalcoefficients_collisionalRateType_binding,
    		collisionalcoefficients_collisionalRates_binding,
    		collisionalcoefficients_numberDensity_binding,
    		attachmentcoefficients_attachmentCoefficients_binding,
    		attachmentcoefficients_k3_binding,
    		attachmentcoefficients_kCID_binding,
    		attachmentcoefficients_numberDensity_binding,
    		textfield0_value_binding_1,
    		textfield1_value_binding_1,
    		customcheckbox0_selected_binding,
    		customcheckbox1_selected_binding,
    		customcheckbox2_selected_binding,
    		customcheckbox3_selected_binding,
    		customcheckbox4_selected_binding,
    		customcheckbox5_selected_binding,
    		customselect_picked_binding,
    		textfield_value_binding_5,
    		click_handler_3,
    		separatewindow_active_binding
    	];
    }

    class ROSAA extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { active: 0 }, null, [-1, -1, -1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ROSAA",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get active() {
    		throw new Error("<ROSAA>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<ROSAA>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\THz.svelte generated by Svelte v3.42.1 */
    const file$6 = "src\\Pages\\THz.svelte";

    // (82:4) <svelte:fragment slot="buttonContainer">
    function create_buttonContainer_slot(ctx) {
    	let div;
    	let button0;
    	let t0;
    	let t1;
    	let button1;
    	let t2;
    	let t3;
    	let customcheckbox0;
    	let updating_selected;
    	let t4;
    	let customcheckbox1;
    	let updating_selected_1;
    	let t5;
    	let button2;
    	let t6;
    	let t7;
    	let button3;
    	let t8;
    	let t9;
    	let customiconswitch;
    	let updating_toggler;
    	let t10;
    	let textfield0;
    	let updating_value;
    	let t11;
    	let textfield1;
    	let updating_value_1;
    	let current;
    	let mounted;
    	let dispose;

    	function customcheckbox0_selected_binding(value) {
    		/*customcheckbox0_selected_binding*/ ctx[19](value);
    	}

    	let customcheckbox0_props = { label: "Bin" };

    	if (/*binData*/ ctx[8] !== void 0) {
    		customcheckbox0_props.selected = /*binData*/ ctx[8];
    	}

    	customcheckbox0 = new CustomCheckbox$1({
    			props: customcheckbox0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox0, 'selected', customcheckbox0_selected_binding));

    	function customcheckbox1_selected_binding(value) {
    		/*customcheckbox1_selected_binding*/ ctx[20](value);
    	}

    	let customcheckbox1_props = { label: "saveInMHz" };

    	if (/*saveInMHz*/ ctx[9] !== void 0) {
    		customcheckbox1_props.selected = /*saveInMHz*/ ctx[9];
    	}

    	customcheckbox1 = new CustomCheckbox$1({
    			props: customcheckbox1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox1, 'selected', customcheckbox1_selected_binding));

    	function customiconswitch_toggler_binding(value) {
    		/*customiconswitch_toggler_binding*/ ctx[23](value);
    	}

    	let customiconswitch_props = {
    		style: "padding:0;",
    		icons: ["settings_ethernet", "code"]
    	};

    	if (/*openShell*/ ctx[2] !== void 0) {
    		customiconswitch_props.toggler = /*openShell*/ ctx[2];
    	}

    	customiconswitch = new CustomIconSwitch$1({
    			props: customiconswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customiconswitch, 'toggler', customiconswitch_toggler_binding));

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[24](value);
    	}

    	let textfield0_props = {
    		type: "number",
    		label: "Delta",
    		input$step: "0.1"
    	};

    	if (/*delta*/ ctx[4] !== void 0) {
    		textfield0_props.value = /*delta*/ ctx[4];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[25](value);
    	}

    	let textfield1_props = {
    		type: "number",
    		label: "Gamma",
    		input$step: "0.1"
    	};

    	if (/*gamma*/ ctx[5] !== void 0) {
    		textfield1_props.value = /*gamma*/ ctx[5];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			t0 = text("ROSAA");
    			t1 = space();
    			button1 = element("button");
    			t2 = text("Plot");
    			t3 = space();
    			create_component(customcheckbox0.$$.fragment);
    			t4 = space();
    			create_component(customcheckbox1.$$.fragment);
    			t5 = space();
    			button2 = element("button");
    			t6 = text("Fit");
    			t7 = space();
    			button3 = element("button");
    			t8 = text("Open in Matplotlib");
    			t9 = space();
    			create_component(customiconswitch.$$.fragment);
    			t10 = space();
    			create_component(textfield0.$$.fragment);
    			t11 = space();
    			create_component(textfield1.$$.fragment);
    			attr_dev(button0, "class", btnClass);
    			add_location(button0, file$6, 83, 12, 3411);
    			attr_dev(button1, "class", btnClass);
    			add_location(button1, file$6, 84, 12, 3509);
    			attr_dev(button2, "class", btnClass);
    			add_location(button2, file$6, 88, 12, 3760);
    			attr_dev(button3, "class", btnClass);
    			add_location(button3, file$6, 89, 12, 3849);
    			attr_dev(div, "class", "align v-center");
    			add_location(div, file$6, 82, 8, 3369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(button0, t0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(button1, t2);
    			append_dev(div, t3);
    			mount_component(customcheckbox0, div, null);
    			append_dev(div, t4);
    			mount_component(customcheckbox1, div, null);
    			append_dev(div, t5);
    			append_dev(div, button2);
    			append_dev(button2, t6);
    			append_dev(div, t7);
    			append_dev(div, button3);
    			append_dev(button3, t8);
    			append_dev(div, t9);
    			mount_component(customiconswitch, div, null);
    			append_dev(div, t10);
    			mount_component(textfield0, div, null);
    			append_dev(div, t11);
    			mount_component(textfield1, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[17], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[18], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[21], false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const customcheckbox0_changes = {};

    			if (!updating_selected && dirty & /*binData*/ 256) {
    				updating_selected = true;
    				customcheckbox0_changes.selected = /*binData*/ ctx[8];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customcheckbox0.$set(customcheckbox0_changes);
    			const customcheckbox1_changes = {};

    			if (!updating_selected_1 && dirty & /*saveInMHz*/ 512) {
    				updating_selected_1 = true;
    				customcheckbox1_changes.selected = /*saveInMHz*/ ctx[9];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customcheckbox1.$set(customcheckbox1_changes);
    			const customiconswitch_changes = {};

    			if (!updating_toggler && dirty & /*openShell*/ 4) {
    				updating_toggler = true;
    				customiconswitch_changes.toggler = /*openShell*/ ctx[2];
    				add_flush_callback(() => updating_toggler = false);
    			}

    			customiconswitch.$set(customiconswitch_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*delta*/ 16) {
    				updating_value = true;
    				textfield0_changes.value = /*delta*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*gamma*/ 32) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*gamma*/ ctx[5];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customcheckbox0.$$.fragment, local);
    			transition_in(customcheckbox1.$$.fragment, local);
    			transition_in(customiconswitch.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customcheckbox0.$$.fragment, local);
    			transition_out(customcheckbox1.$$.fragment, local);
    			transition_out(customiconswitch.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customcheckbox0);
    			destroy_component(customcheckbox1);
    			destroy_component(customiconswitch);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_buttonContainer_slot.name,
    		type: "slot",
    		source: "(82:4) <svelte:fragment slot=\\\"buttonContainer\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:8) {#if graphPlotted}
    function create_if_block$6(ctx) {
    	let div;
    	let customselect;
    	let updating_picked;
    	let t;
    	let customcheckbox;
    	let updating_selected;
    	let current;
    	let mounted;
    	let dispose;

    	function customselect_picked_binding(value) {
    		/*customselect_picked_binding*/ ctx[15](value);
    	}

    	let customselect_props = {
    		options: /*plotStyle*/ ctx[11],
    		label: "Plot Style"
    	};

    	if (/*plotStyleSelected*/ ctx[6] !== void 0) {
    		customselect_props.picked = /*plotStyleSelected*/ ctx[6];
    	}

    	customselect = new CustomSelect$1({
    			props: customselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customselect, 'picked', customselect_picked_binding));

    	function customcheckbox_selected_binding(value) {
    		/*customcheckbox_selected_binding*/ ctx[16](value);
    	}

    	let customcheckbox_props = { label: "Fill area" };

    	if (/*plotFill*/ ctx[7] !== void 0) {
    		customcheckbox_props.selected = /*plotFill*/ ctx[7];
    	}

    	customcheckbox = new CustomCheckbox$1({
    			props: customcheckbox_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customcheckbox, 'selected', customcheckbox_selected_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(customselect.$$.fragment);
    			t = space();
    			create_component(customcheckbox.$$.fragment);
    			attr_dev(div, "class", "animated fadeIn align h-end v-center");
    			add_location(div, file$6, 105, 12, 4468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(customselect, div, null);
    			append_dev(div, t);
    			mount_component(customcheckbox, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "change", /*changePlotStyle*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const customselect_changes = {};

    			if (!updating_picked && dirty & /*plotStyleSelected*/ 64) {
    				updating_picked = true;
    				customselect_changes.picked = /*plotStyleSelected*/ ctx[6];
    				add_flush_callback(() => updating_picked = false);
    			}

    			customselect.$set(customselect_changes);
    			const customcheckbox_changes = {};

    			if (!updating_selected && dirty & /*plotFill*/ 128) {
    				updating_selected = true;
    				customcheckbox_changes.selected = /*plotFill*/ ctx[7];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customcheckbox.$set(customcheckbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customselect.$$.fragment, local);
    			transition_in(customcheckbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customselect.$$.fragment, local);
    			transition_out(customcheckbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(customselect);
    			destroy_component(customcheckbox);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(104:8) {#if graphPlotted}",
    		ctx
    	});

    	return block;
    }

    // (99:4) <svelte:fragment slot="plotContainer">
    function create_plotContainer_slot(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let if_block = /*graphPlotted*/ ctx[3] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "id", "resOnOffPlot");
    			attr_dev(div0, "class", "graph__div");
    			add_location(div0, file$6, 101, 8, 4373);
    			attr_dev(div1, "id", "thzPlot");
    			attr_dev(div1, "class", "graph__div");
    			add_location(div1, file$6, 112, 8, 4797);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*graphPlotted*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*graphPlotted*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_plotContainer_slot.name,
    		type: "slot",
    		source: "(99:4) <svelte:fragment slot=\\\"plotContainer\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let rosaa;
    	let updating_active;
    	let t;
    	let layout;
    	let updating_currentLocation;
    	let updating_fileChecked;
    	let current;

    	function rosaa_active_binding(value) {
    		/*rosaa_active_binding*/ ctx[14](value);
    	}

    	let rosaa_props = {};

    	if (/*ROSAA_modal_active*/ ctx[10] !== void 0) {
    		rosaa_props.active = /*ROSAA_modal_active*/ ctx[10];
    	}

    	rosaa = new ROSAA({ props: rosaa_props, $$inline: true });
    	binding_callbacks.push(() => bind(rosaa, 'active', rosaa_active_binding));

    	function layout_currentLocation_binding(value) {
    		/*layout_currentLocation_binding*/ ctx[26](value);
    	}

    	function layout_fileChecked_binding(value) {
    		/*layout_fileChecked_binding*/ ctx[27](value);
    	}

    	let layout_props = {
    		filetype,
    		graphPlotted: /*graphPlotted*/ ctx[3],
    		id,
    		$$slots: {
    			plotContainer: [create_plotContainer_slot],
    			buttonContainer: [create_buttonContainer_slot]
    		},
    		$$scope: { ctx }
    	};

    	if (/*currentLocation*/ ctx[1] !== void 0) {
    		layout_props.currentLocation = /*currentLocation*/ ctx[1];
    	}

    	if (/*fileChecked*/ ctx[0] !== void 0) {
    		layout_props.fileChecked = /*fileChecked*/ ctx[0];
    	}

    	layout = new Layout({ props: layout_props, $$inline: true });
    	binding_callbacks.push(() => bind(layout, 'currentLocation', layout_currentLocation_binding));
    	binding_callbacks.push(() => bind(layout, 'fileChecked', layout_fileChecked_binding));

    	const block = {
    		c: function create() {
    			create_component(rosaa.$$.fragment);
    			t = space();
    			create_component(layout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(rosaa, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(layout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const rosaa_changes = {};

    			if (!updating_active && dirty & /*ROSAA_modal_active*/ 1024) {
    				updating_active = true;
    				rosaa_changes.active = /*ROSAA_modal_active*/ ctx[10];
    				add_flush_callback(() => updating_active = false);
    			}

    			rosaa.$set(rosaa_changes);
    			const layout_changes = {};
    			if (dirty & /*graphPlotted*/ 8) layout_changes.graphPlotted = /*graphPlotted*/ ctx[3];

    			if (dirty & /*$$scope, plotFill, plotStyleSelected, graphPlotted, gamma, delta, openShell, saveInMHz, binData, ROSAA_modal_active*/ 1073743868) {
    				layout_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_currentLocation && dirty & /*currentLocation*/ 2) {
    				updating_currentLocation = true;
    				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
    				add_flush_callback(() => updating_currentLocation = false);
    			}

    			if (!updating_fileChecked && dirty & /*fileChecked*/ 1) {
    				updating_fileChecked = true;
    				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
    				add_flush_callback(() => updating_fileChecked = false);
    			}

    			layout.$set(layout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rosaa.$$.fragment, local);
    			transition_in(layout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rosaa.$$.fragment, local);
    			transition_out(layout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rosaa, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(layout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const filetype = "thz", id = "THz";
    const btnClass = "button is-link";

    function instance$6($$self, $$props, $$invalidate) {
    	let thzfiles;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('THz', slots, []);
    	let fileChecked = [];
    	let currentLocation = db.get(`${filetype}_location`) || "";
    	let openShell = false, graphPlotted = false;
    	let delta = 10, gamma = 0;
    	const plotStyle = ["", "lines", "markers", "lines+markers"];
    	let plotStyleSelected = plotStyle[3], plotFill = true;
    	let binData = false, saveInMHz = false;

    	const changePlotStyle = () => {
    		Plotly.restyle("thzPlot", {
    			mode: plotStyleSelected,
    			fill: plotFill ? "tozeroy" : ""
    		});
    	};

    	function plotData(
    		{ e = null, filetype = "thz", tkplot = false, justPlot = false, general = {} } = {}
    	) {
    		if (fileChecked.length === 0 && filetype === "thz") {
    			return window.createToast("No files selected", "danger");
    		}

    		const thz_args = {
    			thzfiles,
    			binData,
    			delta,
    			tkplot,
    			gamma,
    			justPlot,
    			saveInMHz
    		};

    		let pyfileInfo = {
    			general,
    			thz: {
    				pyfile: "thz_scan.py",
    				args: [JSON.stringify(thz_args)]
    			}
    		};

    		let { pyfile, args } = pyfileInfo[filetype];

    		if (tkplot) {
    			filetype = "general";
    		}

    		if (filetype == "general") {
    			return computePy_func({
    				e,
    				pyfile,
    				args,
    				general: true,
    				openShell
    			}).catch(error => {
    				window.handleError(error);
    			});
    		}

    		computePy_func({ e, pyfile, args }).then(dataFromPython => {
    			if (filetype == "thz") {
    				plot(`THz Scan: Depletion (%)`, "Frequency (GHz)", "Depletion (%)", dataFromPython["thz"], "thzPlot");
    				plot(`THz Scan`, "Frequency (GHz)", "Counts", dataFromPython["resOnOff_Counts"], "resOnOffPlot");

    				if (!justPlot) {
    					let lines = [];

    					for (let x in dataFromPython["shapes"]) {
    						lines.push(dataFromPython["shapes"][x]);
    					}

    					let layout_update = { shapes: lines };
    					Plotly.relayout("thzPlot", layout_update);
    				}
    			}

    			window.createToast("Graph plotted", "success");
    			$$invalidate(3, graphPlotted = true);
    		}).catch(error => {
    			window.handleError(error);
    		});
    	}

    	let includePlotsInReport = [
    		{
    			id: "resOnOffPlot",
    			include: false,
    			label: "THz Res-ON/OFF"
    		},
    		{
    			id: "thzPlot",
    			include: true,
    			label: "Normalised THz Spectrum"
    		},
    		{
    			id: "boltzman_plot",
    			include: false,
    			label: "Boltzman plot"
    		}
    	];

    	let ROSAA_modal_active = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<THz> was created with unknown prop '${key}'`);
    	});

    	function rosaa_active_binding(value) {
    		ROSAA_modal_active = value;
    		$$invalidate(10, ROSAA_modal_active);
    	}

    	function customselect_picked_binding(value) {
    		plotStyleSelected = value;
    		$$invalidate(6, plotStyleSelected);
    	}

    	function customcheckbox_selected_binding(value) {
    		plotFill = value;
    		$$invalidate(7, plotFill);
    	}

    	const click_handler = () => {
    		$$invalidate(10, ROSAA_modal_active = true);
    	};

    	const click_handler_1 = e => {
    		plotData({ e, justPlot: true });
    	};

    	function customcheckbox0_selected_binding(value) {
    		binData = value;
    		$$invalidate(8, binData);
    	}

    	function customcheckbox1_selected_binding(value) {
    		saveInMHz = value;
    		$$invalidate(9, saveInMHz);
    	}

    	const click_handler_2 = e => {
    		plotData({ e });
    	};

    	const click_handler_3 = e => plotData({ e, tkplot: true });

    	function customiconswitch_toggler_binding(value) {
    		openShell = value;
    		$$invalidate(2, openShell);
    	}

    	function textfield0_value_binding(value) {
    		delta = value;
    		$$invalidate(4, delta);
    	}

    	function textfield1_value_binding(value) {
    		gamma = value;
    		$$invalidate(5, gamma);
    	}

    	function layout_currentLocation_binding(value) {
    		currentLocation = value;
    		$$invalidate(1, currentLocation);
    	}

    	function layout_fileChecked_binding(value) {
    		fileChecked = value;
    		$$invalidate(0, fileChecked);
    	}

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Layout,
    		CustomIconSwitch: CustomIconSwitch$1,
    		CustomSelect: CustomSelect$1,
    		CustomCheckbox: CustomCheckbox$1,
    		Textfield,
    		plot,
    		ROSAA,
    		filetype,
    		id,
    		fileChecked,
    		currentLocation,
    		openShell,
    		graphPlotted,
    		delta,
    		gamma,
    		btnClass,
    		plotStyle,
    		plotStyleSelected,
    		plotFill,
    		binData,
    		saveInMHz,
    		changePlotStyle,
    		plotData,
    		includePlotsInReport,
    		ROSAA_modal_active,
    		thzfiles
    	});

    	$$self.$inject_state = $$props => {
    		if ('fileChecked' in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
    		if ('currentLocation' in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
    		if ('openShell' in $$props) $$invalidate(2, openShell = $$props.openShell);
    		if ('graphPlotted' in $$props) $$invalidate(3, graphPlotted = $$props.graphPlotted);
    		if ('delta' in $$props) $$invalidate(4, delta = $$props.delta);
    		if ('gamma' in $$props) $$invalidate(5, gamma = $$props.gamma);
    		if ('plotStyleSelected' in $$props) $$invalidate(6, plotStyleSelected = $$props.plotStyleSelected);
    		if ('plotFill' in $$props) $$invalidate(7, plotFill = $$props.plotFill);
    		if ('binData' in $$props) $$invalidate(8, binData = $$props.binData);
    		if ('saveInMHz' in $$props) $$invalidate(9, saveInMHz = $$props.saveInMHz);
    		if ('includePlotsInReport' in $$props) includePlotsInReport = $$props.includePlotsInReport;
    		if ('ROSAA_modal_active' in $$props) $$invalidate(10, ROSAA_modal_active = $$props.ROSAA_modal_active);
    		if ('thzfiles' in $$props) thzfiles = $$props.thzfiles;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fileChecked, currentLocation*/ 3) {
    			thzfiles = fileChecked.map(file => pathResolve(currentLocation, file));
    		}
    	};

    	return [
    		fileChecked,
    		currentLocation,
    		openShell,
    		graphPlotted,
    		delta,
    		gamma,
    		plotStyleSelected,
    		plotFill,
    		binData,
    		saveInMHz,
    		ROSAA_modal_active,
    		plotStyle,
    		changePlotStyle,
    		plotData,
    		rosaa_active_binding,
    		customselect_picked_binding,
    		customcheckbox_selected_binding,
    		click_handler,
    		click_handler_1,
    		customcheckbox0_selected_binding,
    		customcheckbox1_selected_binding,
    		click_handler_2,
    		click_handler_3,
    		customiconswitch_toggler_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		layout_currentLocation_binding,
    		layout_fileChecked_binding
    	];
    }

    class THz extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "THz",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\components\Changelog.svelte generated by Svelte v3.42.1 */
    const file$5 = "src\\components\\Changelog.svelte";

    // (62:0) {#if $activateChangelog && $windowLoaded}
    function create_if_block$5(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[8](value);
    	}

    	let modal_props = {
    		title: /*changelogTitle*/ ctx[2],
    		$$slots: {
    			footerbtn: [create_footerbtn_slot],
    			content: [create_content_slot$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*$activateChangelog*/ ctx[3] !== void 0) {
    		modal_props.active = /*$activateChangelog*/ ctx[3];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};
    			if (dirty & /*changelogTitle*/ 4) modal_changes.title = /*changelogTitle*/ ctx[2];

    			if (dirty & /*$$scope, $updating, $updateAvailable, changelogContent*/ 1059) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*$activateChangelog*/ 8) {
    				updating_active = true;
    				modal_changes.active = /*$activateChangelog*/ ctx[3];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(62:0) {#if $activateChangelog && $windowLoaded}",
    		ctx
    	});

    	return block;
    }

    // (69:12) {:else}
    function create_else_block$2(ctx) {
    	let html_tag;
    	let raw_value = marked__default['default'](/*changelogContent*/ ctx[1]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*changelogContent*/ 2 && raw_value !== (raw_value = marked__default['default'](/*changelogContent*/ ctx[1]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(69:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:12) {#if $updateAvailable && window.changelogNewContent}
    function create_if_block_2(ctx) {
    	let html_tag;
    	let raw_value = marked__default['default'](window.changelogNewContent) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(66:12) {#if $updateAvailable && window.changelogNewContent}",
    		ctx
    	});

    	return block;
    }

    // (65:8) 
    function create_content_slot$1(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*$updateAvailable*/ ctx[0] && window.changelogNewContent) return create_if_block_2;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "slot", "content");
    			set_style(div, "user-select", "text");
    			add_location(div, file$5, 64, 8, 1544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$1.name,
    		type: "slot",
    		source: "(65:8) ",
    		ctx
    	});

    	return block;
    }

    // (76:12) {#if $updateAvailable}
    function create_if_block_1$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Update Now";
    			attr_dev(button, "class", "button is-warning");
    			toggle_class(button, "is-loading", /*$updating*/ ctx[5]);
    			add_location(button, file$5, 76, 16, 1938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*updateNow*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$updating*/ 32) {
    				toggle_class(button, "is-loading", /*$updating*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(76:12) {#if $updateAvailable}",
    		ctx
    	});

    	return block;
    }

    // (75:8) 
    function create_footerbtn_slot(ctx) {
    	let div;
    	let if_block = /*$updateAvailable*/ ctx[0] && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "slot", "footerbtn");
    			add_location(div, file$5, 74, 8, 1862);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$updateAvailable*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footerbtn_slot.name,
    		type: "slot",
    		source: "(75:8) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let html_tag;

    	let raw_value = `<style>

    ul {padding-left: 1em;}

    li {list-style: disc;}

    h1 {
        color: #fafafa;
        font-size: 2rem;
        font-weight: 600;
        line-height: 1.125;
    }

    h2 {

        color: #fafafa;
        font-size: 1.25rem;
        font-weight: 400;
        line-height: 1.25;
    }


    h1, h2 {

        word-break: break-word;
        margin-bottom: 0.5em;
    }


</style>` + "";

    	let t;
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activateChangelog*/ ctx[3] && /*$windowLoaded*/ ctx[4] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			html_tag.a = t;
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activateChangelog*/ ctx[3] && /*$windowLoaded*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activateChangelog, $windowLoaded*/ 24) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $newVersion;
    	let $activateChangelog;
    	let $updateAvailable;
    	let $windowLoaded;
    	let $updating;
    	validate_store(newVersion, 'newVersion');
    	component_subscribe($$self, newVersion, $$value => $$invalidate(7, $newVersion = $$value));
    	validate_store(activateChangelog, 'activateChangelog');
    	component_subscribe($$self, activateChangelog, $$value => $$invalidate(3, $activateChangelog = $$value));
    	validate_store(updateAvailable, 'updateAvailable');
    	component_subscribe($$self, updateAvailable, $$value => $$invalidate(0, $updateAvailable = $$value));
    	validate_store(windowLoaded, 'windowLoaded');
    	component_subscribe($$self, windowLoaded, $$value => $$invalidate(4, $windowLoaded = $$value));
    	validate_store(updating, 'updating');
    	component_subscribe($$self, updating, $$value => $$invalidate(5, $updating = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Changelog', slots, []);
    	let changelogContent = fs.readFileSync(pathResolve(__dirname, "../CHANGELOG.md"));

    	beforeUpdate(() => {
    		$$invalidate(1, changelogContent = fs.readFileSync(pathResolve(__dirname, "../CHANGELOG.md")));
    	});

    	const updateEvent = new CustomEvent('update', { bubbles: false });

    	const updateNow = e => {
    		let target = document.getElementById("updateCheckBtn");
    		target.dispatchEvent(updateEvent);
    	};

    	let changelogTitle = "FELion GUI Changelog";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Changelog> was created with unknown prop '${key}'`);
    	});

    	function modal_active_binding(value) {
    		$activateChangelog = value;
    		activateChangelog.set($activateChangelog);
    	}

    	$$self.$capture_state = () => ({
    		windowLoaded,
    		activateChangelog,
    		updateAvailable,
    		newVersion,
    		updating,
    		Modal: Modal$1,
    		beforeUpdate,
    		marked: marked__default['default'],
    		fade,
    		changelogContent,
    		updateEvent,
    		updateNow,
    		changelogTitle,
    		$newVersion,
    		$activateChangelog,
    		$updateAvailable,
    		$windowLoaded,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ('changelogContent' in $$props) $$invalidate(1, changelogContent = $$props.changelogContent);
    		if ('changelogTitle' in $$props) $$invalidate(2, changelogTitle = $$props.changelogTitle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$updateAvailable, $newVersion*/ 129) {
    			if ($updateAvailable) {
    				set_store_value(activateChangelog, $activateChangelog = true, $activateChangelog);
    				$$invalidate(2, changelogTitle = "New update available: " + $newVersion);
    			} else {
    				$$invalidate(2, changelogTitle = "FELion GUI Changelog");
    			}
    		}
    	};

    	return [
    		$updateAvailable,
    		changelogContent,
    		changelogTitle,
    		$activateChangelog,
    		$windowLoaded,
    		$updating,
    		updateNow,
    		$newVersion,
    		modal_active_binding
    	];
    }

    class Changelog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Changelog",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    function resetPyConfig() {
        const mainLocation = appInfo.isPackaged ? appInfo.module : __dirname + "../";
        const unpackedLocation =  pathResolve(mainLocation, appInfo.isPackaged ? "../resources/app.asar.unpacked/" : "../" );
        db.set("pythonscript", pathResolve(unpackedLocation, "static/assets/python_files"));

        pythonscript.set(db.get("pythonscript"));
        const defaultPy = pathResolve(unpackedLocation, "python3/python");
        db.set("pythonpath", defaultPy);


        checkPython({defaultPy})
            .then(({stdout})=>{
                pyVersion.set(stdout.trim());
                pythonpath.set(db.get("pythonpath")); 
                window.createToast("Location resetted", "warning");
        
        
            }).catch(handleError);
        
    }

    function updatePyConfig(){

        checkPython()
            .then(({stdout})=>{
                pyVersion.set(stdout.trim());
                db.set("pythonpath", get_store_value(pythonpath));
                window.createToast("Location updated", "success");
            }).catch(handleError);
            db.set("pythonscript", get_store_value(pythonscript));
    }

    /* src\components\Terminal.svelte generated by Svelte v3.42.1 */

    const file$4 = "src\\components\\Terminal.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i].color;
    	child_ctx[21] = list[i].results;
    	return child_ctx;
    }

    // (117:4) {#if commandInputDiv}
    function create_if_block$4(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let div1;
    	let iconbutton0;
    	let t3;
    	let customswitch;
    	let updating_selected;
    	let t4;
    	let textfield;
    	let updating_value;
    	let t5;
    	let iconbutton1;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*installPythonPackagesMode*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	iconbutton0 = new IconButton({
    			props: {
    				class: "material-icons",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	iconbutton0.$on("click", /*terminalShell*/ ctx[10]);

    	function customswitch_selected_binding(value) {
    		/*customswitch_selected_binding*/ ctx[16](value);
    	}

    	let customswitch_props = { style: "margin: 0 1em;", label: "Shell" };

    	if (/*openShellTerminal*/ ctx[6] !== void 0) {
    		customswitch_props.selected = /*openShellTerminal*/ ctx[6];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding));

    	function textfield_value_binding_1(value) {
    		/*textfield_value_binding_1*/ ctx[17](value);
    	}

    	let textfield_props = {
    		type: "number",
    		step: "1",
    		min: "0",
    		variant: "outlined",
    		style: "width:7em",
    		label: "Font Size"
    	};

    	if (/*teminalFontSize*/ ctx[3] !== void 0) {
    		textfield_props.value = /*teminalFontSize*/ ctx[3];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding_1));

    	iconbutton1 = new IconButton({
    			props: {
    				class: "material-icons is-pulled-right",
    				style: "background: #f14668; border-radius: 2em;",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	iconbutton1.$on("click", /*click_handler*/ ctx[18]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "Python package installation";
    			t1 = space();
    			div0 = element("div");
    			if_block.c();
    			t2 = space();
    			div1 = element("div");
    			create_component(iconbutton0.$$.fragment);
    			t3 = space();
    			create_component(customswitch.$$.fragment);
    			t4 = space();
    			create_component(textfield.$$.fragment);
    			t5 = space();
    			create_component(iconbutton1.$$.fragment);
    			attr_dev(button, "class", "button is-link");
    			add_location(button, file$4, 120, 12, 3880);
    			attr_dev(div0, "class", "align");
    			add_location(div0, file$4, 122, 12, 3996);
    			attr_dev(div1, "class", "align v-center");
    			add_location(div1, file$4, 137, 12, 4434);
    			attr_dev(div2, "class", "align");
    			set_style(div2, "margin-bottom", "1em");
    			add_location(div2, file$4, 118, 8, 3809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			mount_component(iconbutton0, div1, null);
    			append_dev(div1, t3);
    			mount_component(customswitch, div1, null);
    			append_dev(div1, t4);
    			mount_component(textfield, div1, null);
    			append_dev(div1, t5);
    			mount_component(iconbutton1, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*installPythonPackages*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const iconbutton0_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				iconbutton0_changes.$$scope = { dirty, ctx };
    			}

    			iconbutton0.$set(iconbutton0_changes);
    			const customswitch_changes = {};

    			if (!updating_selected && dirty & /*openShellTerminal*/ 64) {
    				updating_selected = true;
    				customswitch_changes.selected = /*openShellTerminal*/ ctx[6];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*teminalFontSize*/ 8) {
    				updating_value = true;
    				textfield_changes.value = /*teminalFontSize*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    			const iconbutton1_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				iconbutton1_changes.$$scope = { dirty, ctx };
    			}

    			iconbutton1.$set(iconbutton1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(iconbutton0.$$.fragment, local);
    			transition_in(customswitch.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			transition_in(iconbutton1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(iconbutton0.$$.fragment, local);
    			transition_out(customswitch.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			transition_out(iconbutton1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_component(iconbutton0);
    			destroy_component(customswitch);
    			destroy_component(textfield);
    			destroy_component(iconbutton1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(117:4) {#if commandInputDiv}",
    		ctx
    	});

    	return block;
    }

    // (128:16) {:else}
    function create_else_block$1(ctx) {
    	let textfield0;
    	let updating_value;
    	let t;
    	let textfield1;
    	let updating_value_1;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[14](value);
    	}

    	let textfield0_props = { label: "Enter command to run" };

    	if (/*commandToRun*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*commandToRun*/ ctx[0];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[15](value);
    	}

    	let textfield1_props = { label: "Enter command-arg" };

    	if (/*commandArgsToRun*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*commandArgsToRun*/ ctx[1];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			create_component(textfield0.$$.fragment);
    			t = space();
    			create_component(textfield1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(textfield1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*commandToRun*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*commandToRun*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*commandArgsToRun*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*commandArgsToRun*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(textfield1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(128:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (125:16) {#if installPythonPackagesMode}
    function create_if_block_1$1(ctx) {
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[13](value);
    	}

    	let textfield_props = { label: "Enter packages name(s)" };

    	if (/*packagesName*/ ctx[8] !== void 0) {
    		textfield_props.value = /*packagesName*/ ctx[8];
    	}

    	textfield = new Textfield({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*packagesName*/ 256) {
    				updating_value = true;
    				textfield_changes.value = /*packagesName*/ ctx[8];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(125:16) {#if installPythonPackagesMode}",
    		ctx
    	});

    	return block;
    }

    // (140:16) <IconButton class="material-icons" on:click={terminalShell}>
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("play_arrow");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(140:16) <IconButton class=\\\"material-icons\\\" on:click={terminalShell}>",
    		ctx
    	});

    	return block;
    }

    // (144:16) <IconButton class="material-icons is-pulled-right" style="background: #f14668; border-radius: 2em;" on:click="{()=>commandResults=[{color:colorSets.normal, results:`>> cleared`}] }">
    function create_default_slot$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("clear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(144:16) <IconButton class=\\\"material-icons is-pulled-right\\\" style=\\\"background: #f14668; border-radius: 2em;\\\" on:click=\\\"{()=>commandResults=[{color:colorSets.normal, results:`>> cleared`}] }\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:8) {#each commandResults as {color, results}}
    function create_each_block$1(ctx) {
    	let h1;
    	let t_value = /*results*/ ctx[21] + "";
    	let t;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			t = text(t_value);
    			attr_dev(h1, "class", "subtitle");
    			set_style(h1, "color", /*color*/ ctx[20]);
    			set_style(h1, "font-size", /*teminalFontSize*/ ctx[3] + "px");
    			set_style(h1, "white-space", "pre-wrap");
    			add_location(h1, file$4, 153, 12, 5239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*commandResults*/ 4 && t_value !== (t_value = /*results*/ ctx[21] + "")) set_data_dev(t, t_value);

    			if (dirty & /*commandResults*/ 4) {
    				set_style(h1, "color", /*color*/ ctx[20]);
    			}

    			if (dirty & /*teminalFontSize*/ 8) {
    				set_style(h1, "font-size", /*teminalFontSize*/ ctx[3] + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(153:8) {#each commandResults as {color, results}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div1;
    	let t;
    	let div0;
    	let current;
    	let if_block = /*commandInputDiv*/ ctx[4] && create_if_block$4(ctx);
    	let each_value = /*commandResults*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "box terminal svelte-1c1mx3e");
    			attr_dev(div0, "id", /*id*/ ctx[5]);
    			set_style(div0, "height", (/*commandInputDiv*/ ctx[4] ? 75 : 90) + "%");
    			add_location(div0, file$4, 150, 4, 5094);
    			attr_dev(div1, "class", "content contentBox terminalBox svelte-1c1mx3e");
    			add_location(div1, file$4, 114, 0, 3723);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*commandInputDiv*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*commandInputDiv*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*commandResults, teminalFontSize*/ 12) {
    				each_value = /*commandResults*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*id*/ 32) {
    				attr_dev(div0, "id", /*id*/ ctx[5]);
    			}

    			if (!current || dirty & /*commandInputDiv*/ 16) {
    				set_style(div0, "height", (/*commandInputDiv*/ ctx[4] ? 75 : 90) + "%");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Terminal', slots, []);

    	const colorSets = {
    		warning: "#ffdd57",
    		danger: "#f14668",
    		info: "#2098d1",
    		normal: "#fafafa",
    		success: "#20f996"
    	};

    	let { commandToRun = db.get("pythonpath") || "", commandArgsToRun = "-m pip", commandResults = [{ color: colorSets.normal, results: ">> " }], teminalFontSize = 20 } = $$props;
    	let { commandInputDiv = true, runShell = false, id = "terminal" } = $$props;
    	let openShellTerminal = false;

    	const srollTerminalDiv = async () => {
    		const terminalDiv = document.getElementById(id);
    		await tick();
    		const scrollTo = terminalDiv.scrollHeight - terminalDiv.clientHeight;
    		terminalDiv.scrollTo({ top: scrollTo, behavior: 'smooth' });
    	};

    	async function terminalShell() {
    		$$invalidate(12, runShell = false);
    		await tick();
    		srollTerminalDiv();

    		if (!commandToRun) {
    			return window.createToast("No command entered", "warning");
    		}

    		$$invalidate(2, commandResults = [
    			...commandResults,
    			{
    				color: colorSets.normal,
    				results: `>> ${commandToRun} ${commandArgsToRun.split(",").join(" ")}`
    			}
    		]);

    		let ls;

    		try {
    			$$invalidate(1, commandArgsToRun += ` ${packagesName}`);

    			ls = spawn(commandToRun, commandArgsToRun.split(" ").map(arg => arg.trim()), {
    				detached: true,
    				stdio: 'pipe',
    				shell: openShellTerminal
    			});
    		} catch(error) {
    			window.handleError(error);
    		}

    		ls.stdout.on("data", data => {
    			const writeData = String.fromCharCode.apply(null, data);

    			$$invalidate(2, commandResults = [
    				...commandResults,
    				{
    					color: colorSets.info,
    					results: `>> ${writeData || ""}`
    				}
    			]);

    			srollTerminalDiv();
    		});

    		ls.stderr.on("data", data => {
    			const errorData = String.fromCharCode.apply(null, data);

    			$$invalidate(2, commandResults = [
    				...commandResults,
    				{
    					color: colorSets.danger,
    					results: `>> ${errorData || ""}`
    				}
    			]);

    			srollTerminalDiv();
    		});

    		ls.on("close", code => {
    			$$invalidate(2, commandResults = [
    				...commandResults,
    				{
    					color: code === 1 ? colorSets.danger : colorSets.success,
    					results: `>> child process exited with code ${code}`
    				}
    			]);

    			srollTerminalDiv();
    			const outputLog = `${new Date().toLocaleString()}\n\n-----------------------------------------\nRunning terminal commands\n${commandResults.map(cmd => cmd.results).join("")}\n-----------------------------------------\n`;

    			try {
    				fs.writeFileSync(pathResolve(appInfo.temp, "FELion_GUI3/output.log"), outputLog);
    			} catch(error) {
    				window.handleError(error);
    			}
    		});
    	}

    	let installPythonPackagesMode = false, packagesName = "";

    	const installPythonPackages = () => {
    		$$invalidate(0, commandToRun = db.get("pythonpath"));
    		$$invalidate(1, commandArgsToRun = "-m pip install");
    		$$invalidate(7, installPythonPackagesMode = !installPythonPackagesMode);
    	};

    	const writable_props = [
    		'commandToRun',
    		'commandArgsToRun',
    		'commandResults',
    		'teminalFontSize',
    		'commandInputDiv',
    		'runShell',
    		'id'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Terminal> was created with unknown prop '${key}'`);
    	});

    	function textfield_value_binding(value) {
    		packagesName = value;
    		$$invalidate(8, packagesName);
    	}

    	function textfield0_value_binding(value) {
    		commandToRun = value;
    		$$invalidate(0, commandToRun);
    	}

    	function textfield1_value_binding(value) {
    		commandArgsToRun = value;
    		$$invalidate(1, commandArgsToRun);
    	}

    	function customswitch_selected_binding(value) {
    		openShellTerminal = value;
    		$$invalidate(6, openShellTerminal);
    	}

    	function textfield_value_binding_1(value) {
    		teminalFontSize = value;
    		$$invalidate(3, teminalFontSize);
    	}

    	const click_handler = () => $$invalidate(2, commandResults = [
    		{
    			color: colorSets.normal,
    			results: `>> cleared`
    		}
    	]);

    	$$self.$$set = $$props => {
    		if ('commandToRun' in $$props) $$invalidate(0, commandToRun = $$props.commandToRun);
    		if ('commandArgsToRun' in $$props) $$invalidate(1, commandArgsToRun = $$props.commandArgsToRun);
    		if ('commandResults' in $$props) $$invalidate(2, commandResults = $$props.commandResults);
    		if ('teminalFontSize' in $$props) $$invalidate(3, teminalFontSize = $$props.teminalFontSize);
    		if ('commandInputDiv' in $$props) $$invalidate(4, commandInputDiv = $$props.commandInputDiv);
    		if ('runShell' in $$props) $$invalidate(12, runShell = $$props.runShell);
    		if ('id' in $$props) $$invalidate(5, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		IconButton,
    		tick,
    		Textfield,
    		CustomSwitch: CustomSwitch$1,
    		colorSets,
    		commandToRun,
    		commandArgsToRun,
    		commandResults,
    		teminalFontSize,
    		commandInputDiv,
    		runShell,
    		id,
    		openShellTerminal,
    		srollTerminalDiv,
    		terminalShell,
    		installPythonPackagesMode,
    		packagesName,
    		installPythonPackages
    	});

    	$$self.$inject_state = $$props => {
    		if ('commandToRun' in $$props) $$invalidate(0, commandToRun = $$props.commandToRun);
    		if ('commandArgsToRun' in $$props) $$invalidate(1, commandArgsToRun = $$props.commandArgsToRun);
    		if ('commandResults' in $$props) $$invalidate(2, commandResults = $$props.commandResults);
    		if ('teminalFontSize' in $$props) $$invalidate(3, teminalFontSize = $$props.teminalFontSize);
    		if ('commandInputDiv' in $$props) $$invalidate(4, commandInputDiv = $$props.commandInputDiv);
    		if ('runShell' in $$props) $$invalidate(12, runShell = $$props.runShell);
    		if ('id' in $$props) $$invalidate(5, id = $$props.id);
    		if ('openShellTerminal' in $$props) $$invalidate(6, openShellTerminal = $$props.openShellTerminal);
    		if ('installPythonPackagesMode' in $$props) $$invalidate(7, installPythonPackagesMode = $$props.installPythonPackagesMode);
    		if ('packagesName' in $$props) $$invalidate(8, packagesName = $$props.packagesName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*runShell*/ 4096) {
    			if (runShell) terminalShell();
    		}
    	};

    	return [
    		commandToRun,
    		commandArgsToRun,
    		commandResults,
    		teminalFontSize,
    		commandInputDiv,
    		id,
    		openShellTerminal,
    		installPythonPackagesMode,
    		packagesName,
    		colorSets,
    		terminalShell,
    		installPythonPackages,
    		runShell,
    		textfield_value_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		customswitch_selected_binding,
    		textfield_value_binding_1,
    		click_handler
    	];
    }

    class Terminal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			commandToRun: 0,
    			commandArgsToRun: 1,
    			commandResults: 2,
    			teminalFontSize: 3,
    			commandInputDiv: 4,
    			runShell: 12,
    			id: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Terminal",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get commandToRun() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set commandToRun(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get commandArgsToRun() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set commandArgsToRun(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get commandResults() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set commandResults(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get teminalFontSize() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set teminalFontSize(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get commandInputDiv() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set commandInputDiv(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get runShell() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set runShell(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Settings.svelte generated by Svelte v3.42.1 */

    const { Object: Object_1, console: console_1$1 } = globals;
    const file$3 = "src\\Pages\\Settings.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (123:24) {#if $developerMode}
    function create_if_block$3(ctx) {
    	let div0;
    	let textfield0;
    	let updating_value;
    	let t0;
    	let textfield1;
    	let updating_value_1;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let div1;
    	let customswitch;
    	let updating_selected;
    	let current;
    	let mounted;
    	let dispose;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[14](value);
    	}

    	let textfield0_props = {
    		label: "Python path",
    		style: "width: 100%; "
    	};

    	if (/*$pythonpath*/ ctx[6] !== void 0) {
    		textfield0_props.value = /*$pythonpath*/ ctx[6];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[15](value);
    	}

    	let textfield1_props = {
    		label: "Python script path",
    		style: "width: 100%; "
    	};

    	if (/*$pythonscript*/ ctx[7] !== void 0) {
    		textfield1_props.value = /*$pythonscript*/ ctx[7];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	function customswitch_selected_binding(value) {
    		/*customswitch_selected_binding*/ ctx[16](value);
    	}

    	let customswitch_props = { label: "suppressWarning" };

    	if (/*$suppressInitialDeveloperWarning*/ ctx[8] !== void 0) {
    		customswitch_props.selected = /*$suppressInitialDeveloperWarning*/ ctx[8];
    	}

    	customswitch = new CustomSwitch$1({
    			props: customswitch_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch, 'selected', customswitch_selected_binding));
    	customswitch.$on("change", /*change_handler*/ ctx[17]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t0 = space();
    			create_component(textfield1.$$.fragment);
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Reset";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Save";
    			t5 = space();
    			div1 = element("div");
    			create_component(customswitch.$$.fragment);
    			attr_dev(button0, "class", "button is-link svelte-1v533f1");
    			add_location(button0, file$3, 127, 32, 4470);
    			attr_dev(button1, "class", "button is-link svelte-1v533f1");
    			add_location(button1, file$3, 129, 32, 4584);
    			attr_dev(div0, "class", "align svelte-1v533f1");
    			add_location(div0, file$3, 124, 28, 4181);
    			attr_dev(div1, "class", "align svelte-1v533f1");
    			add_location(div1, file$3, 131, 28, 4720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(textfield0, div0, null);
    			append_dev(div0, t0);
    			mount_component(textfield1, div0, null);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(customswitch, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", resetPyConfig, false, false, false),
    					listen_dev(button1, "click", updatePyConfig, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*$pythonpath*/ 64) {
    				updating_value = true;
    				textfield0_changes.value = /*$pythonpath*/ ctx[6];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*$pythonscript*/ 128) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*$pythonscript*/ ctx[7];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const customswitch_changes = {};

    			if (!updating_selected && dirty & /*$suppressInitialDeveloperWarning*/ 256) {
    				updating_selected = true;
    				customswitch_changes.selected = /*$suppressInitialDeveloperWarning*/ ctx[8];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch.$set(customswitch_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(customswitch.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(customswitch.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div1);
    			destroy_component(customswitch);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(123:24) {#if $developerMode}",
    		ctx
    	});

    	return block;
    }

    // (186:28) {#each Object.keys(window.versions) as key}
    function create_each_block(ctx) {
    	let li;
    	let t0_value = /*key*/ ctx[21] + "";
    	let t0;
    	let t1;
    	let t2_value = window.versions[/*key*/ ctx[21]] + "";
    	let t2;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = text(": ");
    			t2 = text(t2_value);
    			attr_dev(li, "class", "svelte-1v533f1");
    			add_location(li, file$3, 186, 32, 7715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, t2);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(186:28) {#each Object.keys(window.versions) as key}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let customdialog;
    	let updating_dialog;
    	let t0;
    	let changelog;
    	let t1;
    	let section;
    	let div19;
    	let div5;
    	let div4;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let div3;
    	let t9;
    	let div18;
    	let div17;
    	let div8;
    	let h10;
    	let t11;
    	let div6;
    	let t12;
    	let t13;
    	let div7;
    	let button0;
    	let t14;
    	let t15;
    	let t16;
    	let t17;
    	let div13;
    	let h11;
    	let t19;
    	let div9;
    	let t22;
    	let div12;
    	let div10;
    	let button1;
    	let t24;
    	let button2;
    	let t26;
    	let div11;
    	let label;
    	let t28;
    	let progress;
    	let t30;
    	let div14;
    	let h12;
    	let t32;
    	let terminal;
    	let updating_commandToRun;
    	let updating_commandArgsToRun;
    	let t33;
    	let div16;
    	let h13;
    	let t35;
    	let div15;
    	let ul;
    	let li0;
    	let t38;
    	let li1;
    	let t39;
    	let t40;
    	let hr;
    	let t41;
    	let current;
    	let mounted;
    	let dispose;

    	function customdialog_dialog_binding(value) {
    		/*customdialog_dialog_binding*/ ctx[12](value);
    	}

    	let customdialog_props = {
    		id: "pythonpath_Check",
    		title: "Python path is not valid",
    		content: "Change it in Settings --> Configuration",
    		label1: "Okay",
    		label2: "Cancel"
    	};

    	if (/*pythonpathCheck*/ ctx[1] !== void 0) {
    		customdialog_props.dialog = /*pythonpathCheck*/ ctx[1];
    	}

    	customdialog = new CustomDialog({
    			props: customdialog_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customdialog, 'dialog', customdialog_dialog_binding));
    	customdialog.$on("response", /*handlepythonPathCheck*/ ctx[11]);
    	changelog = new Changelog({ $$inline: true });
    	let if_block = /*$developerMode*/ ctx[5] && create_if_block$3(ctx);

    	function terminal_commandToRun_binding(value) {
    		/*terminal_commandToRun_binding*/ ctx[19](value);
    	}

    	function terminal_commandArgsToRun_binding(value) {
    		/*terminal_commandArgsToRun_binding*/ ctx[20](value);
    	}

    	let terminal_props = { id: "Terminal-settings" };

    	if (/*commandToRun*/ ctx[2] !== void 0) {
    		terminal_props.commandToRun = /*commandToRun*/ ctx[2];
    	}

    	if (/*commandArgsToRun*/ ctx[3] !== void 0) {
    		terminal_props.commandArgsToRun = /*commandArgsToRun*/ ctx[3];
    	}

    	terminal = new Terminal({ props: terminal_props, $$inline: true });
    	binding_callbacks.push(() => bind(terminal, 'commandToRun', terminal_commandToRun_binding));
    	binding_callbacks.push(() => bind(terminal, 'commandArgsToRun', terminal_commandArgsToRun_binding));
    	let each_value = Object.keys(window.versions);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(customdialog.$$.fragment);
    			t0 = space();
    			create_component(changelog.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div19 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			div0.textContent = "Configuration";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Update";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Terminal";
    			t7 = space();
    			div3 = element("div");
    			div3.textContent = "About";
    			t9 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div8 = element("div");
    			h10 = element("h1");
    			h10.textContent = "Configuration";
    			t11 = space();
    			div6 = element("div");
    			t12 = text(/*$pyVersion*/ ctx[4]);
    			t13 = space();
    			div7 = element("div");
    			button0 = element("button");
    			t14 = text("Developer mode: ");
    			t15 = text(/*$developerMode*/ ctx[5]);
    			t16 = space();
    			if (if_block) if_block.c();
    			t17 = space();
    			div13 = element("div");
    			h11 = element("h1");
    			h11.textContent = "Update";
    			t19 = space();
    			div9 = element("div");
    			div9.textContent = `App Version ${window.appVersion}`;
    			t22 = space();
    			div12 = element("div");
    			div10 = element("div");
    			button1 = element("button");
    			button1.textContent = "Check update";
    			t24 = space();
    			button2 = element("button");
    			button2.textContent = "What's New";
    			t26 = space();
    			div11 = element("div");
    			label = element("label");
    			label.textContent = "Download progress:";
    			t28 = space();
    			progress = element("progress");
    			progress.textContent = "0%";
    			t30 = space();
    			div14 = element("div");
    			h12 = element("h1");
    			h12.textContent = "Terminal";
    			t32 = space();
    			create_component(terminal.$$.fragment);
    			t33 = space();
    			div16 = element("div");
    			h13 = element("h1");
    			h13.textContent = "About";
    			t35 = space();
    			div15 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = `FELionGUI: ${window.appVersion}`;
    			t38 = space();
    			li1 = element("li");
    			t39 = text(/*$pyVersion*/ ctx[4]);
    			t40 = space();
    			hr = element("hr");
    			t41 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "hvr-glow svelte-1v533f1");
    			toggle_class(div0, "clicked", /*selected*/ ctx[0] === "Configuration");
    			add_location(div0, file$3, 105, 16, 3084);
    			attr_dev(div1, "class", "hvr-glow svelte-1v533f1");
    			toggle_class(div1, "clicked", /*selected*/ ctx[0] === "Update");
    			add_location(div1, file$3, 106, 16, 3206);
    			attr_dev(div2, "class", "hvr-glow svelte-1v533f1");
    			toggle_class(div2, "clicked", /*selected*/ ctx[0] === "Terminal");
    			add_location(div2, file$3, 107, 16, 3314);
    			attr_dev(div3, "class", "hvr-glow svelte-1v533f1");
    			toggle_class(div3, "clicked", /*selected*/ ctx[0] === "About");
    			add_location(div3, file$3, 109, 16, 3428);
    			attr_dev(div4, "class", "title__div svelte-1v533f1");
    			add_location(div4, file$3, 104, 11, 3042);
    			attr_dev(div5, "class", "box interact left_container__div svelte-1v533f1");
    			add_location(div5, file$3, 102, 8, 2981);
    			attr_dev(h10, "class", "title svelte-1v533f1");
    			add_location(h10, file$3, 116, 20, 3767);
    			attr_dev(div6, "class", "subtitle svelte-1v533f1");
    			add_location(div6, file$3, 118, 20, 3827);
    			attr_dev(button0, "class", "button is-link svelte-1v533f1");
    			add_location(button0, file$3, 121, 24, 3936);
    			attr_dev(div7, "class", "align svelte-1v533f1");
    			add_location(div7, file$3, 120, 20, 3891);
    			attr_dev(div8, "class", "content animated fadeIn svelte-1v533f1");
    			toggle_class(div8, "hide", /*selected*/ ctx[0] !== "Configuration");
    			add_location(div8, file$3, 115, 16, 3668);
    			attr_dev(h11, "class", "title svelte-1v533f1");
    			add_location(h11, file$3, 139, 20, 5184);
    			attr_dev(div9, "class", "subtitle svelte-1v533f1");
    			add_location(div9, file$3, 141, 20, 5237);
    			attr_dev(button1, "class", "button is-link svelte-1v533f1");
    			attr_dev(button1, "id", "updateCheckBtn");
    			add_location(button1, file$3, 151, 28, 5840);
    			attr_dev(button2, "class", "button is-warning svelte-1v533f1");
    			add_location(button2, file$3, 154, 28, 6116);
    			attr_dev(div10, "class", "align svelte-1v533f1");
    			add_location(div10, file$3, 150, 24, 5791);
    			attr_dev(label, "for", "file");
    			attr_dev(label, "class", "svelte-1v533f1");
    			add_location(label, file$3, 159, 28, 6365);
    			attr_dev(progress, "id", "update-progress");
    			attr_dev(progress, "max", "100");
    			progress.value = "0";
    			attr_dev(progress, "class", "svelte-1v533f1");
    			add_location(progress, file$3, 160, 28, 6439);
    			attr_dev(div11, "id", "update-progress-container");
    			set_style(div11, "display", "none");
    			attr_dev(div11, "class", "svelte-1v533f1");
    			add_location(div11, file$3, 158, 24, 6276);
    			attr_dev(div12, "class", "align svelte-1v533f1");
    			add_location(div12, file$3, 142, 20, 5318);
    			attr_dev(div13, "class", "content animated fadeIn svelte-1v533f1");
    			toggle_class(div13, "hide", /*selected*/ ctx[0] !== "Update");
    			add_location(div13, file$3, 138, 16, 5092);
    			attr_dev(h12, "class", "title svelte-1v533f1");
    			add_location(h12, file$3, 170, 20, 7008);
    			attr_dev(div14, "class", "animated fadeIn svelte-1v533f1");
    			toggle_class(div14, "hide", /*selected*/ ctx[0] !== "Terminal");
    			add_location(div14, file$3, 169, 16, 6922);
    			attr_dev(h13, "class", "title svelte-1v533f1");
    			add_location(h13, file$3, 176, 20, 7280);
    			attr_dev(li0, "class", "svelte-1v533f1");
    			add_location(li0, file$3, 181, 28, 7482);
    			attr_dev(li1, "class", "svelte-1v533f1");
    			add_location(li1, file$3, 182, 28, 7551);
    			attr_dev(hr, "class", "svelte-1v533f1");
    			add_location(hr, file$3, 183, 28, 7602);
    			set_style(ul, "user-select", "text");
    			attr_dev(ul, "class", "svelte-1v533f1");
    			add_location(ul, file$3, 179, 24, 7399);
    			attr_dev(div15, "class", "content svelte-1v533f1");
    			add_location(div15, file$3, 177, 20, 7330);
    			attr_dev(div16, "class", "animated fadeIn svelte-1v533f1");
    			toggle_class(div16, "hide", /*selected*/ ctx[0] !== "About");
    			add_location(div16, file$3, 174, 16, 7195);
    			attr_dev(div17, "class", "container right svelte-1v533f1");
    			attr_dev(div17, "id", "Settings_right_column");
    			add_location(div17, file$3, 114, 12, 3594);
    			attr_dev(div18, "class", "box svelte-1v533f1");
    			add_location(div18, file$3, 113, 8, 3563);
    			attr_dev(div19, "class", "main__div svelte-1v533f1");
    			add_location(div19, file$3, 100, 4, 2938);
    			attr_dev(section, "class", "section animated fadeIn svelte-1v533f1");
    			attr_dev(section, "id", "Settings");
    			set_style(section, "display", "none");
    			add_location(section, file$3, 99, 0, 2856);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(customdialog, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(changelog, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section, anchor);
    			append_dev(section, div19);
    			append_dev(div19, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div19, t9);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div8);
    			append_dev(div8, h10);
    			append_dev(div8, t11);
    			append_dev(div8, div6);
    			append_dev(div6, t12);
    			append_dev(div8, t13);
    			append_dev(div8, div7);
    			append_dev(div7, button0);
    			append_dev(button0, t14);
    			append_dev(button0, t15);
    			append_dev(div7, t16);
    			if (if_block) if_block.m(div7, null);
    			append_dev(div17, t17);
    			append_dev(div17, div13);
    			append_dev(div13, h11);
    			append_dev(div13, t19);
    			append_dev(div13, div9);
    			append_dev(div13, t22);
    			append_dev(div13, div12);
    			append_dev(div12, div10);
    			append_dev(div10, button1);
    			append_dev(div10, t24);
    			append_dev(div10, button2);
    			append_dev(div12, t26);
    			append_dev(div12, div11);
    			append_dev(div11, label);
    			append_dev(div11, t28);
    			append_dev(div11, progress);
    			append_dev(div17, t30);
    			append_dev(div17, div14);
    			append_dev(div14, h12);
    			append_dev(div14, t32);
    			mount_component(terminal, div14, null);
    			append_dev(div17, t33);
    			append_dev(div17, div16);
    			append_dev(div16, h13);
    			append_dev(div16, t35);
    			append_dev(div16, div15);
    			append_dev(div15, ul);
    			append_dev(ul, li0);
    			append_dev(ul, t38);
    			append_dev(ul, li1);
    			append_dev(li1, t39);
    			append_dev(ul, t40);
    			append_dev(ul, hr);
    			append_dev(ul, t41);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*navigate*/ ctx[10], false, false, false),
    					listen_dev(div1, "click", /*navigate*/ ctx[10], false, false, false),
    					listen_dev(div2, "click", /*navigate*/ ctx[10], false, false, false),
    					listen_dev(div3, "click", /*navigate*/ ctx[10], false, false, false),
    					listen_dev(button0, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(button1, "click", updateCheck, false, false, false),
    					listen_dev(button2, "click", /*click_handler_1*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const customdialog_changes = {};

    			if (!updating_dialog && dirty & /*pythonpathCheck*/ 2) {
    				updating_dialog = true;
    				customdialog_changes.dialog = /*pythonpathCheck*/ ctx[1];
    				add_flush_callback(() => updating_dialog = false);
    			}

    			customdialog.$set(customdialog_changes);

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div0, "clicked", /*selected*/ ctx[0] === "Configuration");
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div1, "clicked", /*selected*/ ctx[0] === "Update");
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div2, "clicked", /*selected*/ ctx[0] === "Terminal");
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div3, "clicked", /*selected*/ ctx[0] === "About");
    			}

    			if (!current || dirty & /*$pyVersion*/ 16) set_data_dev(t12, /*$pyVersion*/ ctx[4]);
    			if (!current || dirty & /*$developerMode*/ 32) set_data_dev(t15, /*$developerMode*/ ctx[5]);

    			if (/*$developerMode*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$developerMode*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div7, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div8, "hide", /*selected*/ ctx[0] !== "Configuration");
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div13, "hide", /*selected*/ ctx[0] !== "Update");
    			}

    			const terminal_changes = {};

    			if (!updating_commandToRun && dirty & /*commandToRun*/ 4) {
    				updating_commandToRun = true;
    				terminal_changes.commandToRun = /*commandToRun*/ ctx[2];
    				add_flush_callback(() => updating_commandToRun = false);
    			}

    			if (!updating_commandArgsToRun && dirty & /*commandArgsToRun*/ 8) {
    				updating_commandArgsToRun = true;
    				terminal_changes.commandArgsToRun = /*commandArgsToRun*/ ctx[3];
    				add_flush_callback(() => updating_commandArgsToRun = false);
    			}

    			terminal.$set(terminal_changes);

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div14, "hide", /*selected*/ ctx[0] !== "Terminal");
    			}

    			if (!current || dirty & /*$pyVersion*/ 16) set_data_dev(t39, /*$pyVersion*/ ctx[4]);

    			if (dirty & /*window, Object*/ 0) {
    				each_value = Object.keys(window.versions);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*selected*/ 1) {
    				toggle_class(div16, "hide", /*selected*/ ctx[0] !== "About");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customdialog.$$.fragment, local);
    			transition_in(changelog.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(terminal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customdialog.$$.fragment, local);
    			transition_out(changelog.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(terminal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(customdialog, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(changelog, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    			destroy_component(terminal);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateCheck(event) {
    	const { target } = event;

    	try {
    		target.classList.toggle("is-loading");

    		if (!navigator.onLine) {
    			if (info) {
    				window.createToast("No Internet Connection!", "warning");
    			}

    			
    			return;
    		}

    		checkupdate();
    	} catch(error) {
    		window.handleError(error);
    	} finally {
    		target.classList.toggle("is-loading");
    	}
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $pyVersion;
    	let $developerMode;
    	let $pythonpath;
    	let $pythonscript;
    	let $suppressInitialDeveloperWarning;
    	let $activateChangelog;
    	validate_store(pyVersion, 'pyVersion');
    	component_subscribe($$self, pyVersion, $$value => $$invalidate(4, $pyVersion = $$value));
    	validate_store(developerMode, 'developerMode');
    	component_subscribe($$self, developerMode, $$value => $$invalidate(5, $developerMode = $$value));
    	validate_store(pythonpath, 'pythonpath');
    	component_subscribe($$self, pythonpath, $$value => $$invalidate(6, $pythonpath = $$value));
    	validate_store(pythonscript, 'pythonscript');
    	component_subscribe($$self, pythonscript, $$value => $$invalidate(7, $pythonscript = $$value));
    	validate_store(suppressInitialDeveloperWarning, 'suppressInitialDeveloperWarning');
    	component_subscribe($$self, suppressInitialDeveloperWarning, $$value => $$invalidate(8, $suppressInitialDeveloperWarning = $$value));
    	validate_store(activateChangelog, 'activateChangelog');
    	component_subscribe($$self, activateChangelog, $$value => $$invalidate(9, $activateChangelog = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Settings', slots, []);
    	let selected = db.get("settingsActiveTab") || "Update";

    	const navigate = e => {
    		$$invalidate(0, selected = e.target.innerHTML);
    		db.set("settingsActiveTab", selected);
    	};

    	let pythonpathCheck;

    	onMount(() => {
    		setTimeout(
    			async () => {
    				await tick();

    				checkPython().then(({ stdout }) => {
    					set_store_value(pyVersion, $pyVersion = stdout.trim(), $pyVersion);
    					console.log("Python path is valid");
    				}).catch(pythonpathCheck.open);
    			},
    			1000
    		);
    	});

    	const handlepythonPathCheck = () => {
    		console.log("Python path checking done");
    	};

    	let commandToRun = "", commandArgsToRun = "";
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	function customdialog_dialog_binding(value) {
    		pythonpathCheck = value;
    		$$invalidate(1, pythonpathCheck);
    	}

    	const click_handler = () => {
    		set_store_value(developerMode, $developerMode = !$developerMode, $developerMode);
    		db.set("developerMode", $developerMode);
    	};

    	function textfield0_value_binding(value) {
    		$pythonpath = value;
    		pythonpath.set($pythonpath);
    	}

    	function textfield1_value_binding(value) {
    		$pythonscript = value;
    		pythonscript.set($pythonscript);
    	}

    	function customswitch_selected_binding(value) {
    		$suppressInitialDeveloperWarning = value;
    		suppressInitialDeveloperWarning.set($suppressInitialDeveloperWarning);
    	}

    	const change_handler = () => db.set("suppressInitialDeveloperWarning", $suppressInitialDeveloperWarning);

    	const click_handler_1 = () => {
    		set_store_value(activateChangelog, $activateChangelog = true, $activateChangelog);
    	};

    	function terminal_commandToRun_binding(value) {
    		commandToRun = value;
    		$$invalidate(2, commandToRun);
    	}

    	function terminal_commandArgsToRun_binding(value) {
    		commandArgsToRun = value;
    		$$invalidate(3, commandArgsToRun);
    	}

    	$$self.$capture_state = () => ({
    		pythonpath,
    		pythonscript,
    		pyVersion,
    		developerMode,
    		suppressInitialDeveloperWarning,
    		mainPreModal,
    		activateChangelog,
    		Textfield,
    		onMount,
    		CustomDialog,
    		CustomSwitch: CustomSwitch$1,
    		Changelog,
    		resetPyConfig,
    		updatePyConfig,
    		tick,
    		Terminal,
    		selected,
    		navigate,
    		pythonpathCheck,
    		handlepythonPathCheck,
    		commandToRun,
    		commandArgsToRun,
    		updateCheck,
    		$pyVersion,
    		$developerMode,
    		$pythonpath,
    		$pythonscript,
    		$suppressInitialDeveloperWarning,
    		$activateChangelog
    	});

    	$$self.$inject_state = $$props => {
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('pythonpathCheck' in $$props) $$invalidate(1, pythonpathCheck = $$props.pythonpathCheck);
    		if ('commandToRun' in $$props) $$invalidate(2, commandToRun = $$props.commandToRun);
    		if ('commandArgsToRun' in $$props) $$invalidate(3, commandArgsToRun = $$props.commandArgsToRun);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selected,
    		pythonpathCheck,
    		commandToRun,
    		commandArgsToRun,
    		$pyVersion,
    		$developerMode,
    		$pythonpath,
    		$pythonscript,
    		$suppressInitialDeveloperWarning,
    		$activateChangelog,
    		navigate,
    		handlepythonPathCheck,
    		customdialog_dialog_binding,
    		click_handler,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		customswitch_selected_binding,
    		change_handler,
    		click_handler_1,
    		terminal_commandToRun_binding,
    		terminal_commandArgsToRun_binding
    	];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\Pages\Misc.svelte generated by Svelte v3.42.1 */
    const file$2 = "src\\Pages\\Misc.svelte";

    // (96:24) <Label>
    function create_default_slot_2(ctx) {
    	let t_value = /*tab*/ ctx[51] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*tab*/ 1048576 && t_value !== (t_value = /*tab*/ ctx[51] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(96:24) <Label>",
    		ctx
    	});

    	return block;
    }

    // (96:12) <Tab {tab}>
    function create_default_slot_1(ctx) {
    	let label;
    	let current;

    	label = new Label$1({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty[1] & /*$$scope, tab*/ 3145728) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(96:12) <Tab {tab}>",
    		ctx
    	});

    	return block;
    }

    // (95:8) <TabBar tabs={navItems} let:tab bind:active>
    function create_default_slot(ctx) {
    	let tab;
    	let current;

    	tab = new Tab({
    			props: {
    				tab: /*tab*/ ctx[51],
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab_changes = {};
    			if (dirty[1] & /*tab*/ 1048576) tab_changes.tab = /*tab*/ ctx[51];

    			if (dirty[1] & /*$$scope, tab*/ 3145728) {
    				tab_changes.$$scope = { dirty, ctx };
    			}

    			tab.$set(tab_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(95:8) <TabBar tabs={navItems} let:tab bind:active>",
    		ctx
    	});

    	return block;
    }

    // (160:4) {:else}
    function create_else_block(ctx) {
    	let terminal;
    	let current;
    	terminal = new Terminal({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(terminal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(terminal, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(terminal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(terminal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(terminal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(160:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (100:4) {#if active=="Unit Conversion"}
    function create_if_block$2(ctx) {
    	let div8;
    	let div3;
    	let div0;
    	let t1;
    	let hr0;
    	let t2;
    	let div2;
    	let textfield0;
    	let updating_value;
    	let t3;
    	let textfield1;
    	let updating_value_1;
    	let t4;
    	let textfield2;
    	let updating_value_2;
    	let t5;
    	let textfield3;
    	let updating_value_3;
    	let t6;
    	let textfield4;
    	let updating_value_4;
    	let t7;
    	let textfield5;
    	let updating_value_5;
    	let t8;
    	let textfield6;
    	let updating_value_6;
    	let t9;
    	let textfield7;
    	let updating_value_7;
    	let t10;
    	let hr1;
    	let t11;
    	let div1;
    	let t13;
    	let customswitch0;
    	let updating_selected;
    	let t14;
    	let textfield8;
    	let updating_value_8;
    	let t15;
    	let textfield9;
    	let updating_value_9;
    	let t16;
    	let textfield10;
    	let updating_value_10;
    	let t17;
    	let textfield11;
    	let updating_value_11;
    	let t18;
    	let div7;
    	let div4;
    	let t20;
    	let hr2;
    	let t21;
    	let div6;
    	let div5;
    	let t23;
    	let textfield12;
    	let updating_value_12;
    	let t24;
    	let textfield13;
    	let updating_value_13;
    	let t25;
    	let textfield14;
    	let updating_value_14;
    	let t26;
    	let textfield15;
    	let updating_value_15;
    	let t27;
    	let hr3;
    	let t28;
    	let customswitch1;
    	let updating_selected_1;
    	let t29;
    	let textfield16;
    	let updating_value_16;
    	let t30;
    	let textfield17;
    	let updating_value_17;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[24](value);
    	}

    	let textfield0_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "Hz"
    	};

    	if (/*hz*/ ctx[6] !== void 0) {
    		textfield0_props.value = /*hz*/ ctx[6];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[25](value);
    	}

    	let textfield1_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "GHz"
    	};

    	if (/*ghz*/ ctx[16] !== void 0) {
    		textfield1_props.value = /*ghz*/ ctx[16];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));
    	textfield1.$on("change", /*change_handler*/ ctx[26]);

    	function textfield2_value_binding(value) {
    		/*textfield2_value_binding*/ ctx[27](value);
    	}

    	let textfield2_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "Micron"
    	};

    	if (/*um*/ ctx[17] !== void 0) {
    		textfield2_props.value = /*um*/ ctx[17];
    	}

    	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield2, 'value', textfield2_value_binding));
    	textfield2.$on("change", /*change_handler_1*/ ctx[28]);

    	function textfield3_value_binding(value) {
    		/*textfield3_value_binding*/ ctx[29](value);
    	}

    	let textfield3_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "cm-1"
    	};

    	if (/*cm_1*/ ctx[18] !== void 0) {
    		textfield3_props.value = /*cm_1*/ ctx[18];
    	}

    	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield3, 'value', textfield3_value_binding));
    	textfield3.$on("change", /*change_handler_2*/ ctx[30]);

    	function textfield4_value_binding(value) {
    		/*textfield4_value_binding*/ ctx[31](value);
    	}

    	let textfield4_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "Kelvin"
    	};

    	if (/*kelvin*/ ctx[19] !== void 0) {
    		textfield4_props.value = /*kelvin*/ ctx[19];
    	}

    	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield4, 'value', textfield4_value_binding));
    	textfield4.$on("change", /*change_handler_3*/ ctx[32]);

    	function textfield5_value_binding(value) {
    		/*textfield5_value_binding*/ ctx[33](value);
    	}

    	let textfield5_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "eV"
    	};

    	if (/*eV*/ ctx[20] !== void 0) {
    		textfield5_props.value = /*eV*/ ctx[20];
    	}

    	textfield5 = new Textfield({ props: textfield5_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield5, 'value', textfield5_value_binding));
    	textfield5.$on("change", /*change_handler_4*/ ctx[34]);

    	function textfield6_value_binding(value) {
    		/*textfield6_value_binding*/ ctx[35](value);
    	}

    	let textfield6_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "Joule"
    	};

    	if (/*J*/ ctx[14] !== void 0) {
    		textfield6_props.value = /*J*/ ctx[14];
    	}

    	textfield6 = new Textfield({ props: textfield6_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield6, 'value', textfield6_value_binding));
    	textfield6.$on("change", /*change_handler_5*/ ctx[36]);

    	function textfield7_value_binding(value) {
    		/*textfield7_value_binding*/ ctx[37](value);
    	}

    	let textfield7_props = {
    		style: "width:25%; margin-right:0.5em;",
    		label: "nm"
    	};

    	if (/*nm*/ ctx[15] !== void 0) {
    		textfield7_props.value = /*nm*/ ctx[15];
    	}

    	textfield7 = new Textfield({ props: textfield7_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield7, 'value', textfield7_value_binding));
    	textfield7.$on("change", /*change_handler_6*/ ctx[38]);

    	function customswitch0_selected_binding(value) {
    		/*customswitch0_selected_binding*/ ctx[39](value);
    	}

    	let customswitch0_props = { style: "margin: 0 1em;", label: "Edit" };

    	if (/*edit_constants*/ ctx[13] !== void 0) {
    		customswitch0_props.selected = /*edit_constants*/ ctx[13];
    	}

    	customswitch0 = new CustomSwitch$1({
    			props: customswitch0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch0, 'selected', customswitch0_selected_binding));

    	function textfield8_value_binding(value) {
    		/*textfield8_value_binding*/ ctx[40](value);
    	}

    	let textfield8_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_constants*/ ctx[13],
    		label: "Speed of light in vaccum"
    	};

    	if (/*c*/ ctx[8] !== void 0) {
    		textfield8_props.value = /*c*/ ctx[8];
    	}

    	textfield8 = new Textfield({ props: textfield8_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield8, 'value', textfield8_value_binding));

    	function textfield9_value_binding(value) {
    		/*textfield9_value_binding*/ ctx[41](value);
    	}

    	let textfield9_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_constants*/ ctx[13],
    		label: "Boltzman constant"
    	};

    	if (/*boltzman_constant*/ ctx[4] !== void 0) {
    		textfield9_props.value = /*boltzman_constant*/ ctx[4];
    	}

    	textfield9 = new Textfield({ props: textfield9_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield9, 'value', textfield9_value_binding));

    	function textfield10_value_binding(value) {
    		/*textfield10_value_binding*/ ctx[42](value);
    	}

    	let textfield10_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_constants*/ ctx[13],
    		label: "Plank's constant"
    	};

    	if (/*plank_constant*/ ctx[7] !== void 0) {
    		textfield10_props.value = /*plank_constant*/ ctx[7];
    	}

    	textfield10 = new Textfield({ props: textfield10_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield10, 'value', textfield10_value_binding));

    	function textfield11_value_binding(value) {
    		/*textfield11_value_binding*/ ctx[43](value);
    	}

    	let textfield11_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_constants*/ ctx[13],
    		label: "Electric charge"
    	};

    	if (/*electron_charge*/ ctx[9] !== void 0) {
    		textfield11_props.value = /*electron_charge*/ ctx[9];
    	}

    	textfield11 = new Textfield({ props: textfield11_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield11, 'value', textfield11_value_binding));

    	function textfield12_value_binding(value) {
    		/*textfield12_value_binding*/ ctx[44](value);
    	}

    	let textfield12_props = {
    		style: "width:90%; margin-right:0.5em;",
    		label: "Before letting in gas"
    	};

    	if (/*pq1_before*/ ctx[1] !== void 0) {
    		textfield12_props.value = /*pq1_before*/ ctx[1];
    	}

    	textfield12 = new Textfield({ props: textfield12_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield12, 'value', textfield12_value_binding));

    	function textfield13_value_binding(value) {
    		/*textfield13_value_binding*/ ctx[45](value);
    	}

    	let textfield13_props = {
    		style: "width:90%; margin-right:0.5em;",
    		label: "After letting in gas"
    	};

    	if (/*pq1_after*/ ctx[2] !== void 0) {
    		textfield13_props.value = /*pq1_after*/ ctx[2];
    	}

    	textfield13 = new Textfield({ props: textfield13_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield13, 'value', textfield13_value_binding));

    	function textfield14_value_binding(value) {
    		/*textfield14_value_binding*/ ctx[46](value);
    	}

    	let textfield14_props = {
    		style: "width:90%; margin-right:0.5em;",
    		label: "Temperature"
    	};

    	if (/*temperature*/ ctx[0] !== void 0) {
    		textfield14_props.value = /*temperature*/ ctx[0];
    	}

    	textfield14 = new Textfield({ props: textfield14_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield14, 'value', textfield14_value_binding));

    	function textfield15_value_binding(value) {
    		/*textfield15_value_binding*/ ctx[47](value);
    	}

    	let textfield15_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: true,
    		label: "Number density"
    	};

    	if (/*ndensity*/ ctx[11] !== void 0) {
    		textfield15_props.value = /*ndensity*/ ctx[11];
    	}

    	textfield15 = new Textfield({ props: textfield15_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield15, 'value', textfield15_value_binding));

    	function customswitch1_selected_binding(value) {
    		/*customswitch1_selected_binding*/ ctx[48](value);
    	}

    	let customswitch1_props = { style: "margin: 0 1em;", label: "Edit" };

    	if (/*edit_numberDensity_constants*/ ctx[12] !== void 0) {
    		customswitch1_props.selected = /*edit_numberDensity_constants*/ ctx[12];
    	}

    	customswitch1 = new CustomSwitch$1({
    			props: customswitch1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(customswitch1, 'selected', customswitch1_selected_binding));

    	function textfield16_value_binding(value) {
    		/*textfield16_value_binding*/ ctx[49](value);
    	}

    	let textfield16_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_numberDensity_constants*/ ctx[12],
    		label: "Calibration Factor"
    	};

    	if (/*calibration_factor*/ ctx[5] !== void 0) {
    		textfield16_props.value = /*calibration_factor*/ ctx[5];
    	}

    	textfield16 = new Textfield({ props: textfield16_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield16, 'value', textfield16_value_binding));

    	function textfield17_value_binding(value) {
    		/*textfield17_value_binding*/ ctx[50](value);
    	}

    	let textfield17_props = {
    		style: "width:90%; margin-right:0.5em;",
    		disabled: !/*edit_numberDensity_constants*/ ctx[12],
    		label: "Chamber Temperature (RT)"
    	};

    	if (/*rt*/ ctx[3] !== void 0) {
    		textfield17_props.value = /*rt*/ ctx[3];
    	}

    	textfield17 = new Textfield({ props: textfield17_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield17, 'value', textfield17_value_binding));

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Energy Conversion";
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			div2 = element("div");
    			create_component(textfield0.$$.fragment);
    			t3 = space();
    			create_component(textfield1.$$.fragment);
    			t4 = space();
    			create_component(textfield2.$$.fragment);
    			t5 = space();
    			create_component(textfield3.$$.fragment);
    			t6 = space();
    			create_component(textfield4.$$.fragment);
    			t7 = space();
    			create_component(textfield5.$$.fragment);
    			t8 = space();
    			create_component(textfield6.$$.fragment);
    			t9 = space();
    			create_component(textfield7.$$.fragment);
    			t10 = space();
    			hr1 = element("hr");
    			t11 = space();
    			div1 = element("div");
    			div1.textContent = "Fundamental constants";
    			t13 = space();
    			create_component(customswitch0.$$.fragment);
    			t14 = space();
    			create_component(textfield8.$$.fragment);
    			t15 = space();
    			create_component(textfield9.$$.fragment);
    			t16 = space();
    			create_component(textfield10.$$.fragment);
    			t17 = space();
    			create_component(textfield11.$$.fragment);
    			t18 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Number Density";
    			t20 = space();
    			hr2 = element("hr");
    			t21 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div5.textContent = "Main Chamber Press.";
    			t23 = space();
    			create_component(textfield12.$$.fragment);
    			t24 = space();
    			create_component(textfield13.$$.fragment);
    			t25 = space();
    			create_component(textfield14.$$.fragment);
    			t26 = space();
    			create_component(textfield15.$$.fragment);
    			t27 = space();
    			hr3 = element("hr");
    			t28 = space();
    			create_component(customswitch1.$$.fragment);
    			t29 = space();
    			create_component(textfield16.$$.fragment);
    			t30 = space();
    			create_component(textfield17.$$.fragment);
    			attr_dev(div0, "class", "title svelte-7c8hl4");
    			add_location(div0, file$2, 104, 16, 2714);
    			attr_dev(hr0, "class", "svelte-7c8hl4");
    			add_location(hr0, file$2, 106, 16, 2776);
    			attr_dev(hr1, "class", "svelte-7c8hl4");
    			add_location(hr1, file$2, 122, 20, 4035);
    			attr_dev(div1, "class", "subtitle is-pulled-left svelte-7c8hl4");
    			add_location(div1, file$2, 124, 20, 4063);
    			attr_dev(div2, "class", "unit_conversion_contents svelte-7c8hl4");
    			add_location(div2, file$2, 108, 16, 2800);
    			attr_dev(div3, "class", "column box is-4 unit_converter_column svelte-7c8hl4");
    			add_location(div3, file$2, 102, 12, 2643);
    			attr_dev(div4, "class", "title svelte-7c8hl4");
    			add_location(div4, file$2, 137, 16, 4993);
    			attr_dev(hr2, "class", "svelte-7c8hl4");
    			add_location(hr2, file$2, 138, 16, 5050);
    			attr_dev(div5, "class", "subtitle svelte-7c8hl4");
    			add_location(div5, file$2, 142, 20, 5136);
    			attr_dev(hr3, "class", "svelte-7c8hl4");
    			add_location(hr3, file$2, 147, 20, 5713);
    			attr_dev(div6, "class", "unit_conversion_contents svelte-7c8hl4");
    			add_location(div6, file$2, 140, 16, 5074);
    			attr_dev(div7, "class", "column box is-4 unit_converter_column svelte-7c8hl4");
    			add_location(div7, file$2, 135, 12, 4910);
    			attr_dev(div8, "class", "columns is-multiline contentBox svelte-7c8hl4");
    			attr_dev(div8, "id", "unit_conversion_table");
    			add_location(div8, file$2, 100, 8, 2555);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, hr0);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			mount_component(textfield0, div2, null);
    			append_dev(div2, t3);
    			mount_component(textfield1, div2, null);
    			append_dev(div2, t4);
    			mount_component(textfield2, div2, null);
    			append_dev(div2, t5);
    			mount_component(textfield3, div2, null);
    			append_dev(div2, t6);
    			mount_component(textfield4, div2, null);
    			append_dev(div2, t7);
    			mount_component(textfield5, div2, null);
    			append_dev(div2, t8);
    			mount_component(textfield6, div2, null);
    			append_dev(div2, t9);
    			mount_component(textfield7, div2, null);
    			append_dev(div2, t10);
    			append_dev(div2, hr1);
    			append_dev(div2, t11);
    			append_dev(div2, div1);
    			append_dev(div2, t13);
    			mount_component(customswitch0, div2, null);
    			append_dev(div2, t14);
    			mount_component(textfield8, div2, null);
    			append_dev(div2, t15);
    			mount_component(textfield9, div2, null);
    			append_dev(div2, t16);
    			mount_component(textfield10, div2, null);
    			append_dev(div2, t17);
    			mount_component(textfield11, div2, null);
    			append_dev(div8, t18);
    			append_dev(div8, div7);
    			append_dev(div7, div4);
    			append_dev(div7, t20);
    			append_dev(div7, hr2);
    			append_dev(div7, t21);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div6, t23);
    			mount_component(textfield12, div6, null);
    			append_dev(div6, t24);
    			mount_component(textfield13, div6, null);
    			append_dev(div6, t25);
    			mount_component(textfield14, div6, null);
    			append_dev(div6, t26);
    			mount_component(textfield15, div6, null);
    			append_dev(div6, t27);
    			append_dev(div6, hr3);
    			append_dev(div6, t28);
    			mount_component(customswitch1, div6, null);
    			append_dev(div6, t29);
    			mount_component(textfield16, div6, null);
    			append_dev(div6, t30);
    			mount_component(textfield17, div6, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty[0] & /*hz*/ 64) {
    				updating_value = true;
    				textfield0_changes.value = /*hz*/ ctx[6];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty[0] & /*ghz*/ 65536) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*ghz*/ ctx[16];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const textfield2_changes = {};

    			if (!updating_value_2 && dirty[0] & /*um*/ 131072) {
    				updating_value_2 = true;
    				textfield2_changes.value = /*um*/ ctx[17];
    				add_flush_callback(() => updating_value_2 = false);
    			}

    			textfield2.$set(textfield2_changes);
    			const textfield3_changes = {};

    			if (!updating_value_3 && dirty[0] & /*cm_1*/ 262144) {
    				updating_value_3 = true;
    				textfield3_changes.value = /*cm_1*/ ctx[18];
    				add_flush_callback(() => updating_value_3 = false);
    			}

    			textfield3.$set(textfield3_changes);
    			const textfield4_changes = {};

    			if (!updating_value_4 && dirty[0] & /*kelvin*/ 524288) {
    				updating_value_4 = true;
    				textfield4_changes.value = /*kelvin*/ ctx[19];
    				add_flush_callback(() => updating_value_4 = false);
    			}

    			textfield4.$set(textfield4_changes);
    			const textfield5_changes = {};

    			if (!updating_value_5 && dirty[0] & /*eV*/ 1048576) {
    				updating_value_5 = true;
    				textfield5_changes.value = /*eV*/ ctx[20];
    				add_flush_callback(() => updating_value_5 = false);
    			}

    			textfield5.$set(textfield5_changes);
    			const textfield6_changes = {};

    			if (!updating_value_6 && dirty[0] & /*J*/ 16384) {
    				updating_value_6 = true;
    				textfield6_changes.value = /*J*/ ctx[14];
    				add_flush_callback(() => updating_value_6 = false);
    			}

    			textfield6.$set(textfield6_changes);
    			const textfield7_changes = {};

    			if (!updating_value_7 && dirty[0] & /*nm*/ 32768) {
    				updating_value_7 = true;
    				textfield7_changes.value = /*nm*/ ctx[15];
    				add_flush_callback(() => updating_value_7 = false);
    			}

    			textfield7.$set(textfield7_changes);
    			const customswitch0_changes = {};

    			if (!updating_selected && dirty[0] & /*edit_constants*/ 8192) {
    				updating_selected = true;
    				customswitch0_changes.selected = /*edit_constants*/ ctx[13];
    				add_flush_callback(() => updating_selected = false);
    			}

    			customswitch0.$set(customswitch0_changes);
    			const textfield8_changes = {};
    			if (dirty[0] & /*edit_constants*/ 8192) textfield8_changes.disabled = !/*edit_constants*/ ctx[13];

    			if (!updating_value_8 && dirty[0] & /*c*/ 256) {
    				updating_value_8 = true;
    				textfield8_changes.value = /*c*/ ctx[8];
    				add_flush_callback(() => updating_value_8 = false);
    			}

    			textfield8.$set(textfield8_changes);
    			const textfield9_changes = {};
    			if (dirty[0] & /*edit_constants*/ 8192) textfield9_changes.disabled = !/*edit_constants*/ ctx[13];

    			if (!updating_value_9 && dirty[0] & /*boltzman_constant*/ 16) {
    				updating_value_9 = true;
    				textfield9_changes.value = /*boltzman_constant*/ ctx[4];
    				add_flush_callback(() => updating_value_9 = false);
    			}

    			textfield9.$set(textfield9_changes);
    			const textfield10_changes = {};
    			if (dirty[0] & /*edit_constants*/ 8192) textfield10_changes.disabled = !/*edit_constants*/ ctx[13];

    			if (!updating_value_10 && dirty[0] & /*plank_constant*/ 128) {
    				updating_value_10 = true;
    				textfield10_changes.value = /*plank_constant*/ ctx[7];
    				add_flush_callback(() => updating_value_10 = false);
    			}

    			textfield10.$set(textfield10_changes);
    			const textfield11_changes = {};
    			if (dirty[0] & /*edit_constants*/ 8192) textfield11_changes.disabled = !/*edit_constants*/ ctx[13];

    			if (!updating_value_11 && dirty[0] & /*electron_charge*/ 512) {
    				updating_value_11 = true;
    				textfield11_changes.value = /*electron_charge*/ ctx[9];
    				add_flush_callback(() => updating_value_11 = false);
    			}

    			textfield11.$set(textfield11_changes);
    			const textfield12_changes = {};

    			if (!updating_value_12 && dirty[0] & /*pq1_before*/ 2) {
    				updating_value_12 = true;
    				textfield12_changes.value = /*pq1_before*/ ctx[1];
    				add_flush_callback(() => updating_value_12 = false);
    			}

    			textfield12.$set(textfield12_changes);
    			const textfield13_changes = {};

    			if (!updating_value_13 && dirty[0] & /*pq1_after*/ 4) {
    				updating_value_13 = true;
    				textfield13_changes.value = /*pq1_after*/ ctx[2];
    				add_flush_callback(() => updating_value_13 = false);
    			}

    			textfield13.$set(textfield13_changes);
    			const textfield14_changes = {};

    			if (!updating_value_14 && dirty[0] & /*temperature*/ 1) {
    				updating_value_14 = true;
    				textfield14_changes.value = /*temperature*/ ctx[0];
    				add_flush_callback(() => updating_value_14 = false);
    			}

    			textfield14.$set(textfield14_changes);
    			const textfield15_changes = {};

    			if (!updating_value_15 && dirty[0] & /*ndensity*/ 2048) {
    				updating_value_15 = true;
    				textfield15_changes.value = /*ndensity*/ ctx[11];
    				add_flush_callback(() => updating_value_15 = false);
    			}

    			textfield15.$set(textfield15_changes);
    			const customswitch1_changes = {};

    			if (!updating_selected_1 && dirty[0] & /*edit_numberDensity_constants*/ 4096) {
    				updating_selected_1 = true;
    				customswitch1_changes.selected = /*edit_numberDensity_constants*/ ctx[12];
    				add_flush_callback(() => updating_selected_1 = false);
    			}

    			customswitch1.$set(customswitch1_changes);
    			const textfield16_changes = {};
    			if (dirty[0] & /*edit_numberDensity_constants*/ 4096) textfield16_changes.disabled = !/*edit_numberDensity_constants*/ ctx[12];

    			if (!updating_value_16 && dirty[0] & /*calibration_factor*/ 32) {
    				updating_value_16 = true;
    				textfield16_changes.value = /*calibration_factor*/ ctx[5];
    				add_flush_callback(() => updating_value_16 = false);
    			}

    			textfield16.$set(textfield16_changes);
    			const textfield17_changes = {};
    			if (dirty[0] & /*edit_numberDensity_constants*/ 4096) textfield17_changes.disabled = !/*edit_numberDensity_constants*/ ctx[12];

    			if (!updating_value_17 && dirty[0] & /*rt*/ 8) {
    				updating_value_17 = true;
    				textfield17_changes.value = /*rt*/ ctx[3];
    				add_flush_callback(() => updating_value_17 = false);
    			}

    			textfield17.$set(textfield17_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(textfield2.$$.fragment, local);
    			transition_in(textfield3.$$.fragment, local);
    			transition_in(textfield4.$$.fragment, local);
    			transition_in(textfield5.$$.fragment, local);
    			transition_in(textfield6.$$.fragment, local);
    			transition_in(textfield7.$$.fragment, local);
    			transition_in(customswitch0.$$.fragment, local);
    			transition_in(textfield8.$$.fragment, local);
    			transition_in(textfield9.$$.fragment, local);
    			transition_in(textfield10.$$.fragment, local);
    			transition_in(textfield11.$$.fragment, local);
    			transition_in(textfield12.$$.fragment, local);
    			transition_in(textfield13.$$.fragment, local);
    			transition_in(textfield14.$$.fragment, local);
    			transition_in(textfield15.$$.fragment, local);
    			transition_in(customswitch1.$$.fragment, local);
    			transition_in(textfield16.$$.fragment, local);
    			transition_in(textfield17.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(textfield2.$$.fragment, local);
    			transition_out(textfield3.$$.fragment, local);
    			transition_out(textfield4.$$.fragment, local);
    			transition_out(textfield5.$$.fragment, local);
    			transition_out(textfield6.$$.fragment, local);
    			transition_out(textfield7.$$.fragment, local);
    			transition_out(customswitch0.$$.fragment, local);
    			transition_out(textfield8.$$.fragment, local);
    			transition_out(textfield9.$$.fragment, local);
    			transition_out(textfield10.$$.fragment, local);
    			transition_out(textfield11.$$.fragment, local);
    			transition_out(textfield12.$$.fragment, local);
    			transition_out(textfield13.$$.fragment, local);
    			transition_out(textfield14.$$.fragment, local);
    			transition_out(textfield15.$$.fragment, local);
    			transition_out(customswitch1.$$.fragment, local);
    			transition_out(textfield16.$$.fragment, local);
    			transition_out(textfield17.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(textfield2);
    			destroy_component(textfield3);
    			destroy_component(textfield4);
    			destroy_component(textfield5);
    			destroy_component(textfield6);
    			destroy_component(textfield7);
    			destroy_component(customswitch0);
    			destroy_component(textfield8);
    			destroy_component(textfield9);
    			destroy_component(textfield10);
    			destroy_component(textfield11);
    			destroy_component(textfield12);
    			destroy_component(textfield13);
    			destroy_component(textfield14);
    			destroy_component(textfield15);
    			destroy_component(customswitch1);
    			destroy_component(textfield16);
    			destroy_component(textfield17);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(100:4) {#if active==\\\"Unit Conversion\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let section;
    	let div;
    	let tabbar;
    	let updating_active;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	function tabbar_active_binding(value) {
    		/*tabbar_active_binding*/ ctx[23](value);
    	}

    	let tabbar_props = {
    		tabs: /*navItems*/ ctx[21],
    		$$slots: {
    			default: [
    				create_default_slot,
    				({ tab }) => ({ 51: tab }),
    				({ tab }) => [0, tab ? 1048576 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[10] !== void 0) {
    		tabbar_props.active = /*active*/ ctx[10];
    	}

    	tabbar = new TabBar({ props: tabbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(tabbar, 'active', tabbar_active_binding));
    	const if_block_creators = [create_if_block$2, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*active*/ ctx[10] == "Unit Conversion") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			create_component(tabbar.$$.fragment);
    			t = space();
    			if_block.c();
    			attr_dev(div, "class", "misc-nav box animated fadeInDown svelte-7c8hl4");
    			attr_dev(div, "id", "navbar");
    			add_location(div, file$2, 93, 4, 2309);
    			attr_dev(section, "class", "animated fadeIn section svelte-7c8hl4");
    			attr_dev(section, "id", "Misc");
    			set_style(section, "display", "none");
    			add_location(section, file$2, 91, 0, 2229);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			mount_component(tabbar, div, null);
    			append_dev(section, t);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabbar_changes = {};

    			if (dirty[1] & /*$$scope, tab*/ 3145728) {
    				tabbar_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty[0] & /*active*/ 1024) {
    				updating_active = true;
    				tabbar_changes.active = /*active*/ ctx[10];
    				add_flush_callback(() => updating_active = false);
    			}

    			tabbar.$set(tabbar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabbar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabbar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(tabbar);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let c;
    	let plank_constant;
    	let boltzman_constant;
    	let electron_charge;
    	let hz;
    	let eV;
    	let kelvin;
    	let cm_1;
    	let um;
    	let ghz;
    	let nm;
    	let J;
    	let edit_constants;
    	let edit_numberDensity_constants;
    	let pq1_before;
    	let pq1_after;
    	let temperature;
    	let calibration_factor;
    	let rt;
    	let ndensity_temp;
    	let ndensity;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Misc', slots, []);
    	let active = "Unit Conversion";
    	const navItems = ["Unit Conversion", "Terminal"];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Misc> was created with unknown prop '${key}'`);
    	});

    	function tabbar_active_binding(value) {
    		active = value;
    		$$invalidate(10, active);
    	}

    	function textfield0_value_binding(value) {
    		hz = value;
    		$$invalidate(6, hz);
    	}

    	function textfield1_value_binding(value) {
    		ghz = value;
    		($$invalidate(16, ghz), $$invalidate(6, hz));
    	}

    	const change_handler = () => $$invalidate(6, hz = ghz * 1e+9);

    	function textfield2_value_binding(value) {
    		um = value;
    		(($$invalidate(17, um), $$invalidate(8, c)), $$invalidate(6, hz));
    	}

    	const change_handler_1 = () => $$invalidate(6, hz = c / um * 1e6);

    	function textfield3_value_binding(value) {
    		cm_1 = value;
    		(($$invalidate(18, cm_1), $$invalidate(6, hz)), $$invalidate(8, c));
    	}

    	const change_handler_2 = () => $$invalidate(6, hz = cm_1 * c * 1e2);

    	function textfield4_value_binding(value) {
    		kelvin = value;
    		((($$invalidate(19, kelvin), $$invalidate(7, plank_constant)), $$invalidate(4, boltzman_constant)), $$invalidate(6, hz));
    	}

    	const change_handler_3 = () => $$invalidate(6, hz = boltzman_constant / plank_constant * kelvin);

    	function textfield5_value_binding(value) {
    		eV = value;
    		((($$invalidate(20, eV), $$invalidate(7, plank_constant)), $$invalidate(9, electron_charge)), $$invalidate(6, hz));
    	}

    	const change_handler_4 = () => $$invalidate(6, hz = electron_charge / plank_constant * eV);

    	function textfield6_value_binding(value) {
    		J = value;
    		(($$invalidate(14, J), $$invalidate(7, plank_constant)), $$invalidate(6, hz));
    	}

    	const change_handler_5 = () => $$invalidate(6, hz = J / plank_constant);

    	function textfield7_value_binding(value) {
    		nm = value;
    		(($$invalidate(15, nm), $$invalidate(8, c)), $$invalidate(6, hz));
    	}

    	const change_handler_6 = () => $$invalidate(6, hz = c / nm * 1e9);

    	function customswitch0_selected_binding(value) {
    		edit_constants = value;
    		$$invalidate(13, edit_constants);
    	}

    	function textfield8_value_binding(value) {
    		c = value;
    		$$invalidate(8, c);
    	}

    	function textfield9_value_binding(value) {
    		boltzman_constant = value;
    		$$invalidate(4, boltzman_constant);
    	}

    	function textfield10_value_binding(value) {
    		plank_constant = value;
    		$$invalidate(7, plank_constant);
    	}

    	function textfield11_value_binding(value) {
    		electron_charge = value;
    		$$invalidate(9, electron_charge);
    	}

    	function textfield12_value_binding(value) {
    		pq1_before = value;
    		$$invalidate(1, pq1_before);
    	}

    	function textfield13_value_binding(value) {
    		pq1_after = value;
    		$$invalidate(2, pq1_after);
    	}

    	function textfield14_value_binding(value) {
    		temperature = value;
    		$$invalidate(0, temperature);
    	}

    	function textfield15_value_binding(value) {
    		ndensity = value;
    		((((((($$invalidate(11, ndensity), $$invalidate(22, ndensity_temp)), $$invalidate(5, calibration_factor)), $$invalidate(4, boltzman_constant)), $$invalidate(3, rt)), $$invalidate(2, pq1_after)), $$invalidate(1, pq1_before)), $$invalidate(0, temperature));
    	}

    	function customswitch1_selected_binding(value) {
    		edit_numberDensity_constants = value;
    		$$invalidate(12, edit_numberDensity_constants);
    	}

    	function textfield16_value_binding(value) {
    		calibration_factor = value;
    		$$invalidate(5, calibration_factor);
    	}

    	function textfield17_value_binding(value) {
    		rt = value;
    		$$invalidate(3, rt);
    	}

    	$$self.$capture_state = () => ({
    		Textfield,
    		CustomSwitch: CustomSwitch$1,
    		Terminal,
    		Tab,
    		Label: Label$1,
    		TabBar,
    		active,
    		navItems,
    		ndensity_temp,
    		ndensity,
    		temperature,
    		pq1_before,
    		pq1_after,
    		rt,
    		boltzman_constant,
    		calibration_factor,
    		edit_numberDensity_constants,
    		edit_constants,
    		hz,
    		plank_constant,
    		J,
    		c,
    		nm,
    		ghz,
    		um,
    		cm_1,
    		kelvin,
    		electron_charge,
    		eV
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(10, active = $$props.active);
    		if ('ndensity_temp' in $$props) $$invalidate(22, ndensity_temp = $$props.ndensity_temp);
    		if ('ndensity' in $$props) $$invalidate(11, ndensity = $$props.ndensity);
    		if ('temperature' in $$props) $$invalidate(0, temperature = $$props.temperature);
    		if ('pq1_before' in $$props) $$invalidate(1, pq1_before = $$props.pq1_before);
    		if ('pq1_after' in $$props) $$invalidate(2, pq1_after = $$props.pq1_after);
    		if ('rt' in $$props) $$invalidate(3, rt = $$props.rt);
    		if ('boltzman_constant' in $$props) $$invalidate(4, boltzman_constant = $$props.boltzman_constant);
    		if ('calibration_factor' in $$props) $$invalidate(5, calibration_factor = $$props.calibration_factor);
    		if ('edit_numberDensity_constants' in $$props) $$invalidate(12, edit_numberDensity_constants = $$props.edit_numberDensity_constants);
    		if ('edit_constants' in $$props) $$invalidate(13, edit_constants = $$props.edit_constants);
    		if ('hz' in $$props) $$invalidate(6, hz = $$props.hz);
    		if ('plank_constant' in $$props) $$invalidate(7, plank_constant = $$props.plank_constant);
    		if ('J' in $$props) $$invalidate(14, J = $$props.J);
    		if ('c' in $$props) $$invalidate(8, c = $$props.c);
    		if ('nm' in $$props) $$invalidate(15, nm = $$props.nm);
    		if ('ghz' in $$props) $$invalidate(16, ghz = $$props.ghz);
    		if ('um' in $$props) $$invalidate(17, um = $$props.um);
    		if ('cm_1' in $$props) $$invalidate(18, cm_1 = $$props.cm_1);
    		if ('kelvin' in $$props) $$invalidate(19, kelvin = $$props.kelvin);
    		if ('electron_charge' in $$props) $$invalidate(9, electron_charge = $$props.electron_charge);
    		if ('eV' in $$props) $$invalidate(20, eV = $$props.eV);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*plank_constant, electron_charge, hz*/ 704) {
    			$$invalidate(20, eV = plank_constant / electron_charge * hz);
    		}

    		if ($$self.$$.dirty[0] & /*plank_constant, boltzman_constant, hz*/ 208) {
    			$$invalidate(19, kelvin = plank_constant / boltzman_constant * hz);
    		}

    		if ($$self.$$.dirty[0] & /*hz, c*/ 320) {
    			$$invalidate(18, cm_1 = hz / (c * 1e2));
    		}

    		if ($$self.$$.dirty[0] & /*c, hz*/ 320) {
    			$$invalidate(17, um = c / hz * 1e+6);
    		}

    		if ($$self.$$.dirty[0] & /*hz*/ 64) {
    			$$invalidate(16, ghz = hz * 1e-9);
    		}

    		if ($$self.$$.dirty[0] & /*c, hz*/ 320) {
    			$$invalidate(15, nm = c / hz * 1e+9);
    		}

    		if ($$self.$$.dirty[0] & /*plank_constant, hz*/ 192) {
    			$$invalidate(14, J = plank_constant * hz);
    		}

    		if ($$self.$$.dirty[0] & /*calibration_factor, boltzman_constant, rt, pq1_after, pq1_before, temperature*/ 63) {
    			$$invalidate(22, ndensity_temp = calibration_factor / (boltzman_constant * 1e4 * rt ** 0.5) * ((pq1_after - pq1_before) / temperature ** 0.5));
    		}

    		if ($$self.$$.dirty[0] & /*ndensity_temp*/ 4194304) {
    			$$invalidate(11, ndensity = ndensity_temp.toExponential(4));
    		}
    	};

    	$$invalidate(8, c = 299792458); // m/s
    	$$invalidate(7, plank_constant = 6.62607004e-34); // Js
    	$$invalidate(4, boltzman_constant = 1.380649e-23); // J/K
    	$$invalidate(9, electron_charge = 1.602176565e-19); // C or eV = J
    	$$invalidate(6, hz = (1e12).toExponential(4));
    	$$invalidate(13, edit_constants = false);
    	$$invalidate(12, edit_numberDensity_constants = false);

    	// Number density
    	$$invalidate(1, pq1_before = 1e-8);

    	$$invalidate(2, pq1_after = 1e-5);
    	$$invalidate(0, temperature = 5);
    	$$invalidate(5, calibration_factor = 205.54);
    	$$invalidate(3, rt = 300);

    	return [
    		temperature,
    		pq1_before,
    		pq1_after,
    		rt,
    		boltzman_constant,
    		calibration_factor,
    		hz,
    		plank_constant,
    		c,
    		electron_charge,
    		active,
    		ndensity,
    		edit_numberDensity_constants,
    		edit_constants,
    		J,
    		nm,
    		ghz,
    		um,
    		cm_1,
    		kelvin,
    		eV,
    		navItems,
    		ndensity_temp,
    		tabbar_active_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		change_handler,
    		textfield2_value_binding,
    		change_handler_1,
    		textfield3_value_binding,
    		change_handler_2,
    		textfield4_value_binding,
    		change_handler_3,
    		textfield5_value_binding,
    		change_handler_4,
    		textfield6_value_binding,
    		change_handler_5,
    		textfield7_value_binding,
    		change_handler_6,
    		customswitch0_selected_binding,
    		textfield8_value_binding,
    		textfield9_value_binding,
    		textfield10_value_binding,
    		textfield11_value_binding,
    		textfield12_value_binding,
    		textfield13_value_binding,
    		textfield14_value_binding,
    		textfield15_value_binding,
    		customswitch1_selected_binding,
    		textfield16_value_binding,
    		textfield17_value_binding
    	];
    }

    class Misc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Misc",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\components\PreModal.svelte generated by Svelte v3.42.1 */

    const { console: console_1 } = globals;
    const file$1 = "src\\components\\PreModal.svelte";

    // (32:0) {#if active}
    function create_if_block$1(ctx) {
    	let modal;
    	let updating_active;
    	let current;

    	function modal_active_binding(value) {
    		/*modal_active_binding*/ ctx[3](value);
    	}

    	let modal_props = {
    		title: /*$mainPreModal*/ ctx[1].modalTitle || "Error details",
    		bodyBackground: "#634e96",
    		headerBackground: /*headerBackground*/ ctx[2],
    		$$slots: { content: [create_content_slot] },
    		$$scope: { ctx }
    	};

    	if (/*active*/ ctx[0] !== void 0) {
    		modal_props.active = /*active*/ ctx[0];
    	}

    	modal = new Modal$1({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, 'active', modal_active_binding));

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};
    			if (dirty & /*$mainPreModal*/ 2) modal_changes.title = /*$mainPreModal*/ ctx[1].modalTitle || "Error details";
    			if (dirty & /*headerBackground*/ 4) modal_changes.headerBackground = /*headerBackground*/ ctx[2];

    			if (dirty & /*$$scope, $mainPreModal*/ 34) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*active*/ 1) {
    				updating_active = true;
    				modal_changes.active = /*active*/ ctx[0];
    				add_flush_callback(() => updating_active = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(32:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (34:4) 
    function create_content_slot(ctx) {
    	let div;
    	let t_value = /*$mainPreModal*/ ctx[1].modalContent + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "slot", "content");
    			set_style(div, "color", "#fafafa");
    			set_style(div, "white-space", "pre-wrap");
    			set_style(div, "user-select", "text");
    			add_location(div, file$1, 33, 4, 924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$mainPreModal*/ 2 && t_value !== (t_value = /*$mainPreModal*/ ctx[1].modalContent + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(34:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*active*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $mainPreModal;
    	validate_store(mainPreModal, 'mainPreModal');
    	component_subscribe($$self, mainPreModal, $$value => $$invalidate(1, $mainPreModal = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PreModal', slots, []);
    	let active = false;

    	function openModal() {
    		Snackbar.create({
    			message: $mainPreModal.message || "Error Occured",
    			position: "is-top",
    			type: `is-${$mainPreModal.type || "danger"}`,
    			duration: 5000,
    			actionText: $mainPreModal.actionText || "Show Details",
    			onAction: () => {
    				$$invalidate(0, active = true);
    			}
    		});

    		set_store_value(mainPreModal, $mainPreModal.open = false, $mainPreModal);
    	}

    	let headerBackground = "#836ac05c";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<PreModal> was created with unknown prop '${key}'`);
    	});

    	function modal_active_binding(value) {
    		active = value;
    		$$invalidate(0, active);
    	}

    	$$self.$capture_state = () => ({
    		mainPreModal,
    		Snackbar,
    		Modal: Modal$1,
    		active,
    		openModal,
    		headerBackground,
    		$mainPreModal
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('headerBackground' in $$props) $$invalidate(2, headerBackground = $$props.headerBackground);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$mainPreModal*/ 2) {
    			if ($mainPreModal.open) {
    				openModal();
    			}
    		}

    		if ($$self.$$.dirty & /*$mainPreModal*/ 2) {
    			console.log($mainPreModal);
    		}

    		if ($$self.$$.dirty & /*active, $mainPreModal*/ 3) {
    			if (active) {
    				$$invalidate(2, headerBackground = $mainPreModal.type === "danger"
    				? "#f14668"
    				: "#836ac05c");
    			}
    		}
    	};

    	return [active, $mainPreModal, headerBackground, modal_active_binding];
    }

    class PreModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PreModal",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.42.1 */
    const file = "src\\App.svelte";

    // (35:0) {#if $windowLoaded}
    function create_if_block(ctx) {
    	let t0;
    	let navbar;
    	let t1;
    	let home;
    	let t2;
    	let div;
    	let normline;
    	let t3;
    	let masspec;
    	let t4;
    	let timescan;
    	let t5;
    	let thz;
    	let t6;
    	let powerfile;
    	let t7;
    	let misc;
    	let t8;
    	let settings;
    	let t9;
    	let footer;
    	let current;
    	let if_block = /*mounted*/ ctx[0] && create_if_block_1(ctx);

    	navbar = new Navbar({
    			props: { navItems: /*navItems*/ ctx[2] },
    			$$inline: true
    		});

    	home = new Home({ $$inline: true });
    	normline = new Normline({ $$inline: true });
    	masspec = new Masspec({ $$inline: true });
    	timescan = new Timescan({ $$inline: true });
    	thz = new THz({ $$inline: true });
    	powerfile = new Powerfile({ $$inline: true });
    	misc = new Misc({ $$inline: true });
    	settings = new Settings({ $$inline: true });
    	footer = new Footer$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			create_component(home.$$.fragment);
    			t2 = space();
    			div = element("div");
    			create_component(normline.$$.fragment);
    			t3 = space();
    			create_component(masspec.$$.fragment);
    			t4 = space();
    			create_component(timescan.$$.fragment);
    			t5 = space();
    			create_component(thz.$$.fragment);
    			t6 = space();
    			create_component(powerfile.$$.fragment);
    			t7 = space();
    			create_component(misc.$$.fragment);
    			t8 = space();
    			create_component(settings.$$.fragment);
    			t9 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div, "id", "pageContainer");
    			set_style(div, "overflow", "hidden");
    			set_style(div, "display", /*mounted*/ ctx[0] ? 'block' : 'none');
    			add_location(div, file, 41, 1, 1148);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(home, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(normline, div, null);
    			append_dev(div, t3);
    			mount_component(masspec, div, null);
    			append_dev(div, t4);
    			mount_component(timescan, div, null);
    			append_dev(div, t5);
    			mount_component(thz, div, null);
    			append_dev(div, t6);
    			mount_component(powerfile, div, null);
    			append_dev(div, t7);
    			mount_component(misc, div, null);
    			append_dev(div, t8);
    			mount_component(settings, div, null);
    			insert_dev(target, t9, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*mounted*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*mounted*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*mounted*/ 1) {
    				set_style(div, "display", /*mounted*/ ctx[0] ? 'block' : 'none');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(navbar.$$.fragment, local);
    			transition_in(home.$$.fragment, local);
    			transition_in(normline.$$.fragment, local);
    			transition_in(masspec.$$.fragment, local);
    			transition_in(timescan.$$.fragment, local);
    			transition_in(thz.$$.fragment, local);
    			transition_in(powerfile.$$.fragment, local);
    			transition_in(misc.$$.fragment, local);
    			transition_in(settings.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(navbar.$$.fragment, local);
    			transition_out(home.$$.fragment, local);
    			transition_out(normline.$$.fragment, local);
    			transition_out(masspec.$$.fragment, local);
    			transition_out(timescan.$$.fragment, local);
    			transition_out(thz.$$.fragment, local);
    			transition_out(powerfile.$$.fragment, local);
    			transition_out(misc.$$.fragment, local);
    			transition_out(settings.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(home, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			destroy_component(normline);
    			destroy_component(masspec);
    			destroy_component(timescan);
    			destroy_component(thz);
    			destroy_component(powerfile);
    			destroy_component(misc);
    			destroy_component(settings);
    			if (detaching) detach_dev(t9);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(35:0) {#if $windowLoaded}",
    		ctx
    	});

    	return block;
    }

    // (36:1) {#if mounted}
    function create_if_block_1(ctx) {
    	let premodal;
    	let current;
    	premodal = new PreModal({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(premodal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(premodal, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(premodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(premodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(premodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(36:1) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$windowLoaded*/ ctx[1] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$windowLoaded*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$windowLoaded*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $windowLoaded;
    	validate_store(windowLoaded, 'windowLoaded');
    	component_subscribe($$self, windowLoaded, $$value => $$invalidate(1, $windowLoaded = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let mounted = false;

    	onMount(async () => {
    		const allbuttons = Array.from(document.querySelectorAll(".button"));
    		allbuttons.forEach(button => button.classList.add("hvr-glow"));
    		await tick();
    		$$invalidate(0, mounted = true);
    	});

    	const navItems = [
    		"Home",
    		"Normline",
    		"Masspec",
    		"Timescan",
    		"THz",
    		"Powerfile",
    		"Misc",
    		"Settings"
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		windowLoaded,
    		Navbar,
    		Footer: Footer$1,
    		Home,
    		Powerfile,
    		Normline,
    		Masspec,
    		Timescan,
    		THz,
    		Settings,
    		Misc,
    		PreModal,
    		onMount,
    		tick,
    		mounted,
    		navItems,
    		$windowLoaded
    	});

    	$$self.$inject_state = $$props => {
    		if ('mounted' in $$props) $$invalidate(0, mounted = $$props.mounted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [mounted, $windowLoaded, navItems];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({target: document.body});

    return app;

}(marked));
//# sourceMappingURL=bundle.js.map
