
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var child_process = _interopDefault(require('child_process'));
var https = _interopDefault(require('https'));
var fs$4 = _interopDefault(require('fs'));
var originalFs$1 = _interopDefault(require('original-fs'));
var path$2 = _interopDefault(require('path'));
var zlib = _interopDefault(require('zlib'));
var domain$1 = _interopDefault(require('domain'));
var constants$1 = _interopDefault(require('constants'));
var stream = _interopDefault(require('stream'));
var util$1 = _interopDefault(require('util'));
var assert = _interopDefault(require('assert'));
var events$2 = _interopDefault(require('events'));

function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = value;
    }
    else {
        attr(node, prop, value);
    }
}
function xlink_attr(node, attribute, value) {
    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
class HtmlTag {
    constructor(anchor = null) {
        this.a = anchor;
        this.e = this.n = null;
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.h(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.2' }, detail)));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = /** @class */ (function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) { adapter = {}; }
        this.adapter_ = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function () {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: true,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}());
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCComponent = /** @class */ (function () {
    function MDCComponent(root, foundation) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this.root_ = root;
        this.initialize.apply(this, __spread(args));
        // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.
        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
    }
    MDCComponent.attachTo = function (root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation({}));
    };
    /* istanbul ignore next: method param only exists for typing purposes; it does not need to be unit tested */
    MDCComponent.prototype.initialize = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
        // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.
    };
    MDCComponent.prototype.getDefaultFoundation = function () {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' +
            'foundation class');
    };
    MDCComponent.prototype.initialSyncWithDOM = function () {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    };
    MDCComponent.prototype.destroy = function () {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
    };
    MDCComponent.prototype.listen = function (evtType, handler, options) {
        this.root_.addEventListener(evtType, handler, options);
    };
    MDCComponent.prototype.unlisten = function (evtType, handler, options) {
        this.root_.removeEventListener(evtType, handler, options);
    };
    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type, with the given data.
     */
    MDCComponent.prototype.emit = function (evtType, evtData, shouldBubble) {
        if (shouldBubble === void 0) { shouldBubble = false; }
        var evt;
        if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
                bubbles: shouldBubble,
                detail: evtData,
            });
        }
        else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }
        this.root_.dispatchEvent(evt);
    };
    return MDCComponent;
}());
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Stores result from applyPassive to avoid redundant processing to detect
 * passive event listener support.
 */
var supportsPassive_;
/**
 * Determine whether the current browser supports passive event listeners, and
 * if so, use them.
 */
function applyPassive(globalObj, forceRefresh) {
    if (globalObj === void 0) { globalObj = window; }
    if (forceRefresh === void 0) { forceRefresh = false; }
    if (supportsPassive_ === undefined || forceRefresh) {
        var isSupported_1 = false;
        try {
            globalObj.document.addEventListener('test', function () { return undefined; }, {
                get passive() {
                    isSupported_1 = true;
                    return isSupported_1;
                },
            });
        }
        catch (e) {
        } // tslint:disable-line:no-empty cannot throw error due to tests. tslint also disables console.log.
        supportsPassive_ = isSupported_1;
    }
    return supportsPassive_ ? { passive: true } : false;
}
//# sourceMappingURL=events.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    var el = element;
    while (el) {
        if (matches(el, selector)) {
            return el;
        }
        el = el.parentElement;
    }
    return null;
}
function matches(element, selector) {
    var nativeMatches = element.matches
        || element.webkitMatchesSelector
        || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
}
//# sourceMappingURL=ponyfill.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
};
var strings = {
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
};
var numbers = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: 0.6,
    PADDING: 10,
    TAP_DELAY_MS: 300,
};
//# sourceMappingURL=constants.js.map

/**
 * Stores result from supportsCssVariables to avoid redundant processing to
 * detect CSS custom variable support.
 */
var supportsCssVariables_;
function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    // Append to head instead of body because this script might be invoked in the
    // head, in which case the body doesn't exist yet. The probe works either way.
    document.head.appendChild(node);
    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
    return hasPseudoVarBug;
}
function supportsCssVariables(windowObj, forceRefresh) {
    if (forceRefresh === void 0) { forceRefresh = false; }
    var CSS = windowObj.CSS;
    var supportsCssVars = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables_;
    }
    var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
    if (!supportsFunctionPresent) {
        return false;
    }
    var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = (CSS.supports('(--css-vars: yes)') &&
        CSS.supports('color', '#00000000'));
    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVars = !detectEdgePseudoVarBug(windowObj);
    }
    else {
        supportsCssVars = false;
    }
    if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVars;
    }
    return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
    if (!evt) {
        return { x: 0, y: 0 };
    }
    var x = pageOffset.x, y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY;
    // Determine touch point relative to the ripple container.
    if (evt.type === 'touchstart') {
        var touchEvent = evt;
        normalizedX = touchEvent.changedTouches[0].pageX - documentX;
        normalizedY = touchEvent.changedTouches[0].pageY - documentY;
    }
    else {
        var mouseEvent = evt;
        normalizedX = mouseEvent.pageX - documentX;
        normalizedY = mouseEvent.pageY - documentY;
    }
    return { x: normalizedX, y: normalizedY };
}
//# sourceMappingURL=util.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
// Activation events registered on the root element of each instance for activation
var ACTIVATION_EVENT_TYPES = [
    'touchstart', 'pointerdown', 'mousedown', 'keydown',
];
// Deactivation events registered on documentElement when a pointer-related down event occurs
var POINTER_DEACTIVATION_EVENT_TYPES = [
    'touchend', 'pointerup', 'mouseup', 'contextmenu',
];
// simultaneous nested activations
var activatedTargets = [];
var MDCRippleFoundation = /** @class */ (function (_super) {
    __extends(MDCRippleFoundation, _super);
    function MDCRippleFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCRippleFoundation.defaultAdapter, adapter)) || this;
        _this.activationAnimationHasEnded_ = false;
        _this.activationTimer_ = 0;
        _this.fgDeactivationRemovalTimer_ = 0;
        _this.fgScale_ = '0';
        _this.frame_ = { width: 0, height: 0 };
        _this.initialSize_ = 0;
        _this.layoutFrame_ = 0;
        _this.maxRadius_ = 0;
        _this.unboundedCoords_ = { left: 0, top: 0 };
        _this.activationState_ = _this.defaultActivationState_();
        _this.activationTimerCallback_ = function () {
            _this.activationAnimationHasEnded_ = true;
            _this.runDeactivationUXLogicIfReady_();
        };
        _this.activateHandler_ = function (e) { return _this.activate_(e); };
        _this.deactivateHandler_ = function () { return _this.deactivate_(); };
        _this.focusHandler_ = function () { return _this.handleFocus(); };
        _this.blurHandler_ = function () { return _this.handleBlur(); };
        _this.resizeHandler_ = function () { return _this.layout(); };
        return _this;
    }
    Object.defineProperty(MDCRippleFoundation, "cssClasses", {
        get: function () {
            return cssClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "strings", {
        get: function () {
            return strings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "numbers", {
        get: function () {
            return numbers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClass: function () { return undefined; },
                browserSupportsCssVars: function () { return true; },
                computeBoundingRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                containsEventTarget: function () { return true; },
                deregisterDocumentInteractionHandler: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
                deregisterResizeHandler: function () { return undefined; },
                getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },
                isSurfaceActive: function () { return true; },
                isSurfaceDisabled: function () { return true; },
                isUnbounded: function () { return true; },
                registerDocumentInteractionHandler: function () { return undefined; },
                registerInteractionHandler: function () { return undefined; },
                registerResizeHandler: function () { return undefined; },
                removeClass: function () { return undefined; },
                updateCssVariable: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCRippleFoundation.prototype.init = function () {
        var _this = this;
        var supportsPressRipple = this.supportsPressRipple_();
        this.registerRootHandlers_(supportsPressRipple);
        if (supportsPressRipple) {
            var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
            requestAnimationFrame(function () {
                _this.adapter_.addClass(ROOT_1);
                if (_this.adapter_.isUnbounded()) {
                    _this.adapter_.addClass(UNBOUNDED_1);
                    // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                    _this.layoutInternal_();
                }
            });
        }
    };
    MDCRippleFoundation.prototype.destroy = function () {
        var _this = this;
        if (this.supportsPressRipple_()) {
            if (this.activationTimer_) {
                clearTimeout(this.activationTimer_);
                this.activationTimer_ = 0;
                this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
            }
            if (this.fgDeactivationRemovalTimer_) {
                clearTimeout(this.fgDeactivationRemovalTimer_);
                this.fgDeactivationRemovalTimer_ = 0;
                this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
            }
            var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
            requestAnimationFrame(function () {
                _this.adapter_.removeClass(ROOT_2);
                _this.adapter_.removeClass(UNBOUNDED_2);
                _this.removeCssVars_();
            });
        }
        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
    };
    /**
     * @param evt Optional event containing position information.
     */
    MDCRippleFoundation.prototype.activate = function (evt) {
        this.activate_(evt);
    };
    MDCRippleFoundation.prototype.deactivate = function () {
        this.deactivate_();
    };
    MDCRippleFoundation.prototype.layout = function () {
        var _this = this;
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
            _this.layoutInternal_();
            _this.layoutFrame_ = 0;
        });
    };
    MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
        if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
        }
        else {
            this.adapter_.removeClass(UNBOUNDED);
        }
    };
    MDCRippleFoundation.prototype.handleFocus = function () {
        var _this = this;
        requestAnimationFrame(function () {
            return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
    };
    MDCRippleFoundation.prototype.handleBlur = function () {
        var _this = this;
        requestAnimationFrame(function () {
            return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
    };
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     */
    MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
        return this.adapter_.browserSupportsCssVars();
    };
    MDCRippleFoundation.prototype.defaultActivationState_ = function () {
        return {
            activationEvent: undefined,
            hasDeactivationUXRun: false,
            isActivated: false,
            isProgrammatic: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
        };
    };
    /**
     * supportsPressRipple Passed from init to save a redundant function call
     */
    MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
        var _this = this;
        if (supportsPressRipple) {
            ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
            });
            if (this.adapter_.isUnbounded()) {
                this.adapter_.registerResizeHandler(this.resizeHandler_);
            }
        }
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
    };
    MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
        var _this = this;
        if (evt.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        }
        else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
                _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
            });
        }
    };
    MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
        var _this = this;
        ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
    };
    MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
        var _this = this;
        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
            _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
        });
    };
    MDCRippleFoundation.prototype.removeCssVars_ = function () {
        var _this = this;
        var rippleStrings = MDCRippleFoundation.strings;
        var keys = Object.keys(rippleStrings);
        keys.forEach(function (key) {
            if (key.indexOf('VAR_') === 0) {
                _this.adapter_.updateCssVariable(rippleStrings[key], null);
            }
        });
    };
    MDCRippleFoundation.prototype.activate_ = function (evt) {
        var _this = this;
        if (this.adapter_.isSurfaceDisabled()) {
            return;
        }
        var activationState = this.activationState_;
        if (activationState.isActivated) {
            return;
        }
        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
        if (isSameInteraction) {
            return;
        }
        activationState.isActivated = true;
        activationState.isProgrammatic = evt === undefined;
        activationState.activationEvent = evt;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
        var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) { return _this.adapter_.containsEventTarget(target); });
        if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
        }
        if (evt !== undefined) {
            activatedTargets.push(evt.target);
            this.registerDeactivationHandlers_(evt);
        }
        activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
        if (activationState.wasElementMadeActive) {
            this.animateActivation_();
        }
        requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];
            if (!activationState.wasElementMadeActive
                && evt !== undefined
                && (evt.key === ' ' || evt.keyCode === 32)) {
                // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                // active states inconsistently when they're called within event handling code:
                // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                // variable is set within a rAF callback for a submit button interaction (#2241).
                activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
                if (activationState.wasElementMadeActive) {
                    _this.animateActivation_();
                }
            }
            if (!activationState.wasElementMadeActive) {
                // Reset activation state immediately if element was not made active.
                _this.activationState_ = _this.defaultActivationState_();
            }
        });
    };
    MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
        return (evt !== undefined && evt.type === 'keydown') ? this.adapter_.isSurfaceActive() : true;
    };
    MDCRippleFoundation.prototype.animateActivation_ = function () {
        var _this = this;
        var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
        var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';
        if (!this.adapter_.isUnbounded()) {
            var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
            translateStart = startPoint.x + "px, " + startPoint.y + "px";
            translateEnd = endPoint.x + "px, " + endPoint.y + "px";
        }
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);
        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () { return _this.activationTimerCallback_(); }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
        var _a = this.activationState_, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
        var startPoint;
        if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        }
        else {
            startPoint = {
                x: this.frame_.width / 2,
                y: this.frame_.height / 2,
            };
        }
        // Center the element around the start point.
        startPoint = {
            x: startPoint.x - (this.initialSize_ / 2),
            y: startPoint.y - (this.initialSize_ / 2),
        };
        var endPoint = {
            x: (this.frame_.width / 2) - (this.initialSize_ / 2),
            y: (this.frame_.height / 2) - (this.initialSize_ / 2),
        };
        return { startPoint: startPoint, endPoint: endPoint };
    };
    MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
        var _this = this;
        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _a = this.activationState_, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;
        if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
                _this.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers.FG_DEACTIVATION_MS);
        }
    };
    MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
    };
    MDCRippleFoundation.prototype.resetActivationState_ = function () {
        var _this = this;
        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () { return _this.previousActivationEvent_ = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation.prototype.deactivate_ = function () {
        var _this = this;
        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
            return;
        }
        var state = __assign({}, activationState);
        if (activationState.isProgrammatic) {
            requestAnimationFrame(function () { return _this.animateDeactivation_(state); });
            this.resetActivationState_();
        }
        else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
                _this.activationState_.hasDeactivationUXRun = true;
                _this.animateDeactivation_(state);
                _this.resetActivationState_();
            });
        }
    };
    MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
        var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
        if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
        }
    };
    MDCRippleFoundation.prototype.layoutInternal_ = function () {
        var _this = this;
        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);
        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function () {
            var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };
        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();
        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
        this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
    };
    MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
        var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
        if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
                left: Math.round((this.frame_.width / 2) - (this.initialSize_ / 2)),
                top: Math.round((this.frame_.height / 2) - (this.initialSize_ / 2)),
            };
            this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
            this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
        }
    };
    return MDCRippleFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRipple = /** @class */ (function (_super) {
    __extends(MDCRipple, _super);
    function MDCRipple() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.disabled = false;
        return _this;
    }
    MDCRipple.attachTo = function (root, opts) {
        if (opts === void 0) { opts = { isUnbounded: undefined }; }
        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (opts.isUnbounded !== undefined) {
            ripple.unbounded = opts.isUnbounded;
        }
        return ripple;
    };
    MDCRipple.createAdapter = function (instance) {
        return {
            addClass: function (className) { return instance.root_.classList.add(className); },
            browserSupportsCssVars: function () { return supportsCssVariables(window); },
            computeBoundingRect: function () { return instance.root_.getBoundingClientRect(); },
            containsEventTarget: function (target) { return instance.root_.contains(target); },
            deregisterDocumentInteractionHandler: function (evtType, handler) {
                return document.documentElement.removeEventListener(evtType, handler, applyPassive());
            },
            deregisterInteractionHandler: function (evtType, handler) {
                return instance.root_.removeEventListener(evtType, handler, applyPassive());
            },
            deregisterResizeHandler: function (handler) { return window.removeEventListener('resize', handler); },
            getWindowPageOffset: function () { return ({ x: window.pageXOffset, y: window.pageYOffset }); },
            isSurfaceActive: function () { return matches(instance.root_, ':active'); },
            isSurfaceDisabled: function () { return Boolean(instance.disabled); },
            isUnbounded: function () { return Boolean(instance.unbounded); },
            registerDocumentInteractionHandler: function (evtType, handler) {
                return document.documentElement.addEventListener(evtType, handler, applyPassive());
            },
            registerInteractionHandler: function (evtType, handler) {
                return instance.root_.addEventListener(evtType, handler, applyPassive());
            },
            registerResizeHandler: function (handler) { return window.addEventListener('resize', handler); },
            removeClass: function (className) { return instance.root_.classList.remove(className); },
            updateCssVariable: function (varName, value) { return instance.root_.style.setProperty(varName, value); },
        };
    };
    Object.defineProperty(MDCRipple.prototype, "unbounded", {
        get: function () {
            return Boolean(this.unbounded_);
        },
        set: function (unbounded) {
            this.unbounded_ = Boolean(unbounded);
            this.setUnbounded_();
        },
        enumerable: true,
        configurable: true
    });
    MDCRipple.prototype.activate = function () {
        this.foundation_.activate();
    };
    MDCRipple.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    MDCRipple.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCRipple.prototype.getDefaultFoundation = function () {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
    };
    MDCRipple.prototype.initialSyncWithDOM = function () {
        var root = this.root_;
        this.unbounded = 'mdcRippleIsUnbounded' in root.dataset;
    };
    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     */
    MDCRipple.prototype.setUnbounded_ = function () {
        this.foundation_.setUnbounded(Boolean(this.unbounded_));
    };
    return MDCRipple;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
    ACTIVE: 'mdc-tab-indicator--active',
    FADE: 'mdc-tab-indicator--fade',
    NO_TRANSITION: 'mdc-tab-indicator--no-transition',
};
var strings$1 = {
    CONTENT_SELECTOR: '.mdc-tab-indicator__content',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabIndicatorFoundation = /** @class */ (function (_super) {
    __extends(MDCTabIndicatorFoundation, _super);
    function MDCTabIndicatorFoundation(adapter) {
        return _super.call(this, __assign({}, MDCTabIndicatorFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCTabIndicatorFoundation, "cssClasses", {
        get: function () {
            return cssClasses$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabIndicatorFoundation, "strings", {
        get: function () {
            return strings$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabIndicatorFoundation, "defaultAdapter", {
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                computeContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                setContentStyleProperty: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabIndicatorFoundation.prototype.computeContentClientRect = function () {
        return this.adapter_.computeContentClientRect();
    };
    return MDCTabIndicatorFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* istanbul ignore next: subclass is not a branch statement */
var MDCFadingTabIndicatorFoundation = /** @class */ (function (_super) {
    __extends(MDCFadingTabIndicatorFoundation, _super);
    function MDCFadingTabIndicatorFoundation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFadingTabIndicatorFoundation.prototype.activate = function () {
        this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    MDCFadingTabIndicatorFoundation.prototype.deactivate = function () {
        this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    return MDCFadingTabIndicatorFoundation;
}(MDCTabIndicatorFoundation));
//# sourceMappingURL=fading-foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/* istanbul ignore next: subclass is not a branch statement */
var MDCSlidingTabIndicatorFoundation = /** @class */ (function (_super) {
    __extends(MDCSlidingTabIndicatorFoundation, _super);
    function MDCSlidingTabIndicatorFoundation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSlidingTabIndicatorFoundation.prototype.activate = function (previousIndicatorClientRect) {
        // Early exit if no indicator is present to handle cases where an indicator
        // may be activated without a prior indicator state
        if (!previousIndicatorClientRect) {
            this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            return;
        }
        // This animation uses the FLIP approach. You can read more about it at the link below:
        // https://aerotwist.com/blog/flip-your-animations/
        // Calculate the dimensions based on the dimensions of the previous indicator
        var currentClientRect = this.computeContentClientRect();
        var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
        var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
        this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.setContentStyleProperty('transform', "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
        // Force repaint before updating classes and transform to ensure the transform properly takes effect
        this.computeContentClientRect();
        this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        this.adapter_.setContentStyleProperty('transform', '');
    };
    MDCSlidingTabIndicatorFoundation.prototype.deactivate = function () {
        this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
    };
    return MDCSlidingTabIndicatorFoundation;
}(MDCTabIndicatorFoundation));
//# sourceMappingURL=sliding-foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabIndicator = /** @class */ (function (_super) {
    __extends(MDCTabIndicator, _super);
    function MDCTabIndicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabIndicator.attachTo = function (root) {
        return new MDCTabIndicator(root);
    };
    MDCTabIndicator.prototype.initialize = function () {
        this.content_ = this.root_.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTabIndicator.prototype.computeContentClientRect = function () {
        return this.foundation_.computeContentClientRect();
    };
    MDCTabIndicator.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            computeContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
            setContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
        };
        // tslint:enable:object-literal-sort-keys
        if (this.root_.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
            return new MDCFadingTabIndicatorFoundation(adapter);
        }
        // Default to the sliding indicator
        return new MDCSlidingTabIndicatorFoundation(adapter);
    };
    MDCTabIndicator.prototype.activate = function (previousIndicatorClientRect) {
        this.foundation_.activate(previousIndicatorClientRect);
    };
    MDCTabIndicator.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    return MDCTabIndicator;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$2 = {
    ACTIVE: 'mdc-tab--active',
};
var strings$2 = {
    ARIA_SELECTED: 'aria-selected',
    CONTENT_SELECTOR: '.mdc-tab__content',
    INTERACTED_EVENT: 'MDCTab:interacted',
    RIPPLE_SELECTOR: '.mdc-tab__ripple',
    TABINDEX: 'tabIndex',
    TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabFoundation = /** @class */ (function (_super) {
    __extends(MDCTabFoundation, _super);
    function MDCTabFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCTabFoundation.defaultAdapter, adapter)) || this;
        _this.focusOnActivate_ = true;
        return _this;
    }
    Object.defineProperty(MDCTabFoundation, "cssClasses", {
        get: function () {
            return cssClasses$2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabFoundation, "strings", {
        get: function () {
            return strings$2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabFoundation, "defaultAdapter", {
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                setAttr: function () { return undefined; },
                activateIndicator: function () { return undefined; },
                deactivateIndicator: function () { return undefined; },
                notifyInteracted: function () { return undefined; },
                getOffsetLeft: function () { return 0; },
                getOffsetWidth: function () { return 0; },
                getContentOffsetLeft: function () { return 0; },
                getContentOffsetWidth: function () { return 0; },
                focus: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabFoundation.prototype.handleClick = function () {
        // It's up to the parent component to keep track of the active Tab and
        // ensure we don't activate a Tab that's already active.
        this.adapter_.notifyInteracted();
    };
    MDCTabFoundation.prototype.isActive = function () {
        return this.adapter_.hasClass(cssClasses$2.ACTIVE);
    };
    /**
     * Sets whether the tab should focus itself when activated
     */
    MDCTabFoundation.prototype.setFocusOnActivate = function (focusOnActivate) {
        this.focusOnActivate_ = focusOnActivate;
    };
    /**
     * Activates the Tab
     */
    MDCTabFoundation.prototype.activate = function (previousIndicatorClientRect) {
        this.adapter_.addClass(cssClasses$2.ACTIVE);
        this.adapter_.setAttr(strings$2.ARIA_SELECTED, 'true');
        this.adapter_.setAttr(strings$2.TABINDEX, '0');
        this.adapter_.activateIndicator(previousIndicatorClientRect);
        if (this.focusOnActivate_) {
            this.adapter_.focus();
        }
    };
    /**
     * Deactivates the Tab
     */
    MDCTabFoundation.prototype.deactivate = function () {
        // Early exit
        if (!this.isActive()) {
            return;
        }
        this.adapter_.removeClass(cssClasses$2.ACTIVE);
        this.adapter_.setAttr(strings$2.ARIA_SELECTED, 'false');
        this.adapter_.setAttr(strings$2.TABINDEX, '-1');
        this.adapter_.deactivateIndicator();
    };
    /**
     * Returns the dimensions of the Tab
     */
    MDCTabFoundation.prototype.computeDimensions = function () {
        var rootWidth = this.adapter_.getOffsetWidth();
        var rootLeft = this.adapter_.getOffsetLeft();
        var contentWidth = this.adapter_.getContentOffsetWidth();
        var contentLeft = this.adapter_.getContentOffsetLeft();
        return {
            contentLeft: rootLeft + contentLeft,
            contentRight: rootLeft + contentLeft + contentWidth,
            rootLeft: rootLeft,
            rootRight: rootLeft + rootWidth,
        };
    };
    return MDCTabFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTab = /** @class */ (function (_super) {
    __extends(MDCTab, _super);
    function MDCTab() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTab.attachTo = function (root) {
        return new MDCTab(root);
    };
    MDCTab.prototype.initialize = function (rippleFactory, tabIndicatorFactory) {
        if (rippleFactory === void 0) { rippleFactory = function (el, foundation) { return new MDCRipple(el, foundation); }; }
        if (tabIndicatorFactory === void 0) { tabIndicatorFactory = function (el) { return new MDCTabIndicator(el); }; }
        this.id = this.root_.id;
        var rippleSurface = this.root_.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
        var rippleAdapter = __assign({}, MDCRipple.createAdapter(this), { addClass: function (className) { return rippleSurface.classList.add(className); }, removeClass: function (className) { return rippleSurface.classList.remove(className); }, updateCssVariable: function (varName, value) { return rippleSurface.style.setProperty(varName, value); } });
        var rippleFoundation = new MDCRippleFoundation(rippleAdapter);
        this.ripple_ = rippleFactory(this.root_, rippleFoundation);
        var tabIndicatorElement = this.root_.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
        this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
        this.content_ = this.root_.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTab.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleClick_ = function () { return _this.foundation_.handleClick(); };
        this.listen('click', this.handleClick_);
    };
    MDCTab.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCTab.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            activateIndicator: function (previousIndicatorClientRect) { return _this.tabIndicator_.activate(previousIndicatorClientRect); },
            deactivateIndicator: function () { return _this.tabIndicator_.deactivate(); },
            notifyInteracted: function () { return _this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, { tabId: _this.id }, true /* bubble */); },
            getOffsetLeft: function () { return _this.root_.offsetLeft; },
            getOffsetWidth: function () { return _this.root_.offsetWidth; },
            getContentOffsetLeft: function () { return _this.content_.offsetLeft; },
            getContentOffsetWidth: function () { return _this.content_.offsetWidth; },
            focus: function () { return _this.root_.focus(); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCTabFoundation(adapter);
    };
    Object.defineProperty(MDCTab.prototype, "active", {
        /**
         * Getter for the active state of the tab
         */
        get: function () {
            return this.foundation_.isActive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTab.prototype, "focusOnActivate", {
        set: function (focusOnActivate) {
            this.foundation_.setFocusOnActivate(focusOnActivate);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activates the tab
     */
    MDCTab.prototype.activate = function (computeIndicatorClientRect) {
        this.foundation_.activate(computeIndicatorClientRect);
    };
    /**
     * Deactivates the tab
     */
    MDCTab.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    /**
     * Returns the indicator's client rect
     */
    MDCTab.prototype.computeIndicatorClientRect = function () {
        return this.tabIndicator_.computeContentClientRect();
    };
    MDCTab.prototype.computeDimensions = function () {
        return this.foundation_.computeDimensions();
    };
    /**
     * Focuses the tab
     */
    MDCTab.prototype.focus = function () {
        this.root_.focus();
    };
    return MDCTab;
}(MDCComponent));
//# sourceMappingURL=component.js.map

function forwardEventsBuilder(component, additionalEvents = []) {
  const events = [
    'focus', 'blur',
    'fullscreenchange', 'fullscreenerror', 'scroll',
    'cut', 'copy', 'paste',
    'keydown', 'keypress', 'keyup',
    'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel',
    'drag', 'dragend', 'dragenter', 'dragstart', 'dragleave', 'dragover', 'drop',
    'touchcancel', 'touchend', 'touchmove', 'touchstart',
    'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave', 'gotpointercapture', 'lostpointercapture',
    ...additionalEvents
  ];

  function forward(e) {
    bubble(component, e);
  }

  return node => {
    const destructors = [];

    for (let i = 0; i < events.length; i++) {
      destructors.push(listen(node, events[i], forward));
    }

    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
      }
    }
  };
}

function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf('$');
    if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }

  return newObj;
}

function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }

  return newObj;
}

function useActions(node, actions) {
  let objects = [];

  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const isArray = Array.isArray(actions[i]);
      const action = isArray ? actions[i][0] : actions[i];
      if (isArray && actions[i].length > 1) {
        objects.push(action(node, actions[i][1]));
      } else {
        objects.push(action(node));
      }
    }
  }

  return {
    update(actions) {
      if ((actions && actions.length || 0) != objects.length) {
        throw new Error('You must not change the length of an actions array.');
      }

      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          if (objects[i] && 'update' in objects[i]) {
            const isArray = Array.isArray(actions[i]);
            if (isArray && actions[i].length > 1) {
              objects[i].update(actions[i][1]);
            } else {
              objects[i].update();
            }
          }
        }
      }
    },

    destroy() {
      for (let i = 0; i < objects.length; i++) {
        if (objects[i] && 'destroy' in objects[i]) {
          objects[i].destroy();
        }
      }
    }
  }
}

/* node_modules\@smui\common\A.svelte generated by Svelte v3.31.2 */
const file = "node_modules\\@smui\\common\\A.svelte";

function create_fragment(ctx) {
	let a;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let a_levels = [{ href: /*href*/ ctx[1] }, exclude(/*$$props*/ ctx[3], ["use", "href"])];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, a))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 2) && { href: /*href*/ ctx[1] },
				dirty & /*$$props*/ 8 && exclude(/*$$props*/ ctx[3], ["use", "href"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("A", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { href = "javascript:void(0);" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		href
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, href, forwardEvents, $$props, $$scope, slots];
}

class A extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { use: 0, href: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "A",
			options,
			id: create_fragment.name
		});
	}

	get use() {
		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\Button.svelte generated by Svelte v3.31.2 */
const file$1 = "node_modules\\@smui\\common\\Button.svelte";

function create_fragment$1(ctx) {
	let button;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let button_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$1, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, button))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$1.name
		});
	}

	get use() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\tab-indicator\TabIndicator.svelte generated by Svelte v3.31.2 */
const file$2 = "node_modules\\@smui\\tab-indicator\\TabIndicator.svelte";

function create_fragment$2(ctx) {
	let span1;
	let span0;
	let span0_class_value;
	let span0_aria_hidden_value;
	let useActions_action;
	let span1_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let span0_levels = [
		{
			class: span0_class_value = "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === "underline"
			? "mdc-tab-indicator__content--underline"
			: "") + "\n      " + (/*type*/ ctx[3] === "icon"
			? "mdc-tab-indicator__content--icon"
			: "") + "\n    "
		},
		{
			"aria-hidden": span0_aria_hidden_value = /*type*/ ctx[3] === "icon" ? "true" : "false"
		},
		exclude(prefixFilter(/*$$props*/ ctx[9], "content$"), ["use", "class"])
	];

	let span0_data = {};

	for (let i = 0; i < span0_levels.length; i += 1) {
		span0_data = assign(span0_data, span0_levels[i]);
	}

	let span1_levels = [
		{
			class: span1_class_value = "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-tab-indicator--active" : "") + "\n    " + (/*transition*/ ctx[4] === "fade"
			? "mdc-tab-indicator--fade"
			: "") + "\n  "
		},
		exclude(/*$$props*/ ctx[9], ["use", "class", "active", "type", "transition", "content$"])
	];

	let span1_data = {};

	for (let i = 0; i < span1_levels.length; i += 1) {
		span1_data = assign(span1_data, span1_levels[i]);
	}

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span0, span0_data);
			add_location(span0, file$2, 12, 2, 322);
			set_attributes(span1, span1_data);
			add_location(span1, file$2, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);

			if (default_slot) {
				default_slot.m(span0, null);
			}

			/*span1_binding*/ ctx[15](span1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span0, /*content$use*/ ctx[5])),
					action_destroyer(useActions_action_1 = useActions.call(null, span1, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[8].call(null, span1))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(span0, span0_data = get_spread_update(span0_levels, [
				(!current || dirty & /*content$class, type*/ 72 && span0_class_value !== (span0_class_value = "\n      mdc-tab-indicator__content\n      " + /*content$class*/ ctx[6] + "\n      " + (/*type*/ ctx[3] === "underline"
				? "mdc-tab-indicator__content--underline"
				: "") + "\n      " + (/*type*/ ctx[3] === "icon"
				? "mdc-tab-indicator__content--icon"
				: "") + "\n    ")) && { class: span0_class_value },
				(!current || dirty & /*type*/ 8 && span0_aria_hidden_value !== (span0_aria_hidden_value = /*type*/ ctx[3] === "icon" ? "true" : "false")) && { "aria-hidden": span0_aria_hidden_value },
				dirty & /*$$props*/ 512 && exclude(prefixFilter(/*$$props*/ ctx[9], "content$"), ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/ 32) useActions_action.update.call(null, /*content$use*/ ctx[5]);

			set_attributes(span1, span1_data = get_spread_update(span1_levels, [
				(!current || dirty & /*className, active, transition*/ 22 && span1_class_value !== (span1_class_value = "\n    mdc-tab-indicator\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-tab-indicator--active" : "") + "\n    " + (/*transition*/ ctx[4] === "fade"
				? "mdc-tab-indicator--fade"
				: "") + "\n  ")) && { class: span1_class_value },
				dirty & /*$$props*/ 512 && exclude(/*$$props*/ ctx[9], ["use", "class", "active", "type", "transition", "content$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			if (default_slot) default_slot.d(detaching);
			/*span1_binding*/ ctx[15](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabIndicator", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let { type = "underline" } = $$props;
	let { transition = "slide" } = $$props;
	let { content$use = [] } = $$props;
	let { content$class = "" } = $$props;
	let element;
	let tabIndicator;
	let instantiate = getContext("SMUI:tab-indicator:instantiate");
	let getInstance = getContext("SMUI:tab-indicator:getInstance");

	onMount(async () => {
		if (instantiate !== false) {
			tabIndicator = new MDCTabIndicator(element);
		} else {
			tabIndicator = await getInstance();
		}
	});

	onDestroy(() => {
		tabIndicator && tabIndicator.destroy();
	});

	function activate(...args) {
		return tabIndicator.activate(...args);
	}

	function deactivate(...args) {
		return tabIndicator.deactivate(...args);
	}

	function computeContentClientRect(...args) {
		return tabIndicator.computeContentClientRect(...args);
	}

	function span1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(7, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(2, active = $$new_props.active);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("transition" in $$new_props) $$invalidate(4, transition = $$new_props.transition);
		if ("content$use" in $$new_props) $$invalidate(5, content$use = $$new_props.content$use);
		if ("content$class" in $$new_props) $$invalidate(6, content$class = $$new_props.content$class);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTabIndicator,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		active,
		type,
		transition,
		content$use,
		content$class,
		element,
		tabIndicator,
		instantiate,
		getInstance,
		activate,
		deactivate,
		computeContentClientRect
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(2, active = $$new_props.active);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("transition" in $$props) $$invalidate(4, transition = $$new_props.transition);
		if ("content$use" in $$props) $$invalidate(5, content$use = $$new_props.content$use);
		if ("content$class" in $$props) $$invalidate(6, content$class = $$new_props.content$class);
		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
		if ("tabIndicator" in $$props) tabIndicator = $$new_props.tabIndicator;
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		active,
		type,
		transition,
		content$use,
		content$class,
		element,
		forwardEvents,
		$$props,
		activate,
		deactivate,
		computeContentClientRect,
		$$scope,
		slots,
		span1_binding
	];
}

class TabIndicator extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			use: 0,
			class: 1,
			active: 2,
			type: 3,
			transition: 4,
			content$use: 5,
			content$class: 6,
			activate: 10,
			deactivate: 11,
			computeContentClientRect: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabIndicator",
			options,
			id: create_fragment$2.name
		});
	}

	get use() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transition() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transition(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content$use() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content$use(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content$class() {
		throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content$class(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activate() {
		return this.$$.ctx[10];
	}

	set activate(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get deactivate() {
		return this.$$.ctx[11];
	}

	set deactivate(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get computeContentClientRect() {
		return this.$$.ctx[12];
	}

	set computeContentClientRect(value) {
		throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\tab\Tab.svelte generated by Svelte v3.31.2 */

const { Error: Error_1 } = globals;
const file$3 = "node_modules\\@smui\\tab\\Tab.svelte";
const get_tab_indicator_slot_changes_1 = dirty => ({});
const get_tab_indicator_slot_context_1 = ctx => ({});
const get_tab_indicator_slot_changes = dirty => ({});
const get_tab_indicator_slot_context = ctx => ({});

// (25:4) {#if indicatorSpanOnlyContent}
function create_if_block_2(ctx) {
	let tabindicator;
	let current;

	const tabindicator_spread_levels = [
		{ active: /*active*/ ctx[0] },
		prefixFilter(/*$$props*/ ctx[14], "tabIndicator$")
	];

	let tabindicator_props = {
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
	}

	tabindicator = new TabIndicator({
			props: tabindicator_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tabindicator.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tabindicator, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tabindicator_changes = (dirty[0] & /*active, $$props*/ 16385)
			? get_spread_update(tabindicator_spread_levels, [
					dirty[0] & /*active*/ 1 && { active: /*active*/ ctx[0] },
					dirty[0] & /*$$props*/ 16384 && get_spread_object(prefixFilter(/*$$props*/ ctx[14], "tabIndicator$"))
				])
			: {};

			if (dirty[0] & /*$$scope*/ 67108864) {
				tabindicator_changes.$$scope = { dirty, ctx };
			}

			tabindicator.$set(tabindicator_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabindicator.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabindicator.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tabindicator, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(25:4) {#if indicatorSpanOnlyContent}",
		ctx
	});

	return block;
}

// (26:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >
function create_default_slot_2(ctx) {
	let current;
	const tab_indicator_slot_template = /*#slots*/ ctx[24]["tab-indicator"];
	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[26], get_tab_indicator_slot_context);

	const block = {
		c: function create() {
			if (tab_indicator_slot) tab_indicator_slot.c();
		},
		m: function mount(target, anchor) {
			if (tab_indicator_slot) {
				tab_indicator_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (tab_indicator_slot) {
				if (tab_indicator_slot.p && dirty[0] & /*$$scope*/ 67108864) {
					update_slot(tab_indicator_slot, tab_indicator_slot_template, ctx, /*$$scope*/ ctx[26], dirty, get_tab_indicator_slot_changes, get_tab_indicator_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab_indicator_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab_indicator_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(26:6) <TabIndicator         {active}         {...prefixFilter($$props, 'tabIndicator$')}       >",
		ctx
	});

	return block;
}

// (32:2) {#if !indicatorSpanOnlyContent}
function create_if_block_1(ctx) {
	let tabindicator;
	let current;

	const tabindicator_spread_levels = [
		{ active: /*active*/ ctx[0] },
		prefixFilter(/*$$props*/ ctx[14], "tabIndicator$")
	];

	let tabindicator_props = {
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
		tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
	}

	tabindicator = new TabIndicator({
			props: tabindicator_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tabindicator.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tabindicator, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tabindicator_changes = (dirty[0] & /*active, $$props*/ 16385)
			? get_spread_update(tabindicator_spread_levels, [
					dirty[0] & /*active*/ 1 && { active: /*active*/ ctx[0] },
					dirty[0] & /*$$props*/ 16384 && get_spread_object(prefixFilter(/*$$props*/ ctx[14], "tabIndicator$"))
				])
			: {};

			if (dirty[0] & /*$$scope*/ 67108864) {
				tabindicator_changes.$$scope = { dirty, ctx };
			}

			tabindicator.$set(tabindicator_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabindicator.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabindicator.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tabindicator, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(32:2) {#if !indicatorSpanOnlyContent}",
		ctx
	});

	return block;
}

// (33:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >
function create_default_slot_1(ctx) {
	let current;
	const tab_indicator_slot_template = /*#slots*/ ctx[24]["tab-indicator"];
	const tab_indicator_slot = create_slot(tab_indicator_slot_template, ctx, /*$$scope*/ ctx[26], get_tab_indicator_slot_context_1);

	const block = {
		c: function create() {
			if (tab_indicator_slot) tab_indicator_slot.c();
		},
		m: function mount(target, anchor) {
			if (tab_indicator_slot) {
				tab_indicator_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (tab_indicator_slot) {
				if (tab_indicator_slot.p && dirty[0] & /*$$scope*/ 67108864) {
					update_slot(tab_indicator_slot, tab_indicator_slot_template, ctx, /*$$scope*/ ctx[26], dirty, get_tab_indicator_slot_changes_1, get_tab_indicator_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab_indicator_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab_indicator_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (tab_indicator_slot) tab_indicator_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(33:4) <TabIndicator       {active}       {...prefixFilter($$props, 'tabIndicator$')}     >",
		ctx
	});

	return block;
}

// (38:2) {#if ripple}
function create_if_block(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "mdc-tab__ripple");
			add_location(span, file$3, 38, 4, 1148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(38:2) {#if ripple}",
		ctx
	});

	return block;
}

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class="     mdc-tab     {className}     {active ? 'mdc-tab--active' : ''}     {stacked ? 'mdc-tab--stacked' : ''}     {minWidth ? 'mdc-tab--min-width' : ''}   "   role="tab"   aria-selected={active}   tabindex="{active ? '0' : '-1'}"   {...hrefProp}   on:MDCTab:interacted={interactedHandler}   {...exclude($$props, ['use', 'class', 'ripple', 'href', 'active', 'stacked', 'minWidth', 'indicatorSpanOnlyContent', 'focusOnActivate', 'component', 'content$', 'tabIndicator$'])} >
function create_default_slot(ctx) {
	let span;
	let t0;
	let span_class_value;
	let useActions_action;
	let t1;
	let t2;
	let if_block2_anchor;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], null);
	let if_block0 = /*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_2(ctx);

	let span_levels = [
		{
			class: span_class_value = "mdc-tab__content " + /*content$class*/ ctx[9]
		},
		exclude(prefixFilter(/*$$props*/ ctx[14], "content$"), ["use", "class"])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	let if_block1 = !/*indicatorSpanOnlyContent*/ ctx[6] && create_if_block_1(ctx);
	let if_block2 = /*ripple*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			set_attributes(span, span_data);
			add_location(span, file$3, 18, 2, 572);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_dev(span, t0);
			if (if_block0) if_block0.m(span, null);
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(useActions_action = useActions.call(null, span, /*content$use*/ ctx[8]));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 67108864) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[26], dirty, null, null);
				}
			}

			if (/*indicatorSpanOnlyContent*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*indicatorSpanOnlyContent*/ 64) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty[0] & /*content$class*/ 512 && span_class_value !== (span_class_value = "mdc-tab__content " + /*content$class*/ ctx[9])) && { class: span_class_value },
				dirty[0] & /*$$props*/ 16384 && exclude(prefixFilter(/*$$props*/ ctx[14], "content$"), ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*content$use*/ 256) useActions_action.update.call(null, /*content$use*/ ctx[8]);

			if (!/*indicatorSpanOnlyContent*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*indicatorSpanOnlyContent*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*ripple*/ ctx[3]) {
				if (if_block2) ; else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class=\\\"     mdc-tab     {className}     {active ? 'mdc-tab--active' : ''}     {stacked ? 'mdc-tab--stacked' : ''}     {minWidth ? 'mdc-tab--min-width' : ''}   \\\"   role=\\\"tab\\\"   aria-selected={active}   tabindex=\\\"{active ? '0' : '-1'}\\\"   {...hrefProp}   on:MDCTab:interacted={interactedHandler}   {...exclude($$props, ['use', 'class', 'ripple', 'href', 'active', 'stacked', 'minWidth', 'indicatorSpanOnlyContent', 'focusOnActivate', 'component', 'content$', 'tabIndicator$'])} >",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[12], .../*use*/ ctx[1]]
		},
		{
			class: "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? "mdc-tab--active" : "") + "\n    " + (/*stacked*/ ctx[4] ? "mdc-tab--stacked" : "") + "\n    " + (/*minWidth*/ ctx[5] ? "mdc-tab--min-width" : "") + "\n  "
		},
		{ role: "tab" },
		{ "aria-selected": /*active*/ ctx[0] },
		{ tabindex: /*active*/ ctx[0] ? "0" : "-1" },
		/*hrefProp*/ ctx[11],
		exclude(/*$$props*/ ctx[14], [
			"use",
			"class",
			"ripple",
			"href",
			"active",
			"stacked",
			"minWidth",
			"indicatorSpanOnlyContent",
			"focusOnActivate",
			"component",
			"content$",
			"tabIndicator$"
		])
	];

	var switch_value = /*component*/ ctx[7];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[25](switch_instance);
		switch_instance.$on("MDCTab:interacted", /*interactedHandler*/ ctx[13]);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*forwardEvents, use, className, active, stacked, minWidth, hrefProp, $$props*/ 22583)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*forwardEvents, use*/ 4098 && {
						use: [/*forwardEvents*/ ctx[12], .../*use*/ ctx[1]]
					},
					dirty[0] & /*className, active, stacked, minWidth*/ 53 && {
						class: "\n    mdc-tab\n    " + /*className*/ ctx[2] + "\n    " + (/*active*/ ctx[0] ? "mdc-tab--active" : "") + "\n    " + (/*stacked*/ ctx[4] ? "mdc-tab--stacked" : "") + "\n    " + (/*minWidth*/ ctx[5] ? "mdc-tab--min-width" : "") + "\n  "
					},
					switch_instance_spread_levels[2],
					dirty[0] & /*active*/ 1 && { "aria-selected": /*active*/ ctx[0] },
					dirty[0] & /*active*/ 1 && { tabindex: /*active*/ ctx[0] ? "0" : "-1" },
					dirty[0] & /*hrefProp*/ 2048 && get_spread_object(/*hrefProp*/ ctx[11]),
					dirty[0] & /*$$props*/ 16384 && get_spread_object(exclude(/*$$props*/ ctx[14], [
						"use",
						"class",
						"ripple",
						"href",
						"active",
						"stacked",
						"minWidth",
						"indicatorSpanOnlyContent",
						"focusOnActivate",
						"component",
						"content$",
						"tabIndicator$"
					]))
				])
			: {};

			if (dirty[0] & /*$$scope, ripple, active, $$props, indicatorSpanOnlyContent, content$class, content$use*/ 67126089) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[7])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[25](switch_instance);
					switch_instance.$on("MDCTab:interacted", /*interactedHandler*/ ctx[13]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[25](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let hrefProp;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tab", slots, ['default','tab-indicator']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCTab:interacted"]);
	let activeEntry = getContext("SMUI:tab:active");
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { tab: tabEntry } = $$props;
	let { ripple = true } = $$props;
	let { href = null } = $$props;
	let { active = tabEntry === activeEntry } = $$props;
	let { stacked = false } = $$props;
	let { minWidth = false } = $$props;
	let { indicatorSpanOnlyContent = false } = $$props;
	let { focusOnActivate = true } = $$props;
	let { component = href == null ? Button : A } = $$props;
	let { content$use = [] } = $$props;
	let { content$class = "" } = $$props;
	let element;
	let tab;
	let instantiate = getContext("SMUI:tab:instantiate");
	let getInstance = getContext("SMUI:tab:getInstance");
	let tabIndicatorPromiseResolve;
	let tabIndicatorPromise = new Promise(resolve => tabIndicatorPromiseResolve = resolve);
	setContext("SMUI:tab-indicator:instantiate", false);
	setContext("SMUI:tab-indicator:getInstance", getTabIndicatorInstancePromise);
	setContext("SMUI:label:context", "tab");
	setContext("SMUI:icon:context", "tab");

	if (!tabEntry) {
		throw new Error("The tab property is required! It should be passed down from the TabBar to the Tab.");
	}

	onMount(async () => {
		if (instantiate !== false) {
			$$invalidate(23, tab = new MDCTab(element));
		} else {
			$$invalidate(23, tab = await getInstance(tabEntry));
		}

		tabIndicatorPromiseResolve(tab.tabIndicator_);

		if (!ripple) {
			tab.ripple_ && tab.ripple_.destroy();
		}
	});

	onDestroy(() => {
		tab && tab.destroy();
	});

	function getTabIndicatorInstancePromise() {
		return tabIndicatorPromise;
	}

	function interactedHandler() {
		$$invalidate(0, active = tab.active);
	}

	function activate(...args) {
		$$invalidate(0, active = true);
		return tab.activate(...args);
	}

	function deactivate(...args) {
		$$invalidate(0, active = false);
		return tab.deactivate(...args);
	}

	function focus(...args) {
		return tab.focus(...args);
	}

	function computeIndicatorClientRect(...args) {
		return tab.computeIndicatorClientRect(...args);
	}

	function computeDimensions(...args) {
		return tab.computeDimensions(...args);
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(10, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("tab" in $$new_props) $$invalidate(15, tabEntry = $$new_props.tab);
		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("href" in $$new_props) $$invalidate(16, href = $$new_props.href);
		if ("active" in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ("stacked" in $$new_props) $$invalidate(4, stacked = $$new_props.stacked);
		if ("minWidth" in $$new_props) $$invalidate(5, minWidth = $$new_props.minWidth);
		if ("indicatorSpanOnlyContent" in $$new_props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
		if ("focusOnActivate" in $$new_props) $$invalidate(17, focusOnActivate = $$new_props.focusOnActivate);
		if ("component" in $$new_props) $$invalidate(7, component = $$new_props.component);
		if ("content$use" in $$new_props) $$invalidate(8, content$use = $$new_props.content$use);
		if ("content$class" in $$new_props) $$invalidate(9, content$class = $$new_props.content$class);
		if ("$$scope" in $$new_props) $$invalidate(26, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTab,
		onMount,
		onDestroy,
		setContext,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		A,
		Button,
		TabIndicator,
		forwardEvents,
		activeEntry,
		use,
		className,
		tabEntry,
		ripple,
		href,
		active,
		stacked,
		minWidth,
		indicatorSpanOnlyContent,
		focusOnActivate,
		component,
		content$use,
		content$class,
		element,
		tab,
		instantiate,
		getInstance,
		tabIndicatorPromiseResolve,
		tabIndicatorPromise,
		getTabIndicatorInstancePromise,
		interactedHandler,
		activate,
		deactivate,
		focus,
		computeIndicatorClientRect,
		computeDimensions,
		hrefProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ("activeEntry" in $$props) activeEntry = $$new_props.activeEntry;
		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("tabEntry" in $$props) $$invalidate(15, tabEntry = $$new_props.tabEntry);
		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("href" in $$props) $$invalidate(16, href = $$new_props.href);
		if ("active" in $$props) $$invalidate(0, active = $$new_props.active);
		if ("stacked" in $$props) $$invalidate(4, stacked = $$new_props.stacked);
		if ("minWidth" in $$props) $$invalidate(5, minWidth = $$new_props.minWidth);
		if ("indicatorSpanOnlyContent" in $$props) $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
		if ("focusOnActivate" in $$props) $$invalidate(17, focusOnActivate = $$new_props.focusOnActivate);
		if ("component" in $$props) $$invalidate(7, component = $$new_props.component);
		if ("content$use" in $$props) $$invalidate(8, content$use = $$new_props.content$use);
		if ("content$class" in $$props) $$invalidate(9, content$class = $$new_props.content$class);
		if ("element" in $$props) $$invalidate(10, element = $$new_props.element);
		if ("tab" in $$props) $$invalidate(23, tab = $$new_props.tab);
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
		if ("tabIndicatorPromiseResolve" in $$props) tabIndicatorPromiseResolve = $$new_props.tabIndicatorPromiseResolve;
		if ("tabIndicatorPromise" in $$props) tabIndicatorPromise = $$new_props.tabIndicatorPromise;
		if ("hrefProp" in $$props) $$invalidate(11, hrefProp = $$new_props.hrefProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 65536) {
			 $$invalidate(11, hrefProp = href == null ? {} : { href });
		}

		if ($$self.$$.dirty[0] & /*tab, focusOnActivate*/ 8519680) {
			 if (tab) {
				$$invalidate(23, tab.focusOnActivate = focusOnActivate, tab);
			}
		}

		if ($$self.$$.dirty[0] & /*tab, active*/ 8388609) {
			 if (tab && tab.active !== active) {
				$$invalidate(0, active = tab.active);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		active,
		use,
		className,
		ripple,
		stacked,
		minWidth,
		indicatorSpanOnlyContent,
		component,
		content$use,
		content$class,
		element,
		hrefProp,
		forwardEvents,
		interactedHandler,
		$$props,
		tabEntry,
		href,
		focusOnActivate,
		activate,
		deactivate,
		focus,
		computeIndicatorClientRect,
		computeDimensions,
		tab,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				use: 1,
				class: 2,
				tab: 15,
				ripple: 3,
				href: 16,
				active: 0,
				stacked: 4,
				minWidth: 5,
				indicatorSpanOnlyContent: 6,
				focusOnActivate: 17,
				component: 7,
				content$use: 8,
				content$class: 9,
				activate: 18,
				deactivate: 19,
				focus: 20,
				computeIndicatorClientRect: 21,
				computeDimensions: 22
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*tabEntry*/ ctx[15] === undefined && !("tab" in props)) {
			console.warn("<Tab> was created without expected prop 'tab'");
		}
	}

	get use() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stacked() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stacked(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minWidth() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minWidth(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indicatorSpanOnlyContent() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indicatorSpanOnlyContent(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focusOnActivate() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focusOnActivate(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content$use() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content$use(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content$class() {
		throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content$class(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activate() {
		return this.$$.ctx[18];
	}

	set activate(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get deactivate() {
		return this.$$.ctx[19];
	}

	set deactivate(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx[20];
	}

	set focus(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get computeIndicatorClientRect() {
		return this.$$.ctx[21];
	}

	set computeIndicatorClientRect(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get computeDimensions() {
		return this.$$.ctx[22];
	}

	set computeDimensions(value) {
		throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\Label.svelte generated by Svelte v3.31.2 */
const file$4 = "node_modules\\@smui\\common\\Label.svelte";

function create_fragment$4(ctx) {
	let span;
	let span_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let span_levels = [
		{
			class: span_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === "button"
			? "mdc-button__label"
			: "") + "\n    " + (/*context*/ ctx[3] === "fab" ? "mdc-fab__label" : "") + "\n    " + (/*context*/ ctx[3] === "chip" ? "mdc-chip__text" : "") + "\n    " + (/*context*/ ctx[3] === "tab"
			? "mdc-tab__text-label"
			: "") + "\n    " + (/*context*/ ctx[3] === "image-list"
			? "mdc-image-list__label"
			: "") + "\n    " + (/*context*/ ctx[3] === "snackbar"
			? "mdc-snackbar__label"
			: "") + "\n  "
		},
		/*context*/ ctx[3] === "snackbar"
		? { role: "status", "aria-live": "polite" }
		: {},
		exclude(/*$$props*/ ctx[4], ["use", "class"])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[3] === "button"
				? "mdc-button__label"
				: "") + "\n    " + (/*context*/ ctx[3] === "fab" ? "mdc-fab__label" : "") + "\n    " + (/*context*/ ctx[3] === "chip" ? "mdc-chip__text" : "") + "\n    " + (/*context*/ ctx[3] === "tab"
				? "mdc-tab__text-label"
				: "") + "\n    " + (/*context*/ ctx[3] === "image-list"
				? "mdc-image-list__label"
				: "") + "\n    " + (/*context*/ ctx[3] === "snackbar"
				? "mdc-snackbar__label"
				: "") + "\n  ")) && { class: span_class_value },
				/*context*/ ctx[3] === "snackbar"
				? { role: "status", "aria-live": "polite" }
				: {},
				dirty & /*$$props*/ 16 && exclude(/*$$props*/ ctx[4], ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Label", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	const context = getContext("SMUI:label:context");

	$$self.$$set = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		context
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, className, forwardEvents, context, $$props, $$scope, slots];
}

class Label extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { use: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Label",
			options,
			id: create_fragment$4.name
		});
	}

	get use() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\Icon.svelte generated by Svelte v3.31.2 */
const file$5 = "node_modules\\@smui\\common\\Icon.svelte";

function create_fragment$5(ctx) {
	let i;
	let i_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let i_levels = [
		{
			class: i_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === "button"
			? "mdc-button__icon"
			: "") + "\n    " + (/*context*/ ctx[7] === "fab" ? "mdc-fab__icon" : "") + "\n    " + (/*context*/ ctx[7] === "icon-button"
			? "mdc-icon-button__icon"
			: "") + "\n    " + (/*context*/ ctx[7] === "icon-button" && /*on*/ ctx[2]
			? "mdc-icon-button__icon--on"
			: "") + "\n    " + (/*context*/ ctx[7] === "chip" ? "mdc-chip__icon" : "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leading*/ ctx[3]
			? "mdc-chip__icon--leading"
			: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leadingHidden*/ ctx[4]
			? "mdc-chip__icon--leading-hidden"
			: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*trailing*/ ctx[5]
			? "mdc-chip__icon--trailing"
			: "") + "\n    " + (/*context*/ ctx[7] === "tab" ? "mdc-tab__icon" : "") + "\n  "
		},
		{ "aria-hidden": "true" },
		exclude(/*$$props*/ ctx[8], ["use", "class", "on", "leading", "leadingHidden", "trailing"])
	];

	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			if (default_slot) default_slot.c();
			set_attributes(i, i_data);
			add_location(i, file$5, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);

			if (default_slot) {
				default_slot.m(i, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, i, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[6].call(null, i))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [
				(!current || dirty & /*className, on, leading, leadingHidden, trailing*/ 62 && i_class_value !== (i_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*context*/ ctx[7] === "button"
				? "mdc-button__icon"
				: "") + "\n    " + (/*context*/ ctx[7] === "fab" ? "mdc-fab__icon" : "") + "\n    " + (/*context*/ ctx[7] === "icon-button"
				? "mdc-icon-button__icon"
				: "") + "\n    " + (/*context*/ ctx[7] === "icon-button" && /*on*/ ctx[2]
				? "mdc-icon-button__icon--on"
				: "") + "\n    " + (/*context*/ ctx[7] === "chip" ? "mdc-chip__icon" : "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leading*/ ctx[3]
				? "mdc-chip__icon--leading"
				: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*leadingHidden*/ ctx[4]
				? "mdc-chip__icon--leading-hidden"
				: "") + "\n    " + (/*context*/ ctx[7] === "chip" && /*trailing*/ ctx[5]
				? "mdc-chip__icon--trailing"
				: "") + "\n    " + (/*context*/ ctx[7] === "tab" ? "mdc-tab__icon" : "") + "\n  ")) && { class: i_class_value },
				{ "aria-hidden": "true" },
				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "on", "leading", "leadingHidden", "trailing"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Icon", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { on = false } = $$props;
	let { leading = false } = $$props;
	let { leadingHidden = false } = $$props;
	let { trailing = false } = $$props;
	const context = getContext("SMUI:icon:context");

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("on" in $$new_props) $$invalidate(2, on = $$new_props.on);
		if ("leading" in $$new_props) $$invalidate(3, leading = $$new_props.leading);
		if ("leadingHidden" in $$new_props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
		if ("trailing" in $$new_props) $$invalidate(5, trailing = $$new_props.trailing);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		on,
		leading,
		leadingHidden,
		trailing,
		context
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("on" in $$props) $$invalidate(2, on = $$new_props.on);
		if ("leading" in $$props) $$invalidate(3, leading = $$new_props.leading);
		if ("leadingHidden" in $$props) $$invalidate(4, leadingHidden = $$new_props.leadingHidden);
		if ("trailing" in $$props) $$invalidate(5, trailing = $$new_props.trailing);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		on,
		leading,
		leadingHidden,
		trailing,
		forwardEvents,
		context,
		$$props,
		$$scope,
		slots
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			use: 0,
			class: 1,
			on: 2,
			leading: 3,
			leadingHidden: 4,
			trailing: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$5.name
		});
	}

	get use() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get on() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set on(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get leading() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set leading(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get leadingHidden() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set leadingHidden(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trailing() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trailing(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$3 = {
    ANIMATING: 'mdc-tab-scroller--animating',
    SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll',
    SCROLL_TEST: 'mdc-tab-scroller__test',
};
var strings$3 = {
    AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
    CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScrollerRTL = /** @class */ (function () {
    function MDCTabScrollerRTL(adapter) {
        this.adapter_ = adapter;
    }
    return MDCTabScrollerRTL;
}());
//# sourceMappingURL=rtl-scroller.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScrollerRTLDefault = /** @class */ (function (_super) {
    __extends(MDCTabScrollerRTLDefault, _super);
    function MDCTabScrollerRTLDefault() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLDefault.prototype.getScrollPositionRTL = function () {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var right = this.calculateScrollEdges_().right;
        // Scroll values on most browsers are ints instead of floats so we round
        return Math.round(right - currentScrollLeft);
    };
    MDCTabScrollerRTLDefault.prototype.scrollToRTL = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft,
        };
    };
    MDCTabScrollerRTLDefault.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft,
        };
    };
    MDCTabScrollerRTLDefault.prototype.getAnimatingScrollPosition = function (scrollX) {
        return scrollX;
    };
    MDCTabScrollerRTLDefault.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: 0,
            right: contentWidth - rootWidth,
        };
    };
    MDCTabScrollerRTLDefault.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    return MDCTabScrollerRTLDefault;
}(MDCTabScrollerRTL));
//# sourceMappingURL=rtl-default-scroller.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScrollerRTLNegative = /** @class */ (function (_super) {
    __extends(MDCTabScrollerRTLNegative, _super);
    function MDCTabScrollerRTLNegative() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLNegative.prototype.getScrollPositionRTL = function (translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return Math.round(translateX - currentScrollLeft);
    };
    MDCTabScrollerRTLNegative.prototype.scrollToRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(-scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft,
        };
    };
    MDCTabScrollerRTLNegative.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft,
        };
    };
    MDCTabScrollerRTLNegative.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
        return scrollX - translateX;
    };
    MDCTabScrollerRTLNegative.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: rootWidth - contentWidth,
            right: 0,
        };
    };
    MDCTabScrollerRTLNegative.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.max(Math.min(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLNegative;
}(MDCTabScrollerRTL));
//# sourceMappingURL=rtl-negative-scroller.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScrollerRTLReverse = /** @class */ (function (_super) {
    __extends(MDCTabScrollerRTLReverse, _super);
    function MDCTabScrollerRTLReverse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLReverse.prototype.getScrollPositionRTL = function (translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        // Scroll values on most browsers are ints instead of floats so we round
        return Math.round(currentScrollLeft - translateX);
    };
    MDCTabScrollerRTLReverse.prototype.scrollToRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft,
        };
    };
    MDCTabScrollerRTLReverse.prototype.incrementScrollRTL = function (scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
        return {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft,
        };
    };
    MDCTabScrollerRTLReverse.prototype.getAnimatingScrollPosition = function (scrollX, translateX) {
        return scrollX + translateX;
    };
    MDCTabScrollerRTLReverse.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: contentWidth - rootWidth,
            right: 0,
        };
    };
    MDCTabScrollerRTLReverse.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLReverse;
}(MDCTabScrollerRTL));
//# sourceMappingURL=rtl-reverse-scroller.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScrollerFoundation = /** @class */ (function (_super) {
    __extends(MDCTabScrollerFoundation, _super);
    function MDCTabScrollerFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCTabScrollerFoundation.defaultAdapter, adapter)) || this;
        /**
         * Controls whether we should handle the transitionend and interaction events during the animation.
         */
        _this.isAnimating_ = false;
        return _this;
    }
    Object.defineProperty(MDCTabScrollerFoundation, "cssClasses", {
        get: function () {
            return cssClasses$3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation, "strings", {
        get: function () {
            return strings$3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation, "defaultAdapter", {
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                eventTargetMatchesSelector: function () { return false; },
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                addScrollAreaClass: function () { return undefined; },
                setScrollAreaStyleProperty: function () { return undefined; },
                setScrollContentStyleProperty: function () { return undefined; },
                getScrollContentStyleValue: function () { return ''; },
                setScrollAreaScrollLeft: function () { return undefined; },
                getScrollAreaScrollLeft: function () { return 0; },
                getScrollContentOffsetWidth: function () { return 0; },
                getScrollAreaOffsetWidth: function () { return 0; },
                computeScrollAreaClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                computeScrollContentClientRect: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                computeHorizontalScrollbarHeight: function () { return 0; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTabScrollerFoundation.prototype.init = function () {
        // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
        // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
        var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
        this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
        this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
    };
    /**
     * Computes the current visual scroll position
     */
    MDCTabScrollerFoundation.prototype.getScrollPosition = function () {
        if (this.isRTL_()) {
            return this.computeCurrentScrollPositionRTL_();
        }
        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return scrollLeft - currentTranslateX;
    };
    /**
     * Handles interaction events that occur during transition
     */
    MDCTabScrollerFoundation.prototype.handleInteraction = function () {
        // Early exit if we aren't animating
        if (!this.isAnimating_) {
            return;
        }
        // Prevent other event listeners from handling this event
        this.stopScrollAnimation_();
    };
    /**
     * Handles the transitionend event
     */
    MDCTabScrollerFoundation.prototype.handleTransitionEnd = function (evt) {
        // Early exit if we aren't animating or the event was triggered by a different element.
        var evtTarget = evt.target;
        if (!this.isAnimating_ ||
            !this.adapter_.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
            return;
        }
        this.isAnimating_ = false;
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
    };
    /**
     * Increment the scroll value by the scrollXIncrement
     * @param scrollXIncrement The value by which to increment the scroll position
     */
    MDCTabScrollerFoundation.prototype.incrementScroll = function (scrollXIncrement) {
        // Early exit for non-operational increment values
        if (scrollXIncrement === 0) {
            return;
        }
        if (this.isRTL_()) {
            return this.incrementScrollRTL_(scrollXIncrement);
        }
        this.incrementScroll_(scrollXIncrement);
    };
    /**
     * Scrolls to the given scrollX value
     */
    MDCTabScrollerFoundation.prototype.scrollTo = function (scrollX) {
        if (this.isRTL_()) {
            return this.scrollToRTL_(scrollX);
        }
        this.scrollTo_(scrollX);
    };
    /**
     * @return Browser-specific {@link MDCTabScrollerRTL} instance.
     */
    MDCTabScrollerFoundation.prototype.getRTLScroller = function () {
        if (!this.rtlScrollerInstance_) {
            this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
        }
        return this.rtlScrollerInstance_;
    };
    /**
     * @return translateX value from a CSS matrix transform function string.
     */
    MDCTabScrollerFoundation.prototype.calculateCurrentTranslateX_ = function () {
        var transformValue = this.adapter_.getScrollContentStyleValue('transform');
        // Early exit if no transform is present
        if (transformValue === 'none') {
            return 0;
        }
        // The transform value comes back as a matrix transformation in the form
        // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
        // we're going to grab all the parenthesized values, strip out tx, and
        // parse it.
        var match = /\((.+?)\)/.exec(transformValue);
        if (!match) {
            return 0;
        }
        var matrixParams = match[1];
        // tslint:disable-next-line:ban-ts-ignore "Unused vars" should be a linter warning, not a compiler error.
        // @ts-ignore These unused variables should retain their semantic names for clarity.
        var _a = __read(matrixParams.split(','), 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], tx = _a[4], ty = _a[5];
        return parseFloat(tx); // tslint:disable-line:ban
    };
    /**
     * Calculates a safe scroll value that is > 0 and < the max scroll value
     * @param scrollX The distance to scroll
     */
    MDCTabScrollerFoundation.prototype.clampScrollValue_ = function (scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    MDCTabScrollerFoundation.prototype.computeCurrentScrollPositionRTL_ = function () {
        var translateX = this.calculateCurrentTranslateX_();
        return this.getRTLScroller().getScrollPositionRTL(translateX);
    };
    MDCTabScrollerFoundation.prototype.calculateScrollEdges_ = function () {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return {
            left: 0,
            right: contentWidth - rootWidth,
        };
    };
    /**
     * Internal scroll method
     * @param scrollX The new scroll position
     */
    MDCTabScrollerFoundation.prototype.scrollTo_ = function (scrollX) {
        var currentScrollX = this.getScrollPosition();
        var safeScrollX = this.clampScrollValue_(scrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        this.animate_({
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta,
        });
    };
    /**
     * Internal RTL scroll method
     * @param scrollX The new scroll position
     */
    MDCTabScrollerFoundation.prototype.scrollToRTL_ = function (scrollX) {
        var animation = this.getRTLScroller().scrollToRTL(scrollX);
        this.animate_(animation);
    };
    /**
     * Internal increment scroll method
     * @param scrollX The new scroll position increment
     */
    MDCTabScrollerFoundation.prototype.incrementScroll_ = function (scrollX) {
        var currentScrollX = this.getScrollPosition();
        var targetScrollX = scrollX + currentScrollX;
        var safeScrollX = this.clampScrollValue_(targetScrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        this.animate_({
            finalScrollPosition: safeScrollX,
            scrollDelta: scrollDelta,
        });
    };
    /**
     * Internal increment scroll RTL method
     * @param scrollX The new scroll position RTL increment
     */
    MDCTabScrollerFoundation.prototype.incrementScrollRTL_ = function (scrollX) {
        var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
        this.animate_(animation);
    };
    /**
     * Animates the tab scrolling
     * @param animation The animation to apply
     */
    MDCTabScrollerFoundation.prototype.animate_ = function (animation) {
        var _this = this;
        // Early exit if translateX is 0, which means there's no animation to perform
        if (animation.scrollDelta === 0) {
            return;
        }
        this.stopScrollAnimation_();
        // This animation uses the FLIP approach.
        // Read more here: https://aerotwist.com/blog/flip-your-animations/
        this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
        this.adapter_.setScrollContentStyleProperty('transform', "translateX(" + animation.scrollDelta + "px)");
        // Force repaint
        this.adapter_.computeScrollAreaClientRect();
        requestAnimationFrame(function () {
            _this.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
            _this.adapter_.setScrollContentStyleProperty('transform', 'none');
        });
        this.isAnimating_ = true;
    };
    /**
     * Stops scroll animation
     */
    MDCTabScrollerFoundation.prototype.stopScrollAnimation_ = function () {
        this.isAnimating_ = false;
        var currentScrollPosition = this.getAnimatingScrollPosition_();
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
        this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
    };
    /**
     * Gets the current scroll position during animation
     */
    MDCTabScrollerFoundation.prototype.getAnimatingScrollPosition_ = function () {
        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
        if (this.isRTL_()) {
            return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
        }
        return scrollLeft - currentTranslateX;
    };
    /**
     * Determines the RTL Scroller to use
     */
    MDCTabScrollerFoundation.prototype.rtlScrollerFactory_ = function () {
        // Browsers have three different implementations of scrollLeft in RTL mode,
        // dependent on the browser. The behavior is based off the max LTR
        // scrollLeft value and 0.
        //
        // * Default scrolling in RTL *
        //    - Left-most value: 0
        //    - Right-most value: Max LTR scrollLeft value
        //
        // * Negative scrolling in RTL *
        //    - Left-most value: Negated max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // * Reverse scrolling in RTL *
        //    - Left-most value: Max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // We use those principles below to determine which RTL scrollLeft
        // behavior is implemented in the current browser.
        var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
        var newScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        // If the newScrollLeft value is negative,then we know that the browser has
        // implemented negative RTL scrolling, since all other implementations have
        // only positive values.
        if (newScrollLeft < 0) {
            // Undo the scrollLeft test check
            this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
            return new MDCTabScrollerRTLNegative(this.adapter_);
        }
        var rootClientRect = this.adapter_.computeScrollAreaClientRect();
        var contentClientRect = this.adapter_.computeScrollContentClientRect();
        var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
        // Undo the scrollLeft test check
        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
        // By calculating the clientRect of the root element and the clientRect of
        // the content element, we can determine how much the scroll value changed
        // when we performed the scrollLeft subtraction above.
        if (rightEdgeDelta === newScrollLeft) {
            return new MDCTabScrollerRTLReverse(this.adapter_);
        }
        return new MDCTabScrollerRTLDefault(this.adapter_);
    };
    MDCTabScrollerFoundation.prototype.isRTL_ = function () {
        return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
    };
    return MDCTabScrollerFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
 */
var horizontalScrollbarHeight_;
/**
 * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
 * May return 0 (e.g. on OS X browsers under default configuration).
 */
function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
    if (shouldCacheResult === void 0) { shouldCacheResult = true; }
    if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
        return horizontalScrollbarHeight_;
    }
    var el = documentObj.createElement('div');
    el.classList.add(cssClasses$3.SCROLL_TEST);
    documentObj.body.appendChild(el);
    var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
    documentObj.body.removeChild(el);
    if (shouldCacheResult) {
        horizontalScrollbarHeight_ = horizontalScrollbarHeight;
    }
    return horizontalScrollbarHeight;
}
//# sourceMappingURL=util.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTabScroller = /** @class */ (function (_super) {
    __extends(MDCTabScroller, _super);
    function MDCTabScroller() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScroller.attachTo = function (root) {
        return new MDCTabScroller(root);
    };
    MDCTabScroller.prototype.initialize = function () {
        this.area_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
        this.content_ = this.root_.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
    };
    MDCTabScroller.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleInteraction_ = function () { return _this.foundation_.handleInteraction(); };
        this.handleTransitionEnd_ = function (evt) { return _this.foundation_.handleTransitionEnd(evt); };
        this.area_.addEventListener('wheel', this.handleInteraction_, applyPassive());
        this.area_.addEventListener('touchstart', this.handleInteraction_, applyPassive());
        this.area_.addEventListener('pointerdown', this.handleInteraction_, applyPassive());
        this.area_.addEventListener('mousedown', this.handleInteraction_, applyPassive());
        this.area_.addEventListener('keydown', this.handleInteraction_, applyPassive());
        this.content_.addEventListener('transitionend', this.handleTransitionEnd_);
    };
    MDCTabScroller.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.area_.removeEventListener('wheel', this.handleInteraction_, applyPassive());
        this.area_.removeEventListener('touchstart', this.handleInteraction_, applyPassive());
        this.area_.removeEventListener('pointerdown', this.handleInteraction_, applyPassive());
        this.area_.removeEventListener('mousedown', this.handleInteraction_, applyPassive());
        this.area_.removeEventListener('keydown', this.handleInteraction_, applyPassive());
        this.content_.removeEventListener('transitionend', this.handleTransitionEnd_);
    };
    MDCTabScroller.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            eventTargetMatchesSelector: function (evtTarget, selector) { return matches(evtTarget, selector); },
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            addScrollAreaClass: function (className) { return _this.area_.classList.add(className); },
            setScrollAreaStyleProperty: function (prop, value) { return _this.area_.style.setProperty(prop, value); },
            setScrollContentStyleProperty: function (prop, value) { return _this.content_.style.setProperty(prop, value); },
            getScrollContentStyleValue: function (propName) { return window.getComputedStyle(_this.content_).getPropertyValue(propName); },
            setScrollAreaScrollLeft: function (scrollX) { return _this.area_.scrollLeft = scrollX; },
            getScrollAreaScrollLeft: function () { return _this.area_.scrollLeft; },
            getScrollContentOffsetWidth: function () { return _this.content_.offsetWidth; },
            getScrollAreaOffsetWidth: function () { return _this.area_.offsetWidth; },
            computeScrollAreaClientRect: function () { return _this.area_.getBoundingClientRect(); },
            computeScrollContentClientRect: function () { return _this.content_.getBoundingClientRect(); },
            computeHorizontalScrollbarHeight: function () { return computeHorizontalScrollbarHeight(document); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCTabScrollerFoundation(adapter);
    };
    /**
     * Returns the current visual scroll position
     */
    MDCTabScroller.prototype.getScrollPosition = function () {
        return this.foundation_.getScrollPosition();
    };
    /**
     * Returns the width of the scroll content
     */
    MDCTabScroller.prototype.getScrollContentWidth = function () {
        return this.content_.offsetWidth;
    };
    /**
     * Increments the scroll value by the given amount
     * @param scrollXIncrement The pixel value by which to increment the scroll value
     */
    MDCTabScroller.prototype.incrementScroll = function (scrollXIncrement) {
        this.foundation_.incrementScroll(scrollXIncrement);
    };
    /**
     * Scrolls to the given pixel position
     * @param scrollX The pixel value to scroll to
     */
    MDCTabScroller.prototype.scrollTo = function (scrollX) {
        this.foundation_.scrollTo(scrollX);
    };
    return MDCTabScroller;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$4 = {
    ARROW_LEFT_KEY: 'ArrowLeft',
    ARROW_RIGHT_KEY: 'ArrowRight',
    END_KEY: 'End',
    ENTER_KEY: 'Enter',
    HOME_KEY: 'Home',
    SPACE_KEY: 'Space',
    TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
    TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
    TAB_SELECTOR: '.mdc-tab',
};
var numbers$1 = {
    ARROW_LEFT_KEYCODE: 37,
    ARROW_RIGHT_KEYCODE: 39,
    END_KEYCODE: 35,
    ENTER_KEYCODE: 13,
    EXTRA_SCROLL_AMOUNT: 20,
    HOME_KEYCODE: 36,
    SPACE_KEYCODE: 32,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ACCEPTABLE_KEYS = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this by hand
ACCEPTABLE_KEYS.add(strings$4.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings$4.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings$4.END_KEY);
ACCEPTABLE_KEYS.add(strings$4.HOME_KEY);
ACCEPTABLE_KEYS.add(strings$4.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings$4.SPACE_KEY);
var KEYCODE_MAP = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this by hand
KEYCODE_MAP.set(numbers$1.ARROW_LEFT_KEYCODE, strings$4.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers$1.ARROW_RIGHT_KEYCODE, strings$4.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers$1.END_KEYCODE, strings$4.END_KEY);
KEYCODE_MAP.set(numbers$1.HOME_KEYCODE, strings$4.HOME_KEY);
KEYCODE_MAP.set(numbers$1.ENTER_KEYCODE, strings$4.ENTER_KEY);
KEYCODE_MAP.set(numbers$1.SPACE_KEYCODE, strings$4.SPACE_KEY);
var MDCTabBarFoundation = /** @class */ (function (_super) {
    __extends(MDCTabBarFoundation, _super);
    function MDCTabBarFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCTabBarFoundation.defaultAdapter, adapter)) || this;
        _this.useAutomaticActivation_ = false;
        return _this;
    }
    Object.defineProperty(MDCTabBarFoundation, "strings", {
        get: function () {
            return strings$4;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation, "numbers", {
        get: function () {
            return numbers$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation, "defaultAdapter", {
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                scrollTo: function () { return undefined; },
                incrementScroll: function () { return undefined; },
                getScrollPosition: function () { return 0; },
                getScrollContentWidth: function () { return 0; },
                getOffsetWidth: function () { return 0; },
                isRTL: function () { return false; },
                setActiveTab: function () { return undefined; },
                activateTabAtIndex: function () { return undefined; },
                deactivateTabAtIndex: function () { return undefined; },
                focusTabAtIndex: function () { return undefined; },
                getTabIndicatorClientRectAtIndex: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },
                getTabDimensionsAtIndex: function () { return ({ rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 }); },
                getPreviousActiveTabIndex: function () { return -1; },
                getFocusedTabIndex: function () { return -1; },
                getIndexOfTabById: function () { return -1; },
                getTabListLength: function () { return 0; },
                notifyTabActivated: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Switches between automatic and manual activation modes.
     * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
     */
    MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {
        this.useAutomaticActivation_ = useAutomaticActivation;
    };
    MDCTabBarFoundation.prototype.activateTab = function (index) {
        var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();
        if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
            return;
        }
        var previousClientRect;
        if (previousActiveIndex !== -1) {
            this.adapter_.deactivateTabAtIndex(previousActiveIndex);
            previousClientRect = this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex);
        }
        this.adapter_.activateTabAtIndex(index, previousClientRect);
        this.scrollIntoView(index);
        this.adapter_.notifyTabActivated(index);
    };
    MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {
        // Get the key from the event
        var key = this.getKeyFromEvent_(evt);
        // Early exit if the event key isn't one of the keyboard navigation keys
        if (key === undefined) {
            return;
        }
        // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple
        if (!this.isActivationKey_(key)) {
            evt.preventDefault();
        }
        if (this.useAutomaticActivation_) {
            if (this.isActivationKey_(key)) {
                return;
            }
            var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
            this.adapter_.setActiveTab(index);
            this.scrollIntoView(index);
        }
        else {
            var focusedTabIndex = this.adapter_.getFocusedTabIndex();
            if (this.isActivationKey_(key)) {
                this.adapter_.setActiveTab(focusedTabIndex);
            }
            else {
                var index = this.determineTargetFromKey_(focusedTabIndex, key);
                this.adapter_.focusTabAtIndex(index);
                this.scrollIntoView(index);
            }
        }
    };
    /**
     * Handles the MDCTab:interacted event
     */
    MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {
        this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
    };
    /**
     * Scrolls the tab at the given index into view
     * @param index The tab index to make visible
     */
    MDCTabBarFoundation.prototype.scrollIntoView = function (index) {
        // Early exit if the index is out of range
        if (!this.indexIsInRange_(index)) {
            return;
        }
        // Always scroll to 0 if scrolling to the 0th index
        if (index === 0) {
            return this.adapter_.scrollTo(0);
        }
        // Always scroll to the max value if scrolling to the Nth index
        // MDCTabScroller.scrollTo() will never scroll past the max possible value
        if (index === this.adapter_.getTabListLength() - 1) {
            return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
        }
        if (this.isRTL_()) {
            return this.scrollIntoViewRTL_(index);
        }
        this.scrollIntoView_(index);
    };
    /**
     * Private method for determining the index of the destination tab based on what key was pressed
     * @param origin The original index from which to determine the destination
     * @param key The name of the key
     */
    MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {
        var isRTL = this.isRTL_();
        var maxIndex = this.adapter_.getTabListLength() - 1;
        var shouldGoToEnd = key === strings$4.END_KEY;
        var shouldDecrement = key === strings$4.ARROW_LEFT_KEY && !isRTL || key === strings$4.ARROW_RIGHT_KEY && isRTL;
        var shouldIncrement = key === strings$4.ARROW_RIGHT_KEY && !isRTL || key === strings$4.ARROW_LEFT_KEY && isRTL;
        var index = origin;
        if (shouldGoToEnd) {
            index = maxIndex;
        }
        else if (shouldDecrement) {
            index -= 1;
        }
        else if (shouldIncrement) {
            index += 1;
        }
        else {
            index = 0;
        }
        if (index < 0) {
            index = maxIndex;
        }
        else if (index > maxIndex) {
            index = 0;
        }
        return index;
    };
    /**
     * Calculates the scroll increment that will make the tab at the given index visible
     * @param index The index of the tab
     * @param nextIndex The index of the next tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the Tab Bar
     */
    MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
        var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
        var leftIncrement = relativeContentRight - numbers$1.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft + numbers$1.EXTRA_SCROLL_AMOUNT;
        if (nextIndex < index) {
            return Math.min(leftIncrement, 0);
        }
        return Math.max(rightIncrement, 0);
    };
    /**
     * Calculates the scroll increment that will make the tab at the given index visible in RTL
     * @param index The index of the tab
     * @param nextIndex The index of the next tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the Tab Bar
     * @param scrollContentWidth The width of the scroll content
     */
    MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
        var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
        var leftIncrement = relativeContentRight + numbers$1.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft - numbers$1.EXTRA_SCROLL_AMOUNT;
        if (nextIndex > index) {
            return Math.max(leftIncrement, 0);
        }
        return Math.min(rightIncrement, 0);
    };
    /**
     * Determines the index of the adjacent tab closest to either edge of the Tab Bar
     * @param index The index of the tab
     * @param tabDimensions The dimensions of the tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the tab bar
     */
    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {
        /**
         * Tabs are laid out in the Tab Scroller like this:
         *
         *    Scroll Position
         *    +---+
         *    |   |   Bar Width
         *    |   +-----------------------------------+
         *    |   |                                   |
         *    |   V                                   V
         *    |   +-----------------------------------+
         *    V   |             Tab Scroller          |
         *    +------------+--------------+-------------------+
         *    |    Tab     |      Tab     |        Tab        |
         *    +------------+--------------+-------------------+
         *        |                                   |
         *        +-----------------------------------+
         *
         * To determine the next adjacent index, we look at the Tab root left and
         * Tab root right, both relative to the scroll position. If the Tab root
         * left is less than 0, then we know it's out of view to the left. If the
         * Tab root right minus the bar width is greater than 0, we know the Tab is
         * out of view to the right. From there, we either increment or decrement
         * the index.
         */
        var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
        var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
        var relativeRootDelta = relativeRootLeft + relativeRootRight;
        var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
        var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
        if (leftEdgeIsCloser) {
            return index - 1;
        }
        if (rightEdgeIsCloser) {
            return index + 1;
        }
        return -1;
    };
    /**
     * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
     * @param index The index of the tab
     * @param tabDimensions The dimensions of the tab
     * @param scrollPosition The current scroll position
     * @param barWidth The width of the tab bar
     * @param scrollContentWidth The width of the scroller content
     */
    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
        var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
        var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
        var rootDelta = rootLeft + rootRight;
        var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
        var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
        if (leftEdgeIsCloser) {
            return index + 1;
        }
        if (rightEdgeIsCloser) {
            return index - 1;
        }
        return -1;
    };
    /**
     * Returns the key associated with a keydown event
     * @param evt The keydown event
     */
    MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {
        if (ACCEPTABLE_KEYS.has(evt.key)) {
            return evt.key;
        }
        return KEYCODE_MAP.get(evt.keyCode);
    };
    MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {
        return key === strings$4.SPACE_KEY || key === strings$4.ENTER_KEY;
    };
    /**
     * Returns whether a given index is inclusively between the ends
     * @param index The index to test
     */
    MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {
        return index >= 0 && index < this.adapter_.getTabListLength();
    };
    /**
     * Returns the view's RTL property
     */
    MDCTabBarFoundation.prototype.isRTL_ = function () {
        return this.adapter_.isRTL();
    };
    /**
     * Scrolls the tab at the given index into view for left-to-right user agents.
     * @param index The index of the tab to scroll into view
     */
    MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);
        if (!this.indexIsInRange_(nextIndex)) {
            return;
        }
        var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
        this.adapter_.incrementScroll(scrollIncrement);
    };
    /**
     * Scrolls the tab at the given index into view in RTL
     * @param index The tab index to make visible
     */
    MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var scrollWidth = this.adapter_.getScrollContentWidth();
        var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
        if (!this.indexIsInRange_(nextIndex)) {
            return;
        }
        var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
        this.adapter_.incrementScroll(scrollIncrement);
    };
    return MDCTabBarFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$5 = MDCTabBarFoundation.strings;
var tabIdCounter = 0;
var MDCTabBar = /** @class */ (function (_super) {
    __extends(MDCTabBar, _super);
    function MDCTabBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabBar.attachTo = function (root) {
        return new MDCTabBar(root);
    };
    Object.defineProperty(MDCTabBar.prototype, "focusOnActivate", {
        set: function (focusOnActivate) {
            this.tabList_.forEach(function (tab) { return tab.focusOnActivate = focusOnActivate; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTabBar.prototype, "useAutomaticActivation", {
        set: function (useAutomaticActivation) {
            this.foundation_.setUseAutomaticActivation(useAutomaticActivation);
        },
        enumerable: true,
        configurable: true
    });
    MDCTabBar.prototype.initialize = function (tabFactory, tabScrollerFactory) {
        if (tabFactory === void 0) { tabFactory = function (el) { return new MDCTab(el); }; }
        if (tabScrollerFactory === void 0) { tabScrollerFactory = function (el) { return new MDCTabScroller(el); }; }
        this.tabList_ = this.instantiateTabs_(tabFactory);
        this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
    };
    MDCTabBar.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleTabInteraction_ = function (evt) { return _this.foundation_.handleTabInteraction(evt); };
        this.handleKeyDown_ = function (evt) { return _this.foundation_.handleKeyDown(evt); };
        this.listen(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
        this.listen('keydown', this.handleKeyDown_);
        for (var i = 0; i < this.tabList_.length; i++) {
            if (this.tabList_[i].active) {
                this.scrollIntoView(i);
                break;
            }
        }
    };
    MDCTabBar.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.unlisten(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
        this.unlisten('keydown', this.handleKeyDown_);
        this.tabList_.forEach(function (tab) { return tab.destroy(); });
        if (this.tabScroller_) {
            this.tabScroller_.destroy();
        }
    };
    MDCTabBar.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            scrollTo: function (scrollX) { return _this.tabScroller_.scrollTo(scrollX); },
            incrementScroll: function (scrollXIncrement) { return _this.tabScroller_.incrementScroll(scrollXIncrement); },
            getScrollPosition: function () { return _this.tabScroller_.getScrollPosition(); },
            getScrollContentWidth: function () { return _this.tabScroller_.getScrollContentWidth(); },
            getOffsetWidth: function () { return _this.root_.offsetWidth; },
            isRTL: function () { return window.getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
            setActiveTab: function (index) { return _this.foundation_.activateTab(index); },
            activateTabAtIndex: function (index, clientRect) { return _this.tabList_[index].activate(clientRect); },
            deactivateTabAtIndex: function (index) { return _this.tabList_[index].deactivate(); },
            focusTabAtIndex: function (index) { return _this.tabList_[index].focus(); },
            getTabIndicatorClientRectAtIndex: function (index) { return _this.tabList_[index].computeIndicatorClientRect(); },
            getTabDimensionsAtIndex: function (index) { return _this.tabList_[index].computeDimensions(); },
            getPreviousActiveTabIndex: function () {
                for (var i = 0; i < _this.tabList_.length; i++) {
                    if (_this.tabList_[i].active) {
                        return i;
                    }
                }
                return -1;
            },
            getFocusedTabIndex: function () {
                var tabElements = _this.getTabElements_();
                var activeElement = document.activeElement;
                return tabElements.indexOf(activeElement);
            },
            getIndexOfTabById: function (id) {
                for (var i = 0; i < _this.tabList_.length; i++) {
                    if (_this.tabList_[i].id === id) {
                        return i;
                    }
                }
                return -1;
            },
            getTabListLength: function () { return _this.tabList_.length; },
            notifyTabActivated: function (index) {
                return _this.emit(strings$5.TAB_ACTIVATED_EVENT, { index: index }, true);
            },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCTabBarFoundation(adapter);
    };
    /**
     * Activates the tab at the given index
     * @param index The index of the tab
     */
    MDCTabBar.prototype.activateTab = function (index) {
        this.foundation_.activateTab(index);
    };
    /**
     * Scrolls the tab at the given index into view
     * @param index THe index of the tab
     */
    MDCTabBar.prototype.scrollIntoView = function (index) {
        this.foundation_.scrollIntoView(index);
    };
    /**
     * Returns all the tab elements in a nice clean array
     */
    MDCTabBar.prototype.getTabElements_ = function () {
        return [].slice.call(this.root_.querySelectorAll(strings$5.TAB_SELECTOR));
    };
    /**
     * Instantiates tab components on all child tab elements
     */
    MDCTabBar.prototype.instantiateTabs_ = function (tabFactory) {
        return this.getTabElements_().map(function (el) {
            el.id = el.id || "mdc-tab-" + ++tabIdCounter;
            return tabFactory(el);
        });
    };
    /**
     * Instantiates tab scroller component on the child tab scroller element
     */
    MDCTabBar.prototype.instantiateTabScroller_ = function (tabScrollerFactory) {
        var tabScrollerElement = this.root_.querySelector(strings$5.TAB_SCROLLER_SELECTOR);
        if (tabScrollerElement) {
            return tabScrollerFactory(tabScrollerElement);
        }
        return null;
    };
    return MDCTabBar;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\tab-scroller\TabScroller.svelte generated by Svelte v3.31.2 */
const file$6 = "node_modules\\@smui\\tab-scroller\\TabScroller.svelte";

function create_fragment$6(ctx) {
	let div2;
	let div1;
	let div0;
	let div0_class_value;
	let useActions_action;
	let div1_class_value;
	let useActions_action_1;
	let div2_class_value;
	let useActions_action_2;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let div0_levels = [
		{
			class: div0_class_value = "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5]
		},
		exclude(prefixFilter(/*$$props*/ ctx[8], "scrollContent$"), ["use", "class"])
	];

	let div0_data = {};

	for (let i = 0; i < div0_levels.length; i += 1) {
		div0_data = assign(div0_data, div0_levels[i]);
	}

	let div1_levels = [
		{
			class: div1_class_value = "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3]
		},
		exclude(prefixFilter(/*$$props*/ ctx[8], "scrollArea$"), ["use", "class"])
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	let div2_levels = [
		{
			class: div2_class_value = "mdc-tab-scroller " + /*className*/ ctx[1]
		},
		exclude(/*$$props*/ ctx[8], ["use", "class", "scrollArea$", "scrollContent$"])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div0, div0_data);
			add_location(div0, file$6, 12, 4, 371);
			set_attributes(div1, div1_data);
			add_location(div1, file$6, 7, 2, 188);
			set_attributes(div2, div2_data);
			add_location(div2, file$6, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div2_binding*/ ctx[15](div2);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div0, /*scrollContent$use*/ ctx[4])),
					action_destroyer(useActions_action_1 = useActions.call(null, div1, /*scrollArea$use*/ ctx[2])),
					action_destroyer(useActions_action_2 = useActions.call(null, div2, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, div2))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			set_attributes(div0, div0_data = get_spread_update(div0_levels, [
				(!current || dirty & /*scrollContent$class*/ 32 && div0_class_value !== (div0_class_value = "mdc-tab-scroller__scroll-content " + /*scrollContent$class*/ ctx[5])) && { class: div0_class_value },
				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], "scrollContent$"), ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*scrollContent$use*/ 16) useActions_action.update.call(null, /*scrollContent$use*/ ctx[4]);

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*scrollArea$class*/ 8 && div1_class_value !== (div1_class_value = "mdc-tab-scroller__scroll-area " + /*scrollArea$class*/ ctx[3])) && { class: div1_class_value },
				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], "scrollArea$"), ["use", "class"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*scrollArea$use*/ 4) useActions_action_1.update.call(null, /*scrollArea$use*/ ctx[2]);

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = "mdc-tab-scroller " + /*className*/ ctx[1])) && { class: div2_class_value },
				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "scrollArea$", "scrollContent$"])
			]));

			if (useActions_action_2 && is_function(useActions_action_2.update) && dirty & /*use*/ 1) useActions_action_2.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[15](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabScroller", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { scrollArea$use = [] } = $$props;
	let { scrollArea$class = "" } = $$props;
	let { scrollContent$use = [] } = $$props;
	let { scrollContent$class = "" } = $$props;
	let element;
	let tabScroller;
	let instantiate = getContext("SMUI:tab-scroller:instantiate");
	let getInstance = getContext("SMUI:tab-scroller:getInstance");

	onMount(async () => {
		if (instantiate !== false) {
			tabScroller = new MDCTabScroller(element);
		} else {
			tabScroller = await getInstance();
		}
	});

	onDestroy(() => {
		tabScroller && tabScroller.destroy();
	});

	function scrollTo(...args) {
		return tabScroller.scrollTo(...args);
	}

	function incrementScroll(...args) {
		return tabScroller.incrementScroll(...args);
	}

	function getScrollPosition(...args) {
		return tabScroller.getScrollPosition(...args);
	}

	function getScrollContentWidth(...args) {
		return tabScroller.getScrollContentWidth(...args);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("scrollArea$use" in $$new_props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
		if ("scrollArea$class" in $$new_props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
		if ("scrollContent$use" in $$new_props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
		if ("scrollContent$class" in $$new_props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTabScroller,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		scrollArea$use,
		scrollArea$class,
		scrollContent$use,
		scrollContent$class,
		element,
		tabScroller,
		instantiate,
		getInstance,
		scrollTo,
		incrementScroll,
		getScrollPosition,
		getScrollContentWidth
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("scrollArea$use" in $$props) $$invalidate(2, scrollArea$use = $$new_props.scrollArea$use);
		if ("scrollArea$class" in $$props) $$invalidate(3, scrollArea$class = $$new_props.scrollArea$class);
		if ("scrollContent$use" in $$props) $$invalidate(4, scrollContent$use = $$new_props.scrollContent$use);
		if ("scrollContent$class" in $$props) $$invalidate(5, scrollContent$class = $$new_props.scrollContent$class);
		if ("element" in $$props) $$invalidate(6, element = $$new_props.element);
		if ("tabScroller" in $$props) tabScroller = $$new_props.tabScroller;
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		scrollArea$use,
		scrollArea$class,
		scrollContent$use,
		scrollContent$class,
		element,
		forwardEvents,
		$$props,
		scrollTo,
		incrementScroll,
		getScrollPosition,
		getScrollContentWidth,
		$$scope,
		slots,
		div2_binding
	];
}

class TabScroller extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			use: 0,
			class: 1,
			scrollArea$use: 2,
			scrollArea$class: 3,
			scrollContent$use: 4,
			scrollContent$class: 5,
			scrollTo: 9,
			incrementScroll: 10,
			getScrollPosition: 11,
			getScrollContentWidth: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabScroller",
			options,
			id: create_fragment$6.name
		});
	}

	get use() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollArea$use() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollArea$use(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollArea$class() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollArea$class(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollContent$use() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollContent$use(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollContent$class() {
		throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollContent$class(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollTo() {
		return this.$$.ctx[9];
	}

	set scrollTo(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get incrementScroll() {
		return this.$$.ctx[10];
	}

	set incrementScroll(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getScrollPosition() {
		return this.$$.ctx[11];
	}

	set getScrollPosition(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getScrollContentWidth() {
		return this.$$.ctx[12];
	}

	set getScrollContentWidth(value) {
		throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\tab-bar\TabBar.svelte generated by Svelte v3.31.2 */
const file$7 = "node_modules\\@smui\\tab-bar\\TabBar.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({ tab: dirty & /*tabs*/ 4 });
const get_default_slot_context = ctx => ({ tab: /*tab*/ ctx[28] });

// (13:4) {#each tabs as tab, i (key(tab))}
function create_each_block(key_2, ctx) {
	let first;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context);

	const block = {
		key: key_2,
		first: null,
		c: function create() {
			first = empty();
			if (default_slot) default_slot.c();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, tabs*/ 524292) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(13:4) {#each tabs as tab, i (key(tab))}",
		ctx
	});

	return block;
}

// (10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >
function create_default_slot$1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*tabs*/ ctx[2];
	validate_each_argument(each_value);
	const get_key = ctx => /*key*/ ctx[3](/*tab*/ ctx[28]);
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$$scope, tabs, key*/ 524300) {
				each_value = /*tabs*/ ctx[2];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(10:2) <TabScroller     {...prefixFilter($$props, 'tabScroller$')}   >",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div;
	let tabscroller;
	let div_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const tabscroller_spread_levels = [prefixFilter(/*$$props*/ ctx[7], "tabScroller$")];

	let tabscroller_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < tabscroller_spread_levels.length; i += 1) {
		tabscroller_props = assign(tabscroller_props, tabscroller_spread_levels[i]);
	}

	tabscroller = new TabScroller({ props: tabscroller_props, $$inline: true });

	let div_levels = [
		{
			class: div_class_value = "mdc-tab-bar " + /*className*/ ctx[1]
		},
		{ role: "tablist" },
		exclude(/*$$props*/ ctx[7], [
			"use",
			"class",
			"tabs",
			"key",
			"focusOnActivate",
			"useAutomaticActivation",
			"activeIndex",
			"tabScroller$"
		])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			create_component(tabscroller.$$.fragment);
			set_attributes(div, div_data);
			add_location(div, file$7, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(tabscroller, div, null);
			/*div_binding*/ ctx[18](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div)),
					listen_dev(div, "MDCTabBar:activated", /*activatedHandler*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const tabscroller_changes = (dirty & /*prefixFilter, $$props*/ 128)
			? get_spread_update(tabscroller_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[7], "tabScroller$"))])
			: {};

			if (dirty & /*$$scope, tabs*/ 524292) {
				tabscroller_changes.$$scope = { dirty, ctx };
			}

			tabscroller.$set(tabscroller_changes);

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "mdc-tab-bar " + /*className*/ ctx[1])) && { class: div_class_value },
				{ role: "tablist" },
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], [
					"use",
					"class",
					"tabs",
					"key",
					"focusOnActivate",
					"useAutomaticActivation",
					"activeIndex",
					"tabScroller$"
				])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabscroller.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabscroller.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(tabscroller);
			/*div_binding*/ ctx[18](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TabBar", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCTabBar:activated"]);

	let uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { tabs = [] } = $$props;
	let { key = tab => tab } = $$props;
	let { focusOnActivate = true } = $$props;
	let { useAutomaticActivation = true } = $$props;
	let { activeIndex = uninitializedValue } = $$props;
	let { active = uninitializedValue } = $$props;

	if (activeIndex === uninitializedValue && active === uninitializedValue) {
		activeIndex = 0;
		active = tabs[0];
	} else if (activeIndex === uninitializedValue) {
		activeIndex = tabs.indexOf(active);
	} else if (active === uninitializedValue) {
		active = tabs[activeIndex];
	}

	let element;
	let tabBar;
	let tabScrollerPromiseResolve;
	let tabScrollerPromise = new Promise(resolve => tabScrollerPromiseResolve = resolve);
	let tabPromiseResolve = [];
	let tabPromise = tabs.map((tab, i) => new Promise(resolve => tabPromiseResolve[i] = resolve));
	setContext("SMUI:tab-scroller:instantiate", false);
	setContext("SMUI:tab-scroller:getInstance", getTabScrollerInstancePromise);
	setContext("SMUI:tab:instantiate", false);
	setContext("SMUI:tab:getInstance", getTabInstancePromise);
	setContext("SMUI:tab:active", active);
	let previousActiveIndex = activeIndex;
	let previousActive = active;

	onMount(() => {
		$$invalidate(14, tabBar = new MDCTabBar(element));
		tabScrollerPromiseResolve(tabBar.tabScroller_);

		for (let i = 0; i < tabs.length; i++) {
			tabPromiseResolve[i](tabBar.tabList_[i]);
		}
	});

	onDestroy(() => {
		tabBar && tabBar.destroy();
	});

	function getTabScrollerInstancePromise() {
		return tabScrollerPromise;
	}

	function getTabInstancePromise(tabEntry) {
		return tabPromise[tabs.indexOf(tabEntry)];
	}

	function updateIndexAfterActivate(index) {
		$$invalidate(8, activeIndex = index);
		$$invalidate(15, previousActiveIndex = index);
		$$invalidate(9, active = tabs[index]);
		$$invalidate(16, previousActive = tabs[index]);
	}

	function activatedHandler(e) {
		updateIndexAfterActivate(e.detail.index);
	}

	function activateTab(index, ...args) {
		updateIndexAfterActivate(index);
		return tabBar.activateTab(index, ...args);
	}

	function scrollIntoView(...args) {
		return tabBar.scrollIntoView(...args);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("tabs" in $$new_props) $$invalidate(2, tabs = $$new_props.tabs);
		if ("key" in $$new_props) $$invalidate(3, key = $$new_props.key);
		if ("focusOnActivate" in $$new_props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
		if ("useAutomaticActivation" in $$new_props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
		if ("activeIndex" in $$new_props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
		if ("active" in $$new_props) $$invalidate(9, active = $$new_props.active);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTabBar,
		onMount,
		onDestroy,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		TabScroller,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		tabs,
		key,
		focusOnActivate,
		useAutomaticActivation,
		activeIndex,
		active,
		element,
		tabBar,
		tabScrollerPromiseResolve,
		tabScrollerPromise,
		tabPromiseResolve,
		tabPromise,
		previousActiveIndex,
		previousActive,
		getTabScrollerInstancePromise,
		getTabInstancePromise,
		updateIndexAfterActivate,
		activatedHandler,
		activateTab,
		scrollIntoView
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("uninitializedValue" in $$props) uninitializedValue = $$new_props.uninitializedValue;
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("tabs" in $$props) $$invalidate(2, tabs = $$new_props.tabs);
		if ("key" in $$props) $$invalidate(3, key = $$new_props.key);
		if ("focusOnActivate" in $$props) $$invalidate(10, focusOnActivate = $$new_props.focusOnActivate);
		if ("useAutomaticActivation" in $$props) $$invalidate(11, useAutomaticActivation = $$new_props.useAutomaticActivation);
		if ("activeIndex" in $$props) $$invalidate(8, activeIndex = $$new_props.activeIndex);
		if ("active" in $$props) $$invalidate(9, active = $$new_props.active);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("tabBar" in $$props) $$invalidate(14, tabBar = $$new_props.tabBar);
		if ("tabScrollerPromiseResolve" in $$props) tabScrollerPromiseResolve = $$new_props.tabScrollerPromiseResolve;
		if ("tabScrollerPromise" in $$props) tabScrollerPromise = $$new_props.tabScrollerPromise;
		if ("tabPromiseResolve" in $$props) tabPromiseResolve = $$new_props.tabPromiseResolve;
		if ("tabPromise" in $$props) tabPromise = $$new_props.tabPromise;
		if ("previousActiveIndex" in $$props) $$invalidate(15, previousActiveIndex = $$new_props.previousActiveIndex);
		if ("previousActive" in $$props) $$invalidate(16, previousActive = $$new_props.previousActive);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*tabBar, focusOnActivate*/ 17408) {
			 if (tabBar) {
				$$invalidate(14, tabBar.focusOnActivate = focusOnActivate, tabBar);
			}
		}

		if ($$self.$$.dirty & /*tabBar, useAutomaticActivation*/ 18432) {
			 if (tabBar) {
				$$invalidate(14, tabBar.useAutomaticActivation = useAutomaticActivation, tabBar);
			}
		}

		if ($$self.$$.dirty & /*tabBar, tabs, activeIndex*/ 16644) {
			 if (tabBar) {
				$$invalidate(9, active = tabs[activeIndex]);
			}
		}

		if ($$self.$$.dirty & /*tabBar, previousActiveIndex, activeIndex*/ 49408) {
			 if (tabBar && previousActiveIndex !== activeIndex) {
				activateTab(activeIndex);
			}
		}

		if ($$self.$$.dirty & /*tabBar, previousActive, active, tabs*/ 82436) {
			 if (tabBar && previousActive !== active) {
				activateTab(tabs.indexOf(active));
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		tabs,
		key,
		element,
		forwardEvents,
		activatedHandler,
		$$props,
		activeIndex,
		active,
		focusOnActivate,
		useAutomaticActivation,
		activateTab,
		scrollIntoView,
		tabBar,
		previousActiveIndex,
		previousActive,
		slots,
		div_binding,
		$$scope
	];
}

class TabBar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			use: 0,
			class: 1,
			tabs: 2,
			key: 3,
			focusOnActivate: 10,
			useAutomaticActivation: 11,
			activeIndex: 8,
			active: 9,
			activateTab: 12,
			scrollIntoView: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabBar",
			options,
			id: create_fragment$7.name
		});
	}

	get use() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focusOnActivate() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focusOnActivate(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get useAutomaticActivation() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set useAutomaticActivation(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeIndex() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeIndex(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activateTab() {
		return this.$$.ctx[12];
	}

	set activateTab(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollIntoView() {
		return this.$$.ctx[13];
	}

	set scrollIntoView(value) {
		throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Navbar.svelte generated by Svelte v3.31.2 */

const { console: console_1 } = globals;

const file$8 = "src\\components\\Navbar.svelte";

// (30:14) <Label>
function create_default_slot_2$1(ctx) {
	let t_value = /*tab*/ ctx[5] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tab*/ 32 && t_value !== (t_value = /*tab*/ ctx[5] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(30:14) <Label>",
		ctx
	});

	return block;
}

// (30:2) <Tab {tab}>
function create_default_slot_1$1(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope, tab*/ 96) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(30:2) <Tab {tab}>",
		ctx
	});

	return block;
}

// (29:1) <TabBar tabs={navItems} let:tab bind:active>
function create_default_slot$2(ctx) {
	let tab;
	let current;

	tab = new Tab({
			props: {
				tab: /*tab*/ ctx[5],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tab.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tab, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tab_changes = {};
			if (dirty & /*tab*/ 32) tab_changes.tab = /*tab*/ ctx[5];

			if (dirty & /*$$scope, tab*/ 96) {
				tab_changes.$$scope = { dirty, ctx };
			}

			tab.$set(tab_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tab, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(29:1) <TabBar tabs={navItems} let:tab bind:active>",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div;
	let tabbar;
	let updating_active;
	let current;
	let mounted;
	let dispose;

	function tabbar_active_binding(value) {
		/*tabbar_active_binding*/ ctx[4].call(null, value);
	}

	let tabbar_props = {
		tabs: /*navItems*/ ctx[0],
		$$slots: {
			default: [create_default_slot$2, ({ tab }) => ({ 5: tab }), ({ tab }) => tab ? 32 : 0]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[1] !== void 0) {
		tabbar_props.active = /*active*/ ctx[1];
	}

	tabbar = new TabBar({ props: tabbar_props, $$inline: true });
	binding_callbacks.push(() => bind(tabbar, "active", tabbar_active_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(tabbar.$$.fragment);
			attr_dev(div, "class", "box animated fadeInDown svelte-177mb5m");
			attr_dev(div, "id", "navbar");
			set_style(div, "display", "none");
			add_location(div, file$8, 27, 0, 659);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(tabbar, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*navigate*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const tabbar_changes = {};
			if (dirty & /*navItems*/ 1) tabbar_changes.tabs = /*navItems*/ ctx[0];

			if (dirty & /*$$scope, tab*/ 96) {
				tabbar_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 2) {
				updating_active = true;
				tabbar_changes.active = /*active*/ ctx[1];
				add_flush_callback(() => updating_active = false);
			}

			tabbar.$set(tabbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(tabbar);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const activePage = writable("");

function instance$8($$self, $$props, $$invalidate) {
	let $activePage,
		$$unsubscribe_activePage = noop;

	validate_store(activePage, "activePage");
	component_subscribe($$self, activePage, $$value => $$invalidate(3, $activePage = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_activePage());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Navbar", slots, []);
	let { navItems } = $$props;
	let active = "Home";

	const navigate = () => {
		navItems.forEach(item => item == active ? showpage(item) : hidepage(item));
	};

	onMount(() => {
		showpage("navbar");
	});

	const writable_props = ["navItems"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Navbar> was created with unknown prop '${key}'`);
	});

	function tabbar_active_binding(value) {
		active = value;
		$$invalidate(1, active);
	}

	$$self.$$set = $$props => {
		if ("navItems" in $$props) $$invalidate(0, navItems = $$props.navItems);
	};

	$$self.$capture_state = () => ({
		writable,
		activePage,
		Tab,
		Label,
		TabBar,
		onMount,
		navItems,
		active,
		navigate,
		$activePage
	});

	$$self.$inject_state = $$props => {
		if ("navItems" in $$props) $$invalidate(0, navItems = $$props.navItems);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*active*/ 2) {
			 set_store_value(activePage, $activePage = active, $activePage);
		}

		if ($$self.$$.dirty & /*$activePage*/ 8) {
			 console.log(`Current page: ${$activePage}`);
		}
	};

	return [navItems, active, navigate, $activePage, tabbar_active_binding];
}

class Navbar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { navItems: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navbar",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*navItems*/ ctx[0] === undefined && !("navItems" in props)) {
			console_1.warn("<Navbar> was created without expected prop 'navItems'");
		}
	}

	get navItems() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navItems(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Footer.svelte generated by Svelte v3.31.2 */

const file$9 = "src\\components\\Footer.svelte";

function create_fragment$9(ctx) {
	let nav;
	let div4;
	let div1;
	let div0;
	let p0;
	let t1;
	let div3;
	let div2;
	let p1;
	let p2;

	const block = {
		c: function create() {
			nav = element("nav");
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			p0 = element("p");
			p0.textContent = "Developed at Dr.Brünken's group FELion@FELIX";
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			p1 = element("p");
			p1.textContent = "2020 © AN Marimuthu | MIT License";
			p2 = element("p");
			add_location(p0, file$9, 22, 8, 518);
			attr_dev(div0, "class", "navbar-item");
			add_location(div0, file$9, 21, 6, 483);
			attr_dev(div1, "class", "navbar-start");
			add_location(div1, file$9, 19, 4, 447);
			add_location(p1, file$9, 29, 8, 677);
			add_location(p2, file$9, 29, 49, 718);
			attr_dev(div2, "class", "navbar-item");
			add_location(div2, file$9, 27, 6, 640);
			attr_dev(div3, "class", "navbar-end");
			add_location(div3, file$9, 26, 4, 608);
			attr_dev(div4, "class", "navbar-menu");
			add_location(div4, file$9, 18, 2, 416);
			attr_dev(nav, "class", "navbar is-fixed-bottom animated fadeInUp svelte-t975c1");
			attr_dev(nav, "id", "footer");
			set_style(nav, "display", "none");
			add_location(nav, file$9, 17, 0, 325);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, div4);
			append_dev(div4, div1);
			append_dev(div1, div0);
			append_dev(div0, p0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div2);
			append_dev(div2, p1);
			append_dev(div2, p2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $activePage;
	validate_store(activePage, "activePage");
	component_subscribe($$self, activePage, $$value => $$invalidate(0, $activePage = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Footer", slots, []);

	afterUpdate(() => {
		$activePage === "Home"
		? hidepage("footer")
		: showpage("footer");
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ afterUpdate, activePage, $activePage });
	return [];
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment$9.name
		});
	}
}

/* src\components\starterpage_animations\Simplewave.svelte generated by Svelte v3.31.2 */

const file$a = "src\\components\\starterpage_animations\\Simplewave.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (136:36)                       
function fallback_block_1(ctx) {
	let h1;
	let t1;
	let br;
	let t2;
	let h2;

	const block = {
		c: function create() {
			h1 = element("h1");
			h1.textContent = "FELion Spectrum Analyser";
			t1 = space();
			br = element("br");
			t2 = space();
			h2 = element("h2");
			h2.textContent = "To analyse FELIX data for FELion Instrument";
			attr_dev(h1, "class", "svelte-jlsh69");
			add_location(h1, file$a, 144, 20, 3519);
			add_location(br, file$a, 145, 20, 3575);
			attr_dev(h2, "class", "svelte-jlsh69");
			add_location(h2, file$a, 146, 20, 3601);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, br, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, h2, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block_1.name,
		type: "fallback",
		source: "(136:36)                       ",
		ctx
	});

	return block;
}

// (177:28) <p>
function fallback_block(ctx) {
	let p;

	const block = {
		c: function create() {
			p = element("p");
			p.textContent = "Developed at Dr.Brünken's group FELion@FELIX | 2020 © AN Marimuthu | MIT License";
			attr_dev(p, "class", "svelte-jlsh69");
			add_location(p, file$a, 176, 28, 4776);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(177:28) <p>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div5;
	let div3;
	let div1;
	let div0;
	let t0;
	let div2;
	let svg;
	let defs;
	let path;
	let g;
	let use0;
	let use1;
	let use2;
	let use3;
	let t1;
	let div4;
	let current;
	const header_slot_template = /*#slots*/ ctx[1].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[0], get_header_slot_context);
	const header_slot_or_fallback = header_slot || fallback_block_1(ctx);
	const footer_slot_template = /*#slots*/ ctx[1].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[0], get_footer_slot_context);
	const footer_slot_or_fallback = footer_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			div5 = element("div");
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (header_slot_or_fallback) header_slot_or_fallback.c();
			t0 = space();
			div2 = element("div");
			svg = svg_element("svg");
			defs = svg_element("defs");
			path = svg_element("path");
			g = svg_element("g");
			use0 = svg_element("use");
			use1 = svg_element("use");
			use2 = svg_element("use");
			use3 = svg_element("use");
			t1 = space();
			div4 = element("div");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			attr_dev(div0, "class", "container title_container svelte-jlsh69");
			add_location(div0, file$a, 134, 12, 2376);
			attr_dev(div1, "class", "inner-header flex svelte-jlsh69");
			add_location(div1, file$a, 130, 8, 2317);
			attr_dev(path, "id", "gentle-wave");
			attr_dev(path, "d", "M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z");
			add_location(path, file$a, 157, 20, 4020);
			add_location(defs, file$a, 155, 16, 3990);
			xlink_attr(use0, "xlink:href", "#gentle-wave");
			attr_dev(use0, "x", "48");
			attr_dev(use0, "y", "0");
			attr_dev(use0, "fill", "rgba(255,255,255,0.7");
			attr_dev(use0, "class", "svelte-jlsh69");
			add_location(use0, file$a, 160, 20, 4207);
			xlink_attr(use1, "xlink:href", "#gentle-wave");
			attr_dev(use1, "x", "48");
			attr_dev(use1, "y", "3");
			attr_dev(use1, "fill", "rgba(255,255,255,0.5)");
			attr_dev(use1, "class", "svelte-jlsh69");
			add_location(use1, file$a, 161, 20, 4303);
			xlink_attr(use2, "xlink:href", "#gentle-wave");
			attr_dev(use2, "x", "48");
			attr_dev(use2, "y", "5");
			attr_dev(use2, "fill", "rgba(255,255,255,0.3)");
			attr_dev(use2, "class", "svelte-jlsh69");
			add_location(use2, file$a, 162, 20, 4400);
			xlink_attr(use3, "xlink:href", "#gentle-wave");
			attr_dev(use3, "x", "48");
			attr_dev(use3, "y", "7");
			attr_dev(use3, "fill", "#fff");
			attr_dev(use3, "class", "svelte-jlsh69");
			add_location(use3, file$a, 163, 20, 4497);
			attr_dev(g, "class", "parallax svelte-jlsh69");
			add_location(g, file$a, 159, 16, 4165);
			attr_dev(svg, "class", "waves svelte-jlsh69");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr_dev(svg, "viewBox", "0 24 150 28");
			attr_dev(svg, "preserveAspectRatio", "none");
			attr_dev(svg, "shape-rendering", "auto");
			add_location(svg, file$a, 154, 12, 3803);
			attr_dev(div2, "class", "wave_container svelte-jlsh69");
			add_location(div2, file$a, 153, 8, 3761);
			attr_dev(div3, "class", "header svelte-jlsh69");
			add_location(div3, file$a, 126, 4, 2246);
			attr_dev(div4, "class", "content flex svelte-jlsh69");
			add_location(div4, file$a, 175, 4, 4720);
			attr_dev(div5, "class", "animated fadeIn slower");
			add_location(div5, file$a, 125, 0, 2204);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div3);
			append_dev(div3, div1);
			append_dev(div1, div0);

			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(div0, null);
			}

			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, svg);
			append_dev(svg, defs);
			append_dev(defs, path);
			append_dev(svg, g);
			append_dev(g, use0);
			append_dev(g, use1);
			append_dev(g, use2);
			append_dev(g, use3);
			append_dev(div5, t1);
			append_dev(div5, div4);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(div4, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (header_slot) {
				if (header_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}

			if (footer_slot) {
				if (footer_slot.p && dirty & /*$$scope*/ 1) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[0], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			transition_in(footer_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot_or_fallback, local);
			transition_out(footer_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Simplewave", slots, ['header','footer']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Simplewave> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Simplewave extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Simplewave",
			options,
			id: create_fragment$a.name
		});
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}

/* node_modules\svelma\src\components\Notices.svelte generated by Svelte v3.31.2 */

const file$b = "node_modules\\svelma\\src\\components\\Notices.svelte";

function create_fragment$b(ctx) {
	let div;
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", div_class_value = "notices " + /*positionClass*/ ctx[1] + " svelte-1l3nrzu");
			add_location(div, file$b, 38, 0, 883);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[4](div);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*positionClass*/ 2 && div_class_value !== (div_class_value = "notices " + /*positionClass*/ ctx[1] + " svelte-1l3nrzu")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[4](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const notices = {};

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Notices", slots, []);
	let { position = "top" } = $$props;
	let container;
	let positionClass;

	function insert(el) {
		container.insertAdjacentElement("afterbegin", el);
	}

	const writable_props = ["position"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Notices> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ("position" in $$props) $$invalidate(2, position = $$props.position);
	};

	$$self.$capture_state = () => ({
		notices,
		position,
		container,
		positionClass,
		insert
	});

	$$self.$inject_state = $$props => {
		if ("position" in $$props) $$invalidate(2, position = $$props.position);
		if ("container" in $$props) $$invalidate(0, container = $$props.container);
		if ("positionClass" in $$props) $$invalidate(1, positionClass = $$props.positionClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*position*/ 4) {
			 $$invalidate(1, positionClass = position === "top" ? "is-top" : "is-bottom");
		}
	};

	return [container, positionClass, position, insert, div_binding];
}

class Notices extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { position: 2, insert: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Notices",
			options,
			id: create_fragment$b.name
		});
	}

	get position() {
		throw new Error("<Notices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Notices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get insert() {
		return this.$$.ctx[3];
	}

	set insert(value) {
		throw new Error("<Notices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelma\src\components\Notice.svelte generated by Svelte v3.31.2 */

const { Object: Object_1 } = globals;
const file$c = "node_modules\\svelma\\src\\components\\Notice.svelte";

// (95:0) {#if active}
function create_if_block$1(ctx) {
	let div;
	let div_class_value;
	let div_aria_hidden_value;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "notice " + /*position*/ ctx[1] + " svelte-1dar0kx");
			attr_dev(div, "aria-hidden", div_aria_hidden_value = !/*active*/ ctx[0]);
			add_location(div, file$c, 95, 2, 1945);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "outroend", /*remove*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (!current || dirty & /*position*/ 2 && div_class_value !== (div_class_value = "notice " + /*position*/ ctx[1] + " svelte-1dar0kx")) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*active*/ 1 && div_aria_hidden_value !== (div_aria_hidden_value = !/*active*/ ctx[0])) {
				attr_dev(div, "aria-hidden", div_aria_hidden_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fly, { y: /*transitionY*/ ctx[4] });
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (div_intro) div_intro.invalidate();

			div_outro = create_out_transition(div, fade, {
				duration: /*transitionOut*/ ctx[2] ? 400 : 0
			});

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[10](null);
			if (detaching && div_outro) div_outro.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(95:0) {#if active}",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const allowedProps = ["active", "position", "duration"];

function filterProps(props) {
	const newProps = {};

	Object.keys(props).forEach(key => {
		if (allowedProps.includes(key)) newProps[key] = props[key];
	});

	return newProps;
}

function instance$c($$self, $$props, $$invalidate) {
	let transitionY;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Notice", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { active = true } = $$props;
	let { position = "is-top" } = $$props;
	let { duration = 2000 } = $$props;
	let { transitionOut = true } = $$props;
	let el;
	let parent;
	let timer;

	function close() {
		$$invalidate(0, active = false);
	}

	function remove() {
		clearTimeout(timer);

		// Just making sure
		$$invalidate(0, active = false);

		dispatch("destroyed");
	}

	async function setupContainers() {
		await tick;

		if (!notices.top) {
			notices.top = new Notices({
					target: document.body,
					props: { position: "top" }
				});
		}

		if (!notices.bottom) {
			notices.bottom = new Notices({
					target: document.body,
					props: { position: "bottom" }
				});
		}
	}

	function chooseParent() {
		parent = notices.top;
		if (position && position.indexOf("is-bottom") === 0) parent = notices.bottom;
		parent.insert(el);
	}

	onMount(async () => {
		await setupContainers();
		chooseParent();

		timer = setTimeout(
			() => {
				close();
			},
			duration
		);
	});

	const writable_props = ["active", "position", "duration", "transitionOut"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Notice> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("duration" in $$props) $$invalidate(6, duration = $$props.duration);
		if ("transitionOut" in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		allowedProps,
		filterProps,
		createEventDispatcher,
		onDestroy,
		onMount,
		tick,
		fly,
		fade,
		Notices,
		notices,
		dispatch,
		active,
		position,
		duration,
		transitionOut,
		el,
		parent,
		timer,
		close,
		remove,
		setupContainers,
		chooseParent,
		transitionY
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("position" in $$props) $$invalidate(1, position = $$props.position);
		if ("duration" in $$props) $$invalidate(6, duration = $$props.duration);
		if ("transitionOut" in $$props) $$invalidate(2, transitionOut = $$props.transitionOut);
		if ("el" in $$props) $$invalidate(3, el = $$props.el);
		if ("parent" in $$props) parent = $$props.parent;
		if ("timer" in $$props) timer = $$props.timer;
		if ("transitionY" in $$props) $$invalidate(4, transitionY = $$props.transitionY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*position*/ 2) {
			 $$invalidate(4, transitionY = ~position.indexOf("is-top") ? -200 : 200);
		}
	};

	return [
		active,
		position,
		transitionOut,
		el,
		transitionY,
		remove,
		duration,
		close,
		$$scope,
		slots,
		div_binding
	];
}

class Notice extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			active: 0,
			position: 1,
			duration: 6,
			transitionOut: 2,
			close: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Notice",
			options,
			id: create_fragment$c.name
		});
	}

	get active() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionOut() {
		throw new Error("<Notice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionOut(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[7];
	}

	set close(value) {
		throw new Error("<Notice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelma\src\components\Snackbar\Snackbar.svelte generated by Svelte v3.31.2 */

const { Error: Error_1$1 } = globals;
const file$d = "node_modules\\svelma\\src\\components\\Snackbar\\Snackbar.svelte";

// (91:4) {#if actionText}
function create_if_block$2(ctx) {
	let div;
	let button;
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t = text(/*actionText*/ ctx[2]);
			attr_dev(button, "class", button_class_value = "button " + /*newType*/ ctx[4] + " svelte-1wxmrzz");
			add_location(button, file$d, 92, 8, 2720);
			attr_dev(div, "class", "action svelte-1wxmrzz");
			add_location(div, file$d, 91, 6, 2673);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*action*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*actionText*/ 4) set_data_dev(t, /*actionText*/ ctx[2]);

			if (dirty & /*newType*/ 16 && button_class_value !== (button_class_value = "button " + /*newType*/ ctx[4] + " svelte-1wxmrzz")) {
				attr_dev(button, "class", button_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(91:4) {#if actionText}",
		ctx
	});

	return block;
}

// (85:0) <Notice {...props} bind:this={notice} transitionOut={true}>
function create_default_slot$3(ctx) {
	let div1;
	let div0;
	let t;
	let div1_class_value;
	let if_block = /*actionText*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "text svelte-1wxmrzz");
			add_location(div0, file$d, 86, 4, 2514);
			attr_dev(div1, "class", div1_class_value = "snackbar " + /*background*/ ctx[1] + " svelte-1wxmrzz");
			attr_dev(div1, "role", "alert");
			toggle_class(div1, "has-background-dark", !/*background*/ ctx[1]);
			add_location(div1, file$d, 85, 2, 2421);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = /*message*/ ctx[0];
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
			if (/*actionText*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*background*/ 2 && div1_class_value !== (div1_class_value = "snackbar " + /*background*/ ctx[1] + " svelte-1wxmrzz")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (dirty & /*background, background*/ 2) {
				toggle_class(div1, "has-background-dark", !/*background*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(85:0) <Notice {...props} bind:this={notice} transitionOut={true}>",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let notice_1;
	let current;
	const notice_1_spread_levels = [/*props*/ ctx[5], { transitionOut: true }];

	let notice_1_props = {
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notice_1_spread_levels.length; i += 1) {
		notice_1_props = assign(notice_1_props, notice_1_spread_levels[i]);
	}

	notice_1 = new Notice({ props: notice_1_props, $$inline: true });
	/*notice_1_binding*/ ctx[11](notice_1);

	const block = {
		c: function create() {
			create_component(notice_1.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(notice_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const notice_1_changes = (dirty & /*props*/ 32)
			? get_spread_update(notice_1_spread_levels, [get_spread_object(/*props*/ ctx[5]), notice_1_spread_levels[1]])
			: {};

			if (dirty & /*$$scope, background, newType, actionText, message*/ 8215) {
				notice_1_changes.$$scope = { dirty, ctx };
			}

			notice_1.$set(notice_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notice_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notice_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*notice_1_binding*/ ctx[11](null);
			destroy_component(notice_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let newType;
	let props;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Snackbar", slots, []);
	let { message } = $$props;
	let { duration = 3500 } = $$props;
	let { position = "is-bottom-right" } = $$props;
	let { type = "is-primary" } = $$props;
	let { background = "" } = $$props;
	let { actionText = "OK" } = $$props;

	let { onAction = () => {
		
	} } = $$props;

	let notice;

	function action() {
		Promise.resolve(onAction()).then(() => notice.close());
	}

	onMount(() => {
		if (typeof onAction !== "function") throw new Error(`onAction ${onAction} is not a function`);
	});

	function notice_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			notice = $$value;
			$$invalidate(3, notice);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("message" in $$new_props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$new_props) $$invalidate(7, duration = $$new_props.duration);
		if ("position" in $$new_props) $$invalidate(8, position = $$new_props.position);
		if ("type" in $$new_props) $$invalidate(9, type = $$new_props.type);
		if ("background" in $$new_props) $$invalidate(1, background = $$new_props.background);
		if ("actionText" in $$new_props) $$invalidate(2, actionText = $$new_props.actionText);
		if ("onAction" in $$new_props) $$invalidate(10, onAction = $$new_props.onAction);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onDestroy,
		onMount,
		fly,
		fade,
		Notice,
		filterProps,
		message,
		duration,
		position,
		type,
		background,
		actionText,
		onAction,
		notice,
		action,
		newType,
		props
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("message" in $$props) $$invalidate(0, message = $$new_props.message);
		if ("duration" in $$props) $$invalidate(7, duration = $$new_props.duration);
		if ("position" in $$props) $$invalidate(8, position = $$new_props.position);
		if ("type" in $$props) $$invalidate(9, type = $$new_props.type);
		if ("background" in $$props) $$invalidate(1, background = $$new_props.background);
		if ("actionText" in $$props) $$invalidate(2, actionText = $$new_props.actionText);
		if ("onAction" in $$props) $$invalidate(10, onAction = $$new_props.onAction);
		if ("notice" in $$props) $$invalidate(3, notice = $$new_props.notice);
		if ("newType" in $$props) $$invalidate(4, newType = $$new_props.newType);
		if ("props" in $$props) $$invalidate(5, props = $$new_props.props);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type*/ 512) {
			// $: newBackground = background
			 $$invalidate(4, newType = type && type.replace(/^is-(.*)/, "has-text-$1"));
		}

		 $$invalidate(5, props = {
			...filterProps($$props),
			position,
			duration
		});
	};

	$$props = exclude_internal_props($$props);

	return [
		message,
		background,
		actionText,
		notice,
		newType,
		props,
		action,
		duration,
		position,
		type,
		onAction,
		notice_1_binding
	];
}

class Snackbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			message: 0,
			duration: 7,
			position: 8,
			type: 9,
			background: 1,
			actionText: 2,
			onAction: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Snackbar",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
			console.warn("<Snackbar> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get background() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set background(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get actionText() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actionText(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onAction() {
		throw new Error_1$1("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onAction(value) {
		throw new Error_1$1("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

Snackbar.create = create;

function create(props) {
  if (typeof props === 'string') props = { message: props };

  const snackbar = new Snackbar({
    target: document.body,
    props,
    intro: true,
  });

  snackbar.$on('destroyed', snackbar.$destroy);

  return snackbar;
}

/* node_modules\svelma\src\components\Toast\Toast.svelte generated by Svelte v3.31.2 */
const file$e = "node_modules\\svelma\\src\\components\\Toast\\Toast.svelte";

// (48:0) <Notice {...filterProps($$props)}>
function create_default_slot$4(ctx) {
	let div1;
	let div0;
	let div1_class_value;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			attr_dev(div0, "class", "text");
			add_location(div0, file$e, 49, 4, 1497);
			attr_dev(div1, "class", div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-kh3j47");
			attr_dev(div1, "role", "alert");
			add_location(div1, file$e, 48, 2, 1437);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = /*message*/ ctx[0];
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) div0.innerHTML = /*message*/ ctx[0];
			if (dirty & /*type, newBackground*/ 6 && div1_class_value !== (div1_class_value = "toast " + /*type*/ ctx[1] + " " + /*newBackground*/ ctx[2] + " svelte-kh3j47")) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(48:0) <Notice {...filterProps($$props)}>",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let notice;
	let current;
	const notice_spread_levels = [filterProps(/*$$props*/ ctx[3])];

	let notice_props = {
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notice_spread_levels.length; i += 1) {
		notice_props = assign(notice_props, notice_spread_levels[i]);
	}

	notice = new Notice({ props: notice_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(notice.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(notice, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const notice_changes = (dirty & /*filterProps, $$props*/ 8)
			? get_spread_update(notice_spread_levels, [get_spread_object(filterProps(/*$$props*/ ctx[3]))])
			: {};

			if (dirty & /*$$scope, type, newBackground, message*/ 39) {
				notice_changes.$$scope = { dirty, ctx };
			}

			notice.$set(notice_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notice.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notice.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notice, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let newBackground;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Toast", slots, []);
	let { message } = $$props;
	let { type = "is-dark" } = $$props;
	let { background = "" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("message" in $$new_props) $$invalidate(0, message = $$new_props.message);
		if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ("background" in $$new_props) $$invalidate(4, background = $$new_props.background);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onDestroy,
		onMount,
		fly,
		fade,
		Notice,
		filterProps,
		message,
		type,
		background,
		newBackground
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
		if ("message" in $$props) $$invalidate(0, message = $$new_props.message);
		if ("type" in $$props) $$invalidate(1, type = $$new_props.type);
		if ("background" in $$props) $$invalidate(4, background = $$new_props.background);
		if ("newBackground" in $$props) $$invalidate(2, newBackground = $$new_props.newBackground);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*background, type*/ 18) {
			 $$invalidate(2, newBackground = background || type.replace(/^is-(.*)/, "has-background-$1"));
		}
	};

	$$props = exclude_internal_props($$props);
	return [message, type, newBackground, $$props, background];
}

class Toast extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { message: 0, type: 1, background: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toast",
			options,
			id: create_fragment$e.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*message*/ ctx[0] === undefined && !("message" in props)) {
			console.warn("<Toast> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get background() {
		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set background(value) {
		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

Toast.create = create$1;

function create$1(props) {
  if (typeof props === 'string') props = { message: props };

  const toast = new Toast({
    target: document.body,
    props,
    intro: true,
  });

  toast.$on('destroyed', toast.$destroy);

  return toast;
}

const github = writable({ branch: "master", repo: "FELion_GUI3", username: "aravindhnivas" });
const githubRepo = derived(github, ($github) => `https://raw.githubusercontent.com/${$github.username}/${$github.repo}/${$github.branch}`);
const versionJson = derived(githubRepo, ($githubRepo) => `${$githubRepo}/version.json`);
const urlzip = derived(github, ($github) => `https://codeload.github.com/${$github.username}/${$github.repo}/zip/${$github.branch}`);

const pythonpath = writable(localStorage["pythonpath"] || path.resolve(__dirname, "../python3/python"));

const pythonscript = writable(localStorage["pythonscript"] || path.resolve(__dirname, "assets/python_files"));
const pyVersion = writable("");

if (!localStorage["pythonpath"]) localStorage["pythonpath"] = get_store_value(pythonpath);

if (!localStorage["pythonscript"]) localStorage["pythonscript"] = get_store_value(pythonpath);

const backupName = writable("FELion_GUI_backup");

const { exec } = child_process;
window.checkPython = function checkPython({ defaultPy } = {}) {

    if (!defaultPy) { defaultPy = get_store_value(pythonpath); }

    console.log("Python path checking \n", defaultPy);
    return new Promise((resolve, reject) => {
        exec(`${defaultPy} -V`, (err, stdout) => {
            if (err) { reject("Invalid python location"); window.createToast("Python location is not valid", "danger"); }
            else { resolve(stdout.trim()); }

        });
    })
};

window.computePy_func = function computePy_func({ e = null, pyfile = "", args = "", general = false, openShell = false} = {}) {

    return new Promise((resolve, reject) => {

        let target;
        if (!general) {
            target = e.target;
            target.classList.toggle("is-loading");

        }

        checkPython()

            .then(res => {

                console.log(res);
                if (general) {
                    console.log("Sending general arguments: ", args);
                    window.createToast("Process Started");
                    const py = spawn(
                        get_store_value(pythonpath), [path.join(get_store_value(pythonscript), pyfile), args], { detached: true, stdio: 'pipe', shell: openShell }

                    );

                    if(e) {
                    
                    
                        const pyEvent = new CustomEvent('pyEvent', { bubbles: false, detail: { py, pyfile } });
                        e.target.dispatchEvent(pyEvent);
                        console.log("pyEvent dispatched");
                    }

                    // target.classList.toggle("is-loading")

                    py.on("close", () => { 

                        console.log("Closed");

                        if(e) {
                            const pyEventClosed = new CustomEvent('pyEventClosed', { bubbles: false, detail: { py, pyfile } });
                            e.target.dispatchEvent(pyEventClosed);
                            console.log("pyEventClosed dispatched");
                        }
                     });
                    py.stderr.on("data", (err) => { console.log(`Error Occured: ${err.toString()}`); reject(err.toString()); });
                    py.stdout.on("data", (data) => { 

                        const dataReceived = data.toString();
                        console.log(`Output from python: ${dataReceived}`);
                        if(e) {
                    
                            const pyEventData = new CustomEvent('pyEventData', { bubbles: false, detail: { py, pyfile, dataReceived } });
                            e.target.dispatchEvent(pyEventData);
                         
                            console.log("pyEventData dispatched");
    
                        }
                     });


                    py.unref();

                    py.ref();
                } else {

                    let py = null;
                    try { py = spawn(get_store_value(pythonpath), [path.resolve(get_store_value(pythonscript), pyfile), args]); }
                    catch (err) { reject("Error accessing python. Set python location properly in Settings\n" + err); }

                    if(e) {
                    
                        const pyEvent = new CustomEvent('pyEvent', { bubbles: false, detail: { py, pyfile } });
                        e.target.dispatchEvent(pyEvent);
                        console.log("pyEvent dispatched");

                    }

                    window.createToast("Process Started");
                    py.stdout.on("data", data => {

                        console.log("Ouput from python");
                        let dataReceived = data.toString("utf8");
                        console.log(dataReceived);

                        if(e) {
                    
                            const pyEventData = new CustomEvent('pyEventData', { bubbles: false, detail: { py, pyfile, dataReceived } });
                            e.target.dispatchEvent(pyEventData);
                         
                            console.log("pyEventData dispatched");
    
                        }
                    });

                    let error_occured_py = false, errContent="";

                    py.stderr.on("data", err => {
                        
                        errContent = err.toString();
                        console.error(errContent);
                        reject(errContent);
                        error_occured_py = true;
                    });

                    py.on("close", () => {
                        if (!error_occured_py) {
                            let dataFromPython = fs.readFileSync(path.join(get_store_value(pythonscript), "data.json"));
                            window.dataFromPython = dataFromPython = JSON.parse(dataFromPython.toString("utf-8"));
                            console.log(dataFromPython);
                            resolve(dataFromPython);

                        }

                        if(e) {
                            const pyEventClosed = new CustomEvent('pyEventClosed', { bubbles: false, detail: { py, pyfile } });
                            e.target.dispatchEvent(pyEventClosed);
                        
                            console.log("pyEventClosed dispatched");
                        }
                        
                        target.classList.toggle("is-loading");

                        console.log("Process closed");
                    });
                }

            }).catch(err => { reject(err.stack); if (!general) { target.classList.toggle("is-loading"); } });
    })

};

const activateChangelog = writable(false);
const windowLoaded = writable(false);

const updateAvailable = writable(false);
const newVersion = writable("");
const updating = writable(false);


// Global variables

window.createToast = (msg, type = "primary") => Toast.create({ message: msg, position: "is-top", type: `is-${type}` });
window.sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

window.onerror = function(message, source, lineno, colno, error) { 

    // message: error message (string). Available as event (sic!) in HTML onerror="" handler.
    // source: URL of the script where the error was raised (string)
    // lineno: Line number where error was raised (number)
    // colno: Column number for the line where the error occurred (number)
    // error: Error Object (object)
    console.error(error);
    Snackbar.create({ message:error.name, position: "is-top", type: `is-danger` });
 };

window.process.on('unhandledRejection', (reason, promise) => {
    console.error(`Uncaught error in`, promise);
});

window.targetElement = (id) => document.getElementById(id);
window.getPageStatus = (id) => targetElement(id).style.display !== "none";
window.showpage = (id) => { targetElement(id).style.display = "block"; };

window.hidepage = (id) => { targetElement(id).style.display = "none"; };

window.togglepage = (id) => {

    window.getPageStatus(id) ? targetElement(id).style.display = "none" : targetElement(id).style.display = "block";
};

const electronVersion = process.versions.electron;
window.showinfo = electronVersion >= "7" ? remote.dialog.showMessageBoxSync : remote.dialog.showMessageBox;


// Checking curernt version

const versionFile = fs.readFileSync(path.join(__dirname, "../version.json"));

window.currentVersion = localStorage["version"] = JSON.parse(versionFile.toString("utf-8")).version;
window.asyncForEach = async (array, callback) => {

    for (let index = 0; index < array.length; index++) {

        await callback(array[index], index, array);

    }
};


window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    windowLoaded.set(true);

});

function resizableDiv({ div, change = { width: true, height: true }, cursor = { left: false, right: false, bottom: false, top: false } } = {}) {
    interact(div).resizable({

        edges: cursor,

        modifiers: [
            // keep the edges inside the parent
            interact.modifiers.restrictEdges({ outer: 'parent' }),
            interact.modifiers.restrictSize({ min: { width: 50, height: 50 }, max: { width: 500 } })
        ],
        inertia: true
    }).on('resizemove', function (event) {
        let target = event.target;
        let x = (parseFloat(target.getAttribute('data-x')) || 0);
        let y = (parseFloat(target.getAttribute('data-y')) || 0);

        if (change.width) {
            target.style.width = event.rect.width + 'px';
            if (event.rect.width <= 50) {
                if (target.classList.contains("filebrowser")) { target.style.display = "none"; }

            }

        }

        if (change.height) target.style.height = event.rect.height + 'px';

        // translate when resizing from top or left edges


        x += event.deltaRect.left;

        y += event.deltaRect.top;


        target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px,' + y + 'px)';
        target.setAttribute('data-x', x);
        target.setAttribute('data-y', y);

    });

}
resizableDiv({ div: ".adjust-right", cursor: { right: true }, change: { width: true, height: false } });

function plot(mainTitle, xtitle, ytitle, data, plotArea, filetype = null) {

    let dataLayout = {
        title: mainTitle,
        xaxis: { title: xtitle },
        yaxis: { title: ytitle },
        hovermode: 'closest',
        autosize: true,
        height: 450,
    };

    if (filetype == 'mass') { dataLayout.yaxis.type = "log"; }

    let dataPlot = [];

    for (let x in data) { dataPlot.push(data[x]); }

    try { Plotly.react(plotArea, dataPlot, dataLayout, { editable: true }); } catch (err) { console.log("Error occured while plotting\n", err); }
}

function subplot(mainTitle, xtitle, ytitle, data, plotArea, x2, y2, data2) {

    let dataLayout = {
        title: mainTitle,
        xaxis: { domain: [0, 0.4], title: xtitle },
        yaxis: { title: ytitle },
        xaxis2: { domain: [0.5, 1], title: x2 },
        yaxis2: { anchor: "x2", title: y2, overlaying: 'y', },

        yaxis3: { anchor: 'free', overlaying: 'y', side: 'right', title: "Measured (mJ)", position: 0.97 },
        autosize: true,
        height: 450,

    };

    let dataPlot1 = [];
    for (let x in data) { dataPlot1.push(data[x]); }
    let dataPlot2 = [];
    for (let x in data2) { dataPlot2.push(data2[x]); }
    Plotly.react(plotArea, dataPlot1.concat(dataPlot2), dataLayout, { editable: true });
}

/* src\Pages\Home.svelte generated by Svelte v3.31.2 */
const file$f = "src\\Pages\\Home.svelte";

// (18:4) {#if $windowLoaded}
function create_if_block$3(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 1,
		blocks: [,,,]
	};

	handle_promise(promise = window.sleep(500), info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(18:4) {#if $windowLoaded}",
		ctx
	});

	return block;
}

// (1:0)   <script>    import Simplewave from "../components/starterpage_animations/Simplewave.svelte";    import {windowLoaded}
function create_catch_block(ctx) {
	const block = {
		c: noop,
		m: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0)   <script>    import Simplewave from \\\"../components/starterpage_animations/Simplewave.svelte\\\";    import {windowLoaded}",
		ctx
	});

	return block;
}

// (20:43)           <Simplewave />        {/await}
function create_then_block(ctx) {
	let simplewave;
	let current;
	simplewave = new Simplewave({ $$inline: true });

	const block = {
		c: function create() {
			create_component(simplewave.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(simplewave, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(simplewave.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(simplewave.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(simplewave, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(20:43)           <Simplewave />        {/await}",
		ctx
	});

	return block;
}

// (1:0)   <script>    import Simplewave from "../components/starterpage_animations/Simplewave.svelte";    import {windowLoaded}
function create_pending_block(ctx) {
	const block = {
		c: noop,
		m: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(1:0)   <script>    import Simplewave from \\\"../components/starterpage_animations/Simplewave.svelte\\\";    import {windowLoaded}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let section;
	let current;
	let if_block = /*$windowLoaded*/ ctx[0] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block) if_block.c();
			attr_dev(section, "class", "section animated fadeIn svelte-1atxx5i");
			attr_dev(section, "id", "Home");
			add_location(section, file$f, 15, 0, 223);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if (if_block) if_block.m(section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$windowLoaded*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$windowLoaded*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(section, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let $windowLoaded;
	validate_store(windowLoaded, "windowLoaded");
	component_subscribe($$self, windowLoaded, $$value => $$invalidate(0, $windowLoaded = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Home", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Home> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Simplewave, windowLoaded, $windowLoaded });
	return [$windowLoaded];
}

class Home extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Home",
			options,
			id: create_fragment$f.name
		});
	}
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$4 = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake',
    ROOT: 'mdc-floating-label',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFloatingLabelFoundation = /** @class */ (function (_super) {
    __extends(MDCFloatingLabelFoundation, _super);
    function MDCFloatingLabelFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCFloatingLabelFoundation.defaultAdapter, adapter)) || this;
        _this.shakeAnimationEndHandler_ = function () { return _this.handleShakeAnimationEnd_(); };
        return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
        get: function () {
            return cssClasses$4;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
        /**
         * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                getWidth: function () { return 0; },
                registerInteractionHandler: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCFloatingLabelFoundation.prototype.init = function () {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation.prototype.destroy = function () {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
    };
    /**
     * Returns the width of the label element.
     */
    MDCFloatingLabelFoundation.prototype.getWidth = function () {
        return this.adapter_.getWidth();
    };
    /**
     * Styles the label to produce a shake animation to indicate an error.
     * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
     */
    MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
        }
        else {
            this.adapter_.removeClass(LABEL_SHAKE);
        }
    };
    /**
     * Styles the label to float or dock.
     * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
     */
    MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
        var _a = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
        if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        }
        else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
        }
    };
    MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd_ = function () {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        this.adapter_.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFloatingLabel = /** @class */ (function (_super) {
    __extends(MDCFloatingLabel, _super);
    function MDCFloatingLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFloatingLabel.attachTo = function (root) {
        return new MDCFloatingLabel(root);
    };
    /**
     * Styles the label to produce the label shake for errors.
     * @param shouldShake If true, shakes the label by adding a CSS class; otherwise, stops shaking by removing the class.
     */
    MDCFloatingLabel.prototype.shake = function (shouldShake) {
        this.foundation_.shake(shouldShake);
    };
    /**
     * Styles the label to float/dock.
     * @param shouldFloat If true, floats the label by adding a CSS class; otherwise, docks it by removing the class.
     */
    MDCFloatingLabel.prototype.float = function (shouldFloat) {
        this.foundation_.float(shouldFloat);
    };
    MDCFloatingLabel.prototype.getWidth = function () {
        return this.foundation_.getWidth();
    };
    MDCFloatingLabel.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            getWidth: function () { return _this.root_.scrollWidth; },
            registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
            deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCFloatingLabelFoundation(adapter);
    };
    return MDCFloatingLabel;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$5 = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCLineRippleFoundation = /** @class */ (function (_super) {
    __extends(MDCLineRippleFoundation, _super);
    function MDCLineRippleFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCLineRippleFoundation.defaultAdapter, adapter)) || this;
        _this.transitionEndHandler_ = function (evt) { return _this.handleTransitionEnd(evt); };
        return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
        get: function () {
            return cssClasses$5;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
        /**
         * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                setStyle: function () { return undefined; },
                registerEventHandler: function () { return undefined; },
                deregisterEventHandler: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCLineRippleFoundation.prototype.init = function () {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
    };
    MDCLineRippleFoundation.prototype.destroy = function () {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
    };
    MDCLineRippleFoundation.prototype.activate = function () {
        this.adapter_.removeClass(cssClasses$5.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$5.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
        this.adapter_.setStyle('transform-origin', xCoordinate + "px center");
    };
    MDCLineRippleFoundation.prototype.deactivate = function () {
        this.adapter_.addClass(cssClasses$5.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$5.LINE_RIPPLE_DEACTIVATING);
        if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
                this.adapter_.removeClass(cssClasses$5.LINE_RIPPLE_ACTIVE);
                this.adapter_.removeClass(cssClasses$5.LINE_RIPPLE_DEACTIVATING);
            }
        }
    };
    return MDCLineRippleFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCLineRipple = /** @class */ (function (_super) {
    __extends(MDCLineRipple, _super);
    function MDCLineRipple() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCLineRipple.attachTo = function (root) {
        return new MDCLineRipple(root);
    };
    /**
     * Activates the line ripple
     */
    MDCLineRipple.prototype.activate = function () {
        this.foundation_.activate();
    };
    /**
     * Deactivates the line ripple
     */
    MDCLineRipple.prototype.deactivate = function () {
        this.foundation_.deactivate();
    };
    /**
     * Sets the transform origin given a user's click location.
     * The `rippleCenter` is the x-coordinate of the middle of the ripple.
     */
    MDCLineRipple.prototype.setRippleCenter = function (xCoordinate) {
        this.foundation_.setRippleCenter(xCoordinate);
    };
    MDCLineRipple.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            setStyle: function (propertyName, value) { return _this.root_.style.setProperty(propertyName, value); },
            registerEventHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
            deregisterEventHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCLineRippleFoundation(adapter);
    };
    return MDCLineRipple;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$6 = {
    NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch',
};
var numbers$2 = {
    // This should stay in sync with $mdc-notched-outline-padding * 2.
    NOTCH_ELEMENT_PADDING: 8,
};
var cssClasses$6 = {
    NO_LABEL: 'mdc-notched-outline--no-label',
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
    OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCNotchedOutlineFoundation = /** @class */ (function (_super) {
    __extends(MDCNotchedOutlineFoundation, _super);
    function MDCNotchedOutlineFoundation(adapter) {
        return _super.call(this, __assign({}, MDCNotchedOutlineFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
        get: function () {
            return strings$6;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
        get: function () {
            return cssClasses$6;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
        get: function () {
            return numbers$2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
        /**
         * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                setNotchWidthProperty: function () { return undefined; },
                removeNotchWidthProperty: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the outline notched selector and updates the notch width calculated based off of notchWidth.
     */
    MDCNotchedOutlineFoundation.prototype.notch = function (notchWidth) {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        if (notchWidth > 0) {
            notchWidth += numbers$2.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
        }
        this.adapter_.setNotchWidthProperty(notchWidth);
        this.adapter_.addClass(OUTLINE_NOTCHED);
    };
    /**
     * Removes notched outline selector to close the notch in the outline.
     */
    MDCNotchedOutlineFoundation.prototype.closeNotch = function () {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.removeClass(OUTLINE_NOTCHED);
        this.adapter_.removeNotchWidthProperty();
    };
    return MDCNotchedOutlineFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCNotchedOutline = /** @class */ (function (_super) {
    __extends(MDCNotchedOutline, _super);
    function MDCNotchedOutline() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCNotchedOutline.attachTo = function (root) {
        return new MDCNotchedOutline(root);
    };
    MDCNotchedOutline.prototype.initialSyncWithDOM = function () {
        this.notchElement_ = this.root_.querySelector(strings$6.NOTCH_ELEMENT_SELECTOR);
        var label = this.root_.querySelector('.' + MDCFloatingLabelFoundation.cssClasses.ROOT);
        if (label) {
            label.style.transitionDuration = '0s';
            this.root_.classList.add(cssClasses$6.OUTLINE_UPGRADED);
            requestAnimationFrame(function () {
                label.style.transitionDuration = '';
            });
        }
        else {
            this.root_.classList.add(cssClasses$6.NO_LABEL);
        }
    };
    /**
     * Updates classes and styles to open the notch to the specified width.
     * @param notchWidth The notch width in the outline.
     */
    MDCNotchedOutline.prototype.notch = function (notchWidth) {
        this.foundation_.notch(notchWidth);
    };
    /**
     * Updates classes and styles to close the notch.
     */
    MDCNotchedOutline.prototype.closeNotch = function () {
        this.foundation_.closeNotch();
    };
    MDCNotchedOutline.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            setNotchWidthProperty: function (width) { return _this.notchElement_.style.setProperty('width', width + 'px'); },
            removeNotchWidthProperty: function () { return _this.notchElement_.style.removeProperty('width'); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCNotchedOutlineFoundation(adapter);
    };
    return MDCNotchedOutline;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$7 = {
    ROOT: 'mdc-text-field-character-counter',
};
var strings$7 = {
    ROOT_SELECTOR: "." + cssClasses$7.ROOT,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldCharacterCounterFoundation = /** @class */ (function (_super) {
    __extends(MDCTextFieldCharacterCounterFoundation, _super);
    function MDCTextFieldCharacterCounterFoundation(adapter) {
        return _super.call(this, __assign({}, MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "cssClasses", {
        get: function () {
            return cssClasses$7;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "strings", {
        get: function () {
            return strings$7;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return types.
         */
        get: function () {
            return {
                setContent: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldCharacterCounterFoundation.prototype.setCounterValue = function (currentLength, maxLength) {
        currentLength = Math.min(currentLength, maxLength);
        this.adapter_.setContent(currentLength + " / " + maxLength);
    };
    return MDCTextFieldCharacterCounterFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldCharacterCounter = /** @class */ (function (_super) {
    __extends(MDCTextFieldCharacterCounter, _super);
    function MDCTextFieldCharacterCounter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldCharacterCounter.attachTo = function (root) {
        return new MDCTextFieldCharacterCounter(root);
    };
    Object.defineProperty(MDCTextFieldCharacterCounter.prototype, "foundation", {
        get: function () {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldCharacterCounter.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            setContent: function (content) {
                _this.root_.textContent = content;
            },
        };
        return new MDCTextFieldCharacterCounterFoundation(adapter);
    };
    return MDCTextFieldCharacterCounter;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$8 = {
    ARIA_CONTROLS: 'aria-controls',
    ICON_SELECTOR: '.mdc-text-field__icon',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
};
var cssClasses$8 = {
    DENSE: 'mdc-text-field--dense',
    DISABLED: 'mdc-text-field--disabled',
    FOCUSED: 'mdc-text-field--focused',
    FULLWIDTH: 'mdc-text-field--fullwidth',
    HELPER_LINE: 'mdc-text-field-helper-line',
    INVALID: 'mdc-text-field--invalid',
    NO_LABEL: 'mdc-text-field--no-label',
    OUTLINED: 'mdc-text-field--outlined',
    ROOT: 'mdc-text-field',
    TEXTAREA: 'mdc-text-field--textarea',
    WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
    WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon',
};
var numbers$3 = {
    DENSE_LABEL_SCALE: 0.923,
    LABEL_SCALE: 0.75,
};
/**
 * Whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
 * under the "Validation-related attributes" section.
 */
var VALIDATION_ATTR_WHITELIST = [
    'pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength',
];
/**
 * Label should always float for these types as they show some UI even if value is empty.
 */
var ALWAYS_FLOAT_TYPES = [
    'color', 'date', 'datetime-local', 'month', 'range', 'time', 'week',
];
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCTextFieldFoundation = /** @class */ (function (_super) {
    __extends(MDCTextFieldFoundation, _super);
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCTextFieldFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) { foundationMap = {}; }
        var _this = _super.call(this, __assign({}, MDCTextFieldFoundation.defaultAdapter, adapter)) || this;
        _this.isFocused_ = false;
        _this.receivedUserInput_ = false;
        _this.isValid_ = true;
        _this.useNativeValidation_ = true;
        _this.helperText_ = foundationMap.helperText;
        _this.characterCounter_ = foundationMap.characterCounter;
        _this.leadingIcon_ = foundationMap.leadingIcon;
        _this.trailingIcon_ = foundationMap.trailingIcon;
        _this.inputFocusHandler_ = function () { return _this.activateFocus(); };
        _this.inputBlurHandler_ = function () { return _this.deactivateFocus(); };
        _this.inputInputHandler_ = function () { return _this.handleInput(); };
        _this.setPointerXOffset_ = function (evt) { return _this.setTransformOrigin(evt); };
        _this.textFieldInteractionHandler_ = function () { return _this.handleTextFieldInteraction(); };
        _this.validationAttributeChangeHandler_ = function (attributesList) { return _this.handleValidationAttributeChange(attributesList); };
        return _this;
    }
    Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
        get: function () {
            return cssClasses$8;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "strings", {
        get: function () {
            return strings$8;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "numbers", {
        get: function () {
            return numbers$3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat_", {
        get: function () {
            var type = this.getNativeInput_().type;
            return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
        get: function () {
            return this.shouldAlwaysFloat_ || this.isFocused_ || Boolean(this.getValue()) || this.isBadInput_();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
        get: function () {
            return !this.isFocused_ && !this.isValid() && Boolean(this.getValue());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return true; },
                registerTextFieldInteractionHandler: function () { return undefined; },
                deregisterTextFieldInteractionHandler: function () { return undefined; },
                registerInputInteractionHandler: function () { return undefined; },
                deregisterInputInteractionHandler: function () { return undefined; },
                registerValidationAttributeChangeHandler: function () { return new MutationObserver(function () { return undefined; }); },
                deregisterValidationAttributeChangeHandler: function () { return undefined; },
                getNativeInput: function () { return null; },
                isFocused: function () { return false; },
                activateLineRipple: function () { return undefined; },
                deactivateLineRipple: function () { return undefined; },
                setLineRippleTransformOrigin: function () { return undefined; },
                shakeLabel: function () { return undefined; },
                floatLabel: function () { return undefined; },
                hasLabel: function () { return false; },
                getLabelWidth: function () { return 0; },
                hasOutline: function () { return false; },
                notchOutline: function () { return undefined; },
                closeOutline: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldFoundation.prototype.init = function () {
        var _this = this;
        if (this.adapter_.isFocused()) {
            this.inputFocusHandler_();
        }
        else if (this.adapter_.hasLabel() && this.shouldFloat) {
            this.notchOutline(true);
            this.adapter_.floatLabel(true);
        }
        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        POINTERDOWN_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
        });
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
        });
        this.validationObserver_ =
            this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
        this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation.prototype.destroy = function () {
        var _this = this;
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        POINTERDOWN_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
        });
        INTERACTION_EVENTS.forEach(function (evtType) {
            _this.adapter_.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
    };
    /**
     * Handles user interactions with the Text Field.
     */
    MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
        var nativeInput = this.adapter_.getNativeInput();
        if (nativeInput && nativeInput.disabled) {
            return;
        }
        this.receivedUserInput_ = true;
    };
    /**
     * Handles validation attribute changes
     */
    MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
        var _this = this;
        attributesList.some(function (attributeName) {
            if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                _this.styleValidity_(true);
                return true;
            }
            return false;
        });
        if (attributesList.indexOf('maxlength') > -1) {
            this.setCharacterCounter_(this.getValue().length);
        }
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter_.hasOutline()) {
            return;
        }
        if (openNotch) {
            var isDense = this.adapter_.hasClass(cssClasses$8.DENSE);
            var labelScale = isDense ? numbers$3.DENSE_LABEL_SCALE : numbers$3.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            this.adapter_.notchOutline(labelWidth);
        }
        else {
            this.adapter_.closeOutline();
        }
    };
    /**
     * Activates the text field focus state.
     */
    MDCTextFieldFoundation.prototype.activateFocus = function () {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
        if (this.helperText_) {
            this.helperText_.showToScreenReader();
        }
    };
    /**
     * Sets the line ripple's transform origin, so that the line ripple activate
     * animation will animate out from the user's click location.
     */
    MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
        var touches = evt.touches;
        var targetEvent = touches ? touches[0] : evt;
        var targetClientRect = targetEvent.target.getBoundingClientRect();
        var normalizedX = targetEvent.clientX - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
    };
    /**
     * Handles input change of text input and text area.
     */
    MDCTextFieldFoundation.prototype.handleInput = function () {
        this.autoCompleteFocus();
        this.setCharacterCounter_(this.getValue().length);
    };
    /**
     * Activates the Text Field's focus state in cases when the input value
     * changes without user input (e.g. programmatically).
     */
    MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
        if (!this.receivedUserInput_) {
            this.activateFocus();
        }
    };
    /**
     * Deactivates the Text Field's focus state.
     */
    MDCTextFieldFoundation.prototype.deactivateFocus = function () {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
        if (!this.shouldFloat) {
            this.receivedUserInput_ = false;
        }
    };
    MDCTextFieldFoundation.prototype.getValue = function () {
        return this.getNativeInput_().value;
    };
    /**
     * @param value The value to set on the input Element.
     */
    MDCTextFieldFoundation.prototype.setValue = function (value) {
        // Prevent Safari from moving the caret to the end of the input when the value has not changed.
        if (this.getValue() !== value) {
            this.getNativeInput_().value = value;
        }
        this.setCharacterCounter_(value.length);
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter_.floatLabel(this.shouldFloat);
            this.adapter_.shakeLabel(this.shouldShake);
        }
    };
    /**
     * @return The custom validity state, if set; otherwise, the result of a native validity check.
     */
    MDCTextFieldFoundation.prototype.isValid = function () {
        return this.useNativeValidation_
            ? this.isNativeInputValid_() : this.isValid_;
    };
    /**
     * @param isValid Sets the custom validity state of the Text Field.
     */
    MDCTextFieldFoundation.prototype.setValid = function (isValid) {
        this.isValid_ = isValid;
        this.styleValidity_(isValid);
        var shouldShake = !isValid && !this.isFocused_;
        if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(shouldShake);
        }
    };
    /**
     * Enables or disables the use of native validation. Use this for custom validation.
     * @param useNativeValidation Set this to false to ignore native input validation.
     */
    MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
        this.useNativeValidation_ = useNativeValidation;
    };
    MDCTextFieldFoundation.prototype.isDisabled = function () {
        return this.getNativeInput_().disabled;
    };
    /**
     * @param disabled Sets the text-field disabled or enabled.
     */
    MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText_) {
            this.helperText_.setContent(content);
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setContent(content);
        }
    };
    /**
     * Sets the aria label of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
        if (this.trailingIcon_) {
            this.trailingIcon_.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
        if (this.trailingIcon_) {
            this.trailingIcon_.setContent(content);
        }
    };
    /**
     * Sets character counter values that shows characters used and the total character limit.
     */
    MDCTextFieldFoundation.prototype.setCharacterCounter_ = function (currentLength) {
        if (!this.characterCounter_) {
            return;
        }
        var maxLength = this.getNativeInput_().maxLength;
        if (maxLength === -1) {
            throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
        }
        this.characterCounter_.setCounterValue(currentLength, maxLength);
    };
    /**
     * @return True if the Text Field input fails in converting the user-supplied value.
     */
    MDCTextFieldFoundation.prototype.isBadInput_ = function () {
        // The badInput property is not supported in IE 11 💩.
        return this.getNativeInput_().validity.badInput || false;
    };
    /**
     * @return The result of native validity checking (ValidityState.valid).
     */
    MDCTextFieldFoundation.prototype.isNativeInputValid_ = function () {
        return this.getNativeInput_().validity.valid;
    };
    /**
     * Styles the component based on the validity state.
     */
    MDCTextFieldFoundation.prototype.styleValidity_ = function (isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
        if (isValid) {
            this.adapter_.removeClass(INVALID);
        }
        else {
            this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
            this.helperText_.setValidity(isValid);
        }
    };
    /**
     * Styles the component based on the focused state.
     */
    MDCTextFieldFoundation.prototype.styleFocused_ = function (isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
        if (isFocused) {
            this.adapter_.addClass(FOCUSED);
        }
        else {
            this.adapter_.removeClass(FOCUSED);
        }
    };
    /**
     * Styles the component based on the disabled state.
     */
    MDCTextFieldFoundation.prototype.styleDisabled_ = function (isDisabled) {
        var _a = MDCTextFieldFoundation.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
        if (isDisabled) {
            this.adapter_.addClass(DISABLED);
            this.adapter_.removeClass(INVALID);
        }
        else {
            this.adapter_.removeClass(DISABLED);
        }
        if (this.leadingIcon_) {
            this.leadingIcon_.setDisabled(isDisabled);
        }
        if (this.trailingIcon_) {
            this.trailingIcon_.setDisabled(isDisabled);
        }
    };
    /**
     * @return The native text input element from the host environment, or an object with the same shape for unit tests.
     */
    MDCTextFieldFoundation.prototype.getNativeInput_ = function () {
        // this.adapter_ may be undefined in foundation unit tests. This happens when testdouble is creating a mock object
        // and invokes the shouldShake/shouldFloat getters (which in turn call getValue(), which calls this method) before
        // init() has been called from the MDCTextField constructor. To work around that issue, we return a dummy object.
        var nativeInput = this.adapter_ ? this.adapter_.getNativeInput() : null;
        return nativeInput || {
            disabled: false,
            maxLength: -1,
            type: 'input',
            validity: {
                badInput: false,
                valid: true,
            },
            value: '',
        };
    };
    return MDCTextFieldFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$9 = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg',
    ROOT: 'mdc-text-field-helper-text',
};
var strings$9 = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role',
    ROOT_SELECTOR: "." + cssClasses$9.ROOT,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldHelperTextFoundation = /** @class */ (function (_super) {
    __extends(MDCTextFieldHelperTextFoundation, _super);
    function MDCTextFieldHelperTextFoundation(adapter) {
        return _super.call(this, __assign({}, MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "cssClasses", {
        get: function () {
            return cssClasses$9;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "strings", {
        get: function () {
            return strings$9;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldHelperTextFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldHelperTextAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                setAttr: function () { return undefined; },
                removeAttr: function () { return undefined; },
                setContent: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the content of the helper text field.
     */
    MDCTextFieldHelperTextFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    /**
     * @param isPersistent Sets the persistency of the helper text.
     */
    MDCTextFieldHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
        if (isPersistent) {
            this.adapter_.addClass(cssClasses$9.HELPER_TEXT_PERSISTENT);
        }
        else {
            this.adapter_.removeClass(cssClasses$9.HELPER_TEXT_PERSISTENT);
        }
    };
    /**
     * @param isValidation True to make the helper text act as an error validation message.
     */
    MDCTextFieldHelperTextFoundation.prototype.setValidation = function (isValidation) {
        if (isValidation) {
            this.adapter_.addClass(cssClasses$9.HELPER_TEXT_VALIDATION_MSG);
        }
        else {
            this.adapter_.removeClass(cssClasses$9.HELPER_TEXT_VALIDATION_MSG);
        }
    };
    /**
     * Makes the helper text visible to the screen reader.
     */
    MDCTextFieldHelperTextFoundation.prototype.showToScreenReader = function () {
        this.adapter_.removeAttr(strings$9.ARIA_HIDDEN);
    };
    /**
     * Sets the validity of the helper text based on the input validity.
     */
    MDCTextFieldHelperTextFoundation.prototype.setValidity = function (inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$9.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$9.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
        if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings$9.ROLE, 'alert');
        }
        else {
            this.adapter_.removeAttr(strings$9.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
        }
    };
    /**
     * Hides the help text from screen readers.
     */
    MDCTextFieldHelperTextFoundation.prototype.hide_ = function () {
        this.adapter_.setAttr(strings$9.ARIA_HIDDEN, 'true');
    };
    return MDCTextFieldHelperTextFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldHelperText = /** @class */ (function (_super) {
    __extends(MDCTextFieldHelperText, _super);
    function MDCTextFieldHelperText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldHelperText.attachTo = function (root) {
        return new MDCTextFieldHelperText(root);
    };
    Object.defineProperty(MDCTextFieldHelperText.prototype, "foundation", {
        get: function () {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldHelperText.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
            removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
            setContent: function (content) {
                _this.root_.textContent = content;
            },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCTextFieldHelperTextFoundation(adapter);
    };
    return MDCTextFieldHelperText;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$a = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button',
};
var cssClasses$a = {
    ROOT: 'mdc-text-field__icon',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var INTERACTION_EVENTS$1 = ['click', 'keydown'];
var MDCTextFieldIconFoundation = /** @class */ (function (_super) {
    __extends(MDCTextFieldIconFoundation, _super);
    function MDCTextFieldIconFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCTextFieldIconFoundation.defaultAdapter, adapter)) || this;
        _this.savedTabIndex_ = null;
        _this.interactionHandler_ = function (evt) { return _this.handleInteraction(evt); };
        return _this;
    }
    Object.defineProperty(MDCTextFieldIconFoundation, "strings", {
        get: function () {
            return strings$a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldIconFoundation, "cssClasses", {
        get: function () {
            return cssClasses$a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldIconFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldIconAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getAttr: function () { return null; },
                setAttr: function () { return undefined; },
                removeAttr: function () { return undefined; },
                setContent: function () { return undefined; },
                registerInteractionHandler: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
                notifyIconAction: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldIconFoundation.prototype.init = function () {
        var _this = this;
        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        INTERACTION_EVENTS$1.forEach(function (evtType) {
            _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCTextFieldIconFoundation.prototype.destroy = function () {
        var _this = this;
        INTERACTION_EVENTS$1.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCTextFieldIconFoundation.prototype.setDisabled = function (disabled) {
        if (!this.savedTabIndex_) {
            return;
        }
        if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
        }
        else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$a.ICON_ROLE);
        }
    };
    MDCTextFieldIconFoundation.prototype.setAriaLabel = function (label) {
        this.adapter_.setAttr('aria-label', label);
    };
    MDCTextFieldIconFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    MDCTextFieldIconFoundation.prototype.handleInteraction = function (evt) {
        var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
        if (evt.type === 'click' || isEnterKey) {
            this.adapter_.notifyIconAction();
        }
    };
    return MDCTextFieldIconFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextFieldIcon = /** @class */ (function (_super) {
    __extends(MDCTextFieldIcon, _super);
    function MDCTextFieldIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextFieldIcon.attachTo = function (root) {
        return new MDCTextFieldIcon(root);
    };
    Object.defineProperty(MDCTextFieldIcon.prototype, "foundation", {
        get: function () {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCTextFieldIcon.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            getAttr: function (attr) { return _this.root_.getAttribute(attr); },
            setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
            removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
            setContent: function (content) {
                _this.root_.textContent = content;
            },
            registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
            deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
            notifyIconAction: function () { return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCTextFieldIconFoundation(adapter);
    };
    return MDCTextFieldIcon;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTextField = /** @class */ (function (_super) {
    __extends(MDCTextField, _super);
    function MDCTextField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTextField.attachTo = function (root) {
        return new MDCTextField(root);
    };
    MDCTextField.prototype.initialize = function (rippleFactory, lineRippleFactory, helperTextFactory, characterCounterFactory, iconFactory, labelFactory, outlineFactory) {
        if (rippleFactory === void 0) { rippleFactory = function (el, foundation) { return new MDCRipple(el, foundation); }; }
        if (lineRippleFactory === void 0) { lineRippleFactory = function (el) { return new MDCLineRipple(el); }; }
        if (helperTextFactory === void 0) { helperTextFactory = function (el) { return new MDCTextFieldHelperText(el); }; }
        if (characterCounterFactory === void 0) { characterCounterFactory = function (el) { return new MDCTextFieldCharacterCounter(el); }; }
        if (iconFactory === void 0) { iconFactory = function (el) { return new MDCTextFieldIcon(el); }; }
        if (labelFactory === void 0) { labelFactory = function (el) { return new MDCFloatingLabel(el); }; }
        if (outlineFactory === void 0) { outlineFactory = function (el) { return new MDCNotchedOutline(el); }; }
        this.input_ = this.root_.querySelector(strings$8.INPUT_SELECTOR);
        var labelElement = this.root_.querySelector(strings$8.LABEL_SELECTOR);
        this.label_ = labelElement ? labelFactory(labelElement) : null;
        var lineRippleElement = this.root_.querySelector(strings$8.LINE_RIPPLE_SELECTOR);
        this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
        var outlineElement = this.root_.querySelector(strings$8.OUTLINE_SELECTOR);
        this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
        // Helper text
        var helperTextStrings = MDCTextFieldHelperTextFoundation.strings;
        var nextElementSibling = this.root_.nextElementSibling;
        var hasHelperLine = (nextElementSibling && nextElementSibling.classList.contains(cssClasses$8.HELPER_LINE));
        var helperTextEl = hasHelperLine && nextElementSibling && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);
        this.helperText_ = helperTextEl ? helperTextFactory(helperTextEl) : null;
        // Character counter
        var characterCounterStrings = MDCTextFieldCharacterCounterFoundation.strings;
        var characterCounterEl = this.root_.querySelector(characterCounterStrings.ROOT_SELECTOR);
        // If character counter is not found in root element search in sibling element.
        if (!characterCounterEl && hasHelperLine && nextElementSibling) {
            characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
        }
        this.characterCounter_ = characterCounterEl ? characterCounterFactory(characterCounterEl) : null;
        this.leadingIcon_ = null;
        this.trailingIcon_ = null;
        var iconElements = this.root_.querySelectorAll(strings$8.ICON_SELECTOR);
        if (iconElements.length > 0) {
            if (iconElements.length > 1) { // Has both icons.
                this.leadingIcon_ = iconFactory(iconElements[0]);
                this.trailingIcon_ = iconFactory(iconElements[1]);
            }
            else {
                if (this.root_.classList.contains(cssClasses$8.WITH_LEADING_ICON)) {
                    this.leadingIcon_ = iconFactory(iconElements[0]);
                }
                else {
                    this.trailingIcon_ = iconFactory(iconElements[0]);
                }
            }
        }
        this.ripple = this.createRipple_(rippleFactory);
    };
    MDCTextField.prototype.destroy = function () {
        if (this.ripple) {
            this.ripple.destroy();
        }
        if (this.lineRipple_) {
            this.lineRipple_.destroy();
        }
        if (this.helperText_) {
            this.helperText_.destroy();
        }
        if (this.characterCounter_) {
            this.characterCounter_.destroy();
        }
        if (this.leadingIcon_) {
            this.leadingIcon_.destroy();
        }
        if (this.trailingIcon_) {
            this.trailingIcon_.destroy();
        }
        if (this.label_) {
            this.label_.destroy();
        }
        if (this.outline_) {
            this.outline_.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    /**
     * Initializes the Text Field's internal state based on the environment's
     * state.
     */
    MDCTextField.prototype.initialSyncWithDOM = function () {
        this.disabled = this.input_.disabled;
    };
    Object.defineProperty(MDCTextField.prototype, "value", {
        get: function () {
            return this.foundation_.getValue();
        },
        /**
         * @param value The value to set on the input.
         */
        set: function (value) {
            this.foundation_.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "disabled", {
        get: function () {
            return this.foundation_.isDisabled();
        },
        /**
         * @param disabled Sets the Text Field disabled or enabled.
         */
        set: function (disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "valid", {
        get: function () {
            return this.foundation_.isValid();
        },
        /**
         * @param valid Sets the Text Field valid or invalid.
         */
        set: function (valid) {
            this.foundation_.setValid(valid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "required", {
        get: function () {
            return this.input_.required;
        },
        /**
         * @param required Sets the Text Field to required.
         */
        set: function (required) {
            this.input_.required = required;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "pattern", {
        get: function () {
            return this.input_.pattern;
        },
        /**
         * @param pattern Sets the input element's validation pattern.
         */
        set: function (pattern) {
            this.input_.pattern = pattern;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "minLength", {
        get: function () {
            return this.input_.minLength;
        },
        /**
         * @param minLength Sets the input element's minLength.
         */
        set: function (minLength) {
            this.input_.minLength = minLength;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "maxLength", {
        get: function () {
            return this.input_.maxLength;
        },
        /**
         * @param maxLength Sets the input element's maxLength.
         */
        set: function (maxLength) {
            // Chrome throws exception if maxLength is set to a value less than zero
            if (maxLength < 0) {
                this.input_.removeAttribute('maxLength');
            }
            else {
                this.input_.maxLength = maxLength;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "min", {
        get: function () {
            return this.input_.min;
        },
        /**
         * @param min Sets the input element's min.
         */
        set: function (min) {
            this.input_.min = min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "max", {
        get: function () {
            return this.input_.max;
        },
        /**
         * @param max Sets the input element's max.
         */
        set: function (max) {
            this.input_.max = max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "step", {
        get: function () {
            return this.input_.step;
        },
        /**
         * @param step Sets the input element's step.
         */
        set: function (step) {
            this.input_.step = step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "helperTextContent", {
        /**
         * Sets the helper text element content.
         */
        set: function (content) {
            this.foundation_.setHelperTextContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "leadingIconAriaLabel", {
        /**
         * Sets the aria label of the leading icon.
         */
        set: function (label) {
            this.foundation_.setLeadingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "leadingIconContent", {
        /**
         * Sets the text content of the leading icon.
         */
        set: function (content) {
            this.foundation_.setLeadingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "trailingIconAriaLabel", {
        /**
         * Sets the aria label of the trailing icon.
         */
        set: function (label) {
            this.foundation_.setTrailingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "trailingIconContent", {
        /**
         * Sets the text content of the trailing icon.
         */
        set: function (content) {
            this.foundation_.setTrailingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCTextField.prototype, "useNativeValidation", {
        /**
         * Enables or disables the use of native validation. Use this for custom validation.
         * @param useNativeValidation Set this to false to ignore native input validation.
         */
        set: function (useNativeValidation) {
            this.foundation_.setUseNativeValidation(useNativeValidation);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the input element.
     */
    MDCTextField.prototype.focus = function () {
        this.input_.focus();
    };
    /**
     * Recomputes the outline SVG path for the outline element.
     */
    MDCTextField.prototype.layout = function () {
        var openNotch = this.foundation_.shouldFloat;
        this.foundation_.notchOutline(openNotch);
    };
    MDCTextField.prototype.getDefaultFoundation = function () {
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign({}, this.getRootAdapterMethods_(), this.getInputAdapterMethods_(), this.getLabelAdapterMethods_(), this.getLineRippleAdapterMethods_(), this.getOutlineAdapterMethods_());
        // tslint:enable:object-literal-sort-keys
        return new MDCTextFieldFoundation(adapter, this.getFoundationMap_());
    };
    MDCTextField.prototype.getRootAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            registerTextFieldInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
            deregisterTextFieldInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
            registerValidationAttributeChangeHandler: function (handler) {
                var getAttributesList = function (mutationsList) {
                    return mutationsList
                        .map(function (mutation) { return mutation.attributeName; })
                        .filter(function (attributeName) { return attributeName; });
                };
                var observer = new MutationObserver(function (mutationsList) { return handler(getAttributesList(mutationsList)); });
                var config = { attributes: true };
                observer.observe(_this.input_, config);
                return observer;
            },
            deregisterValidationAttributeChangeHandler: function (observer) { return observer.disconnect(); },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCTextField.prototype.getInputAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            getNativeInput: function () { return _this.input_; },
            isFocused: function () { return document.activeElement === _this.input_; },
            registerInputInteractionHandler: function (evtType, handler) {
                return _this.input_.addEventListener(evtType, handler, applyPassive());
            },
            deregisterInputInteractionHandler: function (evtType, handler) {
                return _this.input_.removeEventListener(evtType, handler, applyPassive());
            },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCTextField.prototype.getLabelAdapterMethods_ = function () {
        var _this = this;
        return {
            floatLabel: function (shouldFloat) { return _this.label_ && _this.label_.float(shouldFloat); },
            getLabelWidth: function () { return _this.label_ ? _this.label_.getWidth() : 0; },
            hasLabel: function () { return Boolean(_this.label_); },
            shakeLabel: function (shouldShake) { return _this.label_ && _this.label_.shake(shouldShake); },
        };
    };
    MDCTextField.prototype.getLineRippleAdapterMethods_ = function () {
        var _this = this;
        return {
            activateLineRipple: function () {
                if (_this.lineRipple_) {
                    _this.lineRipple_.activate();
                }
            },
            deactivateLineRipple: function () {
                if (_this.lineRipple_) {
                    _this.lineRipple_.deactivate();
                }
            },
            setLineRippleTransformOrigin: function (normalizedX) {
                if (_this.lineRipple_) {
                    _this.lineRipple_.setRippleCenter(normalizedX);
                }
            },
        };
    };
    MDCTextField.prototype.getOutlineAdapterMethods_ = function () {
        var _this = this;
        return {
            closeOutline: function () { return _this.outline_ && _this.outline_.closeNotch(); },
            hasOutline: function () { return Boolean(_this.outline_); },
            notchOutline: function (labelWidth) { return _this.outline_ && _this.outline_.notch(labelWidth); },
        };
    };
    /**
     * @return A map of all subcomponents to subfoundations.
     */
    MDCTextField.prototype.getFoundationMap_ = function () {
        return {
            characterCounter: this.characterCounter_ ? this.characterCounter_.foundation : undefined,
            helperText: this.helperText_ ? this.helperText_.foundation : undefined,
            leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
            trailingIcon: this.trailingIcon_ ? this.trailingIcon_.foundation : undefined,
        };
    };
    MDCTextField.prototype.createRipple_ = function (rippleFactory) {
        var _this = this;
        var isTextArea = this.root_.classList.contains(cssClasses$8.TEXTAREA);
        var isOutlined = this.root_.classList.contains(cssClasses$8.OUTLINED);
        if (isTextArea || isOutlined) {
            return null;
        }
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign({}, MDCRipple.createAdapter(this), { isSurfaceActive: function () { return matches(_this.input_, ':active'); }, registerInteractionHandler: function (evtType, handler) { return _this.input_.addEventListener(evtType, handler, applyPassive()); }, deregisterInteractionHandler: function (evtType, handler) {
                return _this.input_.removeEventListener(evtType, handler, applyPassive());
            } });
        // tslint:enable:object-literal-sort-keys
        return rippleFactory(this.root_, new MDCRippleFoundation(adapter));
    };
    return MDCTextField;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\floating-label\FloatingLabel.svelte generated by Svelte v3.31.2 */
const file$g = "node_modules\\@smui\\floating-label\\FloatingLabel.svelte";

// (9:0) {:else}
function create_else_block(ctx) {
	let label;
	let label_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let label_levels = [
		{
			class: label_class_value = "mdc-floating-label " + /*className*/ ctx[1]
		},
		/*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
		? {
				"for": /*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
			}
		: {},
		exclude(/*$$props*/ ctx[7], ["use", "class", "for", "wrapped"])
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			set_attributes(label, label_data);
			add_location(label, file$g, 9, 2, 225);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			/*label_binding*/ ctx[14](label);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*className*/ 2 && label_class_value !== (label_class_value = "mdc-floating-label " + /*className*/ ctx[1])) && { class: label_class_value },
				dirty & /*forId*/ 4 && (/*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
				? {
						"for": /*forId*/ ctx[2] || /*inputProps*/ ctx[6] && /*inputProps*/ ctx[6].id
					}
				: {}),
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ["use", "class", "for", "wrapped"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			/*label_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(9:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if wrapped}
function create_if_block$4(ctx) {
	let span;
	let span_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let span_levels = [
		{
			class: span_class_value = "mdc-floating-label " + /*className*/ ctx[1]
		},
		exclude(/*$$props*/ ctx[7], ["use", "class", "wrapped"])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$g, 1, 2, 16);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[13](span);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = "mdc-floating-label " + /*className*/ ctx[1])) && { class: span_class_value },
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ["use", "class", "wrapped"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(1:0) {#if wrapped}",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrapped*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FloatingLabel", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { for: forId = "" } = $$props;
	let { wrapped = false } = $$props;
	let element;
	let floatingLabel;
	let inputProps = getContext("SMUI:generic:input:props") || {};

	onMount(() => {
		floatingLabel = new MDCFloatingLabel(element);
	});

	onDestroy(() => {
		floatingLabel && floatingLabel.destroy();
	});

	function shake(shouldShake, ...args) {
		return floatingLabel.shake(shouldShake, ...args);
	}

	function float(shouldFloat, ...args) {
		return floatingLabel.float(shouldFloat, ...args);
	}

	function getWidth(...args) {
		return floatingLabel.getWidth(...args);
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("for" in $$new_props) $$invalidate(2, forId = $$new_props.for);
		if ("wrapped" in $$new_props) $$invalidate(3, wrapped = $$new_props.wrapped);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCFloatingLabel,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		forId,
		wrapped,
		element,
		floatingLabel,
		inputProps,
		shake,
		float,
		getWidth
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("forId" in $$props) $$invalidate(2, forId = $$new_props.forId);
		if ("wrapped" in $$props) $$invalidate(3, wrapped = $$new_props.wrapped);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("floatingLabel" in $$props) floatingLabel = $$new_props.floatingLabel;
		if ("inputProps" in $$props) $$invalidate(6, inputProps = $$new_props.inputProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		forId,
		wrapped,
		element,
		forwardEvents,
		inputProps,
		$$props,
		shake,
		float,
		getWidth,
		$$scope,
		slots,
		span_binding,
		label_binding
	];
}

class FloatingLabel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			use: 0,
			class: 1,
			for: 2,
			wrapped: 3,
			shake: 8,
			float: 9,
			getWidth: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FloatingLabel",
			options,
			id: create_fragment$g.name
		});
	}

	get use() {
		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get for() {
		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set for(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrapped() {
		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrapped(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shake() {
		return this.$$.ctx[8];
	}

	set shake(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get float() {
		return this.$$.ctx[9];
	}

	set float(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getWidth() {
		return this.$$.ctx[10];
	}

	set getWidth(value) {
		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\line-ripple\LineRipple.svelte generated by Svelte v3.31.2 */
const file$h = "node_modules\\@smui\\line-ripple\\LineRipple.svelte";

function create_fragment$h(ctx) {
	let div;
	let div_class_value;
	let useActions_action;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let div_levels = [
		{
			class: div_class_value = "\n    mdc-line-ripple\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-line-ripple--active" : "") + "\n  "
		},
		exclude(/*$$props*/ ctx[5], ["use", "class", "active"])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			set_attributes(div, div_data);
			add_location(div, file$h, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[9](div);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[4].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*className, active*/ 6 && div_class_value !== (div_class_value = "\n    mdc-line-ripple\n    " + /*className*/ ctx[1] + "\n    " + (/*active*/ ctx[2] ? "mdc-line-ripple--active" : "") + "\n  ") && { class: div_class_value },
				dirty & /*$$props*/ 32 && exclude(/*$$props*/ ctx[5], ["use", "class", "active"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[9](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("LineRipple", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { active = false } = $$props;
	let element;
	let lineRipple;

	onMount(() => {
		lineRipple = new MDCLineRipple(element);
	});

	onDestroy(() => {
		lineRipple && lineRipple.destroy();
	});

	function activate(...args) {
		return lineRipple.activate(...args);
	}

	function deactivate(...args) {
		return lineRipple.deactivate(...args);
	}

	function setRippleCenter(xCoordinate, ...args) {
		return lineRipple.setRippleCenter(xCoordinate, ...args);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("active" in $$new_props) $$invalidate(2, active = $$new_props.active);
	};

	$$self.$capture_state = () => ({
		MDCLineRipple,
		onMount,
		onDestroy,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		active,
		element,
		lineRipple,
		activate,
		deactivate,
		setRippleCenter
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("active" in $$props) $$invalidate(2, active = $$new_props.active);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("lineRipple" in $$props) lineRipple = $$new_props.lineRipple;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		active,
		element,
		forwardEvents,
		$$props,
		activate,
		deactivate,
		setRippleCenter,
		div_binding
	];
}

class LineRipple extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			use: 0,
			class: 1,
			active: 2,
			activate: 6,
			deactivate: 7,
			setRippleCenter: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LineRipple",
			options,
			id: create_fragment$h.name
		});
	}

	get use() {
		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activate() {
		return this.$$.ctx[6];
	}

	set activate(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get deactivate() {
		return this.$$.ctx[7];
	}

	set deactivate(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setRippleCenter() {
		return this.$$.ctx[8];
	}

	set setRippleCenter(value) {
		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\notched-outline\NotchedOutline.svelte generated by Svelte v3.31.2 */
const file$i = "node_modules\\@smui\\notched-outline\\NotchedOutline.svelte";

// (14:2) {#if !noLabel}
function create_if_block$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "mdc-notched-outline__notch");
			add_location(div, file$i, 14, 4, 367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(14:2) {#if !noLabel}",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let div2_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	let if_block = !/*noLabel*/ ctx[3] && create_if_block$5(ctx);

	let div2_levels = [
		{
			class: div2_class_value = "\n    mdc-notched-outline\n    " + /*className*/ ctx[1] + "\n    " + (/*notched*/ ctx[2] ? "mdc-notched-outline--notched" : "") + "\n    " + (/*noLabel*/ ctx[3]
			? "mdc-notched-outline--no-label"
			: "") + "\n  "
		},
		exclude(/*$$props*/ ctx[6], ["use", "class", "notched", "noLabel"])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div1 = element("div");
			attr_dev(div0, "class", "mdc-notched-outline__leading");
			add_location(div0, file$i, 12, 2, 297);
			attr_dev(div1, "class", "mdc-notched-outline__trailing");
			add_location(div1, file$i, 16, 2, 437);
			set_attributes(div2, div2_data);
			add_location(div2, file$i, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);
			if (if_block) if_block.m(div2, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			/*div2_binding*/ ctx[11](div2);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div2, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div2))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!/*noLabel*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*noLabel*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div2, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*className, notched, noLabel*/ 14 && div2_class_value !== (div2_class_value = "\n    mdc-notched-outline\n    " + /*className*/ ctx[1] + "\n    " + (/*notched*/ ctx[2] ? "mdc-notched-outline--notched" : "") + "\n    " + (/*noLabel*/ ctx[3]
				? "mdc-notched-outline--no-label"
				: "") + "\n  ")) && { class: div2_class_value },
				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ["use", "class", "notched", "noLabel"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			/*div2_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NotchedOutline", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { notched = false } = $$props;
	let { noLabel = false } = $$props;
	let element;
	let notchedOutline;

	onMount(() => {
		notchedOutline = new MDCNotchedOutline(element);
	});

	onDestroy(() => {
		notchedOutline && notchedOutline.destroy();
	});

	function notch(notchWidth, ...args) {
		return notchedOutline.notch(notchWidth, ...args);
	}

	function closeNotch(...args) {
		return notchedOutline.closeNotch(...args);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("notched" in $$new_props) $$invalidate(2, notched = $$new_props.notched);
		if ("noLabel" in $$new_props) $$invalidate(3, noLabel = $$new_props.noLabel);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCNotchedOutline,
		onMount,
		onDestroy,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		notched,
		noLabel,
		element,
		notchedOutline,
		notch,
		closeNotch
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("notched" in $$props) $$invalidate(2, notched = $$new_props.notched);
		if ("noLabel" in $$props) $$invalidate(3, noLabel = $$new_props.noLabel);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("notchedOutline" in $$props) notchedOutline = $$new_props.notchedOutline;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		notched,
		noLabel,
		element,
		forwardEvents,
		$$props,
		notch,
		closeNotch,
		$$scope,
		slots,
		div2_binding
	];
}

class NotchedOutline extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			use: 0,
			class: 1,
			notched: 2,
			noLabel: 3,
			notch: 7,
			closeNotch: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NotchedOutline",
			options,
			id: create_fragment$i.name
		});
	}

	get use() {
		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notched() {
		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set notched(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noLabel() {
		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noLabel(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notch() {
		return this.$$.ctx[7];
	}

	set notch(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeNotch() {
		return this.$$.ctx[8];
	}

	set closeNotch(value) {
		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\textfield\Input.svelte generated by Svelte v3.31.2 */
const file$j = "node_modules\\@smui\\textfield\\Input.svelte";

function create_fragment$j(ctx) {
	let input;
	let input_class_value;
	let useActions_action;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let input_levels = [
		{
			class: input_class_value = "mdc-text-field__input " + /*className*/ ctx[1]
		},
		{ type: /*type*/ ctx[2] },
		/*valueProp*/ ctx[3],
		exclude(/*$$props*/ ctx[8], [
			"use",
			"class",
			"type",
			"value",
			"files",
			"dirty",
			"invalid",
			"updateInvalid"
		])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$j, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			/*input_binding*/ ctx[14](input);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, input, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, input)),
					listen_dev(input, "change", /*change_handler*/ ctx[15], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[16], false, false, false),
					listen_dev(input, "change", /*changeHandler*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty & /*className*/ 2 && input_class_value !== (input_class_value = "mdc-text-field__input " + /*className*/ ctx[1]) && { class: input_class_value },
				dirty & /*type*/ 4 && { type: /*type*/ ctx[2] },
				dirty & /*valueProp*/ 8 && /*valueProp*/ ctx[3],
				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], [
					"use",
					"class",
					"type",
					"value",
					"files",
					"dirty",
					"invalid",
					"updateInvalid"
				])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function toNumber(value) {
	if (value === "") {
		const nan = new Number(Number.NaN);
		nan.length = 0;
		return nan;
	}

	return +value;
}

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Input", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["change", "input"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { type = "text" } = $$props;
	let { value = "" } = $$props;
	let { files = undefined } = $$props;
	let { dirty = false } = $$props;
	let { invalid = false } = $$props;
	let { updateInvalid = true } = $$props;
	let element;
	let valueProp = {};

	onMount(() => {
		if (updateInvalid) {
			$$invalidate(12, invalid = element.matches(":invalid"));
		}
	});

	function valueUpdater(e) {
		switch (type) {
			case "number":
			case "range":
				$$invalidate(9, value = toNumber(e.target.value));
				break;
			case "file":
				$$invalidate(10, files = e.target.files);
			default:
				$$invalidate(9, value = e.target.value);
				break;
		}
	}

	function changeHandler(e) {
		$$invalidate(11, dirty = true);

		if (updateInvalid) {
			$$invalidate(12, invalid = element.matches(":invalid"));
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	const change_handler = e => (type === "file" || type === "range") && valueUpdater(e);
	const input_handler = e => type !== "file" && valueUpdater(e);

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ("value" in $$new_props) $$invalidate(9, value = $$new_props.value);
		if ("files" in $$new_props) $$invalidate(10, files = $$new_props.files);
		if ("dirty" in $$new_props) $$invalidate(11, dirty = $$new_props.dirty);
		if ("invalid" in $$new_props) $$invalidate(12, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$new_props) $$invalidate(13, updateInvalid = $$new_props.updateInvalid);
	};

	$$self.$capture_state = () => ({
		onMount,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		type,
		value,
		files,
		dirty,
		invalid,
		updateInvalid,
		element,
		valueProp,
		toNumber,
		valueUpdater,
		changeHandler
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
		if ("value" in $$props) $$invalidate(9, value = $$new_props.value);
		if ("files" in $$props) $$invalidate(10, files = $$new_props.files);
		if ("dirty" in $$props) $$invalidate(11, dirty = $$new_props.dirty);
		if ("invalid" in $$props) $$invalidate(12, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$props) $$invalidate(13, updateInvalid = $$new_props.updateInvalid);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("valueProp" in $$props) $$invalidate(3, valueProp = $$new_props.valueProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type, valueProp, value*/ 524) {
			 if (type === "file") {
				delete valueProp.value;
			} else {
				$$invalidate(3, valueProp.value = value === undefined ? "" : value, valueProp);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		type,
		valueProp,
		element,
		forwardEvents,
		valueUpdater,
		changeHandler,
		$$props,
		value,
		files,
		dirty,
		invalid,
		updateInvalid,
		input_binding,
		change_handler,
		input_handler
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			use: 0,
			class: 1,
			type: 2,
			value: 9,
			files: 10,
			dirty: 11,
			invalid: 12,
			updateInvalid: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$j.name
		});
	}

	get use() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get files() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set files(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dirty() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dirty(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateInvalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateInvalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\textfield\Textarea.svelte generated by Svelte v3.31.2 */
const file$k = "node_modules\\@smui\\textfield\\Textarea.svelte";

function create_fragment$k(ctx) {
	let textarea;
	let textarea_class_value;
	let useActions_action;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let textarea_levels = [
		{
			class: textarea_class_value = "mdc-text-field__input " + /*className*/ ctx[2]
		},
		exclude(/*$$props*/ ctx[6], ["use", "class", "value", "dirty", "invalid", "updateInvalid"])
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			set_attributes(textarea, textarea_data);
			add_location(textarea, file$k, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding*/ ctx[10](textarea);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, textarea, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[4].call(null, textarea)),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[11]),
					listen_dev(textarea, "change", /*changeHandler*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty & /*className*/ 4 && textarea_class_value !== (textarea_class_value = "mdc-text-field__input " + /*className*/ ctx[2]) && { class: textarea_class_value },
				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ["use", "class", "value", "dirty", "invalid", "updateInvalid"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (dirty & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding*/ ctx[10](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Textarea", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["change", "input"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { value = "" } = $$props;
	let { dirty = false } = $$props;
	let { invalid = false } = $$props;
	let { updateInvalid = true } = $$props;
	let element;

	onMount(() => {
		if (updateInvalid) {
			$$invalidate(8, invalid = element.matches(":invalid"));
		}
	});

	function changeHandler() {
		$$invalidate(7, dirty = true);

		if (updateInvalid) {
			$$invalidate(8, invalid = element.matches(":invalid"));
		}
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("dirty" in $$new_props) $$invalidate(7, dirty = $$new_props.dirty);
		if ("invalid" in $$new_props) $$invalidate(8, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$new_props) $$invalidate(9, updateInvalid = $$new_props.updateInvalid);
	};

	$$self.$capture_state = () => ({
		onMount,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		value,
		dirty,
		invalid,
		updateInvalid,
		element,
		changeHandler
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("dirty" in $$props) $$invalidate(7, dirty = $$new_props.dirty);
		if ("invalid" in $$props) $$invalidate(8, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$props) $$invalidate(9, updateInvalid = $$new_props.updateInvalid);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		value,
		use,
		className,
		element,
		forwardEvents,
		changeHandler,
		$$props,
		dirty,
		invalid,
		updateInvalid,
		textarea_binding,
		textarea_input_handler
	];
}

class Textarea extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			use: 1,
			class: 2,
			value: 0,
			dirty: 7,
			invalid: 8,
			updateInvalid: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Textarea",
			options,
			id: create_fragment$k.name
		});
	}

	get use() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dirty() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dirty(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateInvalid() {
		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateInvalid(value) {
		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\textfield\Textfield.svelte generated by Svelte v3.31.2 */
const file$l = "node_modules\\@smui\\textfield\\Textfield.svelte";
const get_label_slot_changes_1 = dirty => ({});
const get_label_slot_context_1 = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});

// (69:0) {:else}
function create_else_block_1(ctx) {
	let div;
	let div_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);

	let div_levels = [
		{
			class: div_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? "mdc-text-field--disabled" : "") + "\n      " + (/*fullwidth*/ ctx[8] ? "mdc-text-field--fullwidth" : "") + "\n      " + (/*textarea*/ ctx[9] ? "mdc-text-field--textarea" : "") + "\n      " + (/*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]
			? "mdc-text-field--outlined"
			: "") + "\n      " + (/*variant*/ ctx[10] === "standard" && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
			? "smui-text-field--standard"
			: "") + "\n      " + (/*dense*/ ctx[11] ? "mdc-text-field--dense" : "") + "\n      " + (/*noLabel*/ ctx[14] ? "mdc-text-field--no-label" : "") + "\n      " + (/*withLeadingIcon*/ ctx[12]
			? "mdc-text-field--with-leading-icon"
			: "") + "\n      " + (/*withTrailingIcon*/ ctx[13]
			? "mdc-text-field--with-trailing-icon"
			: "") + "\n      " + (/*invalid*/ ctx[2] ? "mdc-text-field--invalid" : "") + "\n    "
		},
		/*props*/ ctx[19]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$l, 69, 2, 2148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[44](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[4])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[21].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[45], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*className, disabled, fullwidth, textarea, variant, dense, noLabel, withLeadingIcon, withTrailingIcon, invalid*/ 32676 && div_class_value !== (div_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? "mdc-text-field--disabled" : "") + "\n      " + (/*fullwidth*/ ctx[8] ? "mdc-text-field--fullwidth" : "") + "\n      " + (/*textarea*/ ctx[9] ? "mdc-text-field--textarea" : "") + "\n      " + (/*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]
				? "mdc-text-field--outlined"
				: "") + "\n      " + (/*variant*/ ctx[10] === "standard" && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
				? "smui-text-field--standard"
				: "") + "\n      " + (/*dense*/ ctx[11] ? "mdc-text-field--dense" : "") + "\n      " + (/*noLabel*/ ctx[14] ? "mdc-text-field--no-label" : "") + "\n      " + (/*withLeadingIcon*/ ctx[12]
				? "mdc-text-field--with-leading-icon"
				: "") + "\n      " + (/*withTrailingIcon*/ ctx[13]
				? "mdc-text-field--with-trailing-icon"
				: "") + "\n      " + (/*invalid*/ ctx[2] ? "mdc-text-field--invalid" : "") + "\n    ")) && { class: div_class_value },
				dirty[0] & /*props*/ 524288 && /*props*/ ctx[19]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 16) useActions_action.update.call(null, /*use*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[44](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(69:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if valued}
function create_if_block$6(ctx) {
	let label_1;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let t2;
	let label_1_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);
	const if_block_creators = [create_if_block_6, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*textarea*/ ctx[9]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = !/*textarea*/ ctx[9] && /*variant*/ ctx[10] !== "outlined" && create_if_block_3(ctx);
	let if_block2 = (/*textarea*/ ctx[9] || /*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]) && create_if_block_1$1(ctx);

	let label_1_levels = [
		{
			class: label_1_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? "mdc-text-field--disabled" : "") + "\n      " + (/*fullwidth*/ ctx[8] ? "mdc-text-field--fullwidth" : "") + "\n      " + (/*textarea*/ ctx[9] ? "mdc-text-field--textarea" : "") + "\n      " + (/*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]
			? "mdc-text-field--outlined"
			: "") + "\n      " + (/*variant*/ ctx[10] === "standard" && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
			? "smui-text-field--standard"
			: "") + "\n      " + (/*dense*/ ctx[11] ? "mdc-text-field--dense" : "") + "\n      " + (/*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
			? "mdc-text-field--no-label"
			: "") + "\n      " + (/*withLeadingIcon*/ ctx[12]
			? "mdc-text-field--with-leading-icon"
			: "") + "\n      " + (/*withTrailingIcon*/ ctx[13]
			? "mdc-text-field--with-trailing-icon"
			: "") + "\n      " + (/*invalid*/ ctx[2] ? "mdc-text-field--invalid" : "") + "\n    "
		},
		/*props*/ ctx[19]
	];

	let label_1_data = {};

	for (let i = 0; i < label_1_levels.length; i += 1) {
		label_1_data = assign(label_1_data, label_1_levels[i]);
	}

	const block = {
		c: function create() {
			label_1 = element("label");
			if (default_slot) default_slot.c();
			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			set_attributes(label_1, label_1_data);
			add_location(label_1, file$l, 1, 2, 15);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);

			if (default_slot) {
				default_slot.m(label_1, null);
			}

			append_dev(label_1, t0);
			if_blocks[current_block_type_index].m(label_1, null);
			append_dev(label_1, t1);
			if (if_block1) if_block1.m(label_1, null);
			append_dev(label_1, t2);
			if (if_block2) if_block2.m(label_1, null);
			/*label_1_binding*/ ctx[43](label_1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, label_1, /*use*/ ctx[4])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[21].call(null, label_1))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[45], dirty, null, null);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(label_1, t1);
			}

			if (!/*textarea*/ ctx[9] && /*variant*/ ctx[10] !== "outlined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*textarea, variant*/ 1536) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label_1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*textarea*/ ctx[9] || /*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*textarea, variant, fullwidth*/ 1792) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(label_1, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
				(!current || dirty[0] & /*className, disabled, fullwidth, textarea, variant, dense, noLabel, label, withLeadingIcon, withTrailingIcon, invalid*/ 65444 && label_1_class_value !== (label_1_class_value = "\n      mdc-text-field\n      " + /*className*/ ctx[5] + "\n      " + (/*disabled*/ ctx[7] ? "mdc-text-field--disabled" : "") + "\n      " + (/*fullwidth*/ ctx[8] ? "mdc-text-field--fullwidth" : "") + "\n      " + (/*textarea*/ ctx[9] ? "mdc-text-field--textarea" : "") + "\n      " + (/*variant*/ ctx[10] === "outlined" && !/*fullwidth*/ ctx[8]
				? "mdc-text-field--outlined"
				: "") + "\n      " + (/*variant*/ ctx[10] === "standard" && !/*fullwidth*/ ctx[8] && !/*textarea*/ ctx[9]
				? "smui-text-field--standard"
				: "") + "\n      " + (/*dense*/ ctx[11] ? "mdc-text-field--dense" : "") + "\n      " + (/*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
				? "mdc-text-field--no-label"
				: "") + "\n      " + (/*withLeadingIcon*/ ctx[12]
				? "mdc-text-field--with-leading-icon"
				: "") + "\n      " + (/*withTrailingIcon*/ ctx[13]
				? "mdc-text-field--with-trailing-icon"
				: "") + "\n      " + (/*invalid*/ ctx[2] ? "mdc-text-field--invalid" : "") + "\n    ")) && { class: label_1_class_value },
				dirty[0] & /*props*/ 524288 && /*props*/ ctx[19]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 16) useActions_action.update.call(null, /*use*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			if (default_slot) default_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*label_1_binding*/ ctx[43](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(1:0) {#if valued}",
		ctx
	});

	return block;
}

// (36:4) {:else}
function create_else_block$1(ctx) {
	let input;
	let updating_value;
	let updating_files;
	let updating_dirty;
	let updating_invalid;
	let current;

	const input_spread_levels = [
		{ type: /*type*/ ctx[16] },
		{ disabled: /*disabled*/ ctx[7] },
		{ updateInvalid: /*updateInvalid*/ ctx[17] },
		/*fullwidth*/ ctx[8] && /*label*/ ctx[15]
		? { placeholder: /*label*/ ctx[15] }
		: {},
		prefixFilter(/*$$props*/ ctx[22], "input$")
	];

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[35].call(null, value);
	}

	function input_files_binding(value) {
		/*input_files_binding*/ ctx[36].call(null, value);
	}

	function input_dirty_binding(value) {
		/*input_dirty_binding*/ ctx[37].call(null, value);
	}

	function input_invalid_binding(value) {
		/*input_invalid_binding*/ ctx[38].call(null, value);
	}

	let input_props = {};

	for (let i = 0; i < input_spread_levels.length; i += 1) {
		input_props = assign(input_props, input_spread_levels[i]);
	}

	if (/*value*/ ctx[0] !== void 0) {
		input_props.value = /*value*/ ctx[0];
	}

	if (/*files*/ ctx[1] !== void 0) {
		input_props.files = /*files*/ ctx[1];
	}

	if (/*dirty*/ ctx[3] !== void 0) {
		input_props.dirty = /*dirty*/ ctx[3];
	}

	if (/*invalid*/ ctx[2] !== void 0) {
		input_props.invalid = /*invalid*/ ctx[2];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, "value", input_value_binding));
	binding_callbacks.push(() => bind(input, "files", input_files_binding));
	binding_callbacks.push(() => bind(input, "dirty", input_dirty_binding));
	binding_callbacks.push(() => bind(input, "invalid", input_invalid_binding));
	input.$on("change", /*change_handler_1*/ ctx[39]);
	input.$on("input", /*input_handler_1*/ ctx[40]);
	input.$on("blur", /*blur_handler_1*/ ctx[41]);
	input.$on("focus", /*focus_handler_1*/ ctx[42]);

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const input_changes = (dirty[0] & /*type, disabled, updateInvalid, fullwidth, label, $$props*/ 4424064)
			? get_spread_update(input_spread_levels, [
					dirty[0] & /*type*/ 65536 && { type: /*type*/ ctx[16] },
					dirty[0] & /*disabled*/ 128 && { disabled: /*disabled*/ ctx[7] },
					dirty[0] & /*updateInvalid*/ 131072 && { updateInvalid: /*updateInvalid*/ ctx[17] },
					dirty[0] & /*fullwidth, label*/ 33024 && get_spread_object(/*fullwidth*/ ctx[8] && /*label*/ ctx[15]
					? { placeholder: /*label*/ ctx[15] }
					: {}),
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], "input$"))
				])
			: {};

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				input_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_files && dirty[0] & /*files*/ 2) {
				updating_files = true;
				input_changes.files = /*files*/ ctx[1];
				add_flush_callback(() => updating_files = false);
			}

			if (!updating_dirty && dirty[0] & /*dirty*/ 8) {
				updating_dirty = true;
				input_changes.dirty = /*dirty*/ ctx[3];
				add_flush_callback(() => updating_dirty = false);
			}

			if (!updating_invalid && dirty[0] & /*invalid*/ 4) {
				updating_invalid = true;
				input_changes.invalid = /*invalid*/ ctx[2];
				add_flush_callback(() => updating_invalid = false);
			}

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(36:4) {:else}",
		ctx
	});

	return block;
}

// (23:4) {#if textarea}
function create_if_block_6(ctx) {
	let textarea_1;
	let updating_value;
	let updating_dirty;
	let updating_invalid;
	let current;

	const textarea_1_spread_levels = [
		{ disabled: /*disabled*/ ctx[7] },
		{ updateInvalid: /*updateInvalid*/ ctx[17] },
		prefixFilter(/*$$props*/ ctx[22], "input$")
	];

	function textarea_1_value_binding(value) {
		/*textarea_1_value_binding*/ ctx[28].call(null, value);
	}

	function textarea_1_dirty_binding(value) {
		/*textarea_1_dirty_binding*/ ctx[29].call(null, value);
	}

	function textarea_1_invalid_binding(value) {
		/*textarea_1_invalid_binding*/ ctx[30].call(null, value);
	}

	let textarea_1_props = {};

	for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
		textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
	}

	if (/*value*/ ctx[0] !== void 0) {
		textarea_1_props.value = /*value*/ ctx[0];
	}

	if (/*dirty*/ ctx[3] !== void 0) {
		textarea_1_props.dirty = /*dirty*/ ctx[3];
	}

	if (/*invalid*/ ctx[2] !== void 0) {
		textarea_1_props.invalid = /*invalid*/ ctx[2];
	}

	textarea_1 = new Textarea({ props: textarea_1_props, $$inline: true });
	binding_callbacks.push(() => bind(textarea_1, "value", textarea_1_value_binding));
	binding_callbacks.push(() => bind(textarea_1, "dirty", textarea_1_dirty_binding));
	binding_callbacks.push(() => bind(textarea_1, "invalid", textarea_1_invalid_binding));
	textarea_1.$on("change", /*change_handler*/ ctx[31]);
	textarea_1.$on("input", /*input_handler*/ ctx[32]);
	textarea_1.$on("blur", /*blur_handler*/ ctx[33]);
	textarea_1.$on("focus", /*focus_handler*/ ctx[34]);

	const block = {
		c: function create() {
			create_component(textarea_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textarea_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textarea_1_changes = (dirty[0] & /*disabled, updateInvalid, $$props*/ 4325504)
			? get_spread_update(textarea_1_spread_levels, [
					dirty[0] & /*disabled*/ 128 && { disabled: /*disabled*/ ctx[7] },
					dirty[0] & /*updateInvalid*/ 131072 && { updateInvalid: /*updateInvalid*/ ctx[17] },
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], "input$"))
				])
			: {};

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				textarea_1_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_dirty && dirty[0] & /*dirty*/ 8) {
				updating_dirty = true;
				textarea_1_changes.dirty = /*dirty*/ ctx[3];
				add_flush_callback(() => updating_dirty = false);
			}

			if (!updating_invalid && dirty[0] & /*invalid*/ 4) {
				updating_invalid = true;
				textarea_1_changes.invalid = /*invalid*/ ctx[2];
				add_flush_callback(() => updating_invalid = false);
			}

			textarea_1.$set(textarea_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textarea_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textarea_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textarea_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(23:4) {#if textarea}",
		ctx
	});

	return block;
}

// (53:4) {#if !textarea && variant !== 'outlined'}
function create_if_block_3(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = !/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && !/*fullwidth*/ ctx[8] && create_if_block_5(ctx);
	let if_block1 = /*ripple*/ ctx[6] && create_if_block_4(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && !/*fullwidth*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*noLabel, label, fullwidth*/ 49408) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*ripple*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*ripple*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(53:4) {#if !textarea && variant !== 'outlined'}",
		ctx
	});

	return block;
}

// (54:6) {#if !noLabel && label != null && !fullwidth}
function create_if_block_5(ctx) {
	let floatinglabel;
	let current;
	const floatinglabel_spread_levels = [{ wrapped: true }, prefixFilter(/*$$props*/ ctx[22], "label$")];

	let floatinglabel_props = {
		$$slots: { default: [create_default_slot_2$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
	}

	floatinglabel = new FloatingLabel({
			props: floatinglabel_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(floatinglabel.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(floatinglabel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const floatinglabel_changes = (dirty[0] & /*$$props*/ 4194304)
			? get_spread_update(floatinglabel_spread_levels, [
					floatinglabel_spread_levels[0],
					get_spread_object(prefixFilter(/*$$props*/ ctx[22], "label$"))
				])
			: {};

			if (dirty[0] & /*label*/ 32768 | dirty[1] & /*$$scope*/ 16384) {
				floatinglabel_changes.$$scope = { dirty, ctx };
			}

			floatinglabel.$set(floatinglabel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(floatinglabel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(floatinglabel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(floatinglabel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(54:6) {#if !noLabel && label != null && !fullwidth}",
		ctx
	});

	return block;
}

// (55:8) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>
function create_default_slot_2$2(ctx) {
	let t;
	let current;
	const label_slot_template = /*#slots*/ ctx[27].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[45], get_label_slot_context);

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[15]);
			if (label_slot) label_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);

			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*label*/ 32768) set_data_dev(t, /*label*/ ctx[15]);

			if (label_slot) {
				if (label_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_label_slot_changes, get_label_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(55:8) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>",
		ctx
	});

	return block;
}

// (57:6) {#if ripple}
function create_if_block_4(ctx) {
	let lineripple;
	let current;
	const lineripple_spread_levels = [prefixFilter(/*$$props*/ ctx[22], "ripple$")];
	let lineripple_props = {};

	for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
		lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
	}

	lineripple = new LineRipple({ props: lineripple_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(lineripple.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(lineripple, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const lineripple_changes = (dirty[0] & /*$$props*/ 4194304)
			? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], "ripple$"))])
			: {};

			lineripple.$set(lineripple_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(lineripple.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(lineripple.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(lineripple, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(57:6) {#if ripple}",
		ctx
	});

	return block;
}

// (61:4) {#if textarea || (variant === 'outlined' && !fullwidth)}
function create_if_block_1$1(ctx) {
	let notchedoutline;
	let current;

	const notchedoutline_spread_levels = [
		{
			noLabel: /*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
		},
		prefixFilter(/*$$props*/ ctx[22], "outline$")
	];

	let notchedoutline_props = {
		$$slots: { default: [create_default_slot$5] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
		notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
	}

	notchedoutline = new NotchedOutline({
			props: notchedoutline_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(notchedoutline.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(notchedoutline, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const notchedoutline_changes = (dirty[0] & /*noLabel, label, $$props*/ 4243456)
			? get_spread_update(notchedoutline_spread_levels, [
					dirty[0] & /*noLabel, label*/ 49152 && {
						noLabel: /*noLabel*/ ctx[14] || /*label*/ ctx[15] == null
					},
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], "outline$"))
				])
			: {};

			if (dirty[0] & /*$$props, label, noLabel*/ 4243456 | dirty[1] & /*$$scope*/ 16384) {
				notchedoutline_changes.$$scope = { dirty, ctx };
			}

			notchedoutline.$set(notchedoutline_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notchedoutline.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notchedoutline.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notchedoutline, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(61:4) {#if textarea || (variant === 'outlined' && !fullwidth)}",
		ctx
	});

	return block;
}

// (63:8) {#if !noLabel && label != null}
function create_if_block_2$1(ctx) {
	let floatinglabel;
	let current;
	const floatinglabel_spread_levels = [{ wrapped: true }, prefixFilter(/*$$props*/ ctx[22], "label$")];

	let floatinglabel_props = {
		$$slots: { default: [create_default_slot_1$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
	}

	floatinglabel = new FloatingLabel({
			props: floatinglabel_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(floatinglabel.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(floatinglabel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const floatinglabel_changes = (dirty[0] & /*$$props*/ 4194304)
			? get_spread_update(floatinglabel_spread_levels, [
					floatinglabel_spread_levels[0],
					get_spread_object(prefixFilter(/*$$props*/ ctx[22], "label$"))
				])
			: {};

			if (dirty[0] & /*label*/ 32768 | dirty[1] & /*$$scope*/ 16384) {
				floatinglabel_changes.$$scope = { dirty, ctx };
			}

			floatinglabel.$set(floatinglabel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(floatinglabel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(floatinglabel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(floatinglabel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(63:8) {#if !noLabel && label != null}",
		ctx
	});

	return block;
}

// (64:10) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>
function create_default_slot_1$2(ctx) {
	let t;
	let current;
	const label_slot_template = /*#slots*/ ctx[27].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[45], get_label_slot_context_1);

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[15]);
			if (label_slot) label_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);

			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*label*/ 32768) set_data_dev(t, /*label*/ ctx[15]);

			if (label_slot) {
				if (label_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_label_slot_changes_1, get_label_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(64:10) <FloatingLabel wrapped {...prefixFilter($$props, 'label$')}>",
		ctx
	});

	return block;
}

// (62:6) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>
function create_default_slot$5(ctx) {
	let if_block_anchor;
	let current;
	let if_block = !/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null && create_if_block_2$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!/*noLabel*/ ctx[14] && /*label*/ ctx[15] != null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*noLabel, label*/ 49152) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(62:6) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*valued*/ ctx[20]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let props;
	let valued;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Textfield", slots, ['default','label']);
	const forwardEvents = forwardEventsBuilder(get_current_component());

	let uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { disabled = false } = $$props;
	let { fullwidth = false } = $$props;
	let { textarea = false } = $$props;
	let { variant = "standard" } = $$props;
	let { dense = false } = $$props;
	let { withLeadingIcon = false } = $$props;
	let { withTrailingIcon = false } = $$props;
	let { noLabel = false } = $$props;
	let { label = null } = $$props;
	let { type = "text" } = $$props;
	let { value = uninitializedValue } = $$props;
	let { files = uninitializedValue } = $$props;
	let { dirty = false } = $$props;
	let { invalid = uninitializedValue } = $$props;
	let { updateInvalid = invalid === uninitializedValue } = $$props;
	let { useNativeValidation = updateInvalid } = $$props;
	let element;
	let textField;
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	onMount(() => {
		$$invalidate(26, textField = new MDCTextField(element));

		if (!ripple) {
			textField.ripple && textField.ripple.destroy();
		}
	});

	onDestroy(() => {
		textField && textField.destroy();

		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function focus(...args) {
		return textField.focus(...args);
	}

	function layout(...args) {
		return textField.layout(...args);
	}

	function textarea_1_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function textarea_1_dirty_binding(value) {
		dirty = value;
		$$invalidate(3, dirty);
	}

	function textarea_1_invalid_binding(value$1) {
		invalid = value$1;
		(((((($$invalidate(2, invalid), $$invalidate(26, textField)), $$invalidate(17, updateInvalid)), $$invalidate(0, value)), $$invalidate(47, uninitializedValue)), $$invalidate(7, disabled)), $$invalidate(23, useNativeValidation));
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function blur_handler(event) {
		bubble($$self, event);
	}

	function focus_handler(event) {
		bubble($$self, event);
	}

	function input_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function input_files_binding(value) {
		files = value;
		$$invalidate(1, files);
	}

	function input_dirty_binding(value) {
		dirty = value;
		$$invalidate(3, dirty);
	}

	function input_invalid_binding(value$1) {
		invalid = value$1;
		(((((($$invalidate(2, invalid), $$invalidate(26, textField)), $$invalidate(17, updateInvalid)), $$invalidate(0, value)), $$invalidate(47, uninitializedValue)), $$invalidate(7, disabled)), $$invalidate(23, useNativeValidation));
	}

	function change_handler_1(event) {
		bubble($$self, event);
	}

	function input_handler_1(event) {
		bubble($$self, event);
	}

	function blur_handler_1(event) {
		bubble($$self, event);
	}

	function focus_handler_1(event) {
		bubble($$self, event);
	}

	function label_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(18, element);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(18, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(4, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(6, ripple = $$new_props.ripple);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("fullwidth" in $$new_props) $$invalidate(8, fullwidth = $$new_props.fullwidth);
		if ("textarea" in $$new_props) $$invalidate(9, textarea = $$new_props.textarea);
		if ("variant" in $$new_props) $$invalidate(10, variant = $$new_props.variant);
		if ("dense" in $$new_props) $$invalidate(11, dense = $$new_props.dense);
		if ("withLeadingIcon" in $$new_props) $$invalidate(12, withLeadingIcon = $$new_props.withLeadingIcon);
		if ("withTrailingIcon" in $$new_props) $$invalidate(13, withTrailingIcon = $$new_props.withTrailingIcon);
		if ("noLabel" in $$new_props) $$invalidate(14, noLabel = $$new_props.noLabel);
		if ("label" in $$new_props) $$invalidate(15, label = $$new_props.label);
		if ("type" in $$new_props) $$invalidate(16, type = $$new_props.type);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("files" in $$new_props) $$invalidate(1, files = $$new_props.files);
		if ("dirty" in $$new_props) $$invalidate(3, dirty = $$new_props.dirty);
		if ("invalid" in $$new_props) $$invalidate(2, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$new_props) $$invalidate(17, updateInvalid = $$new_props.updateInvalid);
		if ("useNativeValidation" in $$new_props) $$invalidate(23, useNativeValidation = $$new_props.useNativeValidation);
		if ("$$scope" in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTextField,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		FloatingLabel,
		LineRipple,
		NotchedOutline,
		Input,
		Textarea,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		ripple,
		disabled,
		fullwidth,
		textarea,
		variant,
		dense,
		withLeadingIcon,
		withTrailingIcon,
		noLabel,
		label,
		type,
		value,
		files,
		dirty,
		invalid,
		updateInvalid,
		useNativeValidation,
		element,
		textField,
		addLayoutListener,
		removeLayoutListener,
		focus,
		layout,
		props,
		valued
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
		if ("uninitializedValue" in $$props) $$invalidate(47, uninitializedValue = $$new_props.uninitializedValue);
		if ("use" in $$props) $$invalidate(4, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(6, ripple = $$new_props.ripple);
		if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("fullwidth" in $$props) $$invalidate(8, fullwidth = $$new_props.fullwidth);
		if ("textarea" in $$props) $$invalidate(9, textarea = $$new_props.textarea);
		if ("variant" in $$props) $$invalidate(10, variant = $$new_props.variant);
		if ("dense" in $$props) $$invalidate(11, dense = $$new_props.dense);
		if ("withLeadingIcon" in $$props) $$invalidate(12, withLeadingIcon = $$new_props.withLeadingIcon);
		if ("withTrailingIcon" in $$props) $$invalidate(13, withTrailingIcon = $$new_props.withTrailingIcon);
		if ("noLabel" in $$props) $$invalidate(14, noLabel = $$new_props.noLabel);
		if ("label" in $$props) $$invalidate(15, label = $$new_props.label);
		if ("type" in $$props) $$invalidate(16, type = $$new_props.type);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("files" in $$props) $$invalidate(1, files = $$new_props.files);
		if ("dirty" in $$props) $$invalidate(3, dirty = $$new_props.dirty);
		if ("invalid" in $$props) $$invalidate(2, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$props) $$invalidate(17, updateInvalid = $$new_props.updateInvalid);
		if ("useNativeValidation" in $$props) $$invalidate(23, useNativeValidation = $$new_props.useNativeValidation);
		if ("element" in $$props) $$invalidate(18, element = $$new_props.element);
		if ("textField" in $$props) $$invalidate(26, textField = $$new_props.textField);
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
		if ("props" in $$props) $$invalidate(19, props = $$new_props.props);
		if ("valued" in $$props) $$invalidate(20, valued = $$new_props.valued);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(19, props = exclude($$props, [
			"use",
			"class",
			"ripple",
			"disabled",
			"fullwidth",
			"textarea",
			"variant",
			"dense",
			"withLeadingIcon",
			"withTrailingIcon",
			"noLabel",
			"label",
			"type",
			"value",
			"dirty",
			"invalid",
			"updateInvalid",
			"useNativeValidation",
			"input$",
			"label$",
			"ripple$",
			"outline$"
		]));

		if ($$self.$$.dirty[0] & /*value, files*/ 3) {
			 $$invalidate(20, valued = value !== uninitializedValue || files !== uninitializedValue);
		}

		if ($$self.$$.dirty[0] & /*textField, value*/ 67108865) {
			 if (textField && value !== uninitializedValue && textField.value !== value) {
				$$invalidate(26, textField.value = value, textField);
			}
		}

		if ($$self.$$.dirty[0] & /*textField, disabled*/ 67108992) {
			 if (textField && textField.disabled !== disabled) {
				$$invalidate(26, textField.disabled = disabled, textField);
			}
		}

		if ($$self.$$.dirty[0] & /*textField, invalid, updateInvalid*/ 67239940) {
			 if (textField && textField.valid !== !invalid) {
				if (updateInvalid) {
					$$invalidate(2, invalid = !textField.valid);
				} else {
					$$invalidate(26, textField.valid = !invalid, textField);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*textField, useNativeValidation*/ 75497472) {
			 if (textField && textField.useNativeValidation !== useNativeValidation) {
				$$invalidate(26, textField.useNativeValidation = useNativeValidation, textField);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		files,
		invalid,
		dirty,
		use,
		className,
		ripple,
		disabled,
		fullwidth,
		textarea,
		variant,
		dense,
		withLeadingIcon,
		withTrailingIcon,
		noLabel,
		label,
		type,
		updateInvalid,
		element,
		props,
		valued,
		forwardEvents,
		$$props,
		useNativeValidation,
		focus,
		layout,
		textField,
		slots,
		textarea_1_value_binding,
		textarea_1_dirty_binding,
		textarea_1_invalid_binding,
		change_handler,
		input_handler,
		blur_handler,
		focus_handler,
		input_value_binding,
		input_files_binding,
		input_dirty_binding,
		input_invalid_binding,
		change_handler_1,
		input_handler_1,
		blur_handler_1,
		focus_handler_1,
		label_1_binding,
		div_binding,
		$$scope
	];
}

class Textfield extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$l,
			create_fragment$l,
			safe_not_equal,
			{
				use: 4,
				class: 5,
				ripple: 6,
				disabled: 7,
				fullwidth: 8,
				textarea: 9,
				variant: 10,
				dense: 11,
				withLeadingIcon: 12,
				withTrailingIcon: 13,
				noLabel: 14,
				label: 15,
				type: 16,
				value: 0,
				files: 1,
				dirty: 3,
				invalid: 2,
				updateInvalid: 17,
				useNativeValidation: 23,
				focus: 24,
				layout: 25
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Textfield",
			options,
			id: create_fragment$l.name
		});
	}

	get use() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullwidth() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullwidth(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textarea() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textarea(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variant() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withLeadingIcon() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withLeadingIcon(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withTrailingIcon() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withTrailingIcon(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noLabel() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noLabel(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get files() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set files(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dirty() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dirty(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateInvalid() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateInvalid(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get useNativeValidation() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set useNativeValidation(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx[24];
	}

	set focus(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[25];
	}

	set layout(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\textfield\helper-text\HelperText.svelte generated by Svelte v3.31.2 */
const file$m = "node_modules\\@smui\\textfield\\helper-text\\HelperText.svelte";
const get_character_counter_slot_changes = dirty => ({});
const get_character_counter_slot_context = ctx => ({});

function create_fragment$m(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let useActions_action;
	let forwardEvents_action;
	let t;
	let div1_class_value;
	let useActions_action_1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let div0_levels = [
		{
			class: div0_class_value = "\n      mdc-text-field-helper-text\n      " + /*className*/ ctx[1] + "\n      " + (/*persistent*/ ctx[2]
			? "mdc-text-field-helper-text--persistent"
			: "") + "\n      " + (/*validationMsg*/ ctx[3]
			? "mdc-text-field-helper-text--validation-msg"
			: "") + "\n    "
		},
		{ "aria-hidden": "true" },
		exclude(/*$$props*/ ctx[8], ["use", "class", "persistent", "validationMsg"])
	];

	let div0_data = {};

	for (let i = 0; i < div0_levels.length; i += 1) {
		div0_data = assign(div0_data, div0_levels[i]);
	}

	const character_counter_slot_template = /*#slots*/ ctx[10]["character-counter"];
	const character_counter_slot = create_slot(character_counter_slot_template, ctx, /*$$scope*/ ctx[9], get_character_counter_slot_context);

	let div1_levels = [
		{
			class: div1_class_value = "mdc-text-field-helper-line " + /*line$class*/ ctx[5]
		},
		exclude(prefixFilter(/*$$props*/ ctx[8], "line$"), ["use", "class"])
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (character_counter_slot) character_counter_slot.c();
			set_attributes(div0, div0_data);
			add_location(div0, file$m, 5, 2, 152);
			set_attributes(div1, div1_data);
			add_location(div1, file$m, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[11](div0);
			append_dev(div1, t);

			if (character_counter_slot) {
				character_counter_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div0, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, div0)),
					action_destroyer(useActions_action_1 = useActions.call(null, div1, /*line$use*/ ctx[4]))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(div0, div0_data = get_spread_update(div0_levels, [
				(!current || dirty & /*className, persistent, validationMsg*/ 14 && div0_class_value !== (div0_class_value = "\n      mdc-text-field-helper-text\n      " + /*className*/ ctx[1] + "\n      " + (/*persistent*/ ctx[2]
				? "mdc-text-field-helper-text--persistent"
				: "") + "\n      " + (/*validationMsg*/ ctx[3]
				? "mdc-text-field-helper-text--validation-msg"
				: "") + "\n    ")) && { class: div0_class_value },
				{ "aria-hidden": "true" },
				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "persistent", "validationMsg"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);

			if (character_counter_slot) {
				if (character_counter_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(character_counter_slot, character_counter_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_character_counter_slot_changes, get_character_counter_slot_context);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*line$class*/ 32 && div1_class_value !== (div1_class_value = "mdc-text-field-helper-line " + /*line$class*/ ctx[5])) && { class: div1_class_value },
				dirty & /*$$props*/ 256 && exclude(prefixFilter(/*$$props*/ ctx[8], "line$"), ["use", "class"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*line$use*/ 16) useActions_action_1.update.call(null, /*line$use*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(character_counter_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(character_counter_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[11](null);
			if (character_counter_slot) character_counter_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("HelperText", slots, ['default','character-counter']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { persistent = false } = $$props;
	let { validationMsg = false } = $$props;
	let { line$use = [] } = $$props;
	let { line$class = "" } = $$props;
	let element;
	let helperText;

	onMount(() => {
		helperText = new MDCTextFieldHelperText(element);
	});

	onDestroy(() => {
		helperText && helperText.destroy();
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("persistent" in $$new_props) $$invalidate(2, persistent = $$new_props.persistent);
		if ("validationMsg" in $$new_props) $$invalidate(3, validationMsg = $$new_props.validationMsg);
		if ("line$use" in $$new_props) $$invalidate(4, line$use = $$new_props.line$use);
		if ("line$class" in $$new_props) $$invalidate(5, line$class = $$new_props.line$class);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCTextFieldHelperText,
		onMount,
		onDestroy,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		persistent,
		validationMsg,
		line$use,
		line$class,
		element,
		helperText
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("persistent" in $$props) $$invalidate(2, persistent = $$new_props.persistent);
		if ("validationMsg" in $$props) $$invalidate(3, validationMsg = $$new_props.validationMsg);
		if ("line$use" in $$props) $$invalidate(4, line$use = $$new_props.line$use);
		if ("line$class" in $$props) $$invalidate(5, line$class = $$new_props.line$class);
		if ("element" in $$props) $$invalidate(6, element = $$new_props.element);
		if ("helperText" in $$props) helperText = $$new_props.helperText;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		persistent,
		validationMsg,
		line$use,
		line$class,
		element,
		forwardEvents,
		$$props,
		$$scope,
		slots,
		div0_binding
	];
}

class HelperText extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			use: 0,
			class: 1,
			persistent: 2,
			validationMsg: 3,
			line$use: 4,
			line$class: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HelperText",
			options,
			id: create_fragment$m.name
		});
	}

	get use() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get persistent() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set persistent(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validationMsg() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validationMsg(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get line$use() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set line$use(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get line$class() {
		throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set line$class(value) {
		throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function Ripple(node, props = {ripple: false, unbounded: false, color: null, classForward: () => {}}) {
  let instance = null;
  let addLayoutListener = getContext('SMUI:addLayoutListener');
  let removeLayoutListener;
  let classList = [];

  function addClass(className) {
    const idx = classList.indexOf(className);
    if (idx === -1) {
      node.classList.add(className);
      classList.push(className);
      if (props.classForward) {
        props.classForward(classList);
      }
    }
  }

  function removeClass(className) {
    const idx = classList.indexOf(className);
    if (idx !== -1) {
      node.classList.remove(className);
      classList.splice(idx, 1);
      if (props.classForward) {
        props.classForward(classList);
      }
    }
  }

  function handleProps() {
    if (props.ripple && !instance) {
      // Override the Ripple component's adapter, so that we can forward classes
      // to Svelte components that overwrite Ripple's classes.
      const _createAdapter = MDCRipple.createAdapter;
      MDCRipple.createAdapter = function(...args) {
        const adapter = _createAdapter.apply(this, args);
        adapter.addClass = function(className) {
          return addClass(className);
        };
        adapter.removeClass = function(className) {
          return removeClass(className);
        };
        return adapter;
      };
      instance = new MDCRipple(node);
      MDCRipple.createAdapter = _createAdapter;
    } else if (instance && !props.ripple) {
      instance.destroy();
      instance = null;
    }
    if (props.ripple) {
      instance.unbounded = !!props.unbounded;
      switch (props.color) {
        case 'surface':
          addClass('mdc-ripple-surface');
          removeClass('mdc-ripple-surface--primary');
          removeClass('mdc-ripple-surface--accent');
          return;
        case 'primary':
          addClass('mdc-ripple-surface');
          addClass('mdc-ripple-surface--primary');
          removeClass('mdc-ripple-surface--accent');
          return;
        case 'secondary':
          addClass('mdc-ripple-surface');
          removeClass('mdc-ripple-surface--primary');
          addClass('mdc-ripple-surface--accent');
          return;
      }
    }
    removeClass('mdc-ripple-surface');
    removeClass('mdc-ripple-surface--primary');
    removeClass('mdc-ripple-surface--accent');
  }

  handleProps();

  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }

  function layout() {
    if (instance) {
      instance.layout();
    }
  }

  return {
    update(newProps = {ripple: false, unbounded: false, color: null, classForward: []}) {
      props = newProps;
      handleProps();
    },

    destroy() {
      if (instance) {
        instance.destroy();
        instance = null;
        removeClass('mdc-ripple-surface');
        removeClass('mdc-ripple-surface--primary');
        removeClass('mdc-ripple-surface--accent');
      }

      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  }
}

/* node_modules\@smui\fab\Fab.svelte generated by Svelte v3.31.2 */
const file$n = "node_modules\\@smui\\fab\\Fab.svelte";

function create_fragment$n(ctx) {
	let button;
	let button_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let button_levels = [
		{
			class: button_class_value = "\n    mdc-fab\n    " + /*className*/ ctx[1] + "\n    " + (/*mini*/ ctx[4] ? "mdc-fab--mini" : "") + "\n    " + (/*exited*/ ctx[5] ? "mdc-fab--exited" : "") + "\n    " + (/*extended*/ ctx[6] ? "mdc-fab--extended" : "") + "\n    " + (/*color*/ ctx[3] === "primary"
			? "smui-fab--color-primary"
			: "") + "\n  "
		},
		exclude(/*$$props*/ ctx[8], ["use", "class", "ripple", "color", "mini", "exited", "extended"])
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$n, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, button)),
					action_destroyer(Ripple_action = Ripple.call(null, button, {
						ripple: /*ripple*/ ctx[2],
						unbounded: false
					}))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty & /*className, mini, exited, extended, color*/ 122 && button_class_value !== (button_class_value = "\n    mdc-fab\n    " + /*className*/ ctx[1] + "\n    " + (/*mini*/ ctx[4] ? "mdc-fab--mini" : "") + "\n    " + (/*exited*/ ctx[5] ? "mdc-fab--exited" : "") + "\n    " + (/*extended*/ ctx[6] ? "mdc-fab--extended" : "") + "\n    " + (/*color*/ ctx[3] === "primary"
				? "smui-fab--color-primary"
				: "") + "\n  ")) && { class: button_class_value },
				dirty & /*$$props*/ 256 && exclude(/*$$props*/ ctx[8], ["use", "class", "ripple", "color", "mini", "exited", "extended"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple*/ 4) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[2],
				unbounded: false
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { color = "secondary" } = $$props;
	let { mini = false } = $$props;
	let { exited = false } = $$props;
	let { extended = false } = $$props;
	setContext("SMUI:label:context", "fab");
	setContext("SMUI:icon:context", "fab");

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(2, ripple = $$new_props.ripple);
		if ("color" in $$new_props) $$invalidate(3, color = $$new_props.color);
		if ("mini" in $$new_props) $$invalidate(4, mini = $$new_props.mini);
		if ("exited" in $$new_props) $$invalidate(5, exited = $$new_props.exited);
		if ("extended" in $$new_props) $$invalidate(6, extended = $$new_props.extended);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		Ripple,
		forwardEvents,
		use,
		className,
		ripple,
		color,
		mini,
		exited,
		extended
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(2, ripple = $$new_props.ripple);
		if ("color" in $$props) $$invalidate(3, color = $$new_props.color);
		if ("mini" in $$props) $$invalidate(4, mini = $$new_props.mini);
		if ("exited" in $$props) $$invalidate(5, exited = $$new_props.exited);
		if ("extended" in $$props) $$invalidate(6, extended = $$new_props.extended);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		ripple,
		color,
		mini,
		exited,
		extended,
		forwardEvents,
		$$props,
		$$scope,
		slots
	];
}

class Fab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			use: 0,
			class: 1,
			ripple: 2,
			color: 3,
			mini: 4,
			exited: 5,
			extended: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab",
			options,
			id: create_fragment$n.name
		});
	}

	get use() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mini() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mini(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get exited() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set exited(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get extended() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set extended(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var jsEventTypeMap = {
    animationend: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationEnd',
        standard: 'animationend',
    },
    animationiteration: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationIteration',
        standard: 'animationiteration',
    },
    animationstart: {
        cssProperty: 'animation',
        prefixed: 'webkitAnimationStart',
        standard: 'animationstart',
    },
    transitionend: {
        cssProperty: 'transition',
        prefixed: 'webkitTransitionEnd',
        standard: 'transitionend',
    },
};
function isWindow(windowObj) {
    return Boolean(windowObj.document) && typeof windowObj.document.createElement === 'function';
}
function getCorrectEventName(windowObj, eventType) {
    if (isWindow(windowObj) && eventType in jsEventTypeMap) {
        var el = windowObj.document.createElement('div');
        var _a = jsEventTypeMap[eventType], standard = _a.standard, prefixed = _a.prefixed, cssProperty = _a.cssProperty;
        var isStandard = cssProperty in el.style;
        return isStandard ? standard : prefixed;
    }
    return eventType;
}
//# sourceMappingURL=util.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$b = {
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    BACKGROUND: 'mdc-checkbox__background',
    CHECKED: 'mdc-checkbox--checked',
    CHECKMARK: 'mdc-checkbox__checkmark',
    CHECKMARK_PATH: 'mdc-checkbox__checkmark-path',
    DISABLED: 'mdc-checkbox--disabled',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    MIXEDMARK: 'mdc-checkbox__mixedmark',
    NATIVE_CONTROL: 'mdc-checkbox__native-control',
    ROOT: 'mdc-checkbox',
    SELECTED: 'mdc-checkbox--selected',
    UPGRADED: 'mdc-checkbox--upgraded',
};
var strings$b = {
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed',
    NATIVE_CONTROL_SELECTOR: '.mdc-checkbox__native-control',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
};
var numbers$4 = {
    ANIM_END_LATCH_MS: 250,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCCheckboxFoundation = /** @class */ (function (_super) {
    __extends(MDCCheckboxFoundation, _super);
    function MDCCheckboxFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCCheckboxFoundation.defaultAdapter, adapter)) || this;
        _this.currentCheckState_ = strings$b.TRANSITION_STATE_INIT;
        _this.currentAnimationClass_ = '';
        _this.animEndLatchTimer_ = 0;
        _this.enableAnimationEndHandler_ = false;
        return _this;
    }
    Object.defineProperty(MDCCheckboxFoundation, "cssClasses", {
        get: function () {
            return cssClasses$b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "strings", {
        get: function () {
            return strings$b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "numbers", {
        get: function () {
            return numbers$4;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckboxFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClass: function () { return undefined; },
                forceLayout: function () { return undefined; },
                hasNativeControl: function () { return false; },
                isAttachedToDOM: function () { return false; },
                isChecked: function () { return false; },
                isIndeterminate: function () { return false; },
                removeClass: function () { return undefined; },
                removeNativeControlAttr: function () { return undefined; },
                setNativeControlAttr: function () { return undefined; },
                setNativeControlDisabled: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCCheckboxFoundation.prototype.init = function () {
        this.currentCheckState_ = this.determineCheckState_();
        this.updateAriaChecked_();
        this.adapter_.addClass(cssClasses$b.UPGRADED);
    };
    MDCCheckboxFoundation.prototype.destroy = function () {
        clearTimeout(this.animEndLatchTimer_);
    };
    MDCCheckboxFoundation.prototype.setDisabled = function (disabled) {
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(cssClasses$b.DISABLED);
        }
        else {
            this.adapter_.removeClass(cssClasses$b.DISABLED);
        }
    };
    /**
     * Handles the animationend event for the checkbox
     */
    MDCCheckboxFoundation.prototype.handleAnimationEnd = function () {
        var _this = this;
        if (!this.enableAnimationEndHandler_) {
            return;
        }
        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
            _this.adapter_.removeClass(_this.currentAnimationClass_);
            _this.enableAnimationEndHandler_ = false;
        }, numbers$4.ANIM_END_LATCH_MS);
    };
    /**
     * Handles the change event for the checkbox
     */
    MDCCheckboxFoundation.prototype.handleChange = function () {
        this.transitionCheckState_();
    };
    MDCCheckboxFoundation.prototype.transitionCheckState_ = function () {
        if (!this.adapter_.hasNativeControl()) {
            return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_();
        if (oldState === newState) {
            return;
        }
        this.updateAriaChecked_();
        var TRANSITION_STATE_UNCHECKED = strings$b.TRANSITION_STATE_UNCHECKED;
        var SELECTED = cssClasses$b.SELECTED;
        if (newState === TRANSITION_STATE_UNCHECKED) {
            this.adapter_.removeClass(SELECTED);
        }
        else {
            this.adapter_.addClass(SELECTED);
        }
        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
            clearTimeout(this.animEndLatchTimer_);
            this.adapter_.forceLayout();
            this.adapter_.removeClass(this.currentAnimationClass_);
        }
        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;
        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
            this.adapter_.addClass(this.currentAnimationClass_);
            this.enableAnimationEndHandler_ = true;
        }
    };
    MDCCheckboxFoundation.prototype.determineCheckState_ = function () {
        var TRANSITION_STATE_INDETERMINATE = strings$b.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings$b.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings$b.TRANSITION_STATE_UNCHECKED;
        if (this.adapter_.isIndeterminate()) {
            return TRANSITION_STATE_INDETERMINATE;
        }
        return this.adapter_.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
    };
    MDCCheckboxFoundation.prototype.getTransitionAnimationClass_ = function (oldState, newState) {
        var TRANSITION_STATE_INIT = strings$b.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings$b.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings$b.TRANSITION_STATE_UNCHECKED;
        var _a = MDCCheckboxFoundation.cssClasses, ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
        switch (oldState) {
            case TRANSITION_STATE_INIT:
                if (newState === TRANSITION_STATE_UNCHECKED) {
                    return '';
                }
                return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
            case TRANSITION_STATE_UNCHECKED:
                return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
            case TRANSITION_STATE_CHECKED:
                return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
            default: // TRANSITION_STATE_INDETERMINATE
                return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
    };
    MDCCheckboxFoundation.prototype.updateAriaChecked_ = function () {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.adapter_.isIndeterminate()) {
            this.adapter_.setNativeControlAttr(strings$b.ARIA_CHECKED_ATTR, strings$b.ARIA_CHECKED_INDETERMINATE_VALUE);
        }
        else {
            // The on/off state does not need to keep track of aria-checked, since
            // the screenreader uses the checked property on the checkbox element.
            this.adapter_.removeNativeControlAttr(strings$b.ARIA_CHECKED_ATTR);
        }
    };
    return MDCCheckboxFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var CB_PROTO_PROPS = ['checked', 'indeterminate'];
var MDCCheckbox = /** @class */ (function (_super) {
    __extends(MDCCheckbox, _super);
    function MDCCheckbox() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCCheckbox.attachTo = function (root) {
        return new MDCCheckbox(root);
    };
    Object.defineProperty(MDCCheckbox.prototype, "ripple", {
        get: function () {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "checked", {
        get: function () {
            return this.nativeControl_.checked;
        },
        set: function (checked) {
            this.nativeControl_.checked = checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "indeterminate", {
        get: function () {
            return this.nativeControl_.indeterminate;
        },
        set: function (indeterminate) {
            this.nativeControl_.indeterminate = indeterminate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "disabled", {
        get: function () {
            return this.nativeControl_.disabled;
        },
        set: function (disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCCheckbox.prototype, "value", {
        get: function () {
            return this.nativeControl_.value;
        },
        set: function (value) {
            this.nativeControl_.value = value;
        },
        enumerable: true,
        configurable: true
    });
    MDCCheckbox.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleChange_ = function () { return _this.foundation_.handleChange(); };
        this.handleAnimationEnd_ = function () { return _this.foundation_.handleAnimationEnd(); };
        this.nativeControl_.addEventListener('change', this.handleChange_);
        this.listen(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
        this.installPropertyChangeHooks_();
    };
    MDCCheckbox.prototype.destroy = function () {
        this.ripple_.destroy();
        this.nativeControl_.removeEventListener('change', this.handleChange_);
        this.unlisten(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
        this.uninstallPropertyChangeHooks_();
        _super.prototype.destroy.call(this);
    };
    MDCCheckbox.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            forceLayout: function () { return _this.root_.offsetWidth; },
            hasNativeControl: function () { return !!_this.nativeControl_; },
            isAttachedToDOM: function () { return Boolean(_this.root_.parentNode); },
            isChecked: function () { return _this.checked; },
            isIndeterminate: function () { return _this.indeterminate; },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            removeNativeControlAttr: function (attr) { return _this.nativeControl_.removeAttribute(attr); },
            setNativeControlAttr: function (attr, value) { return _this.nativeControl_.setAttribute(attr, value); },
            setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
        };
        return new MDCCheckboxFoundation(adapter);
    };
    MDCCheckbox.prototype.createRipple_ = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign({}, MDCRipple.createAdapter(this), { deregisterInteractionHandler: function (evtType, handler) { return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive()); }, isSurfaceActive: function () { return matches(_this.nativeControl_, ':active'); }, isUnbounded: function () { return true; }, registerInteractionHandler: function (evtType, handler) { return _this.nativeControl_.addEventListener(evtType, handler, applyPassive()); } });
        return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
    };
    MDCCheckbox.prototype.installPropertyChangeHooks_ = function () {
        var _this = this;
        var nativeCb = this.nativeControl_;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
            // We have to check for this descriptor, since some browsers (Safari) don't support its return.
            // See: https://bugs.webkit.org/show_bug.cgi?id=49739
            if (!validDescriptor(desc)) {
                return;
            }
            // Type cast is needed for compatibility with Closure Compiler.
            var nativeGetter = desc.get;
            var nativeCbDesc = {
                configurable: desc.configurable,
                enumerable: desc.enumerable,
                get: nativeGetter,
                set: function (state) {
                    desc.set.call(nativeCb, state);
                    _this.foundation_.handleChange();
                },
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
        });
    };
    MDCCheckbox.prototype.uninstallPropertyChangeHooks_ = function () {
        var nativeCb = this.nativeControl_;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
            if (!validDescriptor(desc)) {
                return;
            }
            Object.defineProperty(nativeCb, controlState, desc);
        });
    };
    Object.defineProperty(MDCCheckbox.prototype, "nativeControl_", {
        get: function () {
            var NATIVE_CONTROL_SELECTOR = MDCCheckboxFoundation.strings.NATIVE_CONTROL_SELECTOR;
            var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
            if (!el) {
                throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
            }
            return el;
        },
        enumerable: true,
        configurable: true
    });
    return MDCCheckbox;
}(MDCComponent));
function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
}
//# sourceMappingURL=component.js.map

/* node_modules\@smui\checkbox\Checkbox.svelte generated by Svelte v3.31.2 */
const file$o = "node_modules\\@smui\\checkbox\\Checkbox.svelte";

function create_fragment$o(ctx) {
	let div2;
	let input;
	let input_value_value;
	let input_class_value;
	let useActions_action;
	let t0;
	let div1;
	let svg;
	let path;
	let t1;
	let div0;
	let div2_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let input_levels = [
		{
			__value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
			? /*value*/ ctx[3]
			: /*valueKey*/ ctx[4]
		},
		{ type: "checkbox" },
		/*inputProps*/ ctx[11],
		{ disabled: /*disabled*/ ctx[2] },
		{
			class: input_class_value = "mdc-checkbox__native-control " + /*input$class*/ ctx[6]
		},
		exclude(prefixFilter(/*$$props*/ ctx[15], "input$"), ["use", "class"])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	let div2_levels = [
		{
			class: div2_class_value = "\n    mdc-checkbox\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-checkbox--disabled" : "") + "\n    " + (/*context*/ ctx[12] === "data-table" && /*dataTableHeader*/ ctx[13]
			? "mdc-data-table__header-row-checkbox"
			: "") + "\n    " + (/*context*/ ctx[12] === "data-table" && !/*dataTableHeader*/ ctx[13]
			? "mdc-data-table__row-checkbox"
			: "") + "\n  "
		},
		exclude(/*$$props*/ ctx[15], [
			"use",
			"class",
			"disabled",
			"indeterminate",
			"group",
			"checked",
			"value",
			"valueKey",
			"input$"
		])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			input = element("input");
			t0 = space();
			div1 = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			t1 = space();
			div0 = element("div");
			set_attributes(input, input_data);
			add_location(input, file$o, 13, 2, 478);
			attr_dev(path, "class", "mdc-checkbox__checkmark-path");
			attr_dev(path, "fill", "none");
			attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
			add_location(path, file$o, 28, 6, 984);
			attr_dev(svg, "class", "mdc-checkbox__checkmark");
			attr_dev(svg, "viewBox", "0 0 24 24");
			add_location(svg, file$o, 27, 4, 920);
			attr_dev(div0, "class", "mdc-checkbox__mixedmark");
			add_location(div0, file$o, 30, 4, 1094);
			attr_dev(div1, "class", "mdc-checkbox__background");
			add_location(div1, file$o, 26, 2, 877);
			set_attributes(div2, div2_data);
			add_location(div2, file$o, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, input);
			input.checked = /*nativeChecked*/ ctx[7];
			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, svg);
			append_dev(svg, path);
			append_dev(div1, t1);
			append_dev(div1, div0);
			/*div2_binding*/ ctx[25](div2);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
					listen_dev(input, "change", /*input_change_handler*/ ctx[24]),
					listen_dev(input, "change", /*handleChange*/ ctx[14], false, false, false),
					listen_dev(input, "input", /*handleChange*/ ctx[14], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[23], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[22], false, false, false),
					action_destroyer(useActions_action_1 = useActions.call(null, div2, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, div2))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
				? /*value*/ ctx[3]
				: /*valueKey*/ ctx[4]) && { __value: input_value_value },
				{ type: "checkbox" },
				/*inputProps*/ ctx[11],
				dirty[0] & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
				dirty[0] & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-checkbox__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
				dirty[0] & /*$$props*/ 32768 && exclude(prefixFilter(/*$$props*/ ctx[15], "input$"), ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

			if (dirty[0] & /*nativeChecked*/ 128) {
				input.checked = /*nativeChecked*/ ctx[7];
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty[0] & /*className, disabled*/ 6 && div2_class_value !== (div2_class_value = "\n    mdc-checkbox\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-checkbox--disabled" : "") + "\n    " + (/*context*/ ctx[12] === "data-table" && /*dataTableHeader*/ ctx[13]
				? "mdc-data-table__header-row-checkbox"
				: "") + "\n    " + (/*context*/ ctx[12] === "data-table" && !/*dataTableHeader*/ ctx[13]
				? "mdc-data-table__row-checkbox"
				: "") + "\n  ") && { class: div2_class_value },
				dirty[0] & /*$$props*/ 32768 && exclude(/*$$props*/ ctx[15], [
					"use",
					"class",
					"disabled",
					"indeterminate",
					"group",
					"checked",
					"value",
					"valueKey",
					"input$"
				])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			/*div2_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component());

	let uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { disabled = false } = $$props;
	let { indeterminate = uninitializedValue } = $$props;
	let { group = uninitializedValue } = $$props;
	let { checked = uninitializedValue } = $$props;
	let { value = null } = $$props;
	let { valueKey = uninitializedValue } = $$props;
	let { input$use = [] } = $$props;
	let { input$class = "" } = $$props;
	let element;
	let checkbox;
	let formField = getContext("SMUI:form-field");
	let inputProps = getContext("SMUI:generic:input:props") || {};
	let setChecked = getContext("SMUI:generic:input:setChecked");
	let addChangeHandler = getContext("SMUI:generic:input:addChangeHandler");

	let nativeChecked = group === uninitializedValue
	? checked === uninitializedValue ? false : checked
	: group.indexOf(value) !== -1;

	let context = getContext("SMUI:checkbox:context");
	let dataTableHeader = getContext("SMUI:data-table:row:header");
	let getDataTableRowIndex = getContext("SMUI:data-table:row:getIndex");
	let instantiate = getContext("SMUI:checkbox:instantiate");
	let getInstance = getContext("SMUI:checkbox:getInstance");
	let previousChecked = checked;

	if (addChangeHandler) {
		addChangeHandler(handleChange);
	}

	onMount(async () => {
		if (instantiate !== false) {
			$$invalidate(20, checkbox = new MDCCheckbox(element));
		} else {
			if (context === "data-table") {
				if (dataTableHeader) {
					$$invalidate(20, checkbox = await getInstance(true));
				} else {
					$$invalidate(20, checkbox = (await getInstance(false))[getDataTableRowIndex()]);
				}
			} else {
				$$invalidate(20, checkbox = await getInstance());
			}
		}

		if (formField && formField()) {
			formField().input = checkbox;
		}
	});

	onDestroy(() => {
		if (instantiate !== false) {
			checkbox && checkbox.destroy();
		}
	});

	function handleChange() {
		if (group !== uninitializedValue) {
			const idx = group.indexOf(value);

			if (checkbox.checked && idx === -1) {
				group.push(value);
				$$invalidate(16, group);
			} else if (!checkbox.checked && idx !== -1) {
				group.splice(idx, 1);
				$$invalidate(16, group);
			}
		}
	}

	function getId() {
		return inputProps && inputProps.id;
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_change_handler() {
		nativeChecked = this.checked;
		((($$invalidate(7, nativeChecked), $$invalidate(17, checked)), $$invalidate(10, uninitializedValue)), $$invalidate(21, previousChecked));
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(8, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("indeterminate" in $$new_props) $$invalidate(18, indeterminate = $$new_props.indeterminate);
		if ("group" in $$new_props) $$invalidate(16, group = $$new_props.group);
		if ("checked" in $$new_props) $$invalidate(17, checked = $$new_props.checked);
		if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
	};

	$$self.$capture_state = () => ({
		MDCCheckbox,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		disabled,
		indeterminate,
		group,
		checked,
		value,
		valueKey,
		input$use,
		input$class,
		element,
		checkbox,
		formField,
		inputProps,
		setChecked,
		addChangeHandler,
		nativeChecked,
		context,
		dataTableHeader,
		getDataTableRowIndex,
		instantiate,
		getInstance,
		previousChecked,
		handleChange,
		getId
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("uninitializedValue" in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("indeterminate" in $$props) $$invalidate(18, indeterminate = $$new_props.indeterminate);
		if ("group" in $$props) $$invalidate(16, group = $$new_props.group);
		if ("checked" in $$props) $$invalidate(17, checked = $$new_props.checked);
		if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$props) $$invalidate(6, input$class = $$new_props.input$class);
		if ("element" in $$props) $$invalidate(8, element = $$new_props.element);
		if ("checkbox" in $$props) $$invalidate(20, checkbox = $$new_props.checkbox);
		if ("formField" in $$props) formField = $$new_props.formField;
		if ("inputProps" in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
		if ("setChecked" in $$props) $$invalidate(27, setChecked = $$new_props.setChecked);
		if ("addChangeHandler" in $$props) addChangeHandler = $$new_props.addChangeHandler;
		if ("nativeChecked" in $$props) $$invalidate(7, nativeChecked = $$new_props.nativeChecked);
		if ("context" in $$props) $$invalidate(12, context = $$new_props.context);
		if ("dataTableHeader" in $$props) $$invalidate(13, dataTableHeader = $$new_props.dataTableHeader);
		if ("getDataTableRowIndex" in $$props) getDataTableRowIndex = $$new_props.getDataTableRowIndex;
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
		if ("previousChecked" in $$props) $$invalidate(21, previousChecked = $$new_props.previousChecked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*checked, previousChecked, nativeChecked*/ 2228352) {
			 if (checked !== uninitializedValue) {
				if (checked === previousChecked) {
					$$invalidate(17, checked = nativeChecked);
				} else if (nativeChecked !== checked) {
					$$invalidate(7, nativeChecked = checked);
				}

				$$invalidate(21, previousChecked = checked);
			}
		}

		if ($$self.$$.dirty[0] & /*nativeChecked*/ 128) {
			 if (setChecked) {
				setChecked(nativeChecked);
			}
		}

		if ($$self.$$.dirty[0] & /*checkbox, indeterminate*/ 1310720) {
			 if (checkbox && indeterminate !== uninitializedValue && checkbox.indeterminate !== indeterminate) {
				$$invalidate(20, checkbox.indeterminate = indeterminate, checkbox);
			}
		}

		if ($$self.$$.dirty[0] & /*checkbox, group, value, checked*/ 1245192) {
			 if (checkbox) {
				if (group !== uninitializedValue) {
					const isChecked = group.indexOf(value) !== -1;

					if (checkbox.checked !== isChecked) {
						$$invalidate(20, checkbox.checked = isChecked, checkbox);
					}
				} else if (checked !== uninitializedValue && checkbox.checked !== checked) {
					$$invalidate(20, checkbox.checked = checked, checkbox);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*checkbox, disabled*/ 1048580) {
			 if (checkbox && checkbox.disabled !== disabled) {
				$$invalidate(20, checkbox.disabled = disabled, checkbox);
			}
		}

		if ($$self.$$.dirty[0] & /*checkbox, valueKey, value*/ 1048600) {
			 if (checkbox && valueKey === uninitializedValue && checkbox.value !== value) {
				$$invalidate(20, checkbox.value = value, checkbox);
			}
		}

		if ($$self.$$.dirty[0] & /*checkbox, valueKey*/ 1048592) {
			 if (checkbox && valueKey !== uninitializedValue && checkbox.value !== valueKey) {
				$$invalidate(20, checkbox.value = valueKey, checkbox);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		disabled,
		value,
		valueKey,
		input$use,
		input$class,
		nativeChecked,
		element,
		forwardEvents,
		uninitializedValue,
		inputProps,
		context,
		dataTableHeader,
		handleChange,
		$$props,
		group,
		checked,
		indeterminate,
		getId,
		checkbox,
		previousChecked,
		input_handler,
		change_handler,
		input_change_handler,
		div2_binding
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$o,
			create_fragment$o,
			safe_not_equal,
			{
				use: 0,
				class: 1,
				disabled: 2,
				indeterminate: 18,
				group: 16,
				checked: 17,
				value: 3,
				valueKey: 4,
				input$use: 5,
				input$class: 6,
				getId: 19
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$o.name
		});
	}

	get use() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueKey() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueKey(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$use() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$use(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$class() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$class(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getId() {
		return this.$$.ctx[19];
	}

	set getId(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$c = {
    ROOT: 'mdc-form-field',
};
var strings$c = {
    LABEL_SELECTOR: '.mdc-form-field > label',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFormFieldFoundation = /** @class */ (function (_super) {
    __extends(MDCFormFieldFoundation, _super);
    function MDCFormFieldFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCFormFieldFoundation.defaultAdapter, adapter)) || this;
        _this.clickHandler_ = function () { return _this.handleClick_(); };
        return _this;
    }
    Object.defineProperty(MDCFormFieldFoundation, "cssClasses", {
        get: function () {
            return cssClasses$c;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation, "strings", {
        get: function () {
            return strings$c;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation, "defaultAdapter", {
        get: function () {
            return {
                activateInputRipple: function () { return undefined; },
                deactivateInputRipple: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
                registerInteractionHandler: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCFormFieldFoundation.prototype.init = function () {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    };
    MDCFormFieldFoundation.prototype.destroy = function () {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    };
    MDCFormFieldFoundation.prototype.handleClick_ = function () {
        var _this = this;
        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () { return _this.adapter_.deactivateInputRipple(); });
    };
    return MDCFormFieldFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFormField = /** @class */ (function (_super) {
    __extends(MDCFormField, _super);
    function MDCFormField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFormField.attachTo = function (root) {
        return new MDCFormField(root);
    };
    Object.defineProperty(MDCFormField.prototype, "input", {
        get: function () {
            return this.input_;
        },
        set: function (input) {
            this.input_ = input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCFormField.prototype, "label_", {
        get: function () {
            var LABEL_SELECTOR = MDCFormFieldFoundation.strings.LABEL_SELECTOR;
            return this.root_.querySelector(LABEL_SELECTOR);
        },
        enumerable: true,
        configurable: true
    });
    MDCFormField.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            activateInputRipple: function () {
                if (_this.input_ && _this.input_.ripple) {
                    _this.input_.ripple.activate();
                }
            },
            deactivateInputRipple: function () {
                if (_this.input_ && _this.input_.ripple) {
                    _this.input_.ripple.deactivate();
                }
            },
            deregisterInteractionHandler: function (evtType, handler) {
                if (_this.label_) {
                    _this.label_.removeEventListener(evtType, handler);
                }
            },
            registerInteractionHandler: function (evtType, handler) {
                if (_this.label_) {
                    _this.label_.addEventListener(evtType, handler);
                }
            },
        };
        return new MDCFormFieldFoundation(adapter);
    };
    return MDCFormField;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\form-field\FormField.svelte generated by Svelte v3.31.2 */
const file$p = "node_modules\\@smui\\form-field\\FormField.svelte";
const get_label_slot_changes$1 = dirty => ({});
const get_label_slot_context$1 = ctx => ({});

function create_fragment$p(ctx) {
	let div;
	let t;
	let label;
	let useActions_action;
	let div_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	const label_slot_template = /*#slots*/ ctx[9].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[8], get_label_slot_context$1);

	let label_levels = [
		{ for: /*inputId*/ ctx[3] },
		exclude(prefixFilter(/*$$props*/ ctx[7], "label$"), ["use"])
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	let div_levels = [
		{
			class: div_class_value = "\n    mdc-form-field\n    " + /*className*/ ctx[1] + "\n    " + (/*align*/ ctx[2] === "end"
			? "mdc-form-field--align-end"
			: "") + "\n  "
		},
		exclude(/*$$props*/ ctx[7], ["use", "class", "alignEnd", "inputId", "label$"])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			label = element("label");
			if (label_slot) label_slot.c();
			set_attributes(label, label_data);
			add_location(label, file$p, 12, 2, 271);
			set_attributes(div, div_data);
			add_location(div, file$p, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			append_dev(div, label);

			if (label_slot) {
				label_slot.m(label, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, label, /*label$use*/ ctx[4])),
					action_destroyer(useActions_action_1 = useActions.call(null, div, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[6].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (label_slot) {
				if (label_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_label_slot_changes$1, get_label_slot_context$1);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*inputId*/ 8) && { for: /*inputId*/ ctx[3] },
				dirty & /*$$props*/ 128 && exclude(prefixFilter(/*$$props*/ ctx[7], "label$"), ["use"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*label$use*/ 16) useActions_action.update.call(null, /*label$use*/ ctx[4]);

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*className, align*/ 6 && div_class_value !== (div_class_value = "\n    mdc-form-field\n    " + /*className*/ ctx[1] + "\n    " + (/*align*/ ctx[2] === "end"
				? "mdc-form-field--align-end"
				: "") + "\n  ")) && { class: div_class_value },
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ["use", "class", "alignEnd", "inputId", "label$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (label_slot) label_slot.d(detaching);
			/*div_binding*/ ctx[10](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let counter = 0;

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FormField", slots, ['default','label']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { align = "start" } = $$props;
	let { inputId = "SMUI-form-field-" + counter++ } = $$props;
	let { label$use = [] } = $$props;
	let element;
	let formField;
	setContext("SMUI:form-field", () => formField);
	setContext("SMUI:generic:input:props", { id: inputId });

	onMount(() => {
		formField = new MDCFormField(element);
	});

	onDestroy(() => {
		formField && formField.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(5, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("align" in $$new_props) $$invalidate(2, align = $$new_props.align);
		if ("inputId" in $$new_props) $$invalidate(3, inputId = $$new_props.inputId);
		if ("label$use" in $$new_props) $$invalidate(4, label$use = $$new_props.label$use);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		counter,
		MDCFormField,
		onMount,
		onDestroy,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		align,
		inputId,
		label$use,
		element,
		formField
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("align" in $$props) $$invalidate(2, align = $$new_props.align);
		if ("inputId" in $$props) $$invalidate(3, inputId = $$new_props.inputId);
		if ("label$use" in $$props) $$invalidate(4, label$use = $$new_props.label$use);
		if ("element" in $$props) $$invalidate(5, element = $$new_props.element);
		if ("formField" in $$props) formField = $$new_props.formField;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		align,
		inputId,
		label$use,
		element,
		forwardEvents,
		$$props,
		$$scope,
		slots,
		div_binding
	];
}

class FormField extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			use: 0,
			class: 1,
			align: 2,
			inputId: 3,
			label$use: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FormField",
			options,
			id: create_fragment$p.name
		});
	}

	get use() {
		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label$use() {
		throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label$use(value) {
		throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$d = {
    ICON_BUTTON_ON: 'mdc-icon-button--on',
    ROOT: 'mdc-icon-button',
};
var strings$d = {
    ARIA_PRESSED: 'aria-pressed',
    CHANGE_EVENT: 'MDCIconButtonToggle:change',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCIconButtonToggleFoundation = /** @class */ (function (_super) {
    __extends(MDCIconButtonToggleFoundation, _super);
    function MDCIconButtonToggleFoundation(adapter) {
        return _super.call(this, __assign({}, MDCIconButtonToggleFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCIconButtonToggleFoundation, "cssClasses", {
        get: function () {
            return cssClasses$d;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggleFoundation, "strings", {
        get: function () {
            return strings$d;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggleFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClass: function () { return undefined; },
                hasClass: function () { return false; },
                notifyChange: function () { return undefined; },
                removeClass: function () { return undefined; },
                setAttr: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCIconButtonToggleFoundation.prototype.init = function () {
        this.adapter_.setAttr(strings$d.ARIA_PRESSED, "" + this.isOn());
    };
    MDCIconButtonToggleFoundation.prototype.handleClick = function () {
        this.toggle();
        this.adapter_.notifyChange({ isOn: this.isOn() });
    };
    MDCIconButtonToggleFoundation.prototype.isOn = function () {
        return this.adapter_.hasClass(cssClasses$d.ICON_BUTTON_ON);
    };
    MDCIconButtonToggleFoundation.prototype.toggle = function (isOn) {
        if (isOn === void 0) { isOn = !this.isOn(); }
        if (isOn) {
            this.adapter_.addClass(cssClasses$d.ICON_BUTTON_ON);
        }
        else {
            this.adapter_.removeClass(cssClasses$d.ICON_BUTTON_ON);
        }
        this.adapter_.setAttr(strings$d.ARIA_PRESSED, "" + isOn);
    };
    return MDCIconButtonToggleFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$e = MDCIconButtonToggleFoundation.strings;
var MDCIconButtonToggle = /** @class */ (function (_super) {
    __extends(MDCIconButtonToggle, _super);
    function MDCIconButtonToggle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCIconButtonToggle.attachTo = function (root) {
        return new MDCIconButtonToggle(root);
    };
    MDCIconButtonToggle.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleClick_ = function () { return _this.foundation_.handleClick(); };
        this.listen('click', this.handleClick_);
    };
    MDCIconButtonToggle.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCIconButtonToggle.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            notifyChange: function (evtData) { return _this.emit(strings$e.CHANGE_EVENT, evtData); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            setAttr: function (attrName, attrValue) { return _this.root_.setAttribute(attrName, attrValue); },
        };
        return new MDCIconButtonToggleFoundation(adapter);
    };
    Object.defineProperty(MDCIconButtonToggle.prototype, "ripple", {
        get: function () {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCIconButtonToggle.prototype, "on", {
        get: function () {
            return this.foundation_.isOn();
        },
        set: function (isOn) {
            this.foundation_.toggle(isOn);
        },
        enumerable: true,
        configurable: true
    });
    MDCIconButtonToggle.prototype.createRipple_ = function () {
        var ripple = new MDCRipple(this.root_);
        ripple.unbounded = true;
        return ripple;
    };
    return MDCIconButtonToggle;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\icon-button\IconButton.svelte generated by Svelte v3.31.2 */
const file$q = "node_modules\\@smui\\icon-button\\IconButton.svelte";

// (23:0) {:else}
function create_else_block$2(ctx) {
	let button;
	let button_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	let button_levels = [
		{
			class: button_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? "mdc-icon-button--on" : "") + "\n      " + (/*context*/ ctx[10] === "card:action"
			? "mdc-card__action"
			: "") + "\n      " + (/*context*/ ctx[10] === "card:action"
			? "mdc-card__action--icon"
			: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:navigation"
			? "mdc-top-app-bar__navigation-icon"
			: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:action"
			? "mdc-top-app-bar__action-item"
			: "") + "\n      " + (/*context*/ ctx[10] === "snackbar"
			? "mdc-snackbar__dismiss"
			: "") + "\n    "
		},
		{ "aria-hidden": "true" },
		{ "aria-pressed": /*pressed*/ ctx[0] },
		/*props*/ ctx[8]
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$q, 23, 2, 769);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			/*button_binding*/ ctx[17](button);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, button, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, button)),
					action_destroyer(Ripple_action = Ripple.call(null, button, {
						ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
						unbounded: true,
						color: /*color*/ ctx[4]
					})),
					listen_dev(button, "MDCIconButtonToggle:change", /*handleChange*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty & /*className, pressed*/ 5 && button_class_value !== (button_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? "mdc-icon-button--on" : "") + "\n      " + (/*context*/ ctx[10] === "card:action"
				? "mdc-card__action"
				: "") + "\n      " + (/*context*/ ctx[10] === "card:action"
				? "mdc-card__action--icon"
				: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:navigation"
				? "mdc-top-app-bar__navigation-icon"
				: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:action"
				? "mdc-top-app-bar__action-item"
				: "") + "\n      " + (/*context*/ ctx[10] === "snackbar"
				? "mdc-snackbar__dismiss"
				: "") + "\n    ")) && { class: button_class_value },
				{ "aria-hidden": "true" },
				(!current || dirty & /*pressed*/ 1) && { "aria-pressed": /*pressed*/ ctx[0] },
				dirty & /*props*/ 256 && /*props*/ ctx[8]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, toggle, color*/ 56) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
				unbounded: true,
				color: /*color*/ ctx[4]
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			/*button_binding*/ ctx[17](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(23:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if href}
function create_if_block$7(ctx) {
	let a;
	let a_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	let a_levels = [
		{
			class: a_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? "mdc-icon-button--on" : "") + "\n      " + (/*context*/ ctx[10] === "card:action"
			? "mdc-card__action"
			: "") + "\n      " + (/*context*/ ctx[10] === "card:action"
			? "mdc-card__action--icon"
			: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:navigation"
			? "mdc-top-app-bar__navigation-icon"
			: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:action"
			? "mdc-top-app-bar__action-item"
			: "") + "\n      " + (/*context*/ ctx[10] === "snackbar"
			? "mdc-snackbar__dismiss"
			: "") + "\n    "
		},
		{ "aria-hidden": "true" },
		{ "aria-pressed": /*pressed*/ ctx[0] },
		{ href: /*href*/ ctx[6] },
		/*props*/ ctx[8]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$q, 1, 2, 13);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[16](a);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, a)),
					action_destroyer(Ripple_action = Ripple.call(null, a, {
						ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
						unbounded: true,
						color: /*color*/ ctx[4]
					})),
					listen_dev(a, "MDCIconButtonToggle:change", /*handleChange*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*className, pressed*/ 5 && a_class_value !== (a_class_value = "\n      mdc-icon-button\n      " + /*className*/ ctx[2] + "\n      " + (/*pressed*/ ctx[0] ? "mdc-icon-button--on" : "") + "\n      " + (/*context*/ ctx[10] === "card:action"
				? "mdc-card__action"
				: "") + "\n      " + (/*context*/ ctx[10] === "card:action"
				? "mdc-card__action--icon"
				: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:navigation"
				? "mdc-top-app-bar__navigation-icon"
				: "") + "\n      " + (/*context*/ ctx[10] === "top-app-bar:action"
				? "mdc-top-app-bar__action-item"
				: "") + "\n      " + (/*context*/ ctx[10] === "snackbar"
				? "mdc-snackbar__dismiss"
				: "") + "\n    ")) && { class: a_class_value },
				{ "aria-hidden": "true" },
				(!current || dirty & /*pressed*/ 1) && { "aria-pressed": /*pressed*/ ctx[0] },
				(!current || dirty & /*href*/ 64) && { href: /*href*/ ctx[6] },
				dirty & /*props*/ 256 && /*props*/ ctx[8]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, toggle, color*/ 56) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[3] && !/*toggle*/ ctx[5],
				unbounded: true,
				color: /*color*/ ctx[4]
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(1:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$7, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let props;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("IconButton", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCIconButtonToggle:change"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { color = null } = $$props;
	let { toggle = false } = $$props;
	let { pressed = false } = $$props;
	let { href = null } = $$props;
	let element;
	let toggleButton;
	let context = getContext("SMUI:icon-button:context");
	setContext("SMUI:icon:context", "icon-button");
	let oldToggle = null;

	onDestroy(() => {
		toggleButton && toggleButton.destroy();
	});

	function handleChange(e) {
		$$invalidate(0, pressed = e.detail.isOn);
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(7, element);
		});
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(7, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ("toggle" in $$new_props) $$invalidate(5, toggle = $$new_props.toggle);
		if ("pressed" in $$new_props) $$invalidate(0, pressed = $$new_props.pressed);
		if ("href" in $$new_props) $$invalidate(6, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCIconButtonToggle,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		Ripple,
		forwardEvents,
		use,
		className,
		ripple,
		color,
		toggle,
		pressed,
		href,
		element,
		toggleButton,
		context,
		oldToggle,
		handleChange,
		props
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
		if ("toggle" in $$props) $$invalidate(5, toggle = $$new_props.toggle);
		if ("pressed" in $$props) $$invalidate(0, pressed = $$new_props.pressed);
		if ("href" in $$props) $$invalidate(6, href = $$new_props.href);
		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
		if ("toggleButton" in $$props) $$invalidate(12, toggleButton = $$new_props.toggleButton);
		if ("context" in $$props) $$invalidate(10, context = $$new_props.context);
		if ("oldToggle" in $$props) $$invalidate(13, oldToggle = $$new_props.oldToggle);
		if ("props" in $$props) $$invalidate(8, props = $$new_props.props);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(8, props = exclude($$props, ["use", "class", "ripple", "color", "toggle", "pressed", "href"]));

		if ($$self.$$.dirty & /*element, toggle, oldToggle, ripple, toggleButton, pressed*/ 12457) {
			 if (element && toggle !== oldToggle) {
				if (toggle) {
					$$invalidate(12, toggleButton = new MDCIconButtonToggle(element));

					if (!ripple) {
						toggleButton.ripple.destroy();
					}

					$$invalidate(12, toggleButton.on = pressed, toggleButton);
				} else if (oldToggle) {
					toggleButton && toggleButton.destroy();
					$$invalidate(12, toggleButton = null);
				}

				$$invalidate(13, oldToggle = toggle);
			}
		}

		if ($$self.$$.dirty & /*toggleButton, pressed*/ 4097) {
			 if (toggleButton && toggleButton.on !== pressed) {
				$$invalidate(12, toggleButton.on = pressed, toggleButton);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		pressed,
		use,
		className,
		ripple,
		color,
		toggle,
		href,
		element,
		props,
		forwardEvents,
		context,
		handleChange,
		toggleButton,
		oldToggle,
		$$scope,
		slots,
		a_binding,
		button_binding
	];
}

class IconButton extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			use: 1,
			class: 2,
			ripple: 3,
			color: 4,
			toggle: 5,
			pressed: 0,
			href: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconButton",
			options,
			id: create_fragment$q.name
		});
	}

	get use() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pressed() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pressed(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/** CSS classes used by the switch. */
var cssClasses$e = {
    /** Class used for a switch that is in the "checked" (on) position. */
    CHECKED: 'mdc-switch--checked',
    /** Class used for a switch that is disabled. */
    DISABLED: 'mdc-switch--disabled',
};
/** String constants used by the switch. */
var strings$f = {
    /** A CSS selector used to locate the native HTML control for the switch.  */
    NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
    /** A CSS selector used to locate the ripple surface element for the switch. */
    RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSwitchFoundation = /** @class */ (function (_super) {
    __extends(MDCSwitchFoundation, _super);
    function MDCSwitchFoundation(adapter) {
        return _super.call(this, __assign({}, MDCSwitchFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCSwitchFoundation, "strings", {
        /** The string constants used by the switch. */
        get: function () {
            return strings$f;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitchFoundation, "cssClasses", {
        /** The CSS classes used by the switch. */
        get: function () {
            return cssClasses$e;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitchFoundation, "defaultAdapter", {
        /** The default Adapter for the switch. */
        get: function () {
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                setNativeControlChecked: function () { return undefined; },
                setNativeControlDisabled: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    /** Sets the checked state of the switch. */
    MDCSwitchFoundation.prototype.setChecked = function (checked) {
        this.adapter_.setNativeControlChecked(checked);
        this.updateCheckedStyling_(checked);
    };
    /** Sets the disabled state of the switch. */
    MDCSwitchFoundation.prototype.setDisabled = function (disabled) {
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(cssClasses$e.DISABLED);
        }
        else {
            this.adapter_.removeClass(cssClasses$e.DISABLED);
        }
    };
    /** Handles the change event for the switch native control. */
    MDCSwitchFoundation.prototype.handleChange = function (evt) {
        var nativeControl = evt.target;
        this.updateCheckedStyling_(nativeControl.checked);
    };
    /** Updates the styling of the switch based on its checked state. */
    MDCSwitchFoundation.prototype.updateCheckedStyling_ = function (checked) {
        if (checked) {
            this.adapter_.addClass(cssClasses$e.CHECKED);
        }
        else {
            this.adapter_.removeClass(cssClasses$e.CHECKED);
        }
    };
    return MDCSwitchFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSwitch = /** @class */ (function (_super) {
    __extends(MDCSwitch, _super);
    function MDCSwitch() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCSwitch.attachTo = function (root) {
        return new MDCSwitch(root);
    };
    MDCSwitch.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.ripple_.destroy();
        this.nativeControl_.removeEventListener('change', this.changeHandler_);
    };
    MDCSwitch.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.changeHandler_ = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = _this.foundation_).handleChange.apply(_a, __spread(args));
        };
        this.nativeControl_.addEventListener('change', this.changeHandler_);
        // Sometimes the checked state of the input element is saved in the history.
        // The switch styling should match the checked state of the input element.
        // Do an initial sync between the native control and the foundation.
        this.checked = this.checked;
    };
    MDCSwitch.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            setNativeControlChecked: function (checked) { return _this.nativeControl_.checked = checked; },
            setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
        };
        return new MDCSwitchFoundation(adapter);
    };
    Object.defineProperty(MDCSwitch.prototype, "ripple", {
        get: function () {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitch.prototype, "checked", {
        get: function () {
            return this.nativeControl_.checked;
        },
        set: function (checked) {
            this.foundation_.setChecked(checked);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSwitch.prototype, "disabled", {
        get: function () {
            return this.nativeControl_.disabled;
        },
        set: function (disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    MDCSwitch.prototype.createRipple_ = function () {
        var _this = this;
        var RIPPLE_SURFACE_SELECTOR = MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
        var rippleSurface = this.root_.querySelector(RIPPLE_SURFACE_SELECTOR);
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign({}, MDCRipple.createAdapter(this), { addClass: function (className) { return rippleSurface.classList.add(className); }, computeBoundingRect: function () { return rippleSurface.getBoundingClientRect(); }, deregisterInteractionHandler: function (evtType, handler) {
                _this.nativeControl_.removeEventListener(evtType, handler, applyPassive());
            }, isSurfaceActive: function () { return matches(_this.nativeControl_, ':active'); }, isUnbounded: function () { return true; }, registerInteractionHandler: function (evtType, handler) {
                _this.nativeControl_.addEventListener(evtType, handler, applyPassive());
            }, removeClass: function (className) { return rippleSurface.classList.remove(className); }, updateCssVariable: function (varName, value) {
                rippleSurface.style.setProperty(varName, value);
            } });
        return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
    };
    Object.defineProperty(MDCSwitch.prototype, "nativeControl_", {
        get: function () {
            var NATIVE_CONTROL_SELECTOR = MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
            return this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
        },
        enumerable: true,
        configurable: true
    });
    return MDCSwitch;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\switch\Switch.svelte generated by Svelte v3.31.2 */
const file$r = "node_modules\\@smui\\switch\\Switch.svelte";

function create_fragment$r(ctx) {
	let div3;
	let div0;
	let t;
	let div2;
	let div1;
	let input;
	let input_class_value;
	let input_value_value;
	let useActions_action;
	let div3_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let input_levels = [
		exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"]),
		{ type: "checkbox" },
		{ role: "switch" },
		/*inputProps*/ ctx[11],
		{ disabled: /*disabled*/ ctx[2] },
		{
			class: input_class_value = "mdc-switch__native-control " + /*input$class*/ ctx[6]
		},
		{
			__value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
			? /*value*/ ctx[3]
			: /*valueKey*/ ctx[4]
		}
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	let div3_levels = [
		{
			class: div3_class_value = "\n    mdc-switch\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-switch--disabled" : "") + "\n    " + (/*nativeChecked*/ ctx[7] ? "mdc-switch--checked" : "") + "\n  "
		},
		exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "checked", "value", "input$"])
	];

	let div3_data = {};

	for (let i = 0; i < div3_levels.length; i += 1) {
		div3_data = assign(div3_data, div3_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t = space();
			div2 = element("div");
			div1 = element("div");
			input = element("input");
			attr_dev(div0, "class", "mdc-switch__track");
			add_location(div0, file$r, 12, 2, 306);
			set_attributes(input, input_data);
			add_location(input, file$r, 15, 6, 429);
			attr_dev(div1, "class", "mdc-switch__thumb");
			add_location(div1, file$r, 14, 4, 391);
			attr_dev(div2, "class", "mdc-switch__thumb-underlay");
			add_location(div2, file$r, 13, 2, 346);
			set_attributes(div3, div3_data);
			add_location(div3, file$r, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, input);
			input.checked = /*nativeChecked*/ ctx[7];
			/*div3_binding*/ ctx[22](div3);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
					listen_dev(input, "change", /*input_change_handler*/ ctx[21]),
					listen_dev(input, "change", /*handleChange*/ ctx[12], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[19], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[20], false, false, false),
					action_destroyer(useActions_action_1 = useActions.call(null, div3, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, div3))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty & /*$$props*/ 8192 && exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"]),
				{ type: "checkbox" },
				{ role: "switch" },
				/*inputProps*/ ctx[11],
				dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
				dirty & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-switch__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
				dirty & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
				? /*value*/ ctx[3]
				: /*valueKey*/ ctx[4]) && { __value: input_value_value }
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

			if (dirty & /*nativeChecked*/ 128) {
				input.checked = /*nativeChecked*/ ctx[7];
			}

			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
				dirty & /*className, disabled, nativeChecked*/ 134 && div3_class_value !== (div3_class_value = "\n    mdc-switch\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-switch--disabled" : "") + "\n    " + (/*nativeChecked*/ ctx[7] ? "mdc-switch--checked" : "") + "\n  ") && { class: div3_class_value },
				dirty & /*$$props*/ 8192 && exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "checked", "value", "input$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			/*div3_binding*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Switch", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component());

	let uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { disabled = false } = $$props;
	let { group = uninitializedValue } = $$props;
	let { checked = uninitializedValue } = $$props;
	let { value = null } = $$props;
	let { valueKey = uninitializedValue } = $$props;
	let { input$use = [] } = $$props;
	let { input$class = "" } = $$props;
	let element;
	let switchControl;
	let formField = getContext("SMUI:form-field");
	let inputProps = getContext("SMUI:generic:input:props") || {};
	let setChecked = getContext("SMUI:generic:input:setChecked");

	let nativeChecked = group === uninitializedValue
	? checked === uninitializedValue ? false : checked
	: group.indexOf(value) !== -1;

	let previousChecked = checked;

	onMount(() => {
		$$invalidate(17, switchControl = new MDCSwitch(element));

		if (formField && formField()) {
			formField().input = switchControl;
		}
	});

	onDestroy(() => {
		switchControl && switchControl.destroy();
	});

	function handleChange(e) {
		if (group !== uninitializedValue) {
			const idx = group.indexOf(value);

			if (switchControl.checked && idx === -1) {
				group.push(value);
				$$invalidate(14, group);
			} else if (!switchControl.checked && idx !== -1) {
				group.splice(idx, 1);
				$$invalidate(14, group);
			}
		}
	}

	function getId() {
		return inputProps && inputProps.id;
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function input_change_handler() {
		nativeChecked = this.checked;
		((($$invalidate(7, nativeChecked), $$invalidate(15, checked)), $$invalidate(10, uninitializedValue)), $$invalidate(18, previousChecked));
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(8, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$new_props) $$invalidate(14, group = $$new_props.group);
		if ("checked" in $$new_props) $$invalidate(15, checked = $$new_props.checked);
		if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
	};

	$$self.$capture_state = () => ({
		MDCSwitch,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		disabled,
		group,
		checked,
		value,
		valueKey,
		input$use,
		input$class,
		element,
		switchControl,
		formField,
		inputProps,
		setChecked,
		nativeChecked,
		previousChecked,
		handleChange,
		getId
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("uninitializedValue" in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$props) $$invalidate(14, group = $$new_props.group);
		if ("checked" in $$props) $$invalidate(15, checked = $$new_props.checked);
		if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$props) $$invalidate(6, input$class = $$new_props.input$class);
		if ("element" in $$props) $$invalidate(8, element = $$new_props.element);
		if ("switchControl" in $$props) $$invalidate(17, switchControl = $$new_props.switchControl);
		if ("formField" in $$props) formField = $$new_props.formField;
		if ("inputProps" in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
		if ("setChecked" in $$props) $$invalidate(24, setChecked = $$new_props.setChecked);
		if ("nativeChecked" in $$props) $$invalidate(7, nativeChecked = $$new_props.nativeChecked);
		if ("previousChecked" in $$props) $$invalidate(18, previousChecked = $$new_props.previousChecked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*checked, previousChecked, nativeChecked*/ 295040) {
			 if (checked !== uninitializedValue) {
				if (checked === previousChecked) {
					$$invalidate(15, checked = nativeChecked);
				} else if (nativeChecked !== checked) {
					$$invalidate(7, nativeChecked = checked);
				}

				$$invalidate(18, previousChecked = checked);
			}
		}

		if ($$self.$$.dirty & /*nativeChecked*/ 128) {
			 if (setChecked) {
				setChecked(nativeChecked);
			}
		}

		if ($$self.$$.dirty & /*switchControl, group, value, checked*/ 180232) {
			 if (switchControl) {
				if (group !== uninitializedValue) {
					const isChecked = group.indexOf(value) !== -1;

					if (switchControl.checked !== isChecked) {
						$$invalidate(17, switchControl.checked = isChecked, switchControl);
					}
				} else if (checked !== uninitializedValue && switchControl.checked !== checked) {
					$$invalidate(17, switchControl.checked = checked, switchControl);
				}
			}
		}

		if ($$self.$$.dirty & /*switchControl, disabled*/ 131076) {
			 if (switchControl && switchControl.disabled !== disabled) {
				$$invalidate(17, switchControl.disabled = disabled, switchControl);
			}
		}

		if ($$self.$$.dirty & /*switchControl, valueKey, value*/ 131096) {
			 if (switchControl && valueKey === uninitializedValue && switchControl.value !== value) {
				$$invalidate(17, switchControl.value = value, switchControl);
			}
		}

		if ($$self.$$.dirty & /*switchControl, valueKey*/ 131088) {
			 if (switchControl && valueKey !== uninitializedValue && switchControl.value !== valueKey) {
				$$invalidate(17, switchControl.value = valueKey, switchControl);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		disabled,
		value,
		valueKey,
		input$use,
		input$class,
		nativeChecked,
		element,
		forwardEvents,
		uninitializedValue,
		inputProps,
		handleChange,
		$$props,
		group,
		checked,
		getId,
		switchControl,
		previousChecked,
		change_handler,
		input_handler,
		input_change_handler,
		div3_binding
	];
}

class Switch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			use: 0,
			class: 1,
			disabled: 2,
			group: 14,
			checked: 15,
			value: 3,
			valueKey: 4,
			input$use: 5,
			input$class: 6,
			getId: 16
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Switch",
			options,
			id: create_fragment$r.name
		});
	}

	get use() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueKey() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueKey(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$use() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$use(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$class() {
		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$class(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getId() {
		return this.$$.ctx[16];
	}

	set getId(value) {
		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomIconSwitch.svelte generated by Svelte v3.31.2 */

// (9:4) <Icon class="material-icons" on>
function create_default_slot_2$3(ctx) {
	let t_value = /*icons*/ ctx[1][0] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][0] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(9:4) <Icon class=\\\"material-icons\\\" on>",
		ctx
	});

	return block;
}

// (11:4) <Icon class="material-icons">
function create_default_slot_1$3(ctx) {
	let t_value = /*icons*/ ctx[1][1] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*icons*/ 2 && t_value !== (t_value = /*icons*/ ctx[1][1] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(11:4) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>
function create_default_slot$6(ctx) {
	let icon0;
	let t;
	let icon1;
	let current;

	icon0 = new Icon({
			props: {
				class: "material-icons",
				on: true,
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon1 = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon0.$$.fragment);
			t = space();
			create_component(icon1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(icon1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon0_changes = {};

			if (dirty & /*$$scope, icons*/ 34) {
				icon0_changes.$$scope = { dirty, ctx };
			}

			icon0.$set(icon0_changes);
			const icon1_changes = {};

			if (dirty & /*$$scope, icons*/ 34) {
				icon1_changes.$$scope = { dirty, ctx };
			}

			icon1.$set(icon1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(icon1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(7:0) <IconButton {style} toggle bind:pressed={toggler} on:click>",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let iconbutton;
	let updating_pressed;
	let current;

	function iconbutton_pressed_binding(value) {
		/*iconbutton_pressed_binding*/ ctx[3].call(null, value);
	}

	let iconbutton_props = {
		style: /*style*/ ctx[2],
		toggle: true,
		$$slots: { default: [create_default_slot$6] },
		$$scope: { ctx }
	};

	if (/*toggler*/ ctx[0] !== void 0) {
		iconbutton_props.pressed = /*toggler*/ ctx[0];
	}

	iconbutton = new IconButton({ props: iconbutton_props, $$inline: true });
	binding_callbacks.push(() => bind(iconbutton, "pressed", iconbutton_pressed_binding));
	iconbutton.$on("click", /*click_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbutton_changes = {};
			if (dirty & /*style*/ 4) iconbutton_changes.style = /*style*/ ctx[2];

			if (dirty & /*$$scope, icons*/ 34) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_pressed && dirty & /*toggler*/ 1) {
				updating_pressed = true;
				iconbutton_changes.pressed = /*toggler*/ ctx[0];
				add_flush_callback(() => updating_pressed = false);
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomIconSwitch", slots, []);
	let { icons = [] } = $$props, { toggler = "" } = $$props, { style = "" } = $$props;
	const writable_props = ["icons", "toggler", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomIconSwitch> was created with unknown prop '${key}'`);
	});

	function iconbutton_pressed_binding(value) {
		toggler = value;
		$$invalidate(0, toggler);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("icons" in $$props) $$invalidate(1, icons = $$props.icons);
		if ("toggler" in $$props) $$invalidate(0, toggler = $$props.toggler);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$capture_state = () => ({ IconButton, Icon, icons, toggler, style });

	$$self.$inject_state = $$props => {
		if ("icons" in $$props) $$invalidate(1, icons = $$props.icons);
		if ("toggler" in $$props) $$invalidate(0, toggler = $$props.toggler);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [toggler, icons, style, iconbutton_pressed_binding, click_handler];
}

class CustomIconSwitch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$s, create_fragment$s, safe_not_equal, { icons: 1, toggler: 0, style: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomIconSwitch",
			options,
			id: create_fragment$s.name
		});
	}

	get icons() {
		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icons(value) {
		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggler() {
		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggler(value) {
		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomIconSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomIconSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$f = {
    LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
    LIST_ITEM_CLASS: 'mdc-list-item',
    LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
    LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
    ROOT: 'mdc-list',
};
var strings$g = {
    ACTION_EVENT: 'MDCList:action',
    ARIA_CHECKED: 'aria-checked',
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: 'aria-current',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: 'aria-selected',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$f.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$f.LIST_ITEM_CLASS + " a\n  ",
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$f.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$f.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$f.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses$f.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled)\n  ",
    RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
};
var numbers$5 = {
    UNSET_INDEX: -1,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
function isNumberArray(selectedIndex) {
    return selectedIndex instanceof Array;
}
var MDCListFoundation = /** @class */ (function (_super) {
    __extends(MDCListFoundation, _super);
    function MDCListFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCListFoundation.defaultAdapter, adapter)) || this;
        _this.wrapFocus_ = false;
        _this.isVertical_ = true;
        _this.isSingleSelectionList_ = false;
        _this.selectedIndex_ = numbers$5.UNSET_INDEX;
        _this.focusedItemIndex_ = numbers$5.UNSET_INDEX;
        _this.useActivatedClass_ = false;
        _this.ariaCurrentAttrValue_ = null;
        _this.isCheckboxList_ = false;
        _this.isRadioList_ = false;
        return _this;
    }
    Object.defineProperty(MDCListFoundation, "strings", {
        get: function () {
            return strings$g;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "cssClasses", {
        get: function () {
            return cssClasses$f;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "numbers", {
        get: function () {
            return numbers$5;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCListFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClassForElementIndex: function () { return undefined; },
                focusItemAtIndex: function () { return undefined; },
                getAttributeForElementIndex: function () { return null; },
                getFocusedElementIndex: function () { return 0; },
                getListItemCount: function () { return 0; },
                hasCheckboxAtIndex: function () { return false; },
                hasRadioAtIndex: function () { return false; },
                isCheckboxCheckedAtIndex: function () { return false; },
                isFocusInsideList: function () { return false; },
                isRootFocused: function () { return false; },
                notifyAction: function () { return undefined; },
                removeClassForElementIndex: function () { return undefined; },
                setAttributeForElementIndex: function () { return undefined; },
                setCheckedCheckboxOrRadioAtIndex: function () { return undefined; },
                setTabIndexForListItemChildren: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCListFoundation.prototype.layout = function () {
        if (this.adapter_.getListItemCount() === 0) {
            return;
        }
        if (this.adapter_.hasCheckboxAtIndex(0)) {
            this.isCheckboxList_ = true;
        }
        else if (this.adapter_.hasRadioAtIndex(0)) {
            this.isRadioList_ = true;
        }
    };
    /**
     * Sets the private wrapFocus_ variable.
     */
    MDCListFoundation.prototype.setWrapFocus = function (value) {
        this.wrapFocus_ = value;
    };
    /**
     * Sets the isVertical_ private variable.
     */
    MDCListFoundation.prototype.setVerticalOrientation = function (value) {
        this.isVertical_ = value;
    };
    /**
     * Sets the isSingleSelectionList_ private variable.
     */
    MDCListFoundation.prototype.setSingleSelection = function (value) {
        this.isSingleSelectionList_ = value;
    };
    /**
     * Sets the useActivatedClass_ private variable.
     */
    MDCListFoundation.prototype.setUseActivatedClass = function (useActivated) {
        this.useActivatedClass_ = useActivated;
    };
    MDCListFoundation.prototype.getSelectedIndex = function () {
        return this.selectedIndex_;
    };
    MDCListFoundation.prototype.setSelectedIndex = function (index) {
        if (!this.isIndexValid_(index)) {
            return;
        }
        if (this.isCheckboxList_) {
            this.setCheckboxAtIndex_(index);
        }
        else if (this.isRadioList_) {
            this.setRadioAtIndex_(index);
        }
        else {
            this.setSingleSelectionAtIndex_(index);
        }
    };
    /**
     * Focus in handler for the list items.
     */
    MDCListFoundation.prototype.handleFocusIn = function (_, listItemIndex) {
        if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, '0');
        }
    };
    /**
     * Focus out handler for the list items.
     */
    MDCListFoundation.prototype.handleFocusOut = function (_, listItemIndex) {
        var _this = this;
        if (listItemIndex >= 0) {
            this.adapter_.setTabIndexForListItemChildren(listItemIndex, '-1');
        }
        /**
         * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
         * is moved to next element.
         */
        setTimeout(function () {
            if (!_this.adapter_.isFocusInsideList()) {
                _this.setTabindexToFirstSelectedItem_();
            }
        }, 0);
    };
    /**
     * Key handler for the list.
     */
    MDCListFoundation.prototype.handleKeydown = function (evt, isRootListItem, listItemIndex) {
        var isArrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
        var isArrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
        var isArrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
        var isArrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
        var isHome = evt.key === 'Home' || evt.keyCode === 36;
        var isEnd = evt.key === 'End' || evt.keyCode === 35;
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        var isSpace = evt.key === 'Space' || evt.keyCode === 32;
        if (this.adapter_.isRootFocused()) {
            if (isArrowUp || isEnd) {
                evt.preventDefault();
                this.focusLastElement();
            }
            else if (isArrowDown || isHome) {
                evt.preventDefault();
                this.focusFirstElement();
            }
            return;
        }
        var currentIndex = this.adapter_.getFocusedElementIndex();
        if (currentIndex === -1) {
            currentIndex = listItemIndex;
            if (currentIndex < 0) {
                // If this event doesn't have a mdc-list-item ancestor from the
                // current list (not from a sublist), return early.
                return;
            }
        }
        var nextIndex;
        if ((this.isVertical_ && isArrowDown) || (!this.isVertical_ && isArrowRight)) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusNextElement(currentIndex);
        }
        else if ((this.isVertical_ && isArrowUp) || (!this.isVertical_ && isArrowLeft)) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusPrevElement(currentIndex);
        }
        else if (isHome) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusFirstElement();
        }
        else if (isEnd) {
            this.preventDefaultEvent_(evt);
            nextIndex = this.focusLastElement();
        }
        else if (isEnter || isSpace) {
            if (isRootListItem) {
                // Return early if enter key is pressed on anchor element which triggers synthetic MouseEvent event.
                var target = evt.target;
                if (target && target.tagName === 'A' && isEnter) {
                    return;
                }
                this.preventDefaultEvent_(evt);
                if (this.isSelectableList_()) {
                    this.setSelectedIndexOnAction_(currentIndex);
                }
                this.adapter_.notifyAction(currentIndex);
            }
        }
        this.focusedItemIndex_ = currentIndex;
        if (nextIndex !== undefined) {
            this.setTabindexAtIndex_(nextIndex);
            this.focusedItemIndex_ = nextIndex;
        }
    };
    /**
     * Click handler for the list.
     */
    MDCListFoundation.prototype.handleClick = function (index, toggleCheckbox) {
        if (index === numbers$5.UNSET_INDEX) {
            return;
        }
        if (this.isSelectableList_()) {
            this.setSelectedIndexOnAction_(index, toggleCheckbox);
        }
        this.adapter_.notifyAction(index);
        this.setTabindexAtIndex_(index);
        this.focusedItemIndex_ = index;
    };
    /**
     * Focuses the next element on the list.
     */
    MDCListFoundation.prototype.focusNextElement = function (index) {
        var count = this.adapter_.getListItemCount();
        var nextIndex = index + 1;
        if (nextIndex >= count) {
            if (this.wrapFocus_) {
                nextIndex = 0;
            }
            else {
                // Return early because last item is already focused.
                return index;
            }
        }
        this.adapter_.focusItemAtIndex(nextIndex);
        return nextIndex;
    };
    /**
     * Focuses the previous element on the list.
     */
    MDCListFoundation.prototype.focusPrevElement = function (index) {
        var prevIndex = index - 1;
        if (prevIndex < 0) {
            if (this.wrapFocus_) {
                prevIndex = this.adapter_.getListItemCount() - 1;
            }
            else {
                // Return early because first item is already focused.
                return index;
            }
        }
        this.adapter_.focusItemAtIndex(prevIndex);
        return prevIndex;
    };
    MDCListFoundation.prototype.focusFirstElement = function () {
        this.adapter_.focusItemAtIndex(0);
        return 0;
    };
    MDCListFoundation.prototype.focusLastElement = function () {
        var lastIndex = this.adapter_.getListItemCount() - 1;
        this.adapter_.focusItemAtIndex(lastIndex);
        return lastIndex;
    };
    /**
     * @param itemIndex Index of the list item
     * @param isEnabled Sets the list item to enabled or disabled.
     */
    MDCListFoundation.prototype.setEnabled = function (itemIndex, isEnabled) {
        if (!this.isIndexValid_(itemIndex)) {
            return;
        }
        if (isEnabled) {
            this.adapter_.removeClassForElementIndex(itemIndex, cssClasses$f.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.setAttributeForElementIndex(itemIndex, strings$g.ARIA_DISABLED, 'false');
        }
        else {
            this.adapter_.addClassForElementIndex(itemIndex, cssClasses$f.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.setAttributeForElementIndex(itemIndex, strings$g.ARIA_DISABLED, 'true');
        }
    };
    /**
     * Ensures that preventDefault is only called if the containing element doesn't
     * consume the event, and it will cause an unintended scroll.
     */
    MDCListFoundation.prototype.preventDefaultEvent_ = function (evt) {
        var target = evt.target;
        var tagName = ("" + target.tagName).toLowerCase();
        if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
            evt.preventDefault();
        }
    };
    MDCListFoundation.prototype.setSingleSelectionAtIndex_ = function (index) {
        if (this.selectedIndex_ === index) {
            return;
        }
        var selectedClassName = cssClasses$f.LIST_ITEM_SELECTED_CLASS;
        if (this.useActivatedClass_) {
            selectedClassName = cssClasses$f.LIST_ITEM_ACTIVATED_CLASS;
        }
        if (this.selectedIndex_ !== numbers$5.UNSET_INDEX) {
            this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
        }
        this.adapter_.addClassForElementIndex(index, selectedClassName);
        this.setAriaForSingleSelectionAtIndex_(index);
        this.selectedIndex_ = index;
    };
    /**
     * Sets aria attribute for single selection at given index.
     */
    MDCListFoundation.prototype.setAriaForSingleSelectionAtIndex_ = function (index) {
        // Detect the presence of aria-current and get the value only during list initialization when it is in unset state.
        if (this.selectedIndex_ === numbers$5.UNSET_INDEX) {
            this.ariaCurrentAttrValue_ =
                this.adapter_.getAttributeForElementIndex(index, strings$g.ARIA_CURRENT);
        }
        var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
        var ariaAttribute = isAriaCurrent ? strings$g.ARIA_CURRENT : strings$g.ARIA_SELECTED;
        if (this.selectedIndex_ !== numbers$5.UNSET_INDEX) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
        }
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
        this.adapter_.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
    };
    /**
     * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
     */
    MDCListFoundation.prototype.setRadioAtIndex_ = function (index) {
        this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);
        if (this.selectedIndex_ !== numbers$5.UNSET_INDEX) {
            this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$g.ARIA_CHECKED, 'false');
        }
        this.adapter_.setAttributeForElementIndex(index, strings$g.ARIA_CHECKED, 'true');
        this.selectedIndex_ = index;
    };
    MDCListFoundation.prototype.setCheckboxAtIndex_ = function (index) {
        for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
            var isChecked = false;
            if (index.indexOf(i) >= 0) {
                isChecked = true;
            }
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
            this.adapter_.setAttributeForElementIndex(i, strings$g.ARIA_CHECKED, isChecked ? 'true' : 'false');
        }
        this.selectedIndex_ = index;
    };
    MDCListFoundation.prototype.setTabindexAtIndex_ = function (index) {
        if (this.focusedItemIndex_ === numbers$5.UNSET_INDEX && index !== 0) {
            // If no list item was selected set first list item's tabindex to -1.
            // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
            this.adapter_.setAttributeForElementIndex(0, 'tabindex', '-1');
        }
        else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
            this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', '-1');
        }
        this.adapter_.setAttributeForElementIndex(index, 'tabindex', '0');
    };
    /**
     * @return Return true if it is single selectin list, checkbox list or radio list.
     */
    MDCListFoundation.prototype.isSelectableList_ = function () {
        return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
    };
    MDCListFoundation.prototype.setTabindexToFirstSelectedItem_ = function () {
        var targetIndex = 0;
        if (this.isSelectableList_()) {
            if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== numbers$5.UNSET_INDEX) {
                targetIndex = this.selectedIndex_;
            }
            else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
                targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) { return Math.min(currentIndex, minIndex); });
            }
        }
        this.setTabindexAtIndex_(targetIndex);
    };
    MDCListFoundation.prototype.isIndexValid_ = function (index) {
        var _this = this;
        if (index instanceof Array) {
            if (!this.isCheckboxList_) {
                throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
            }
            if (index.length === 0) {
                return true;
            }
            else {
                return index.some(function (i) { return _this.isIndexInRange_(i); });
            }
        }
        else if (typeof index === 'number') {
            if (this.isCheckboxList_) {
                throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
            }
            return this.isIndexInRange_(index);
        }
        else {
            return false;
        }
    };
    MDCListFoundation.prototype.isIndexInRange_ = function (index) {
        var listSize = this.adapter_.getListItemCount();
        return index >= 0 && index < listSize;
    };
    MDCListFoundation.prototype.setSelectedIndexOnAction_ = function (index, toggleCheckbox) {
        if (toggleCheckbox === void 0) { toggleCheckbox = true; }
        if (this.isCheckboxList_) {
            this.toggleCheckboxAtIndex_(index, toggleCheckbox);
        }
        else {
            this.setSelectedIndex(index);
        }
    };
    MDCListFoundation.prototype.toggleCheckboxAtIndex_ = function (index, toggleCheckbox) {
        var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);
        if (toggleCheckbox) {
            isChecked = !isChecked;
            this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
        }
        this.adapter_.setAttributeForElementIndex(index, strings$g.ARIA_CHECKED, isChecked ? 'true' : 'false');
        // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.
        var selectedIndexes = this.selectedIndex_ === numbers$5.UNSET_INDEX ? [] : this.selectedIndex_.slice();
        if (isChecked) {
            selectedIndexes.push(index);
        }
        else {
            selectedIndexes = selectedIndexes.filter(function (i) { return i !== index; });
        }
        this.selectedIndex_ = selectedIndexes;
    };
    return MDCListFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCList = /** @class */ (function (_super) {
    __extends(MDCList, _super);
    function MDCList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCList.prototype, "vertical", {
        set: function (value) {
            this.foundation_.setVerticalOrientation(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "listElements", {
        get: function () {
            return [].slice.call(this.root_.querySelectorAll("." + cssClasses$f.LIST_ITEM_CLASS));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "wrapFocus", {
        set: function (value) {
            this.foundation_.setWrapFocus(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "singleSelection", {
        set: function (isSingleSelectionList) {
            this.foundation_.setSingleSelection(isSingleSelectionList);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCList.prototype, "selectedIndex", {
        get: function () {
            return this.foundation_.getSelectedIndex();
        },
        set: function (index) {
            this.foundation_.setSelectedIndex(index);
        },
        enumerable: true,
        configurable: true
    });
    MDCList.attachTo = function (root) {
        return new MDCList(root);
    };
    MDCList.prototype.initialSyncWithDOM = function () {
        this.handleClick_ = this.handleClickEvent_.bind(this);
        this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
        this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
        this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
        this.listen('keydown', this.handleKeydown_);
        this.listen('click', this.handleClick_);
        this.listen('focusin', this.focusInEventListener_);
        this.listen('focusout', this.focusOutEventListener_);
        this.layout();
        this.initializeListType();
    };
    MDCList.prototype.destroy = function () {
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten('click', this.handleClick_);
        this.unlisten('focusin', this.focusInEventListener_);
        this.unlisten('focusout', this.focusOutEventListener_);
    };
    MDCList.prototype.layout = function () {
        var direction = this.root_.getAttribute(strings$g.ARIA_ORIENTATION);
        this.vertical = direction !== strings$g.ARIA_ORIENTATION_HORIZONTAL;
        // List items need to have at least tabindex=-1 to be focusable.
        [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])'))
            .forEach(function (el) {
            el.setAttribute('tabindex', '-1');
        });
        // Child button/a elements are not tabbable until the list item is focused.
        [].slice.call(this.root_.querySelectorAll(strings$g.FOCUSABLE_CHILD_ELEMENTS))
            .forEach(function (el) { return el.setAttribute('tabindex', '-1'); });
        this.foundation_.layout();
    };
    /**
     * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
     */
    MDCList.prototype.initializeListType = function () {
        var _this = this;
        var checkboxListItems = this.root_.querySelectorAll(strings$g.ARIA_ROLE_CHECKBOX_SELECTOR);
        var singleSelectedListItem = this.root_.querySelector("\n      ." + cssClasses$f.LIST_ITEM_ACTIVATED_CLASS + ",\n      ." + cssClasses$f.LIST_ITEM_SELECTED_CLASS + "\n    ");
        var radioSelectedListItem = this.root_.querySelector(strings$g.ARIA_CHECKED_RADIO_SELECTOR);
        if (checkboxListItems.length) {
            var preselectedItems = this.root_.querySelectorAll(strings$g.ARIA_CHECKED_CHECKBOX_SELECTOR);
            this.selectedIndex =
                [].map.call(preselectedItems, function (listItem) { return _this.listElements.indexOf(listItem); });
        }
        else if (singleSelectedListItem) {
            if (singleSelectedListItem.classList.contains(cssClasses$f.LIST_ITEM_ACTIVATED_CLASS)) {
                this.foundation_.setUseActivatedClass(true);
            }
            this.singleSelection = true;
            this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
        }
        else if (radioSelectedListItem) {
            this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
        }
    };
    /**
     * Updates the list item at itemIndex to the desired isEnabled state.
     * @param itemIndex Index of the list item
     * @param isEnabled Sets the list item to enabled or disabled.
     */
    MDCList.prototype.setEnabled = function (itemIndex, isEnabled) {
        this.foundation_.setEnabled(itemIndex, isEnabled);
    };
    MDCList.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClassForElementIndex: function (index, className) {
                var element = _this.listElements[index];
                if (element) {
                    element.classList.add(className);
                }
            },
            focusItemAtIndex: function (index) {
                var element = _this.listElements[index];
                if (element) {
                    element.focus();
                }
            },
            getAttributeForElementIndex: function (index, attr) { return _this.listElements[index].getAttribute(attr); },
            getFocusedElementIndex: function () { return _this.listElements.indexOf(document.activeElement); },
            getListItemCount: function () { return _this.listElements.length; },
            hasCheckboxAtIndex: function (index) {
                var listItem = _this.listElements[index];
                return !!listItem.querySelector(strings$g.CHECKBOX_SELECTOR);
            },
            hasRadioAtIndex: function (index) {
                var listItem = _this.listElements[index];
                return !!listItem.querySelector(strings$g.RADIO_SELECTOR);
            },
            isCheckboxCheckedAtIndex: function (index) {
                var listItem = _this.listElements[index];
                var toggleEl = listItem.querySelector(strings$g.CHECKBOX_SELECTOR);
                return toggleEl.checked;
            },
            isFocusInsideList: function () {
                return _this.root_.contains(document.activeElement);
            },
            isRootFocused: function () { return document.activeElement === _this.root_; },
            notifyAction: function (index) {
                _this.emit(strings$g.ACTION_EVENT, { index: index }, /** shouldBubble */ true);
            },
            removeClassForElementIndex: function (index, className) {
                var element = _this.listElements[index];
                if (element) {
                    element.classList.remove(className);
                }
            },
            setAttributeForElementIndex: function (index, attr, value) {
                var element = _this.listElements[index];
                if (element) {
                    element.setAttribute(attr, value);
                }
            },
            setCheckedCheckboxOrRadioAtIndex: function (index, isChecked) {
                var listItem = _this.listElements[index];
                var toggleEl = listItem.querySelector(strings$g.CHECKBOX_RADIO_SELECTOR);
                toggleEl.checked = isChecked;
                var event = document.createEvent('Event');
                event.initEvent('change', true, true);
                toggleEl.dispatchEvent(event);
            },
            setTabIndexForListItemChildren: function (listItemIndex, tabIndexValue) {
                var element = _this.listElements[listItemIndex];
                var listItemChildren = [].slice.call(element.querySelectorAll(strings$g.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                listItemChildren.forEach(function (el) { return el.setAttribute('tabindex', tabIndexValue); });
            },
        };
        return new MDCListFoundation(adapter);
    };
    /**
     * Used to figure out which list item this event is targetting. Or returns -1 if
     * there is no list item
     */
    MDCList.prototype.getListItemIndex_ = function (evt) {
        var eventTarget = evt.target;
        var nearestParent = closest(eventTarget, "." + cssClasses$f.LIST_ITEM_CLASS + ", ." + cssClasses$f.ROOT);
        // Get the index of the element if it is a list item.
        if (nearestParent && matches(nearestParent, "." + cssClasses$f.LIST_ITEM_CLASS)) {
            return this.listElements.indexOf(nearestParent);
        }
        return -1;
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleFocusInEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusIn(evt, index);
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleFocusOutEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusOut(evt, index);
    };
    /**
     * Used to figure out which element was focused when keydown event occurred before sending the event to the
     * foundation.
     */
    MDCList.prototype.handleKeydownEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        var target = evt.target;
        this.foundation_.handleKeydown(evt, target.classList.contains(cssClasses$f.LIST_ITEM_CLASS), index);
    };
    /**
     * Used to figure out which element was clicked before sending the event to the foundation.
     */
    MDCList.prototype.handleClickEvent_ = function (evt) {
        var index = this.getListItemIndex_(evt);
        var target = evt.target;
        // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.
        var toggleCheckbox = !matches(target, strings$g.CHECKBOX_RADIO_SELECTOR);
        this.foundation_.handleClick(index, toggleCheckbox);
    };
    return MDCList;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\list\List.svelte generated by Svelte v3.31.2 */
const file$s = "node_modules\\@smui\\list\\List.svelte";

// (18:0) {:else}
function create_else_block$3(ctx) {
	let ul;
	let ul_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	let ul_levels = [
		{
			class: ul_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
			? "mdc-list--non-interactive"
			: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
			? "smui-list--three-line"
			: "") + "\n    "
		},
		{ role: /*role*/ ctx[8] },
		/*props*/ ctx[9]
	];

	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = assign(ul_data, ul_levels[i]);
	}

	const block = {
		c: function create() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			set_attributes(ul, ul_data);
			add_location(ul, file$s, 18, 2, 478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			/*ul_binding*/ ctx[26](ul);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, ul, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[10].call(null, ul)),
					listen_dev(ul, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 8388608) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[23], dirty, null, null);
				}
			}

			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
				(!current || dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && ul_class_value !== (ul_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
				? "mdc-list--non-interactive"
				: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
				? "smui-list--three-line"
				: "") + "\n    ")) && { class: ul_class_value },
				(!current || dirty[0] & /*role*/ 256) && { role: /*role*/ ctx[8] },
				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
			/*ul_binding*/ ctx[26](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(18:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if nav}
function create_if_block$8(ctx) {
	let nav_1;
	let nav_1_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	let nav_1_levels = [
		{
			class: nav_1_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
			? "mdc-list--non-interactive"
			: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
			? "smui-list--three-line"
			: "") + "\n    "
		},
		/*props*/ ctx[9]
	];

	let nav_1_data = {};

	for (let i = 0; i < nav_1_levels.length; i += 1) {
		nav_1_data = assign(nav_1_data, nav_1_levels[i]);
	}

	const block = {
		c: function create() {
			nav_1 = element("nav");
			if (default_slot) default_slot.c();
			set_attributes(nav_1, nav_1_data);
			add_location(nav_1, file$s, 1, 2, 12);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav_1, anchor);

			if (default_slot) {
				default_slot.m(nav_1, null);
			}

			/*nav_1_binding*/ ctx[25](nav_1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, nav_1, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[10].call(null, nav_1)),
					listen_dev(nav_1, "MDCList:action", /*handleAction*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 8388608) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[23], dirty, null, null);
				}
			}

			set_attributes(nav_1, nav_1_data = get_spread_update(nav_1_levels, [
				(!current || dirty[0] & /*className, nonInteractive, dense, avatarList, twoLine, threeLine*/ 126 && nav_1_class_value !== (nav_1_class_value = "\n      mdc-list\n      " + /*className*/ ctx[1] + "\n      " + (/*nonInteractive*/ ctx[2]
				? "mdc-list--non-interactive"
				: "") + "\n      " + (/*dense*/ ctx[3] ? "mdc-list--dense" : "") + "\n      " + (/*avatarList*/ ctx[4] ? "mdc-list--avatar-list" : "") + "\n      " + (/*twoLine*/ ctx[5] ? "mdc-list--two-line" : "") + "\n      " + (/*threeLine*/ ctx[6] && !/*twoLine*/ ctx[5]
				? "smui-list--three-line"
				: "") + "\n    ")) && { class: nav_1_class_value },
				dirty[0] & /*props*/ 512 && /*props*/ ctx[9]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav_1);
			if (default_slot) default_slot.d(detaching);
			/*nav_1_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(1:0) {#if nav}",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[11]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let props;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCList:action"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { nonInteractive = false } = $$props;
	let { dense = false } = $$props;
	let { avatarList = false } = $$props;
	let { twoLine = false } = $$props;
	let { threeLine = false } = $$props;
	let { vertical = true } = $$props;
	let { wrapFocus = false } = $$props;
	let { singleSelection = false } = $$props;
	let { selectedIndex = null } = $$props;
	let { radiolist = false } = $$props;
	let { checklist = false } = $$props;
	let element;
	let list;
	let role = getContext("SMUI:list:role");
	let nav = getContext("SMUI:list:nav");
	let instantiate = getContext("SMUI:list:instantiate");
	let getInstance = getContext("SMUI:list:getInstance");
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;
	setContext("SMUI:list:nonInteractive", nonInteractive);

	if (!role) {
		if (singleSelection) {
			role = "listbox";
			setContext("SMUI:list:item:role", "option");
		} else if (radiolist) {
			role = "radiogroup";
			setContext("SMUI:list:item:role", "radio");
		} else if (checklist) {
			role = "group";
			setContext("SMUI:list:item:role", "checkbox");
		} else {
			role = "list";
			setContext("SMUI:list:item:role", undefined);
		}
	}

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	onMount(async () => {
		if (instantiate !== false) {
			$$invalidate(22, list = new MDCList(element));
		} else {
			$$invalidate(22, list = await getInstance());
		}

		if (singleSelection) {
			list.initializeListType();
			$$invalidate(13, selectedIndex = list.selectedIndex);
		}
	});

	onDestroy(() => {
		if (instantiate !== false) {
			list && list.destroy();
		}

		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function handleAction(e) {
		if (list && list.listElements[e.detail.index].classList.contains("mdc-list-item--disabled")) {
			e.preventDefault();
			$$invalidate(22, list.selectedIndex = selectedIndex, list);
		} else if (list && list.selectedIndex === e.detail.index) {
			$$invalidate(13, selectedIndex = e.detail.index);
		}
	}

	function layout(...args) {
		return list.layout(...args);
	}

	function setEnabled(...args) {
		return list.setEnabled(...args);
	}

	function getDefaultFoundation(...args) {
		return list.getDefaultFoundation(...args);
	}

	function nav_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(7, element);
		});
	}

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(7, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("nonInteractive" in $$new_props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
		if ("dense" in $$new_props) $$invalidate(3, dense = $$new_props.dense);
		if ("avatarList" in $$new_props) $$invalidate(4, avatarList = $$new_props.avatarList);
		if ("twoLine" in $$new_props) $$invalidate(5, twoLine = $$new_props.twoLine);
		if ("threeLine" in $$new_props) $$invalidate(6, threeLine = $$new_props.threeLine);
		if ("vertical" in $$new_props) $$invalidate(14, vertical = $$new_props.vertical);
		if ("wrapFocus" in $$new_props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
		if ("singleSelection" in $$new_props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
		if ("selectedIndex" in $$new_props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
		if ("radiolist" in $$new_props) $$invalidate(17, radiolist = $$new_props.radiolist);
		if ("checklist" in $$new_props) $$invalidate(18, checklist = $$new_props.checklist);
		if ("$$scope" in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCList,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		nonInteractive,
		dense,
		avatarList,
		twoLine,
		threeLine,
		vertical,
		wrapFocus,
		singleSelection,
		selectedIndex,
		radiolist,
		checklist,
		element,
		list,
		role,
		nav,
		instantiate,
		getInstance,
		addLayoutListener,
		removeLayoutListener,
		handleAction,
		layout,
		setEnabled,
		getDefaultFoundation,
		props
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("nonInteractive" in $$props) $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
		if ("dense" in $$props) $$invalidate(3, dense = $$new_props.dense);
		if ("avatarList" in $$props) $$invalidate(4, avatarList = $$new_props.avatarList);
		if ("twoLine" in $$props) $$invalidate(5, twoLine = $$new_props.twoLine);
		if ("threeLine" in $$props) $$invalidate(6, threeLine = $$new_props.threeLine);
		if ("vertical" in $$props) $$invalidate(14, vertical = $$new_props.vertical);
		if ("wrapFocus" in $$props) $$invalidate(15, wrapFocus = $$new_props.wrapFocus);
		if ("singleSelection" in $$props) $$invalidate(16, singleSelection = $$new_props.singleSelection);
		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$new_props.selectedIndex);
		if ("radiolist" in $$props) $$invalidate(17, radiolist = $$new_props.radiolist);
		if ("checklist" in $$props) $$invalidate(18, checklist = $$new_props.checklist);
		if ("element" in $$props) $$invalidate(7, element = $$new_props.element);
		if ("list" in $$props) $$invalidate(22, list = $$new_props.list);
		if ("role" in $$props) $$invalidate(8, role = $$new_props.role);
		if ("nav" in $$props) $$invalidate(11, nav = $$new_props.nav);
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
		if ("props" in $$props) $$invalidate(9, props = $$new_props.props);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(9, props = exclude($$props, [
			"use",
			"class",
			"nonInteractive",
			"dense",
			"avatarList",
			"twoLine",
			"threeLine",
			"vertical",
			"wrapFocus",
			"singleSelection",
			"selectedIndex",
			"radiolist",
			"checklist"
		]));

		if ($$self.$$.dirty[0] & /*list, vertical*/ 4210688) {
			 if (list && list.vertical !== vertical) {
				$$invalidate(22, list.vertical = vertical, list);
			}
		}

		if ($$self.$$.dirty[0] & /*list, wrapFocus*/ 4227072) {
			 if (list && list.wrapFocus !== wrapFocus) {
				$$invalidate(22, list.wrapFocus = wrapFocus, list);
			}
		}

		if ($$self.$$.dirty[0] & /*list, singleSelection*/ 4259840) {
			 if (list && list.singleSelection !== singleSelection) {
				$$invalidate(22, list.singleSelection = singleSelection, list);
			}
		}

		if ($$self.$$.dirty[0] & /*list, singleSelection, selectedIndex*/ 4268032) {
			 if (list && singleSelection && list.selectedIndex !== selectedIndex) {
				$$invalidate(22, list.selectedIndex = selectedIndex, list);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		nonInteractive,
		dense,
		avatarList,
		twoLine,
		threeLine,
		element,
		role,
		props,
		forwardEvents,
		nav,
		handleAction,
		selectedIndex,
		vertical,
		wrapFocus,
		singleSelection,
		radiolist,
		checklist,
		layout,
		setEnabled,
		getDefaultFoundation,
		list,
		$$scope,
		slots,
		nav_1_binding,
		ul_binding
	];
}

class List extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$t,
			create_fragment$t,
			safe_not_equal,
			{
				use: 0,
				class: 1,
				nonInteractive: 2,
				dense: 3,
				avatarList: 4,
				twoLine: 5,
				threeLine: 6,
				vertical: 14,
				wrapFocus: 15,
				singleSelection: 16,
				selectedIndex: 13,
				radiolist: 17,
				checklist: 18,
				layout: 19,
				setEnabled: 20,
				getDefaultFoundation: 21
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List",
			options,
			id: create_fragment$t.name
		});
	}

	get use() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nonInteractive() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nonInteractive(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatarList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatarList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get twoLine() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set twoLine(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get threeLine() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set threeLine(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrapFocus() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrapFocus(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get singleSelection() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set singleSelection(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedIndex() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedIndex(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get radiolist() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set radiolist(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checklist() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checklist(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[19];
	}

	set layout(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setEnabled() {
		return this.$$.ctx[20];
	}

	set setEnabled(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getDefaultFoundation() {
		return this.$$.ctx[21];
	}

	set getDefaultFoundation(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\list\Item.svelte generated by Svelte v3.31.2 */
const file$t = "node_modules\\@smui\\list\\Item.svelte";

// (40:0) {:else}
function create_else_block$4(ctx) {
	let li;
	let li_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	let li_levels = [
		/*role*/ ctx[6] === "option"
		? {
				"aria-selected": /*selected*/ ctx[7] ? "true" : "false"
			}
		: {},
		/*props*/ ctx[12],
		{
			class: li_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n      " + (/*role*/ ctx[6] === "menuitem" && /*selected*/ ctx[7]
			? "mdc-menu-item--selected"
			: "") + "\n    "
		},
		{ role: /*role*/ ctx[6] },
		/*role*/ ctx[6] === "radio" || /*role*/ ctx[6] === "checkbox"
		? {
				"aria-checked": /*checked*/ ctx[10] ? "true" : "false"
			}
		: {},
		{ tabindex: /*tabindex*/ ctx[0] }
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$t, 40, 2, 1053);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding*/ ctx[23](li);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, li, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, li)),
					action_destroyer(Ripple_action = Ripple.call(null, li, {
						ripple: /*ripple*/ ctx[3],
						unbounded: false,
						color: /*color*/ ctx[4]
					})),
					listen_dev(li, "click", /*action*/ ctx[15], false, false, false),
					listen_dev(li, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				dirty & /*role, selected*/ 192 && (/*role*/ ctx[6] === "option"
				? {
						"aria-selected": /*selected*/ ctx[7] ? "true" : "false"
					}
				: {}),
				dirty & /*props*/ 4096 && /*props*/ ctx[12],
				(!current || dirty & /*className, activated, selected, disabled, role*/ 484 && li_class_value !== (li_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n      " + (/*role*/ ctx[6] === "menuitem" && /*selected*/ ctx[7]
				? "mdc-menu-item--selected"
				: "") + "\n    ")) && { class: li_class_value },
				(!current || dirty & /*role*/ 64) && { role: /*role*/ ctx[6] },
				dirty & /*role, checked*/ 1088 && (/*role*/ ctx[6] === "radio" || /*role*/ ctx[6] === "checkbox"
				? {
						"aria-checked": /*checked*/ ctx[10] ? "true" : "false"
					}
				: {}),
				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] }
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[3],
				unbounded: false,
				color: /*color*/ ctx[4]
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[23](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(40:0) {:else}",
		ctx
	});

	return block;
}

// (21:23) 
function create_if_block_1$2(ctx) {
	let span;
	let span_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	let span_levels = [
		{
			class: span_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
		},
		/*activated*/ ctx[5] ? { "aria-current": "page" } : {},
		{ tabindex: /*tabindex*/ ctx[0] },
		/*props*/ ctx[12]
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$t, 21, 2, 547);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[22](span);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, span)),
					action_destroyer(Ripple_action = Ripple.call(null, span, {
						ripple: /*ripple*/ ctx[3],
						unbounded: false,
						color: /*color*/ ctx[4]
					})),
					listen_dev(span, "click", /*action*/ ctx[15], false, false, false),
					listen_dev(span, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*className, activated, selected, disabled*/ 420 && span_class_value !== (span_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    ")) && { class: span_class_value },
				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { "aria-current": "page" } : {}),
				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] },
				dirty & /*props*/ 4096 && /*props*/ ctx[12]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[3],
				unbounded: false,
				color: /*color*/ ctx[4]
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(21:23) ",
		ctx
	});

	return block;
}

// (1:0) {#if nav && href}
function create_if_block$9(ctx) {
	let a;
	let a_class_value;
	let useActions_action;
	let forwardEvents_action;
	let Ripple_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	let a_levels = [
		{ href: /*href*/ ctx[9] },
		/*props*/ ctx[12],
		{
			class: a_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    "
		},
		/*activated*/ ctx[5] ? { "aria-current": "page" } : {},
		{ tabindex: /*tabindex*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$t, 1, 2, 20);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[21](a);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, a, /*use*/ ctx[1])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[13].call(null, a)),
					action_destroyer(Ripple_action = Ripple.call(null, a, {
						ripple: /*ripple*/ ctx[3],
						unbounded: false,
						color: /*color*/ ctx[4]
					})),
					listen_dev(a, "click", /*action*/ ctx[15], false, false, false),
					listen_dev(a, "keydown", /*handleKeydown*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 512) && { href: /*href*/ ctx[9] },
				dirty & /*props*/ 4096 && /*props*/ ctx[12],
				(!current || dirty & /*className, activated, selected, disabled*/ 420 && a_class_value !== (a_class_value = "\n      mdc-list-item\n      " + /*className*/ ctx[2] + "\n      " + (/*activated*/ ctx[5] ? "mdc-list-item--activated" : "") + "\n      " + (/*selected*/ ctx[7] ? "mdc-list-item--selected" : "") + "\n      " + (/*disabled*/ ctx[8] ? "mdc-list-item--disabled" : "") + "\n    ")) && { class: a_class_value },
				dirty & /*activated*/ 32 && (/*activated*/ ctx[5] ? { "aria-current": "page" } : {}),
				(!current || dirty & /*tabindex*/ 1) && { tabindex: /*tabindex*/ ctx[0] }
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

			if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple, color*/ 24) Ripple_action.update.call(null, {
				ripple: /*ripple*/ ctx[3],
				unbounded: false,
				color: /*color*/ ctx[4]
			});
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(1:0) {#if nav && href}",
		ctx
	});

	return block;
}

function create_fragment$u(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_if_block_1$2, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[14] && /*href*/ ctx[9]) return 0;
		if (/*nav*/ ctx[14] && !/*href*/ ctx[9]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let counter$1 = 0;

function instance$u($$self, $$props, $$invalidate) {
	let props;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Item", slots, ['default']);
	const dispatch = createEventDispatcher();
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let checked = false;
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { color = null } = $$props;
	let { nonInteractive = getContext("SMUI:list:nonInteractive") } = $$props;
	let { activated = false } = $$props;
	let { role = getContext("SMUI:list:item:role") } = $$props;
	let { selected = false } = $$props;
	let { disabled = false } = $$props;
	let { tabindex = !nonInteractive && !disabled && (selected || checked) && "0" || "-1" } = $$props;
	let { href = false } = $$props;
	let { inputId = "SMUI-form-field-list-" + counter$1++ } = $$props;
	let element;
	let addTabindexIfNoItemsSelectedRaf;
	let nav = getContext("SMUI:list:item:nav");
	setContext("SMUI:generic:input:props", { id: inputId });
	setContext("SMUI:generic:input:setChecked", setChecked);

	onMount(() => {
		// Tabindex needs to be '0' if this is the first non-disabled list item, and
		// no other item is selected.
		if (!selected && !nonInteractive) {
			let first = true;
			let el = element;

			while (el.previousSibling) {
				el = el.previousSibling;

				if (el.nodeType === 1 && el.classList.contains("mdc-list-item") && !el.classList.contains("mdc-list-item--disabled")) {
					first = false;
					break;
				}
			}

			if (first) {
				// This is first, so now set up a check that no other items are
				// selected.
				addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
			}
		}
	});

	onDestroy(() => {
		if (addTabindexIfNoItemsSelectedRaf) {
			window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
		}
	});

	function addTabindexIfNoItemsSelected() {
		// Look through next siblings to see if none of them are selected.
		let noneSelected = true;

		let el = element;

		while (el.nextSibling) {
			el = el.nextSibling;

			if (el.nodeType === 1 && el.classList.contains("mdc-list-item") && el.attributes["tabindex"] && el.attributes["tabindex"].value === "0") {
				noneSelected = false;
				break;
			}
		}

		if (noneSelected) {
			// This is the first element, and no other element is selected, so the
			// tabindex should be '0'.
			$$invalidate(0, tabindex = "0");
		}
	}

	function action(e) {
		if (disabled) {
			e.preventDefault();
		} else {
			dispatch("SMUI:action", e);
		}
	}

	function handleKeydown(e) {
		const isEnter = e.key === "Enter" || e.keyCode === 13;
		const isSpace = e.key === "Space" || e.keyCode === 32;

		if (isEnter || isSpace) {
			action(e);
		}
	}

	function setChecked(isChecked) {
		$$invalidate(10, checked = isChecked);
		$$invalidate(0, tabindex = !nonInteractive && !disabled && (selected || checked) && "0" || "-1");
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(11, element);
		});
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(11, element);
		});
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(11, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(1, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ("nonInteractive" in $$new_props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
		if ("activated" in $$new_props) $$invalidate(5, activated = $$new_props.activated);
		if ("role" in $$new_props) $$invalidate(6, role = $$new_props.role);
		if ("selected" in $$new_props) $$invalidate(7, selected = $$new_props.selected);
		if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("tabindex" in $$new_props) $$invalidate(0, tabindex = $$new_props.tabindex);
		if ("href" in $$new_props) $$invalidate(9, href = $$new_props.href);
		if ("inputId" in $$new_props) $$invalidate(18, inputId = $$new_props.inputId);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		counter: counter$1,
		onMount,
		onDestroy,
		getContext,
		setContext,
		createEventDispatcher,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		Ripple,
		dispatch,
		forwardEvents,
		checked,
		use,
		className,
		ripple,
		color,
		nonInteractive,
		activated,
		role,
		selected,
		disabled,
		tabindex,
		href,
		inputId,
		element,
		addTabindexIfNoItemsSelectedRaf,
		nav,
		addTabindexIfNoItemsSelected,
		action,
		handleKeydown,
		setChecked,
		props
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
		if ("checked" in $$props) $$invalidate(10, checked = $$new_props.checked);
		if ("use" in $$props) $$invalidate(1, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
		if ("nonInteractive" in $$props) $$invalidate(17, nonInteractive = $$new_props.nonInteractive);
		if ("activated" in $$props) $$invalidate(5, activated = $$new_props.activated);
		if ("role" in $$props) $$invalidate(6, role = $$new_props.role);
		if ("selected" in $$props) $$invalidate(7, selected = $$new_props.selected);
		if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("tabindex" in $$props) $$invalidate(0, tabindex = $$new_props.tabindex);
		if ("href" in $$props) $$invalidate(9, href = $$new_props.href);
		if ("inputId" in $$props) $$invalidate(18, inputId = $$new_props.inputId);
		if ("element" in $$props) $$invalidate(11, element = $$new_props.element);
		if ("addTabindexIfNoItemsSelectedRaf" in $$props) addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
		if ("nav" in $$props) $$invalidate(14, nav = $$new_props.nav);
		if ("props" in $$props) $$invalidate(12, props = $$new_props.props);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(12, props = exclude($$props, [
			"use",
			"class",
			"ripple",
			"color",
			"nonInteractive",
			"activated",
			"selected",
			"disabled",
			"tabindex",
			"href",
			"inputId"
		]));
	};

	$$props = exclude_internal_props($$props);

	return [
		tabindex,
		use,
		className,
		ripple,
		color,
		activated,
		role,
		selected,
		disabled,
		href,
		checked,
		element,
		props,
		forwardEvents,
		nav,
		action,
		handleKeydown,
		nonInteractive,
		inputId,
		$$scope,
		slots,
		a_binding,
		span_binding,
		li_binding
	];
}

class Item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
			use: 1,
			class: 2,
			ripple: 3,
			color: 4,
			nonInteractive: 17,
			activated: 5,
			role: 6,
			selected: 7,
			disabled: 8,
			tabindex: 0,
			href: 9,
			inputId: 18
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment$u.name
		});
	}

	get use() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nonInteractive() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nonInteractive(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activated() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activated(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get role() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set role(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabindex() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabindex(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\ClassAdder.svelte generated by Svelte v3.31.2 */

// (1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class="{smuiClass} {className}"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >
function create_default_slot$7(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   use={[forwardEvents, ...use]}   class=\\\"{smuiClass} {className}\\\"   {...exclude($$props, ['use', 'class', 'component', 'forwardEvents'])} >",
		ctx
	});

	return block;
}

function create_fragment$v(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
		},
		{
			class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
		},
		exclude(/*$$props*/ ctx[5], ["use", "class", "component", "forwardEvents"])
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$7] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, smuiClass, className, exclude, $$props*/ 59)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 17 && {
						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
					},
					dirty & /*smuiClass, className*/ 10 && {
						class: "" + (/*smuiClass*/ ctx[3] + " " + /*className*/ ctx[1])
					},
					dirty & /*exclude, $$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ["use", "class", "component", "forwardEvents"]))
				])
			: {};

			if (dirty & /*$$scope*/ 256) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const internals = {
	component: null,
	smuiClass: null,
	contexts: {}
};

function instance$v($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClassAdder", slots, ['default']);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { component = internals.component } = $$props;
	let { forwardEvents: smuiForwardEvents = [] } = $$props;
	const smuiClass = internals.class;
	const contexts = internals.contexts;
	const forwardEvents = forwardEventsBuilder(get_current_component(), smuiForwardEvents);

	for (let context in contexts) {
		if (contexts.hasOwnProperty(context)) {
			setContext(context, contexts[context]);
		}
	}

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("forwardEvents" in $$new_props) $$invalidate(6, smuiForwardEvents = $$new_props.forwardEvents);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		internals,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		use,
		className,
		component,
		smuiForwardEvents,
		smuiClass,
		contexts,
		forwardEvents
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
		if ("smuiForwardEvents" in $$props) $$invalidate(6, smuiForwardEvents = $$new_props.smuiForwardEvents);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		component,
		smuiClass,
		forwardEvents,
		$$props,
		smuiForwardEvents,
		slots,
		$$scope
	];
}

class ClassAdder extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			forwardEvents: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClassAdder",
			options,
			id: create_fragment$v.name
		});
	}

	get use() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get forwardEvents() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set forwardEvents(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function classAdderBuilder(props) {
  function Component(...args) {
    Object.assign(internals, props);
    return new ClassAdder(...args);
  }

  Component.prototype = ClassAdder;

  // SSR support
  if (ClassAdder.$$render) {
    Component.$$render = (...args) => Object.assign(internals, props) && ClassAdder.$$render(...args);
  }
  if (ClassAdder.render) {
    Component.render = (...args) => Object.assign(internals, props) && ClassAdder.render(...args);
  }

  return Component;
}

/* node_modules\@smui\common\Span.svelte generated by Svelte v3.31.2 */
const file$u = "node_modules\\@smui\\common\\Span.svelte";

function create_fragment$w(ctx) {
	let span;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let span_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$u, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$w($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Span", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class Span extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$w, create_fragment$w, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Span",
			options,
			id: create_fragment$w.name
		});
	}

	get use() {
		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

classAdderBuilder({
  class: 'mdc-list-item__text',
  component: Span,
  contexts: {}
});

classAdderBuilder({
  class: 'mdc-list-item__primary-text',
  component: Span,
  contexts: {}
});

classAdderBuilder({
  class: 'mdc-list-item__secondary-text',
  component: Span,
  contexts: {}
});

classAdderBuilder({
  class: 'mdc-list-item__graphic',
  component: Span,
  contexts: {}
});

var Meta = classAdderBuilder({
  class: 'mdc-list-item__meta',
  component: Span,
  contexts: {}
});

/* node_modules\@smui\list\Label.svelte generated by Svelte v3.31.2 */
const file$v = "node_modules\\@smui\\list\\Label.svelte";

function create_fragment$x(ctx) {
	let label;
	let label_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let label_levels = [
		{
			class: label_class_value = "mdc-list-item__text " + /*className*/ ctx[1]
		},
		/*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
		? {
				"for": /*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
			}
		: {},
		exclude(/*$$props*/ ctx[4], ["use", "class"])
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			set_attributes(label, label_data);
			add_location(label, file$v, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*className*/ 2 && label_class_value !== (label_class_value = "mdc-list-item__text " + /*className*/ ctx[1])) && { class: label_class_value },
				/*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
				? {
						"for": /*inputProps*/ ctx[3] && /*inputProps*/ ctx[3].id
					}
				: {},
				dirty & /*$$props*/ 16 && exclude(/*$$props*/ ctx[4], ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Label", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let inputProps = getContext("SMUI:generic:input:props") || {};

	$$self.$$set = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		inputProps
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("inputProps" in $$props) $$invalidate(3, inputProps = $$new_props.inputProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, className, forwardEvents, inputProps, $$props, $$scope, slots];
}

class Label$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$x, create_fragment$x, safe_not_equal, { use: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Label",
			options,
			id: create_fragment$x.name
		});
	}

	get use() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\Div.svelte generated by Svelte v3.31.2 */
const file$w = "node_modules\\@smui\\common\\Div.svelte";

function create_fragment$y(ctx) {
	let div;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$w, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Div", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class Div extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$y, create_fragment$y, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Div",
			options,
			id: create_fragment$y.name
		});
	}

	get use() {
		throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

classAdderBuilder({
  class: 'mdc-list-group',
  component: Div,
  contexts: {}
});

/* node_modules\@smui\common\H3.svelte generated by Svelte v3.31.2 */
const file$x = "node_modules\\@smui\\common\\H3.svelte";

function create_fragment$z(ctx) {
	let h3;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let h3_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let h3_data = {};

	for (let i = 0; i < h3_levels.length; i += 1) {
		h3_data = assign(h3_data, h3_levels[i]);
	}

	const block = {
		c: function create() {
			h3 = element("h3");
			if (default_slot) default_slot.c();
			set_attributes(h3, h3_data);
			add_location(h3, file$x, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, h3, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, h3))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$z($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("H3", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class H3 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$z, create_fragment$z, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "H3",
			options,
			id: create_fragment$z.name
		});
	}

	get use() {
		throw new Error("<H3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

classAdderBuilder({
  class: 'mdc-list-group__subheader',
  component: H3,
  contexts: {}
});

/* node_modules\@sveltejs\svelte-virtual-list\VirtualList.svelte generated by Svelte v3.31.2 */
const file$y = "node_modules\\@sveltejs\\svelte-virtual-list\\VirtualList.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

const get_default_slot_changes$1 = dirty => ({ item: dirty & /*visible*/ 16 });
const get_default_slot_context$1 = ctx => ({ item: /*row*/ ctx[23].data });

// (166:26) Missing template
function fallback_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Missing template");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(166:26) Missing template",
		ctx
	});

	return block;
}

// (164:2) {#each visible as row (row.index)}
function create_each_block$1(key_1, ctx) {
	let svelte_virtual_list_row;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$1);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			svelte_virtual_list_row = element("svelte-virtual-list-row");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-ukqkvk");
			add_location(svelte_virtual_list_row, file$y, 164, 3, 3457);
			this.first = svelte_virtual_list_row;
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_virtual_list_row, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(svelte_virtual_list_row, null);
			}

			append_dev(svelte_virtual_list_row, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, visible*/ 8208) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_default_slot_changes$1, get_default_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_virtual_list_row);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(164:2) {#each visible as row (row.index)}",
		ctx
	});

	return block;
}

function create_fragment$A(ctx) {
	let svelte_virtual_list_viewport;
	let svelte_virtual_list_contents;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let svelte_virtual_list_viewport_resize_listener;
	let current;
	let mounted;
	let dispose;
	let each_value = /*visible*/ ctx[4];
	validate_each_argument(each_value);
	const get_key = ctx => /*row*/ ctx[23].index;
	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[5] + "px");
			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[6] + "px");
			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-ukqkvk");
			add_location(svelte_virtual_list_contents, file$y, 159, 1, 3301);
			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-ukqkvk");
			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[17].call(svelte_virtual_list_viewport));
			add_location(svelte_virtual_list_viewport, file$y, 153, 0, 3155);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_virtual_list_viewport, anchor);
			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svelte_virtual_list_contents, null);
			}

			/*svelte_virtual_list_contents_binding*/ ctx[15](svelte_virtual_list_contents);
			/*svelte_virtual_list_viewport_binding*/ ctx[16](svelte_virtual_list_viewport);
			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[17].bind(svelte_virtual_list_viewport));
			current = true;

			if (!mounted) {
				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$$scope, visible*/ 8208) {
				each_value = /*visible*/ ctx[4];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				check_outros();
			}

			if (!current || dirty & /*top*/ 32) {
				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[5] + "px");
			}

			if (!current || dirty & /*bottom*/ 64) {
				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[6] + "px");
			}

			if (!current || dirty & /*height*/ 1) {
				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_virtual_list_viewport);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*svelte_virtual_list_contents_binding*/ ctx[15](null);
			/*svelte_virtual_list_viewport_binding*/ ctx[16](null);
			svelte_virtual_list_viewport_resize_listener();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("VirtualList", slots, ['default']);
	let { items } = $$props;
	let { height = "100%" } = $$props;
	let { itemHeight = undefined } = $$props;
	let foo;
	let { start = 0 } = $$props;
	let { end = 0 } = $$props;

	// local state
	let height_map = [];

	let rows;
	let viewport;
	let contents;
	let viewport_height = 0;
	let visible;
	let mounted;
	let top = 0;
	let bottom = 0;
	let average_height;

	async function refresh(items, viewport_height, itemHeight) {
		const { scrollTop } = viewport;
		await tick(); // wait until the DOM is up to date
		let content_height = top - scrollTop;
		let i = start;

		while (content_height < viewport_height && i < items.length) {
			let row = rows[i - start];

			if (!row) {
				$$invalidate(9, end = i + 1);
				await tick(); // render the newly visible row
				row = rows[i - start];
			}

			const row_height = height_map[i] = itemHeight || row.offsetHeight;
			content_height += row_height;
			i += 1;
		}

		$$invalidate(9, end = i);
		const remaining = items.length - end;
		average_height = (top + content_height) / end;
		$$invalidate(6, bottom = remaining * average_height);
		height_map.length = items.length;
	}

	async function handle_scroll() {
		const { scrollTop } = viewport;
		const old_start = start;

		for (let v = 0; v < rows.length; v += 1) {
			height_map[start + v] = itemHeight || rows[v].offsetHeight;
		}

		let i = 0;
		let y = 0;

		while (i < items.length) {
			const row_height = height_map[i] || average_height;

			if (y + row_height > scrollTop) {
				$$invalidate(8, start = i);
				$$invalidate(5, top = y);
				break;
			}

			y += row_height;
			i += 1;
		}

		while (i < items.length) {
			y += height_map[i] || average_height;
			i += 1;
			if (y > scrollTop + viewport_height) break;
		}

		$$invalidate(9, end = i);
		const remaining = items.length - end;
		average_height = y / end;
		while (i < items.length) height_map[i++] = average_height;
		$$invalidate(6, bottom = remaining * average_height);

		// prevent jumping if we scrolled up into unknown territory
		if (start < old_start) {
			await tick();
			let expected_height = 0;
			let actual_height = 0;

			for (let i = start; i < old_start; i += 1) {
				if (rows[i - start]) {
					expected_height += height_map[i];
					actual_height += itemHeight || rows[i - start].offsetHeight;
				}
			}

			const d = actual_height - expected_height;
			viewport.scrollTo(0, scrollTop + d);
		}
	} // TODO if we overestimated the space these
	// rows would occupy we may need to add some

	// more. maybe we can just call handle_scroll again?
	// trigger initial refresh
	onMount(() => {
		rows = contents.getElementsByTagName("svelte-virtual-list-row");
		$$invalidate(12, mounted = true);
	});

	const writable_props = ["items", "height", "itemHeight", "start", "end"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualList> was created with unknown prop '${key}'`);
	});

	function svelte_virtual_list_contents_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			contents = $$value;
			$$invalidate(3, contents);
		});
	}

	function svelte_virtual_list_viewport_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			viewport = $$value;
			$$invalidate(2, viewport);
		});
	}

	function svelte_virtual_list_viewport_elementresize_handler() {
		viewport_height = this.offsetHeight;
		$$invalidate(1, viewport_height);
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(10, items = $$props.items);
		if ("height" in $$props) $$invalidate(0, height = $$props.height);
		if ("itemHeight" in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
		if ("start" in $$props) $$invalidate(8, start = $$props.start);
		if ("end" in $$props) $$invalidate(9, end = $$props.end);
		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		tick,
		items,
		height,
		itemHeight,
		foo,
		start,
		end,
		height_map,
		rows,
		viewport,
		contents,
		viewport_height,
		visible,
		mounted,
		top,
		bottom,
		average_height,
		refresh,
		handle_scroll
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(10, items = $$props.items);
		if ("height" in $$props) $$invalidate(0, height = $$props.height);
		if ("itemHeight" in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
		if ("foo" in $$props) foo = $$props.foo;
		if ("start" in $$props) $$invalidate(8, start = $$props.start);
		if ("end" in $$props) $$invalidate(9, end = $$props.end);
		if ("height_map" in $$props) height_map = $$props.height_map;
		if ("rows" in $$props) rows = $$props.rows;
		if ("viewport" in $$props) $$invalidate(2, viewport = $$props.viewport);
		if ("contents" in $$props) $$invalidate(3, contents = $$props.contents);
		if ("viewport_height" in $$props) $$invalidate(1, viewport_height = $$props.viewport_height);
		if ("visible" in $$props) $$invalidate(4, visible = $$props.visible);
		if ("mounted" in $$props) $$invalidate(12, mounted = $$props.mounted);
		if ("top" in $$props) $$invalidate(5, top = $$props.top);
		if ("bottom" in $$props) $$invalidate(6, bottom = $$props.bottom);
		if ("average_height" in $$props) average_height = $$props.average_height;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items, start, end*/ 1792) {
			 $$invalidate(4, visible = items.slice(start, end).map((data, i) => {
				return { index: i + start, data };
			}));
		}

		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 7170) {
			// whenever `items` changes, invalidate the current heightmap
			 if (mounted) refresh(items, viewport_height, itemHeight);
		}
	};

	return [
		height,
		viewport_height,
		viewport,
		contents,
		visible,
		top,
		bottom,
		handle_scroll,
		start,
		end,
		items,
		itemHeight,
		mounted,
		$$scope,
		slots,
		svelte_virtual_list_contents_binding,
		svelte_virtual_list_viewport_binding,
		svelte_virtual_list_viewport_elementresize_handler
	];
}

class VirtualList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			items: 10,
			height: 0,
			itemHeight: 11,
			start: 8,
			end: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VirtualList",
			options,
			id: create_fragment$A.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[10] === undefined && !("items" in props)) {
			console.warn("<VirtualList> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHeight() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHeight(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get start() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set start(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get end() {
		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set end(value) {
		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\VirtualCheckList.svelte generated by Svelte v3.31.2 */
const file$z = "src\\components\\VirtualCheckList.svelte";

// (16:16) <Label>
function create_default_slot_4(ctx) {
	let t_value = /*item*/ ctx[6].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*item*/ 64 && t_value !== (t_value = /*item*/ ctx[6].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(16:16) <Label>",
		ctx
	});

	return block;
}

// (17:16) <Meta>
function create_default_slot_3(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding(value) {
		/*checkbox_group_binding*/ ctx[4].call(null, value);
	}

	let checkbox_props = { value: /*item*/ ctx[6].name };

	if (/*fileChecked*/ ctx[0] !== void 0) {
		checkbox_props.group = /*fileChecked*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding));
	checkbox.$on("click", /*click_handler*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*item*/ 64) checkbox_changes.value = /*item*/ ctx[6].name;

			if (!updating_group && dirty & /*fileChecked*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(17:16) <Meta>",
		ctx
	});

	return block;
}

// (15:12) <Item style="height:2.5em;">
function create_default_slot_2$4(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label$1({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope, item*/ 192) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, item, fileChecked*/ 193) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(15:12) <Item style=\\\"height:2.5em;\\\">",
		ctx
	});

	return block;
}

// (14:8) <List checklist>
function create_default_slot_1$4(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				style: "height:2.5em;",
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope, item, fileChecked*/ 193) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(14:8) <List checklist>",
		ctx
	});

	return block;
}

// (12:4) <VirtualList {items} let:item {height}>
function create_default_slot$8(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				checklist: true,
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, item, fileChecked*/ 193) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(12:4) <VirtualList {items} let:item {height}>",
		ctx
	});

	return block;
}

function create_fragment$B(ctx) {
	let div;
	let virtuallist;
	let current;

	virtuallist = new VirtualList({
			props: {
				items: /*items*/ ctx[1],
				height: /*height*/ ctx[2],
				$$slots: {
					default: [
						create_default_slot$8,
						({ item }) => ({ 6: item }),
						({ item }) => item ? 64 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(virtuallist.$$.fragment);
			attr_dev(div, "style", /*style*/ ctx[3]);
			add_location(div, file$z, 10, 0, 264);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(virtuallist, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const virtuallist_changes = {};
			if (dirty & /*items*/ 2) virtuallist_changes.items = /*items*/ ctx[1];
			if (dirty & /*height*/ 4) virtuallist_changes.height = /*height*/ ctx[2];

			if (dirty & /*$$scope, item, fileChecked*/ 193) {
				virtuallist_changes.$$scope = { dirty, ctx };
			}

			virtuallist.$set(virtuallist_changes);

			if (!current || dirty & /*style*/ 8) {
				attr_dev(div, "style", /*style*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(virtuallist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(virtuallist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(virtuallist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("VirtualCheckList", slots, []);

	let { items = [] } = $$props,
		{ fileChecked = [] } = $$props,
		{ height = "500px" } = $$props,
		{ style = "" } = $$props;

	const writable_props = ["items", "fileChecked", "height", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualCheckList> was created with unknown prop '${key}'`);
	});

	function checkbox_group_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("height" in $$props) $$invalidate(2, height = $$props.height);
		if ("style" in $$props) $$invalidate(3, style = $$props.style);
	};

	$$self.$capture_state = () => ({
		List,
		Item,
		Meta,
		Label: Label$1,
		Checkbox,
		VirtualList,
		items,
		fileChecked,
		height,
		style
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("height" in $$props) $$invalidate(2, height = $$props.height);
		if ("style" in $$props) $$invalidate(3, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [fileChecked, items, height, style, checkbox_group_binding, click_handler];
}

class VirtualCheckList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			items: 1,
			fileChecked: 0,
			height: 2,
			style: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VirtualCheckList",
			options,
			id: create_fragment$B.name
		});
	}

	get items() {
		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fileChecked() {
		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<VirtualCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<VirtualCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Modal.svelte generated by Svelte v3.31.2 */

const file$A = "src\\components\\Modal.svelte";
const get_footerbtn_slot_changes = dirty => ({});
const get_footerbtn_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({ style: "white-space: pre-wrap;" });

function create_fragment$C(ctx) {
	let div3;
	let div0;
	let t0;
	let div2;
	let header;
	let p;
	let t1;
	let t2;
	let span;
	let t3;
	let section;
	let t4;
	let footer;
	let div1;
	let current;
	let mounted;
	let dispose;
	const content_slot_template = /*#slots*/ ctx[5].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[4], get_content_slot_context);
	const footerbtn_slot_template = /*#slots*/ ctx[5].footerbtn;
	const footerbtn_slot = create_slot(footerbtn_slot_template, ctx, /*$$scope*/ ctx[4], get_footerbtn_slot_context);

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div2 = element("div");
			header = element("header");
			p = element("p");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			span = element("span");
			t3 = space();
			section = element("section");
			if (content_slot) content_slot.c();
			t4 = space();
			footer = element("footer");
			div1 = element("div");
			if (footerbtn_slot) footerbtn_slot.c();
			attr_dev(div0, "class", "modal-background");
			add_location(div0, file$A, 17, 2, 426);
			attr_dev(p, "class", "modal-card-title");
			add_location(p, file$A, 22, 6, 571);
			attr_dev(span, "class", "delete is-pulled-right svelte-1kfm71n");
			add_location(span, file$A, 23, 6, 618);
			attr_dev(header, "class", "modal-card-head");
			add_location(header, file$A, 21, 4, 531);
			attr_dev(section, "class", "modal-card-body svelte-1kfm71n");
			set_style(section, "background", /*bodyBackground*/ ctx[3]);
			add_location(section, file$A, 25, 4, 713);
			set_style(div1, "margin-left", "auto");
			set_style(div1, "display", "flex");
			add_location(div1, file$A, 28, 6, 895);
			attr_dev(footer, "class", "modal-card-foot");
			add_location(footer, file$A, 27, 4, 855);
			attr_dev(div2, "class", "modal-card animated fadeIn faster");
			attr_dev(div2, "style", /*style*/ ctx[2]);
			add_location(div2, file$A, 19, 2, 468);
			attr_dev(div3, "class", "modal");
			toggle_class(div3, "is-active", /*active*/ ctx[0]);
			add_location(div3, file$A, 15, 0, 376);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, header);
			append_dev(header, p);
			append_dev(p, t1);
			append_dev(header, t2);
			append_dev(header, span);
			append_dev(div2, t3);
			append_dev(div2, section);

			if (content_slot) {
				content_slot.m(section, null);
			}

			append_dev(div2, t4);
			append_dev(div2, footer);
			append_dev(footer, div1);

			if (footerbtn_slot) {
				footerbtn_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*keydown_handler*/ ctx[6], false, false, false),
					listen_dev(span, "click", /*click_handler*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);

			if (content_slot) {
				if (content_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_content_slot_changes, get_content_slot_context);
				}
			}

			if (!current || dirty & /*bodyBackground*/ 8) {
				set_style(section, "background", /*bodyBackground*/ ctx[3]);
			}

			if (footerbtn_slot) {
				if (footerbtn_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(footerbtn_slot, footerbtn_slot_template, ctx, /*$$scope*/ ctx[4], dirty, get_footerbtn_slot_changes, get_footerbtn_slot_context);
				}
			}

			if (!current || dirty & /*style*/ 4) {
				attr_dev(div2, "style", /*style*/ ctx[2]);
			}

			if (dirty & /*active*/ 1) {
				toggle_class(div3, "is-active", /*active*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_slot, local);
			transition_in(footerbtn_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_slot, local);
			transition_out(footerbtn_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (content_slot) content_slot.d(detaching);
			if (footerbtn_slot) footerbtn_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Modal", slots, ['content','footerbtn']);

	let { active = false } = $$props,
		{ title = "Title" } = $$props,
		{ style = "width:60vw" } = $$props,
		{ bodyBackground = "#634e96" } = $$props;

	const writable_props = ["active", "title", "style", "bodyBackground"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
	});

	const keydown_handler = e => {
		if (e.keyCode === 27) $$invalidate(0, active = false);
	};

	const click_handler = () => $$invalidate(0, active = false);

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("bodyBackground" in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ active, title, style, bodyBackground });

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("bodyBackground" in $$props) $$invalidate(3, bodyBackground = $$props.bodyBackground);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		title,
		style,
		bodyBackground,
		$$scope,
		slots,
		keydown_handler,
		click_handler
	];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
			active: 0,
			title: 1,
			style: 2,
			bodyBackground: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$C.name
		});
	}

	get active() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bodyBackground() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bodyBackground(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\PreModal.svelte generated by Svelte v3.31.2 */
const file$B = "src\\components\\PreModal.svelte";

// (29:2) <div slot="content" style="color:black; white-space: pre-wrap; user-select:text;">
function create_content_slot(ctx) {
	let div;
	let t_value = /*preModal*/ ctx[0].modalContent + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "slot", "content");
			set_style(div, "color", "black");
			set_style(div, "white-space", "pre-wrap");
			set_style(div, "user-select", "text");
			add_location(div, file$B, 28, 2, 626);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*preModal*/ 1 && t_value !== (t_value = /*preModal*/ ctx[0].modalContent + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot.name,
		type: "slot",
		source: "(29:2) <div slot=\\\"content\\\" style=\\\"color:black; white-space: pre-wrap; user-select:text;\\\">",
		ctx
	});

	return block;
}

function create_fragment$D(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[2].call(null, value);
	}

	let modal_props = {
		title: /*preModal*/ ctx[0].modalTitle || "Error details",
		bodyBackground: "#fafafa",
		$$slots: { content: [create_content_slot] },
		$$scope: { ctx }
	};

	if (/*active*/ ctx[1] !== void 0) {
		modal_props.active = /*active*/ ctx[1];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const modal_changes = {};
			if (dirty & /*preModal*/ 1) modal_changes.title = /*preModal*/ ctx[0].modalTitle || "Error details";

			if (dirty & /*$$scope, preModal*/ 17) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 2) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[1];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PreModal", slots, []);
	let { preModal = {} } = $$props;
	let active = false;

	function openModal() {
		Snackbar.create({
			message: preModal.message || "Error Occured",
			position: "is-top",
			type: `is-${preModal.type || "danger"}`,
			duration: 5000,
			actionText: preModal.actionText || "Show Details",
			onAction: () => {
				$$invalidate(1, active = true);
			}
		});

		$$invalidate(0, preModal.open = false, preModal);
	}

	const writable_props = ["preModal"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PreModal> was created with unknown prop '${key}'`);
	});

	function modal_active_binding(value) {
		active = value;
		$$invalidate(1, active);
	}

	$$self.$$set = $$props => {
		if ("preModal" in $$props) $$invalidate(0, preModal = $$props.preModal);
	};

	$$self.$capture_state = () => ({
		Snackbar,
		Modal,
		preModal,
		active,
		openModal
	});

	$$self.$inject_state = $$props => {
		if ("preModal" in $$props) $$invalidate(0, preModal = $$props.preModal);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*preModal*/ 1) {
			 if (preModal.open) openModal();
		}
	};

	return [preModal, active, modal_active_binding];
}

class PreModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$D, create_fragment$D, safe_not_equal, { preModal: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PreModal",
			options,
			id: create_fragment$D.name
		});
	}

	get preModal() {
		throw new Error("<PreModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<PreModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\FileBrowser.svelte generated by Svelte v3.31.2 */

const { console: console_1$1 } = globals;
const file_1 = "src\\components\\FileBrowser.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

// (111:4) <Icon class="material-icons" on:click="{()=>changeDirectory("..")}">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_back");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(111:4) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=>changeDirectory(\\\"..\\\")}\\\">",
		ctx
	});

	return block;
}

// (113:4) <Icon class="material-icons" on:click="{()=>{getfiles(true)}}">
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("refresh");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(113:4) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=>{getfiles(true)}}\\\">",
		ctx
	});

	return block;
}

// (124:8) <span slot="label">
function create_label_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Select All";
			attr_dev(span, "slot", "label");
			add_location(span, file_1, 123, 8, 4438);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot.name,
		type: "slot",
		source: "(124:8) <span slot=\\\"label\\\">",
		ctx
	});

	return block;
}

// (121:4) <FormField>
function create_default_slot_4$1(ctx) {
	let switch_1;
	let updating_checked;
	let t;
	let current;

	function switch_1_checked_binding(value) {
		/*switch_1_checked_binding*/ ctx[22].call(null, value);
	}

	let switch_1_props = {};

	if (/*selectAll*/ ctx[7] !== void 0) {
		switch_1_props.checked = /*selectAll*/ ctx[7];
	}

	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
	binding_callbacks.push(() => bind(switch_1, "checked", switch_1_checked_binding));
	switch_1.$on("change", /*change_handler*/ ctx[23]);

	const block = {
		c: function create() {
			create_component(switch_1.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(switch_1, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_1_changes = {};

			if (!updating_checked && dirty[0] & /*selectAll*/ 128) {
				updating_checked = true;
				switch_1_changes.checked = /*selectAll*/ ctx[7];
				add_flush_callback(() => updating_checked = false);
			}

			switch_1.$set(switch_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(switch_1, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(121:4) <FormField>",
		ctx
	});

	return block;
}

// (134:12) <Icon class="material-icons" on>
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("keyboard_arrow_down");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(134:12) <Icon class=\\\"material-icons\\\" on>",
		ctx
	});

	return block;
}

// (135:12) <Icon class="material-icons" >
function create_default_slot_2$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("keyboard_arrow_right");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(135:12) <Icon class=\\\"material-icons\\\" >",
		ctx
	});

	return block;
}

// (132:8) <IconButton  toggle bind:pressed={showfiles}>
function create_default_slot_1$5(ctx) {
	let icon0;
	let t;
	let icon1;
	let current;

	icon0 = new Icon({
			props: {
				class: "material-icons",
				on: true,
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon1 = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon0.$$.fragment);
			t = space();
			create_component(icon1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(icon1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon0_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				icon0_changes.$$scope = { dirty, ctx };
			}

			icon0.$set(icon0_changes);
			const icon1_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				icon1_changes.$$scope = { dirty, ctx };
			}

			icon1.$set(icon1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(icon1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(132:8) <IconButton  toggle bind:pressed={showfiles}>",
		ctx
	});

	return block;
}

// (165:4) {:else}
function create_else_block$5(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			div.textContent = "...loading";
			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-cksuwj");
			add_location(div, file_1, 166, 8, 5900);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(165:4) {:else}",
		ctx
	});

	return block;
}

// (161:30) 
function create_if_block_3$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			div.textContent = "Location doesn't exist: Browse files again";
			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-cksuwj");
			add_location(div, file_1, 162, 8, 5769);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(161:30) ",
		ctx
	});

	return block;
}

// (141:4) {#if files_loaded && locationStatus}
function create_if_block$a(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	const if_block_creators = [create_if_block_1$3, create_if_block_2$2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*showfiles*/ ctx[8] && /*fullfiles*/ ctx[2].length > 0) return 0;
		if (/*fullfiles*/ ctx[2].length <= 0) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let each_value = /*otherfolders*/ ctx[6];
	validate_each_argument(each_value);
	const get_key = ctx => /*folder*/ ctx[33].id;
	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "otherFolderlist");
			set_style(div, "cursor", "pointer");
			add_location(div, file_1, 149, 8, 5286);
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				} else {
					if_block = null;
				}
			}

			if (dirty[0] & /*changeDirectory, otherfolders*/ 16448) {
				each_value = /*otherfolders*/ ctx[6];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(141:4) {#if files_loaded && locationStatus}",
		ctx
	});

	return block;
}

// (145:40) 
function create_if_block_2$2(ctx) {
	let div;
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text("No ");
			t1 = text(/*filetype*/ ctx[1]);
			t2 = text(" here!");
			attr_dev(div, "class", "mdc-typography--subtitle1 align center svelte-cksuwj");
			add_location(div, file_1, 145, 12, 5164);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*filetype*/ 2) set_data_dev(t1, /*filetype*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(145:40) ",
		ctx
	});

	return block;
}

// (143:8) {#if showfiles && fullfiles.length>0 }
function create_if_block_1$3(ctx) {
	let virtualchecklist;
	let updating_fileChecked;
	let updating_items;
	let current;

	function virtualchecklist_fileChecked_binding(value) {
		/*virtualchecklist_fileChecked_binding*/ ctx[25].call(null, value);
	}

	function virtualchecklist_items_binding(value) {
		/*virtualchecklist_items_binding*/ ctx[26].call(null, value);
	}

	let virtualchecklist_props = {};

	if (/*fileChecked*/ ctx[0] !== void 0) {
		virtualchecklist_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	if (/*fullfiles*/ ctx[2] !== void 0) {
		virtualchecklist_props.items = /*fullfiles*/ ctx[2];
	}

	virtualchecklist = new VirtualCheckList({
			props: virtualchecklist_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(virtualchecklist, "fileChecked", virtualchecklist_fileChecked_binding));
	binding_callbacks.push(() => bind(virtualchecklist, "items", virtualchecklist_items_binding));
	virtualchecklist.$on("click", /*click_handler_2*/ ctx[27]);

	const block = {
		c: function create() {
			create_component(virtualchecklist.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(virtualchecklist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const virtualchecklist_changes = {};

			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				virtualchecklist_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			if (!updating_items && dirty[0] & /*fullfiles*/ 4) {
				updating_items = true;
				virtualchecklist_changes.items = /*fullfiles*/ ctx[2];
				add_flush_callback(() => updating_items = false);
			}

			virtualchecklist.$set(virtualchecklist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(virtualchecklist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(virtualchecklist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(virtualchecklist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(143:8) {#if showfiles && fullfiles.length>0 }",
		ctx
	});

	return block;
}

// (153:20) <Icon class="material-icons">
function create_default_slot$9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("keyboard_arrow_right");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(153:20) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (151:12) {#each otherfolders as folder (folder.id)}
function create_each_block$2(key_1, ctx) {
	let div1;
	let icon;
	let t0;
	let div0;
	let t1_value = /*folder*/ ctx[33].name + "";
	let t1;
	let t2;
	let div1_transition;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function click_handler_3() {
		return /*click_handler_3*/ ctx[28](/*folder*/ ctx[33]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div1 = element("div");
			create_component(icon.$$.fragment);
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			t2 = space();
			attr_dev(div0, "class", "mdc-typography--subtitle1");
			add_location(div0, file_1, 154, 20, 5602);
			attr_dev(div1, "class", "align svelte-cksuwj");
			add_location(div1, file_1, 151, 16, 5412);
			this.first = div1;
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(icon, div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, t1);
			append_dev(div1, t2);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_3, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const icon_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			if ((!current || dirty[0] & /*otherfolders*/ 64) && t1_value !== (t1_value = /*folder*/ ctx[33].name + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			if (local) {
				add_render_callback(() => {
					if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, true);
					div1_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);

			if (local) {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, false);
				div1_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(icon);
			if (detaching && div1_transition) div1_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(151:12) {#each otherfolders as folder (folder.id)}",
		ctx
	});

	return block;
}

function create_fragment$E(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let div0;
	let icon0;
	let t1;
	let icon1;
	let t2;
	let customiconswitch;
	let updating_toggler;
	let t3;
	let textfield;
	let updating_value;
	let t4;
	let div1;
	let formfield;
	let t5;
	let div4;
	let div3;
	let iconbutton;
	let updating_pressed;
	let t6;
	let div2;
	let t7;
	let t8;
	let current_block_type_index;
	let if_block;
	let div4_id_value;
	let current;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[17].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[5] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[5];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));

	icon0 = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon0.$on("click", /*click_handler*/ ctx[18]);

	icon1 = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon1.$on("click", /*click_handler_1*/ ctx[19]);

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[20].call(null, value);
	}

	let customiconswitch_props = { icons: ["trending_up", "trending_down"] };

	if (/*sortFile*/ ctx[3] !== void 0) {
		customiconswitch_props.toggler = /*sortFile*/ ctx[3];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[21].call(null, value);
	}

	let textfield_props = {
		style: "margin-bottom:1em;",
		label: "Seach"
	};

	if (/*searchKey*/ ctx[9] !== void 0) {
		textfield_props.value = /*searchKey*/ ctx[9];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
	textfield.$on("keyup", /*searchfile*/ ctx[12]);

	formfield = new FormField({
			props: {
				$$slots: {
					default: [create_default_slot_4$1],
					label: [create_label_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	function iconbutton_pressed_binding(value) {
		/*iconbutton_pressed_binding*/ ctx[24].call(null, value);
	}

	let iconbutton_props = {
		toggle: true,
		$$slots: { default: [create_default_slot_1$5] },
		$$scope: { ctx }
	};

	if (/*showfiles*/ ctx[8] !== void 0) {
		iconbutton_props.pressed = /*showfiles*/ ctx[8];
	}

	iconbutton = new IconButton({ props: iconbutton_props, $$inline: true });
	binding_callbacks.push(() => bind(iconbutton, "pressed", iconbutton_pressed_binding));
	const if_block_creators = [create_if_block$a, create_if_block_3$1, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*files_loaded*/ ctx[10] && /*locationStatus*/ ctx[4]) return 0;
		if (!/*locationStatus*/ ctx[4]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			div0 = element("div");
			create_component(icon0.$$.fragment);
			t1 = space();
			create_component(icon1.$$.fragment);
			t2 = space();
			create_component(customiconswitch.$$.fragment);
			t3 = space();
			create_component(textfield.$$.fragment);
			t4 = space();
			div1 = element("div");
			create_component(formfield.$$.fragment);
			t5 = space();
			div4 = element("div");
			div3 = element("div");
			create_component(iconbutton.$$.fragment);
			t6 = space();
			div2 = element("div");
			t7 = text(/*parentFolder*/ ctx[11]);
			t8 = space();
			if_block.c();
			attr_dev(div0, "class", "align center browseIcons svelte-cksuwj");
			add_location(div0, file_1, 109, 0, 3815);
			attr_dev(div1, "class", "align center svelte-cksuwj");
			add_location(div1, file_1, 119, 0, 4236);
			attr_dev(div2, "class", "mdc-typography--subtitle1");
			add_location(div2, file_1, 136, 8, 4835);
			attr_dev(div3, "class", "align folderlist svelte-cksuwj");
			add_location(div3, file_1, 129, 4, 4569);
			attr_dev(div4, "class", "folderfile-list svelte-cksuwj");
			attr_dev(div4, "id", div4_id_value = "" + (/*filetype*/ ctx[1] + "_filebrowser"));
			add_location(div4, file_1, 127, 0, 4504);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div0, anchor);
			mount_component(icon0, div0, null);
			append_dev(div0, t1);
			mount_component(icon1, div0, null);
			append_dev(div0, t2);
			mount_component(customiconswitch, div0, null);
			insert_dev(target, t3, anchor);
			mount_component(textfield, target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, div1, anchor);
			mount_component(formfield, div1, null);
			insert_dev(target, t5, anchor);
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			mount_component(iconbutton, div3, null);
			append_dev(div3, t6);
			append_dev(div3, div2);
			append_dev(div2, t7);
			append_dev(div4, t8);
			if_blocks[current_block_type_index].m(div4, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const premodal_changes = {};

			if (!updating_preModal && dirty[0] & /*preModal*/ 32) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[5];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);
			const icon0_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				icon0_changes.$$scope = { dirty, ctx };
			}

			icon0.$set(icon0_changes);
			const icon1_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				icon1_changes.$$scope = { dirty, ctx };
			}

			icon1.$set(icon1_changes);
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty[0] & /*sortFile*/ 8) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*sortFile*/ ctx[3];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);
			const textfield_changes = {};

			if (!updating_value && dirty[0] & /*searchKey*/ 512) {
				updating_value = true;
				textfield_changes.value = /*searchKey*/ ctx[9];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
			const formfield_changes = {};

			if (dirty[0] & /*selectAll, fileChecked, fullfiles*/ 133 | dirty[1] & /*$$scope*/ 32) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
			const iconbutton_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_pressed && dirty[0] & /*showfiles*/ 256) {
				updating_pressed = true;
				iconbutton_changes.pressed = /*showfiles*/ ctx[8];
				add_flush_callback(() => updating_pressed = false);
			}

			iconbutton.$set(iconbutton_changes);
			if (!current || dirty[0] & /*parentFolder*/ 2048) set_data_dev(t7, /*parentFolder*/ ctx[11]);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div4, null);
			}

			if (!current || dirty[0] & /*filetype*/ 2 && div4_id_value !== (div4_id_value = "" + (/*filetype*/ ctx[1] + "_filebrowser"))) {
				attr_dev(div4, "id", div4_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(customiconswitch.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(formfield.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(customiconswitch.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(formfield.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div0);
			destroy_component(icon0);
			destroy_component(icon1);
			destroy_component(customiconswitch);
			if (detaching) detach_dev(t3);
			destroy_component(textfield, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div1);
			destroy_component(formfield);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(div4);
			destroy_component(iconbutton);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$E($$self, $$props, $$invalidate) {
	let locationStatus;
	let parentFolder;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FileBrowser", slots, []);

	let { fileChecked = [] } = $$props,
		{ currentLocation = "" } = $$props,
		{ filetype = "*.*" } = $$props,
		{ fullfileslist = [] } = $$props;

	const dispatch = createEventDispatcher();
	let preModal = {};
	let fullfiles = [];

	// $: fullfileslist
	function dispatch_chdir_event() {
		dispatch("chdir", {
			action: "chdir",
			filetype,
			currentLocation
		});
	}

	let original_location = currentLocation;
	let otherfolders = [], selectAll = false, showfiles = true, original_files = [];
	let searchKey = "";

	const searchfile = () => {
		console.log(searchKey);

		if (!searchKey) {
			$$invalidate(2, fullfiles = original_files);
		} else {
			$$invalidate(2, fullfiles = original_files.filter(file => file.name.includes(searchKey)));
		}
	};

	let files_loaded = false;

	function getfiles(toast = false) {
		if (!locationStatus) {
			return window.createToast("Location undefined", "danger");
		}

		original_files = $$invalidate(6, otherfolders = $$invalidate(2, fullfiles = $$invalidate(0, fileChecked = [])));
		$$invalidate(7, selectAll = $$invalidate(10, files_loaded = false));

		try {
			console.log("Current location: ", currentLocation);
			let folderfile = fs.readdirSync(currentLocation);
			original_files = $$invalidate(2, fullfiles = folderfile.filter(file => file.endsWith(filetype) && fs.lstatSync(path.join(currentLocation, file)).isFile()).map(file => file = { name: file, id: getID() }).sort((a, b) => a.name < b.name ? 1 : -1));
			$$invalidate(16, fullfileslist = fullfiles.map(file => file = file.name));
			$$invalidate(6, otherfolders = folderfile.filter(file => fs.lstatSync(path.join(currentLocation, file)).isDirectory()).map(file => file = { name: file, id: getID() }).sort((a, b) => a.name > b.name ? 1 : -1));
			original_location = currentLocation;
			$$invalidate(10, files_loaded = true);
			console.log("Folder updated", otherfolders);
			dispatch_chdir_event();

			if (filetype.length > 2) {
				localStorage[`${filetype}_location`] = currentLocation;
			}

			if (toast) {
				window.createToast("Files updated");
			}
		} catch(err) {
			console.log(err);
			$$invalidate(5, preModal.modalContent = err.stack, preModal);
			$$invalidate(5, preModal.open = true, preModal);
			return;
		}
	}

	let sortFile = false;

	const changeDirectory = goto => {
		$$invalidate(15, currentLocation = path.resolve(currentLocation, goto));
		getfiles();
	};

	onMount(() => {
		if (locationStatus) {
			getfiles();
			console.log("onMount Updating location for ", filetype);
		}
	});

	afterUpdate(() => {
		if (original_location !== currentLocation && locationStatus) {
			getfiles(true);
			console.log("Updating location for ", filetype);
		}
	});

	const writable_props = ["fileChecked", "currentLocation", "filetype", "fullfileslist"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<FileBrowser> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(5, preModal);
	}

	const click_handler = () => changeDirectory("..");

	const click_handler_1 = () => {
		getfiles(true);
	};

	function customiconswitch_toggler_binding(value) {
		sortFile = value;
		$$invalidate(3, sortFile);
	}

	function textfield_value_binding(value) {
		searchKey = value;
		$$invalidate(9, searchKey);
	}

	function switch_1_checked_binding(value) {
		selectAll = value;
		$$invalidate(7, selectAll);
	}

	const change_handler = () => selectAll
	? $$invalidate(0, fileChecked = fullfiles.map(file => file = file.name))
	: $$invalidate(0, fileChecked = []);

	function iconbutton_pressed_binding(value) {
		showfiles = value;
		$$invalidate(8, showfiles);
	}

	function virtualchecklist_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	function virtualchecklist_items_binding(value) {
		fullfiles = value;
		($$invalidate(2, fullfiles), $$invalidate(3, sortFile));
	}

	const click_handler_2 = () => $$invalidate(7, selectAll = false);
	const click_handler_3 = folder => changeDirectory(folder.name);

	$$self.$$set = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("currentLocation" in $$props) $$invalidate(15, currentLocation = $$props.currentLocation);
		if ("filetype" in $$props) $$invalidate(1, filetype = $$props.filetype);
		if ("fullfileslist" in $$props) $$invalidate(16, fullfileslist = $$props.fullfileslist);
	};

	$$self.$capture_state = () => ({
		IconButton,
		Icon,
		slide,
		FormField,
		Switch,
		Textfield,
		onMount,
		afterUpdate,
		CustomIconSwitch,
		VirtualCheckList,
		createEventDispatcher,
		PreModal,
		fileChecked,
		currentLocation,
		filetype,
		fullfileslist,
		dispatch,
		preModal,
		fullfiles,
		dispatch_chdir_event,
		original_location,
		otherfolders,
		selectAll,
		showfiles,
		original_files,
		searchKey,
		searchfile,
		files_loaded,
		getfiles,
		sortFile,
		changeDirectory,
		locationStatus,
		parentFolder
	});

	$$self.$inject_state = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("currentLocation" in $$props) $$invalidate(15, currentLocation = $$props.currentLocation);
		if ("filetype" in $$props) $$invalidate(1, filetype = $$props.filetype);
		if ("fullfileslist" in $$props) $$invalidate(16, fullfileslist = $$props.fullfileslist);
		if ("preModal" in $$props) $$invalidate(5, preModal = $$props.preModal);
		if ("fullfiles" in $$props) $$invalidate(2, fullfiles = $$props.fullfiles);
		if ("original_location" in $$props) original_location = $$props.original_location;
		if ("otherfolders" in $$props) $$invalidate(6, otherfolders = $$props.otherfolders);
		if ("selectAll" in $$props) $$invalidate(7, selectAll = $$props.selectAll);
		if ("showfiles" in $$props) $$invalidate(8, showfiles = $$props.showfiles);
		if ("original_files" in $$props) original_files = $$props.original_files;
		if ("searchKey" in $$props) $$invalidate(9, searchKey = $$props.searchKey);
		if ("files_loaded" in $$props) $$invalidate(10, files_loaded = $$props.files_loaded);
		if ("sortFile" in $$props) $$invalidate(3, sortFile = $$props.sortFile);
		if ("locationStatus" in $$props) $$invalidate(4, locationStatus = $$props.locationStatus);
		if ("parentFolder" in $$props) $$invalidate(11, parentFolder = $$props.parentFolder);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentLocation*/ 32768) {
			 $$invalidate(4, locationStatus = fs.existsSync(currentLocation));
		}

		if ($$self.$$.dirty[0] & /*locationStatus, currentLocation*/ 32784) {
			 $$invalidate(11, parentFolder = locationStatus
			? path.basename(currentLocation)
			: "Undefined");
		}

		if ($$self.$$.dirty[0] & /*sortFile, fullfiles*/ 12) {
			 sortFile
			? $$invalidate(2, fullfiles = fullfiles.sort((a, b) => a.name > b.name ? 1 : -1))
			: $$invalidate(2, fullfiles = fullfiles.sort((a, b) => a.name < b.name ? 1 : -1));
		}
	};

	return [
		fileChecked,
		filetype,
		fullfiles,
		sortFile,
		locationStatus,
		preModal,
		otherfolders,
		selectAll,
		showfiles,
		searchKey,
		files_loaded,
		parentFolder,
		searchfile,
		getfiles,
		changeDirectory,
		currentLocation,
		fullfileslist,
		premodal_preModal_binding,
		click_handler,
		click_handler_1,
		customiconswitch_toggler_binding,
		textfield_value_binding,
		switch_1_checked_binding,
		change_handler,
		iconbutton_pressed_binding,
		virtualchecklist_fileChecked_binding,
		virtualchecklist_items_binding,
		click_handler_2,
		click_handler_3
	];
}

class FileBrowser extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$E,
			create_fragment$E,
			safe_not_equal,
			{
				fileChecked: 0,
				currentLocation: 15,
				filetype: 1,
				fullfileslist: 16
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FileBrowser",
			options,
			id: create_fragment$E.name
		});
	}

	get fileChecked() {
		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLocation() {
		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filetype() {
		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filetype(value) {
		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullfileslist() {
		throw new Error("<FileBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullfileslist(value) {
		throw new Error("<FileBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\icon_animations\Hamburger1.svelte generated by Svelte v3.31.2 */

const file$C = "src\\components\\icon_animations\\Hamburger1.svelte";

// (609:4) {:else}
function create_else_block$6(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 611, 12, 12286);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 613, 12, 12315);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 614, 12, 12342);
			attr_dev(div, "class", "icon nav-icon-8 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 610, 8, 12189);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_7*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(609:4) {:else}",
		ctx
	});

	return block;
}

// (602:25) 
function create_if_block_6$1(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 603, 12, 12075);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 604, 12, 12102);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 605, 12, 12129);
			attr_dev(div, "class", "icon nav-icon-7 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 602, 8, 11978);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_6*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(602:25) ",
		ctx
	});

	return block;
}

// (596:25) 
function create_if_block_5$1(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 597, 12, 11858);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 598, 12, 11885);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 599, 12, 11912);
			attr_dev(div, "class", "icon nav-icon-6 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 596, 8, 11761);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_5*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(596:25) ",
		ctx
	});

	return block;
}

// (590:25) 
function create_if_block_4$1(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 591, 12, 11641);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 592, 12, 11668);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 593, 12, 11695);
			attr_dev(div, "class", "icon nav-icon-5 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 590, 8, 11544);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_4*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(590:25) ",
		ctx
	});

	return block;
}

// (584:25) 
function create_if_block_3$2(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 585, 12, 11424);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 586, 12, 11451);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 587, 12, 11478);
			attr_dev(div, "class", "icon nav-icon-4 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 584, 8, 11327);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_3*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(584:25) ",
		ctx
	});

	return block;
}

// (578:25) 
function create_if_block_2$3(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 579, 12, 11207);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 580, 12, 11234);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 581, 12, 11261);
			attr_dev(div, "class", "icon nav-icon-3 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 578, 8, 11110);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_2*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(578:25) ",
		ctx
	});

	return block;
}

// (572:25) 
function create_if_block_1$4(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 573, 12, 10990);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 574, 12, 11017);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 575, 12, 11044);
			attr_dev(div, "class", "icon nav-icon-2 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 572, 8, 10893);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(572:25) ",
		ctx
	});

	return block;
}

// (560:4) {#if style===1}
function create_if_block$b(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let t2;
	let span3;
	let t3;
	let span4;
	let t4;
	let span5;
	let t5;
	let span6;
	let t6;
	let span7;
	let t7;
	let span8;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			t2 = space();
			span3 = element("span");
			t3 = space();
			span4 = element("span");
			t4 = space();
			span5 = element("span");
			t5 = space();
			span6 = element("span");
			t6 = space();
			span7 = element("span");
			t7 = space();
			span8 = element("span");
			attr_dev(span0, "class", "svelte-1dmun7w");
			add_location(span0, file$C, 561, 12, 10611);
			attr_dev(span1, "class", "svelte-1dmun7w");
			add_location(span1, file$C, 562, 12, 10638);
			attr_dev(span2, "class", "svelte-1dmun7w");
			add_location(span2, file$C, 563, 12, 10665);
			attr_dev(span3, "class", "svelte-1dmun7w");
			add_location(span3, file$C, 564, 12, 10692);
			attr_dev(span4, "class", "svelte-1dmun7w");
			add_location(span4, file$C, 565, 12, 10719);
			attr_dev(span5, "class", "svelte-1dmun7w");
			add_location(span5, file$C, 566, 12, 10746);
			attr_dev(span6, "class", "svelte-1dmun7w");
			add_location(span6, file$C, 567, 12, 10773);
			attr_dev(span7, "class", "svelte-1dmun7w");
			add_location(span7, file$C, 568, 12, 10800);
			attr_dev(span8, "class", "svelte-1dmun7w");
			add_location(span8, file$C, 569, 12, 10827);
			attr_dev(div, "class", "icon nav-icon-1 svelte-1dmun7w");
			toggle_class(div, "open", /*active*/ ctx[0]);
			add_location(div, file$C, 560, 8, 10514);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(div, t0);
			append_dev(div, span1);
			append_dev(div, t1);
			append_dev(div, span2);
			append_dev(div, t2);
			append_dev(div, span3);
			append_dev(div, t3);
			append_dev(div, span4);
			append_dev(div, t4);
			append_dev(div, span5);
			append_dev(div, t5);
			append_dev(div, span6);
			append_dev(div, t6);
			append_dev(div, span7);
			append_dev(div, t7);
			append_dev(div, span8);

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*active*/ 1) {
				toggle_class(div, "open", /*active*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(560:4) {#if style===1}",
		ctx
	});

	return block;
}

function create_fragment$F(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*style*/ ctx[1] === 1) return create_if_block$b;
		if (/*style*/ ctx[1] === 2) return create_if_block_1$4;
		if (/*style*/ ctx[1] === 3) return create_if_block_2$3;
		if (/*style*/ ctx[1] === 4) return create_if_block_3$2;
		if (/*style*/ ctx[1] === 5) return create_if_block_4$1;
		if (/*style*/ ctx[1] === 6) return create_if_block_5$1;
		if (/*style*/ ctx[1] === 7) return create_if_block_6$1;
		return create_else_block$6;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			add_location(div, file$C, 557, 0, 10475);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Hamburger1", slots, []);
	let { style = 6 } = $$props, { active = false } = $$props;
	const writable_props = ["style", "active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Hamburger1> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, active = !active);
	const click_handler_1 = () => $$invalidate(0, active = !active);
	const click_handler_2 = () => $$invalidate(0, active = !active);
	const click_handler_3 = () => $$invalidate(0, active = !active);
	const click_handler_4 = () => $$invalidate(0, active = !active);
	const click_handler_5 = () => $$invalidate(0, active = !active);
	const click_handler_6 = () => $$invalidate(0, active = !active);
	const click_handler_7 = () => $$invalidate(0, active = !active);

	$$self.$$set = $$props => {
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({ style, active });

	$$self.$inject_state = $$props => {
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		style,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		click_handler_7
	];
}

class Hamburger1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$F, create_fragment$F, safe_not_equal, { style: 1, active: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Hamburger1",
			options,
			id: create_fragment$F.name
		});
	}

	get style() {
		throw new Error("<Hamburger1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Hamburger1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Hamburger1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Hamburger1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Layout.svelte generated by Svelte v3.31.2 */

const { console: console_1$2 } = globals;
const file$D = "src\\components\\Layout.svelte";
const get_plotContainer_slot_changes = dirty => ({});
const get_plotContainer_slot_context = ctx => ({});
const get_buttonContainer_slot_changes = dirty => ({});
const get_buttonContainer_slot_context = ctx => ({});

// (124:8) {#if toggleBrowser}
function create_if_block_1$5(ctx) {
	let div;
	let filebrowser;
	let updating_currentLocation;
	let updating_fileChecked;
	let updating_fullfileslist;
	let div_transition;
	let current;

	function filebrowser_currentLocation_binding(value) {
		/*filebrowser_currentLocation_binding*/ ctx[14].call(null, value);
	}

	function filebrowser_fileChecked_binding(value) {
		/*filebrowser_fileChecked_binding*/ ctx[15].call(null, value);
	}

	function filebrowser_fullfileslist_binding(value) {
		/*filebrowser_fullfileslist_binding*/ ctx[16].call(null, value);
	}

	let filebrowser_props = { filetype: /*filetype*/ ctx[6] };

	if (/*currentLocation*/ ctx[4] !== void 0) {
		filebrowser_props.currentLocation = /*currentLocation*/ ctx[4];
	}

	if (/*fileChecked*/ ctx[0] !== void 0) {
		filebrowser_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	if (/*fullfileslist*/ ctx[3] !== void 0) {
		filebrowser_props.fullfileslist = /*fullfileslist*/ ctx[3];
	}

	filebrowser = new FileBrowser({ props: filebrowser_props, $$inline: true });
	binding_callbacks.push(() => bind(filebrowser, "currentLocation", filebrowser_currentLocation_binding));
	binding_callbacks.push(() => bind(filebrowser, "fileChecked", filebrowser_fileChecked_binding));
	binding_callbacks.push(() => bind(filebrowser, "fullfileslist", filebrowser_fullfileslist_binding));
	filebrowser.$on("chdir", /*chdir_handler*/ ctx[17]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(filebrowser.$$.fragment);
			attr_dev(div, "class", "column is-one-fifth-widescreen is-one-quarter-desktop box filebrowser adjust-right svelte-dv3co1");
			add_location(div, file$D, 124, 12, 3674);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(filebrowser, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const filebrowser_changes = {};
			if (dirty & /*filetype*/ 64) filebrowser_changes.filetype = /*filetype*/ ctx[6];

			if (!updating_currentLocation && dirty & /*currentLocation*/ 16) {
				updating_currentLocation = true;
				filebrowser_changes.currentLocation = /*currentLocation*/ ctx[4];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				filebrowser_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			if (!updating_fullfileslist && dirty & /*fullfileslist*/ 8) {
				updating_fullfileslist = true;
				filebrowser_changes.fullfileslist = /*fullfileslist*/ ctx[3];
				add_flush_callback(() => updating_fullfileslist = false);
			}

			filebrowser.$set(filebrowser_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(filebrowser.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: -100, duration: 500 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(filebrowser.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: -100, duration: 500 }, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(filebrowser);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(124:8) {#if toggleBrowser}",
		ctx
	});

	return block;
}

// (144:20) {#if toggleBrowser}
function create_if_block$c(ctx) {
	let current;
	const buttonContainer_slot_template = /*#slots*/ ctx[12].buttonContainer;
	const buttonContainer_slot = create_slot(buttonContainer_slot_template, ctx, /*$$scope*/ ctx[11], get_buttonContainer_slot_context);

	const block = {
		c: function create() {
			if (buttonContainer_slot) buttonContainer_slot.c();
		},
		m: function mount(target, anchor) {
			if (buttonContainer_slot) {
				buttonContainer_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (buttonContainer_slot) {
				if (buttonContainer_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(buttonContainer_slot, buttonContainer_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_buttonContainer_slot_changes, get_buttonContainer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(buttonContainer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(buttonContainer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (buttonContainer_slot) buttonContainer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(144:20) {#if toggleBrowser}",
		ctx
	});

	return block;
}

function create_fragment$G(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let section;
	let div5;
	let t1;
	let div4;
	let div3;
	let div0;
	let hamburger1;
	let updating_active;
	let t2;
	let button0;
	let t3;
	let button0_id_value;
	let t4;
	let textfield;
	let updating_value;
	let t5;
	let button1;
	let t7;
	let div1;
	let div1_id_value;
	let div1_resize_listener;
	let t8;
	let div2;
	let div2_id_value;
	let div3_id_value;
	let div3_resize_listener;
	let current;
	let mounted;
	let dispose;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[13].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[2] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[2];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));
	let if_block0 = /*toggleBrowser*/ ctx[1] && create_if_block_1$5(ctx);

	function hamburger1_active_binding(value) {
		/*hamburger1_active_binding*/ ctx[18].call(null, value);
	}

	let hamburger1_props = {};

	if (/*toggleBrowser*/ ctx[1] !== void 0) {
		hamburger1_props.active = /*toggleBrowser*/ ctx[1];
	}

	hamburger1 = new Hamburger1({ props: hamburger1_props, $$inline: true });
	binding_callbacks.push(() => bind(hamburger1, "active", hamburger1_active_binding));

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[19].call(null, value);
	}

	let textfield_props = {
		style: "margin-bottom:1em; width:70%;",
		label: "Current location"
	};

	if (/*currentLocation*/ ctx[4] !== void 0) {
		textfield_props.value = /*currentLocation*/ ctx[4];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
	let if_block1 = /*toggleBrowser*/ ctx[1] && create_if_block$c(ctx);
	const plotContainer_slot_template = /*#slots*/ ctx[12].plotContainer;
	const plotContainer_slot = create_slot(plotContainer_slot_template, ctx, /*$$scope*/ ctx[11], get_plotContainer_slot_context);

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			section = element("section");
			div5 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			create_component(hamburger1.$$.fragment);
			t2 = space();
			button0 = element("button");
			t3 = text("Browse");
			t4 = space();
			create_component(textfield.$$.fragment);
			t5 = space();
			button1 = element("button");
			button1.textContent = "Need help?";
			t7 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t8 = space();
			div2 = element("div");
			if (plotContainer_slot) plotContainer_slot.c();
			attr_dev(button0, "class", "button is-link gap");
			attr_dev(button0, "id", button0_id_value = "" + (/*filetype*/ ctx[6] + "_filebrowser_btn"));
			add_location(button0, file$D, 136, 20, 4299);
			attr_dev(button1, "class", "button is-link is-pulled-right");
			add_location(button1, file$D, 139, 20, 4557);
			attr_dev(div0, "class", "align");
			set_style(div0, "flex-wrap", "nowrap");
			add_location(div0, file$D, 132, 16, 4164);
			attr_dev(div1, "class", "align buttonContainer svelte-dv3co1");
			attr_dev(div1, "id", div1_id_value = "" + (/*filetype*/ ctx[6] + "-buttonContainer"));
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[20].call(div1));
			add_location(div1, file$D, 142, 16, 4689);
			attr_dev(div2, "class", "plotContainer svelte-dv3co1");
			attr_dev(div2, "id", div2_id_value = "" + (/*filetype*/ ctx[6] + "-plotContainer"));
			add_location(div2, file$D, 147, 16, 4966);
			attr_dev(div3, "class", "container button-plot-container box svelte-dv3co1");
			attr_dev(div3, "id", div3_id_value = "" + (/*filetype*/ ctx[6] + "-button-plot-container"));
			add_render_callback(() => /*div3_elementresize_handler*/ ctx[21].call(div3));
			add_location(div3, file$D, 131, 12, 4023);
			attr_dev(div4, "class", "column fileContainer svelte-dv3co1");
			add_location(div4, file$D, 129, 8, 3972);
			attr_dev(div5, "class", "columns");
			add_location(div5, file$D, 121, 4, 3608);
			attr_dev(section, "id", /*id*/ ctx[5]);
			set_style(section, "display", "none");
			attr_dev(section, "class", "animated fadeIn");
			add_location(section, file$D, 120, 0, 3543);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div5);
			if (if_block0) if_block0.m(div5, null);
			append_dev(div5, t1);
			append_dev(div5, div4);
			append_dev(div4, div3);
			append_dev(div3, div0);
			mount_component(hamburger1, div0, null);
			append_dev(div0, t2);
			append_dev(div0, button0);
			append_dev(button0, t3);
			append_dev(div0, t4);
			mount_component(textfield, div0, null);
			append_dev(div0, t5);
			append_dev(div0, button1);
			append_dev(div3, t7);
			append_dev(div3, div1);
			if (if_block1) if_block1.m(div1, null);
			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[20].bind(div1));
			append_dev(div3, t8);
			append_dev(div3, div2);

			if (plotContainer_slot) {
				plotContainer_slot.m(div2, null);
			}

			div3_resize_listener = add_resize_listener(div3, /*div3_elementresize_handler*/ ctx[21].bind(div3));
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*browse_folder*/ ctx[9], false, false, false),
					listen_dev(button1, "click", /*tour_event*/ ctx[10], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const premodal_changes = {};

			if (!updating_preModal && dirty & /*preModal*/ 4) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[2];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);

			if (/*toggleBrowser*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*toggleBrowser*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div5, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const hamburger1_changes = {};

			if (!updating_active && dirty & /*toggleBrowser*/ 2) {
				updating_active = true;
				hamburger1_changes.active = /*toggleBrowser*/ ctx[1];
				add_flush_callback(() => updating_active = false);
			}

			hamburger1.$set(hamburger1_changes);

			if (!current || dirty & /*filetype*/ 64 && button0_id_value !== (button0_id_value = "" + (/*filetype*/ ctx[6] + "_filebrowser_btn"))) {
				attr_dev(button0, "id", button0_id_value);
			}

			const textfield_changes = {};

			if (!updating_value && dirty & /*currentLocation*/ 16) {
				updating_value = true;
				textfield_changes.value = /*currentLocation*/ ctx[4];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (/*toggleBrowser*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*toggleBrowser*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$c(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*filetype*/ 64 && div1_id_value !== (div1_id_value = "" + (/*filetype*/ ctx[6] + "-buttonContainer"))) {
				attr_dev(div1, "id", div1_id_value);
			}

			if (plotContainer_slot) {
				if (plotContainer_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(plotContainer_slot, plotContainer_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_plotContainer_slot_changes, get_plotContainer_slot_context);
				}
			}

			if (!current || dirty & /*filetype*/ 64 && div2_id_value !== (div2_id_value = "" + (/*filetype*/ ctx[6] + "-plotContainer"))) {
				attr_dev(div2, "id", div2_id_value);
			}

			if (!current || dirty & /*filetype*/ 64 && div3_id_value !== (div3_id_value = "" + (/*filetype*/ ctx[6] + "-button-plot-container"))) {
				attr_dev(div3, "id", div3_id_value);
			}

			if (!current || dirty & /*id*/ 32) {
				attr_dev(section, "id", /*id*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(if_block0);
			transition_in(hamburger1.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block1);
			transition_in(plotContainer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(if_block0);
			transition_out(hamburger1.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block1);
			transition_out(plotContainer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			if (if_block0) if_block0.d();
			destroy_component(hamburger1);
			destroy_component(textfield);
			if (if_block1) if_block1.d();
			div1_resize_listener();
			if (plotContainer_slot) plotContainer_slot.d(detaching);
			div3_resize_listener();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function browse({ filetype = "", dir = true } = {}) {
	return new Promise((resolve, reject) => {
			const mainWindow = remote.getCurrentWindow();
			let type;
			dir ? type = "openDirectory" : type = "openFile";

			const options = {
				filters: [
					{
						name: filetype,
						extensions: [`*${filetype}`]
					},
					{ name: "All Files", extensions: ["*"] }
				],
				properties: [type, "multiSelections"]
			};

			if (process.versions.electron >= "7") {
				remote.dialog.showOpenDialog(mainWindow, options).then(result => {
					console.log(result.canceled);
					console.log(result.filePaths);
					resolve(result);
				}).catch(err => {
					window.createToast("Couldn't open folder", "danger");
					reject(err);
				});
			} else {
				let result = {};

				remote.dialog.showOpenDialog(null, options, location => {
					location === undefined
					? result = { canceled: true, filePaths: [] }
					: result = { canceled: false, filePaths: location };

					console.log(result.canceled);
					console.log(result.filePaths);
					resolve(result);
				});
			}
		});
}

function instance$G($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Layout", slots, ['buttonContainer','plotContainer']);

	let { id } = $$props,
		{ fileChecked = [] } = $$props,
		{ filetype = "felix" } = $$props,
		{ toggleBrowser = false } = $$props,
		{ preModal = {} } = $$props,
		{ fullfileslist = [] } = $$props;

	let { currentLocation = localStorage[`${filetype}_location`] || "" } = $$props;
	const dispatch = createEventDispatcher();

	function browse_folder() {
		browse({ dir: true }).then(result => {
			if (!result.canceled) {
				$$invalidate(4, currentLocation = localStorage[`${filetype}_location`] = result.filePaths[0]);
			}
		});
	}

	function tour_event() {
		dispatch("tour", { filetype });
	}

	let ContainerHeight, buttonContainerHeight, mounted = false;

	onMount(() => {
		$$invalidate(1, toggleBrowser = true);
		mounted = true;
	});

	afterUpdate(() => {
		const plotContainer = document.getElementById(`${filetype}-plotContainer`);
		plotContainer.style.height = `calc(${ContainerHeight}px - ${buttonContainerHeight}px - 11em)`;
	});

	const writable_props = [
		"id",
		"fileChecked",
		"filetype",
		"toggleBrowser",
		"preModal",
		"fullfileslist",
		"currentLocation"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(2, preModal);
	}

	function filebrowser_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(4, currentLocation);
	}

	function filebrowser_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	function filebrowser_fullfileslist_binding(value) {
		fullfileslist = value;
		$$invalidate(3, fullfileslist);
	}

	function chdir_handler(event) {
		bubble($$self, event);
	}

	function hamburger1_active_binding(value) {
		toggleBrowser = value;
		$$invalidate(1, toggleBrowser);
	}

	function textfield_value_binding(value) {
		currentLocation = value;
		$$invalidate(4, currentLocation);
	}

	function div1_elementresize_handler() {
		buttonContainerHeight = this.clientHeight;
		$$invalidate(8, buttonContainerHeight);
	}

	function div3_elementresize_handler() {
		ContainerHeight = this.clientHeight;
		$$invalidate(7, ContainerHeight);
	}

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(5, id = $$props.id);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("filetype" in $$props) $$invalidate(6, filetype = $$props.filetype);
		if ("toggleBrowser" in $$props) $$invalidate(1, toggleBrowser = $$props.toggleBrowser);
		if ("preModal" in $$props) $$invalidate(2, preModal = $$props.preModal);
		if ("fullfileslist" in $$props) $$invalidate(3, fullfileslist = $$props.fullfileslist);
		if ("currentLocation" in $$props) $$invalidate(4, currentLocation = $$props.currentLocation);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		browse,
		fly,
		Textfield,
		onMount,
		afterUpdate,
		FileBrowser,
		Hamburger1,
		createEventDispatcher,
		PreModal,
		id,
		fileChecked,
		filetype,
		toggleBrowser,
		preModal,
		fullfileslist,
		currentLocation,
		dispatch,
		browse_folder,
		tour_event,
		ContainerHeight,
		buttonContainerHeight,
		mounted
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(5, id = $$props.id);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("filetype" in $$props) $$invalidate(6, filetype = $$props.filetype);
		if ("toggleBrowser" in $$props) $$invalidate(1, toggleBrowser = $$props.toggleBrowser);
		if ("preModal" in $$props) $$invalidate(2, preModal = $$props.preModal);
		if ("fullfileslist" in $$props) $$invalidate(3, fullfileslist = $$props.fullfileslist);
		if ("currentLocation" in $$props) $$invalidate(4, currentLocation = $$props.currentLocation);
		if ("ContainerHeight" in $$props) $$invalidate(7, ContainerHeight = $$props.ContainerHeight);
		if ("buttonContainerHeight" in $$props) $$invalidate(8, buttonContainerHeight = $$props.buttonContainerHeight);
		if ("mounted" in $$props) mounted = $$props.mounted;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		fileChecked,
		toggleBrowser,
		preModal,
		fullfileslist,
		currentLocation,
		id,
		filetype,
		ContainerHeight,
		buttonContainerHeight,
		browse_folder,
		tour_event,
		$$scope,
		slots,
		premodal_preModal_binding,
		filebrowser_currentLocation_binding,
		filebrowser_fileChecked_binding,
		filebrowser_fullfileslist_binding,
		chdir_handler,
		hamburger1_active_binding,
		textfield_value_binding,
		div1_elementresize_handler,
		div3_elementresize_handler
	];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			id: 5,
			fileChecked: 0,
			filetype: 6,
			toggleBrowser: 1,
			preModal: 2,
			fullfileslist: 3,
			currentLocation: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$G.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[5] === undefined && !("id" in props)) {
			console_1$2.warn("<Layout> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fileChecked() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filetype() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filetype(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggleBrowser() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggleBrowser(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullfileslist() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullfileslist(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLocation() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var candidateSelectors = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])',
];
var candidateSelector = candidateSelectors.join(',');

var matches$1 = typeof Element === 'undefined'
  ? function () {}
  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};

  var regularTabbables = [];
  var orderedTabbables = [];

  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches$1.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate)) continue;

    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(sortOrderedTabbables)
    .map(function(a) { return a.node })
    .concat(regularTabbables);

  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node) {
  if (
    !isNodeMatchingSelectorFocusable(node)
    || isNonTabbableRadio(node)
    || getTabindex(node) < 0
  ) {
    return false;
  }
  return true;
}

function isTabbable(node) {
  if (!node) throw new Error('No node provided');
  if (matches$1.call(node, candidateSelector) === false) return false;
  return isNodeMatchingSelectorTabbable(node);
}

function isNodeMatchingSelectorFocusable(node) {
  if (
    node.disabled
    || isHiddenInput(node)
    || isHidden(node)
  ) {
    return false;
  }
  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
function isFocusable(node) {
  if (!node) throw new Error('No node provided');
  if (matches$1.call(node, focusableCandidateSelector) === false) return false;
  return isNodeMatchingSelectorFocusable(node);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
  if (!isNaN(tabindexAttr)) return tabindexAttr;
  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  if (isContentEditable(node)) return 0;
  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) return true;
  // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

function isHidden(node) {
  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
}

var tabbable_1 = tabbable;

var immutable = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var activeFocusDelay;

var activeFocusTraps = (function() {
  var trapQueue = [];
  return {
    activateTrap: function(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }

      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        // move this existing trap to the front of the queue
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },

    deactivateTrap: function(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }

      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
})();

function focusTrap(element, userOptions) {
  var doc = document;
  var container =
    typeof element === 'string' ? doc.querySelector(element) : element;

  var config = immutable(
    {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    },
    userOptions
  );

  var state = {
    firstTabbableNode: null,
    lastTabbableNode: null,
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (state.active) return;

    updateTabbableNodes();

    state.active = true;
    state.paused = false;
    state.nodeFocusedBeforeActivation = doc.activeElement;

    var onActivate =
      activateOptions && activateOptions.onActivate
        ? activateOptions.onActivate
        : config.onActivate;
    if (onActivate) {
      onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!state.active) return;

    clearTimeout(activeFocusDelay);

    removeListeners();
    state.active = false;
    state.paused = false;

    activeFocusTraps.deactivateTrap(trap);

    var onDeactivate =
      deactivateOptions && deactivateOptions.onDeactivate !== undefined
        ? deactivateOptions.onDeactivate
        : config.onDeactivate;
    if (onDeactivate) {
      onDeactivate();
    }

    var returnFocus =
      deactivateOptions && deactivateOptions.returnFocus !== undefined
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate;
    if (returnFocus) {
      delay(function() {
        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
      });
    }

    return trap;
  }

  function pause() {
    if (state.paused || !state.active) return;
    state.paused = true;
    removeListeners();
  }

  function unpause() {
    if (!state.paused || !state.active) return;
    state.paused = false;
    updateTabbableNodes();
    addListeners();
  }

  function addListeners() {
    if (!state.active) return;

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    activeFocusDelay = delay(function() {
      tryFocus(getInitialFocusNode());
    });

    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });

    return trap;
  }

  function removeListeners() {
    if (!state.active) return;

    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function getInitialFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error(
        'Your focus-trap needs to have at least one focusable element'
      );
    }

    return node;
  }

  function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus');
    return node ? node : previousActiveElement;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  function checkPointerDown(e) {
    if (container.contains(e.target)) return;
    if (config.clickOutsideDeactivates) {
      deactivate({
        returnFocus: !tabbable_1.isFocusable(e.target)
      });
      return;
    }
    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
  }

  // In case focus escapes the trap for some strange reason, pull it back in.
  function checkFocusIn(e) {
    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (container.contains(e.target) || e.target instanceof Document) {
      return;
    }
    e.stopImmediatePropagation();
    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
  }

  function checkKey(e) {
    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      e.preventDefault();
      deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  }

  // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  function checkTab(e) {
    updateTabbableNodes();
    if (e.shiftKey && e.target === state.firstTabbableNode) {
      e.preventDefault();
      tryFocus(state.lastTabbableNode);
      return;
    }
    if (!e.shiftKey && e.target === state.lastTabbableNode) {
      e.preventDefault();
      tryFocus(state.firstTabbableNode);
      return;
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function updateTabbableNodes() {
    var tabbableNodes = tabbable_1(container);
    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
    state.lastTabbableNode =
      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
  }

  function tryFocus(node) {
    if (node === doc.activeElement) return;
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus();
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  }
}

function isSelectableInput(node) {
  return (
    node.tagName &&
    node.tagName.toLowerCase() === 'input' &&
    typeof node.select === 'function'
  );
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
}

function delay(fn) {
  return setTimeout(fn, 0);
}

var focusTrap_1 = focusTrap;

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
    if (focusTrapFactory === void 0) { focusTrapFactory = focusTrap_1; }
    return focusTrapFactory(surfaceEl, {
        clickOutsideDeactivates: true,
        escapeDeactivates: false,
        initialFocus: initialFocusEl,
    });
}
function isScrollable(el) {
    return el ? el.scrollHeight > el.offsetHeight : false;
}
function areTopsMisaligned(els) {
    var tops = new Set();
    [].forEach.call(els, function (el) { return tops.add(el.offsetTop); });
    return tops.size > 1;
}
//# sourceMappingURL=util.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$g = {
    CLOSING: 'mdc-dialog--closing',
    OPEN: 'mdc-dialog--open',
    OPENING: 'mdc-dialog--opening',
    SCROLLABLE: 'mdc-dialog--scrollable',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    STACKED: 'mdc-dialog--stacked',
};
var strings$h = {
    ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
    BUTTON_DEFAULT_ATTRIBUTE: 'data-mdc-dialog-button-default',
    BUTTON_SELECTOR: '.mdc-dialog__button',
    CLOSED_EVENT: 'MDCDialog:closed',
    CLOSE_ACTION: 'close',
    CLOSING_EVENT: 'MDCDialog:closing',
    CONTAINER_SELECTOR: '.mdc-dialog__container',
    CONTENT_SELECTOR: '.mdc-dialog__content',
    DESTROY_ACTION: 'destroy',
    INITIAL_FOCUS_ATTRIBUTE: 'data-mdc-dialog-initial-focus',
    OPENED_EVENT: 'MDCDialog:opened',
    OPENING_EVENT: 'MDCDialog:opening',
    SCRIM_SELECTOR: '.mdc-dialog__scrim',
    SUPPRESS_DEFAULT_PRESS_SELECTOR: [
        'textarea',
        '.mdc-menu .mdc-list-item',
    ].join(', '),
    SURFACE_SELECTOR: '.mdc-dialog__surface',
};
var numbers$6 = {
    DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
    DIALOG_ANIMATION_OPEN_TIME_MS: 150,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCDialogFoundation = /** @class */ (function (_super) {
    __extends(MDCDialogFoundation, _super);
    function MDCDialogFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCDialogFoundation.defaultAdapter, adapter)) || this;
        _this.isOpen_ = false;
        _this.animationFrame_ = 0;
        _this.animationTimer_ = 0;
        _this.layoutFrame_ = 0;
        _this.escapeKeyAction_ = strings$h.CLOSE_ACTION;
        _this.scrimClickAction_ = strings$h.CLOSE_ACTION;
        _this.autoStackButtons_ = true;
        _this.areButtonsStacked_ = false;
        return _this;
    }
    Object.defineProperty(MDCDialogFoundation, "cssClasses", {
        get: function () {
            return cssClasses$g;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "strings", {
        get: function () {
            return strings$h;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "numbers", {
        get: function () {
            return numbers$6;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
        get: function () {
            return {
                addBodyClass: function () { return undefined; },
                addClass: function () { return undefined; },
                areButtonsStacked: function () { return false; },
                clickDefaultButton: function () { return undefined; },
                eventTargetMatches: function () { return false; },
                getActionFromEvent: function () { return ''; },
                getInitialFocusEl: function () { return null; },
                hasClass: function () { return false; },
                isContentScrollable: function () { return false; },
                notifyClosed: function () { return undefined; },
                notifyClosing: function () { return undefined; },
                notifyOpened: function () { return undefined; },
                notifyOpening: function () { return undefined; },
                releaseFocus: function () { return undefined; },
                removeBodyClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                reverseButtons: function () { return undefined; },
                trapFocus: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCDialogFoundation.prototype.init = function () {
        if (this.adapter_.hasClass(cssClasses$g.STACKED)) {
            this.setAutoStackButtons(false);
        }
    };
    MDCDialogFoundation.prototype.destroy = function () {
        if (this.isOpen_) {
            this.close(strings$h.DESTROY_ACTION);
        }
        if (this.animationTimer_) {
            clearTimeout(this.animationTimer_);
            this.handleAnimationTimerEnd_();
        }
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
            this.layoutFrame_ = 0;
        }
    };
    MDCDialogFoundation.prototype.open = function () {
        var _this = this;
        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.addClass(cssClasses$g.OPENING);
        // Wait a frame once display is no longer "none", to establish basis for animation
        this.runNextAnimationFrame_(function () {
            _this.adapter_.addClass(cssClasses$g.OPEN);
            _this.adapter_.addBodyClass(cssClasses$g.SCROLL_LOCK);
            _this.layout();
            _this.animationTimer_ = setTimeout(function () {
                _this.handleAnimationTimerEnd_();
                _this.adapter_.trapFocus(_this.adapter_.getInitialFocusEl());
                _this.adapter_.notifyOpened();
            }, numbers$6.DIALOG_ANIMATION_OPEN_TIME_MS);
        });
    };
    MDCDialogFoundation.prototype.close = function (action) {
        var _this = this;
        if (action === void 0) { action = ''; }
        if (!this.isOpen_) {
            // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
            return;
        }
        this.isOpen_ = false;
        this.adapter_.notifyClosing(action);
        this.adapter_.addClass(cssClasses$g.CLOSING);
        this.adapter_.removeClass(cssClasses$g.OPEN);
        this.adapter_.removeBodyClass(cssClasses$g.SCROLL_LOCK);
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
            _this.adapter_.releaseFocus();
            _this.handleAnimationTimerEnd_();
            _this.adapter_.notifyClosed(action);
        }, numbers$6.DIALOG_ANIMATION_CLOSE_TIME_MS);
    };
    MDCDialogFoundation.prototype.isOpen = function () {
        return this.isOpen_;
    };
    MDCDialogFoundation.prototype.getEscapeKeyAction = function () {
        return this.escapeKeyAction_;
    };
    MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {
        this.escapeKeyAction_ = action;
    };
    MDCDialogFoundation.prototype.getScrimClickAction = function () {
        return this.scrimClickAction_;
    };
    MDCDialogFoundation.prototype.setScrimClickAction = function (action) {
        this.scrimClickAction_ = action;
    };
    MDCDialogFoundation.prototype.getAutoStackButtons = function () {
        return this.autoStackButtons_;
    };
    MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {
        this.autoStackButtons_ = autoStack;
    };
    MDCDialogFoundation.prototype.layout = function () {
        var _this = this;
        if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
            _this.layoutInternal_();
            _this.layoutFrame_ = 0;
        });
    };
    /** Handles click on the dialog root element. */
    MDCDialogFoundation.prototype.handleClick = function (evt) {
        var isScrim = this.adapter_.eventTargetMatches(evt.target, strings$h.SCRIM_SELECTOR);
        // Check for scrim click first since it doesn't require querying ancestors.
        if (isScrim && this.scrimClickAction_ !== '') {
            this.close(this.scrimClickAction_);
        }
        else {
            var action = this.adapter_.getActionFromEvent(evt);
            if (action) {
                this.close(action);
            }
        }
    };
    /** Handles keydown on the dialog root element. */
    MDCDialogFoundation.prototype.handleKeydown = function (evt) {
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        if (!isEnter) {
            return;
        }
        var action = this.adapter_.getActionFromEvent(evt);
        if (action) {
            // Action button callback is handled in `handleClick`,
            // since space/enter keydowns on buttons trigger click events.
            return;
        }
        var isDefault = !this.adapter_.eventTargetMatches(evt.target, strings$h.SUPPRESS_DEFAULT_PRESS_SELECTOR);
        if (isEnter && isDefault) {
            this.adapter_.clickDefaultButton();
        }
    };
    /** Handles keydown on the document. */
    MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {
        var isEscape = evt.key === 'Escape' || evt.keyCode === 27;
        if (isEscape && this.escapeKeyAction_ !== '') {
            this.close(this.escapeKeyAction_);
        }
    };
    MDCDialogFoundation.prototype.layoutInternal_ = function () {
        if (this.autoStackButtons_) {
            this.detectStackedButtons_();
        }
        this.detectScrollableContent_();
    };
    MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function () {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(cssClasses$g.OPENING);
        this.adapter_.removeClass(cssClasses$g.CLOSING);
    };
    /**
     * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
     */
    MDCDialogFoundation.prototype.runNextAnimationFrame_ = function (callback) {
        var _this = this;
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
            _this.animationFrame_ = 0;
            clearTimeout(_this.animationTimer_);
            _this.animationTimer_ = setTimeout(callback, 0);
        });
    };
    MDCDialogFoundation.prototype.detectStackedButtons_ = function () {
        // Remove the class first to let us measure the buttons' natural positions.
        this.adapter_.removeClass(cssClasses$g.STACKED);
        var areButtonsStacked = this.adapter_.areButtonsStacked();
        if (areButtonsStacked) {
            this.adapter_.addClass(cssClasses$g.STACKED);
        }
        if (areButtonsStacked !== this.areButtonsStacked_) {
            this.adapter_.reverseButtons();
            this.areButtonsStacked_ = areButtonsStacked;
        }
    };
    MDCDialogFoundation.prototype.detectScrollableContent_ = function () {
        // Remove the class first to let us measure the natural height of the content.
        this.adapter_.removeClass(cssClasses$g.SCROLLABLE);
        if (this.adapter_.isContentScrollable()) {
            this.adapter_.addClass(cssClasses$g.SCROLLABLE);
        }
    };
    return MDCDialogFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$i = MDCDialogFoundation.strings;
var MDCDialog = /** @class */ (function (_super) {
    __extends(MDCDialog, _super);
    function MDCDialog() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCDialog.prototype, "isOpen", {
        get: function () {
            return this.foundation_.isOpen();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "escapeKeyAction", {
        get: function () {
            return this.foundation_.getEscapeKeyAction();
        },
        set: function (action) {
            this.foundation_.setEscapeKeyAction(action);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "scrimClickAction", {
        get: function () {
            return this.foundation_.getScrimClickAction();
        },
        set: function (action) {
            this.foundation_.setScrimClickAction(action);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCDialog.prototype, "autoStackButtons", {
        get: function () {
            return this.foundation_.getAutoStackButtons();
        },
        set: function (autoStack) {
            this.foundation_.setAutoStackButtons(autoStack);
        },
        enumerable: true,
        configurable: true
    });
    MDCDialog.attachTo = function (root) {
        return new MDCDialog(root);
    };
    MDCDialog.prototype.initialize = function (focusTrapFactory) {
        var e_1, _a;
        var container = this.root_.querySelector(strings$i.CONTAINER_SELECTOR);
        if (!container) {
            throw new Error("Dialog component requires a " + strings$i.CONTAINER_SELECTOR + " container element");
        }
        this.container_ = container;
        this.content_ = this.root_.querySelector(strings$i.CONTENT_SELECTOR);
        this.buttons_ = [].slice.call(this.root_.querySelectorAll(strings$i.BUTTON_SELECTOR));
        this.defaultButton_ = this.root_.querySelector("[" + strings$i.BUTTON_DEFAULT_ATTRIBUTE + "]");
        this.focusTrapFactory_ = focusTrapFactory;
        this.buttonRipples_ = [];
        try {
            for (var _b = __values(this.buttons_), _c = _b.next(); !_c.done; _c = _b.next()) {
                var buttonEl = _c.value;
                this.buttonRipples_.push(new MDCRipple(buttonEl));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    MDCDialog.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.getInitialFocusEl_() || undefined);
        this.handleClick_ = this.foundation_.handleClick.bind(this.foundation_);
        this.handleKeydown_ = this.foundation_.handleKeydown.bind(this.foundation_);
        this.handleDocumentKeydown_ = this.foundation_.handleDocumentKeydown.bind(this.foundation_);
        this.handleLayout_ = this.layout.bind(this);
        var LAYOUT_EVENTS = ['resize', 'orientationchange'];
        this.handleOpening_ = function () {
            LAYOUT_EVENTS.forEach(function (evtType) { return window.addEventListener(evtType, _this.handleLayout_); });
            document.addEventListener('keydown', _this.handleDocumentKeydown_);
        };
        this.handleClosing_ = function () {
            LAYOUT_EVENTS.forEach(function (evtType) { return window.removeEventListener(evtType, _this.handleLayout_); });
            document.removeEventListener('keydown', _this.handleDocumentKeydown_);
        };
        this.listen('click', this.handleClick_);
        this.listen('keydown', this.handleKeydown_);
        this.listen(strings$i.OPENING_EVENT, this.handleOpening_);
        this.listen(strings$i.CLOSING_EVENT, this.handleClosing_);
    };
    MDCDialog.prototype.destroy = function () {
        this.unlisten('click', this.handleClick_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(strings$i.OPENING_EVENT, this.handleOpening_);
        this.unlisten(strings$i.CLOSING_EVENT, this.handleClosing_);
        this.handleClosing_();
        this.buttonRipples_.forEach(function (ripple) { return ripple.destroy(); });
        _super.prototype.destroy.call(this);
    };
    MDCDialog.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCDialog.prototype.open = function () {
        this.foundation_.open();
    };
    MDCDialog.prototype.close = function (action) {
        if (action === void 0) { action = ''; }
        this.foundation_.close(action);
    };
    MDCDialog.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addBodyClass: function (className) { return document.body.classList.add(className); },
            addClass: function (className) { return _this.root_.classList.add(className); },
            areButtonsStacked: function () { return areTopsMisaligned(_this.buttons_); },
            clickDefaultButton: function () { return _this.defaultButton_ && _this.defaultButton_.click(); },
            eventTargetMatches: function (target, selector) { return target ? matches(target, selector) : false; },
            getActionFromEvent: function (evt) {
                if (!evt.target) {
                    return '';
                }
                var element = closest(evt.target, "[" + strings$i.ACTION_ATTRIBUTE + "]");
                return element && element.getAttribute(strings$i.ACTION_ATTRIBUTE);
            },
            getInitialFocusEl: function () { return _this.getInitialFocusEl_(); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            isContentScrollable: function () { return isScrollable(_this.content_); },
            notifyClosed: function (action) { return _this.emit(strings$i.CLOSED_EVENT, action ? { action: action } : {}); },
            notifyClosing: function (action) { return _this.emit(strings$i.CLOSING_EVENT, action ? { action: action } : {}); },
            notifyOpened: function () { return _this.emit(strings$i.OPENED_EVENT, {}); },
            notifyOpening: function () { return _this.emit(strings$i.OPENING_EVENT, {}); },
            releaseFocus: function () { return _this.focusTrap_.deactivate(); },
            removeBodyClass: function (className) { return document.body.classList.remove(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            reverseButtons: function () {
                _this.buttons_.reverse();
                _this.buttons_.forEach(function (button) {
                    button.parentElement.appendChild(button);
                });
            },
            trapFocus: function () { return _this.focusTrap_.activate(); },
        };
        return new MDCDialogFoundation(adapter);
    };
    MDCDialog.prototype.getInitialFocusEl_ = function () {
        return document.querySelector("[" + strings$i.INITIAL_FOCUS_ATTRIBUTE + "]");
    };
    return MDCDialog;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\dialog\Dialog.svelte generated by Svelte v3.31.2 */
const file$E = "node_modules\\@smui\\dialog\\Dialog.svelte";

function create_fragment$H(ctx) {
	let div3;
	let div1;
	let div0;
	let t;
	let div2;
	let div3_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	let div3_levels = [
		{
			class: div3_class_value = "mdc-dialog " + /*className*/ ctx[1]
		},
		{ role: "alertdialog" },
		{ "aria-modal": "true" },
		exclude(/*$$props*/ ctx[5], ["use", "class"])
	];

	let div3_data = {};

	for (let i = 0; i < div3_levels.length; i += 1) {
		div3_data = assign(div3_data, div3_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div2 = element("div");
			attr_dev(div0, "class", "mdc-dialog__surface");
			add_location(div0, file$E, 11, 4, 273);
			attr_dev(div1, "class", "mdc-dialog__container");
			add_location(div1, file$E, 10, 2, 233);
			attr_dev(div2, "class", "mdc-dialog__scrim");
			add_location(div2, file$E, 15, 2, 349);
			set_attributes(div3, div3_data);
			add_location(div3, file$E, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div3, t);
			append_dev(div3, div2);
			/*div3_binding*/ ctx[16](div3);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div3, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[3].call(null, div3)),
					listen_dev(div3, "MDCDialog:opened", /*handleDialogOpened*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}

			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
				(!current || dirty & /*className*/ 2 && div3_class_value !== (div3_class_value = "mdc-dialog " + /*className*/ ctx[1])) && { class: div3_class_value },
				{ role: "alertdialog" },
				{ "aria-modal": "true" },
				dirty & /*$$props*/ 32 && exclude(/*$$props*/ ctx[5], ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (default_slot) default_slot.d(detaching);
			/*div3_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Dialog", slots, ['default']);

	const forwardEvents = forwardEventsBuilder(get_current_component(), [
		"MDCDialog:opening",
		"MDCDialog:opened",
		"MDCDialog:closing",
		"MDCDialog:closed"
	]);

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { escapeKeyAction = "close" } = $$props;
	let { scrimClickAction = "close" } = $$props;
	let { autoStackButtons = true } = $$props;
	let element;
	let dialog;
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;
	let layoutListeners = [];

	let addLayoutListenerFn = listener => {
		layoutListeners.push(listener);

		return () => {
			const idx = layoutListeners.indexOf(listener);

			if (idx >= 0) {
				layoutListeners.splice(idx, 1);
			}
		};
	};

	setContext("SMUI:addLayoutListener", addLayoutListenerFn);

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	onMount(() => {
		$$invalidate(13, dialog = new MDCDialog(element));
	});

	onDestroy(() => {
		dialog && dialog.destroy();

		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function handleDialogOpened() {
		layoutListeners.forEach(listener => listener());
	}

	function open(...args) {
		return dialog.open(...args);
	}

	function close(...args) {
		return dialog.close(...args);
	}

	function isOpen() {
		return dialog.isOpen;
	}

	function layout(...args) {
		return dialog.layout(...args);
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("escapeKeyAction" in $$new_props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
		if ("scrimClickAction" in $$new_props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
		if ("autoStackButtons" in $$new_props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCDialog,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		escapeKeyAction,
		scrimClickAction,
		autoStackButtons,
		element,
		dialog,
		addLayoutListener,
		removeLayoutListener,
		layoutListeners,
		addLayoutListenerFn,
		handleDialogOpened,
		open,
		close,
		isOpen,
		layout
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("escapeKeyAction" in $$props) $$invalidate(6, escapeKeyAction = $$new_props.escapeKeyAction);
		if ("scrimClickAction" in $$props) $$invalidate(7, scrimClickAction = $$new_props.scrimClickAction);
		if ("autoStackButtons" in $$props) $$invalidate(8, autoStackButtons = $$new_props.autoStackButtons);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("dialog" in $$props) $$invalidate(13, dialog = $$new_props.dialog);
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
		if ("layoutListeners" in $$props) layoutListeners = $$new_props.layoutListeners;
		if ("addLayoutListenerFn" in $$props) addLayoutListenerFn = $$new_props.addLayoutListenerFn;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dialog, escapeKeyAction*/ 8256) {
			 dialog && $$invalidate(13, dialog.escapeKeyAction = escapeKeyAction, dialog);
		}

		if ($$self.$$.dirty & /*dialog, scrimClickAction*/ 8320) {
			 dialog && $$invalidate(13, dialog.scrimClickAction = scrimClickAction, dialog);
		}

		if ($$self.$$.dirty & /*dialog, autoStackButtons*/ 8448) {
			 dialog && $$invalidate(13, dialog.autoStackButtons = autoStackButtons, dialog);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		element,
		forwardEvents,
		handleDialogOpened,
		$$props,
		escapeKeyAction,
		scrimClickAction,
		autoStackButtons,
		open,
		close,
		isOpen,
		layout,
		dialog,
		$$scope,
		slots,
		div3_binding
	];
}

class Dialog extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
			use: 0,
			class: 1,
			escapeKeyAction: 6,
			scrimClickAction: 7,
			autoStackButtons: 8,
			open: 9,
			close: 10,
			isOpen: 11,
			layout: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dialog",
			options,
			id: create_fragment$H.name
		});
	}

	get use() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get escapeKeyAction() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set escapeKeyAction(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrimClickAction() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrimClickAction(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoStackButtons() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoStackButtons(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[9];
	}

	set open(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[10];
	}

	set close(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		return this.$$.ctx[11];
	}

	set isOpen(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[12];
	}

	set layout(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\H2.svelte generated by Svelte v3.31.2 */
const file$F = "node_modules\\@smui\\common\\H2.svelte";

function create_fragment$I(ctx) {
	let h2;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let h2_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let h2_data = {};

	for (let i = 0; i < h2_levels.length; i += 1) {
		h2_data = assign(h2_data, h2_levels[i]);
	}

	const block = {
		c: function create() {
			h2 = element("h2");
			if (default_slot) default_slot.c();
			set_attributes(h2, h2_data);
			add_location(h2, file$F, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);

			if (default_slot) {
				default_slot.m(h2, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, h2, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, h2))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(h2, h2_data = get_spread_update(h2_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("H2", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class H2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$I, create_fragment$I, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "H2",
			options,
			id: create_fragment$I.name
		});
	}

	get use() {
		throw new Error("<H2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<H2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Title = classAdderBuilder({
  class: 'mdc-dialog__title',
  component: H2,
  contexts: {}
});

var Content = classAdderBuilder({
  class: 'mdc-dialog__content',
  component: Div,
  contexts: {}
});

/* node_modules\@smui\common\Footer.svelte generated by Svelte v3.31.2 */
const file$G = "node_modules\\@smui\\common\\Footer.svelte";

function create_fragment$J(ctx) {
	let footer;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let footer_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let footer_data = {};

	for (let i = 0; i < footer_levels.length; i += 1) {
		footer_data = assign(footer_data, footer_levels[i]);
	}

	const block = {
		c: function create() {
			footer = element("footer");
			if (default_slot) default_slot.c();
			set_attributes(footer, footer_data);
			add_location(footer, file$G, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);

			if (default_slot) {
				default_slot.m(footer, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, footer, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, footer))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(footer, footer_data = get_spread_update(footer_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Footer", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class Footer$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$J, create_fragment$J, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment$J.name
		});
	}

	get use() {
		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Actions = classAdderBuilder({
  class: 'mdc-dialog__actions',
  component: Footer$1,
  contexts: {
    'SMUI:button:context': 'dialog:action'
  }
});

function InitialFocus(node) {
  node.setAttribute('data-mdc-dialog-initial-focus', '');

  return {
    destroy() {
      node.removeAttribute('data-mdc-dialog-initial-focus');
    }
  }
}

/* node_modules\@smui\button\Button.svelte generated by Svelte v3.31.2 */

// (1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class="     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   "   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >
function create_default_slot$a(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   use={[[Ripple, {ripple, unbounded: false, classForward: classes => rippleClasses = classes}], forwardEvents, ...use]}   class=\\\"     mdc-button     {className}     {rippleClasses.join(' ')}     {variant === 'raised' ? 'mdc-button--raised' : ''}     {variant === 'unelevated' ? 'mdc-button--unelevated' : ''}     {variant === 'outlined' ? 'mdc-button--outlined' : ''}     {dense ? 'mdc-button--dense' : ''}     {color === 'secondary' ? 'smui-button--color-secondary' : ''}     {context === 'card:action' ? 'mdc-card__action' : ''}     {context === 'card:action' ? 'mdc-card__action--button' : ''}     {context === 'dialog:action' ? 'mdc-dialog__button' : ''}     {context === 'top-app-bar:navigation' ? 'mdc-top-app-bar__navigation-icon' : ''}     {context === 'top-app-bar:action' ? 'mdc-top-app-bar__action-item' : ''}     {context === 'snackbar' ? 'mdc-snackbar__action' : ''}   \\\"   {...actionProp}   {...defaultProp}   {...exclude($$props, ['use', 'class', 'ripple', 'color', 'variant', 'dense', ...dialogExcludes])} >",
		ctx
	});

	return block;
}

function create_fragment$K(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [
				[
					Ripple,
					{
						ripple: /*ripple*/ ctx[2],
						unbounded: false,
						classForward: /*func*/ ctx[18]
					}
				],
				/*forwardEvents*/ ctx[11],
				.../*use*/ ctx[0]
			]
		},
		{
			class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(" ") + "\n    " + (/*variant*/ ctx[4] === "raised"
			? "mdc-button--raised"
			: "") + "\n    " + (/*variant*/ ctx[4] === "unelevated"
			? "mdc-button--unelevated"
			: "") + "\n    " + (/*variant*/ ctx[4] === "outlined"
			? "mdc-button--outlined"
			: "") + "\n    " + (/*dense*/ ctx[5] ? "mdc-button--dense" : "") + "\n    " + (/*color*/ ctx[3] === "secondary"
			? "smui-button--color-secondary"
			: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
			? "mdc-card__action"
			: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
			? "mdc-card__action--button"
			: "") + "\n    " + (/*context*/ ctx[12] === "dialog:action"
			? "mdc-dialog__button"
			: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:navigation"
			? "mdc-top-app-bar__navigation-icon"
			: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:action"
			? "mdc-top-app-bar__action-item"
			: "") + "\n    " + (/*context*/ ctx[12] === "snackbar"
			? "mdc-snackbar__action"
			: "") + "\n  "
		},
		/*actionProp*/ ctx[9],
		/*defaultProp*/ ctx[10],
		exclude(/*$$props*/ ctx[13], [
			"use",
			"class",
			"ripple",
			"color",
			"variant",
			"dense",
			.../*dialogExcludes*/ ctx[8]
		])
	];

	var switch_value = /*component*/ ctx[6];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$a] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use, className, variant, dense, color, context, actionProp, defaultProp, exclude, $$props, dialogExcludes*/ 16319)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*Ripple, ripple, rippleClasses, forwardEvents, use*/ 2181 && {
						use: [
							[
								Ripple,
								{
									ripple: /*ripple*/ ctx[2],
									unbounded: false,
									classForward: /*func*/ ctx[18]
								}
							],
							/*forwardEvents*/ ctx[11],
							.../*use*/ ctx[0]
						]
					},
					dirty & /*className, rippleClasses, variant, dense, color, context*/ 4282 && {
						class: "\n    mdc-button\n    " + /*className*/ ctx[1] + "\n    " + /*rippleClasses*/ ctx[7].join(" ") + "\n    " + (/*variant*/ ctx[4] === "raised"
						? "mdc-button--raised"
						: "") + "\n    " + (/*variant*/ ctx[4] === "unelevated"
						? "mdc-button--unelevated"
						: "") + "\n    " + (/*variant*/ ctx[4] === "outlined"
						? "mdc-button--outlined"
						: "") + "\n    " + (/*dense*/ ctx[5] ? "mdc-button--dense" : "") + "\n    " + (/*color*/ ctx[3] === "secondary"
						? "smui-button--color-secondary"
						: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
						? "mdc-card__action"
						: "") + "\n    " + (/*context*/ ctx[12] === "card:action"
						? "mdc-card__action--button"
						: "") + "\n    " + (/*context*/ ctx[12] === "dialog:action"
						? "mdc-dialog__button"
						: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:navigation"
						? "mdc-top-app-bar__navigation-icon"
						: "") + "\n    " + (/*context*/ ctx[12] === "top-app-bar:action"
						? "mdc-top-app-bar__action-item"
						: "") + "\n    " + (/*context*/ ctx[12] === "snackbar"
						? "mdc-snackbar__action"
						: "") + "\n  "
					},
					dirty & /*actionProp*/ 512 && get_spread_object(/*actionProp*/ ctx[9]),
					dirty & /*defaultProp*/ 1024 && get_spread_object(/*defaultProp*/ ctx[10]),
					dirty & /*exclude, $$props, dialogExcludes*/ 8448 && get_spread_object(exclude(/*$$props*/ ctx[13], [
						"use",
						"class",
						"ripple",
						"color",
						"variant",
						"dense",
						.../*dialogExcludes*/ ctx[8]
					]))
				])
			: {};

			if (dirty & /*$$scope*/ 524288) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[6])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props, $$invalidate) {
	let dialogExcludes;
	let actionProp;
	let defaultProp;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { color = "primary" } = $$props;
	let { variant = "text" } = $$props;
	let { dense = false } = $$props;
	let { href = null } = $$props;
	let { action = "close" } = $$props;
	let { default: defaultAction = false } = $$props;
	let { component = href == null ? Button : A } = $$props;
	let context = getContext("SMUI:button:context");
	let rippleClasses = [];
	setContext("SMUI:label:context", "button");
	setContext("SMUI:icon:context", "button");
	const func = classes => $$invalidate(7, rippleClasses = classes);

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(2, ripple = $$new_props.ripple);
		if ("color" in $$new_props) $$invalidate(3, color = $$new_props.color);
		if ("variant" in $$new_props) $$invalidate(4, variant = $$new_props.variant);
		if ("dense" in $$new_props) $$invalidate(5, dense = $$new_props.dense);
		if ("href" in $$new_props) $$invalidate(14, href = $$new_props.href);
		if ("action" in $$new_props) $$invalidate(15, action = $$new_props.action);
		if ("default" in $$new_props) $$invalidate(16, defaultAction = $$new_props.default);
		if ("component" in $$new_props) $$invalidate(6, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		A,
		Button,
		Ripple,
		forwardEvents,
		use,
		className,
		ripple,
		color,
		variant,
		dense,
		href,
		action,
		defaultAction,
		component,
		context,
		rippleClasses,
		dialogExcludes,
		actionProp,
		defaultProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(2, ripple = $$new_props.ripple);
		if ("color" in $$props) $$invalidate(3, color = $$new_props.color);
		if ("variant" in $$props) $$invalidate(4, variant = $$new_props.variant);
		if ("dense" in $$props) $$invalidate(5, dense = $$new_props.dense);
		if ("href" in $$props) $$invalidate(14, href = $$new_props.href);
		if ("action" in $$props) $$invalidate(15, action = $$new_props.action);
		if ("defaultAction" in $$props) $$invalidate(16, defaultAction = $$new_props.defaultAction);
		if ("component" in $$props) $$invalidate(6, component = $$new_props.component);
		if ("context" in $$props) $$invalidate(12, context = $$new_props.context);
		if ("rippleClasses" in $$props) $$invalidate(7, rippleClasses = $$new_props.rippleClasses);
		if ("dialogExcludes" in $$props) $$invalidate(8, dialogExcludes = $$new_props.dialogExcludes);
		if ("actionProp" in $$props) $$invalidate(9, actionProp = $$new_props.actionProp);
		if ("defaultProp" in $$props) $$invalidate(10, defaultProp = $$new_props.defaultProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*action*/ 32768) {
			 $$invalidate(9, actionProp = context === "dialog:action" && action !== null
			? { "data-mdc-dialog-action": action }
			: {});
		}

		if ($$self.$$.dirty & /*defaultAction*/ 65536) {
			 $$invalidate(10, defaultProp = context === "dialog:action" && defaultAction
			? { "data-mdc-dialog-button-default": "" }
			: {});
		}
	};

	 $$invalidate(8, dialogExcludes = context === "dialog:action" ? ["action", "default"] : []);
	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		ripple,
		color,
		variant,
		dense,
		component,
		rippleClasses,
		dialogExcludes,
		actionProp,
		defaultProp,
		forwardEvents,
		context,
		$$props,
		href,
		action,
		defaultAction,
		slots,
		func,
		$$scope
	];
}

class Button_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			use: 0,
			class: 1,
			ripple: 2,
			color: 3,
			variant: 4,
			dense: 5,
			href: 14,
			action: 15,
			default: 16,
			component: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button_1",
			options,
			id: create_fragment$K.name
		});
	}

	get use() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variant() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get action() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set action(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get default() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set default(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomDialog.svelte generated by Svelte v3.31.2 */

// (18:2) <Title id="{id}-title">
function create_default_slot_7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*title*/ ctx[4]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 16) set_data_dev(t, /*title*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(18:2) <Title id=\\\"{id}-title\\\">",
		ctx
	});

	return block;
}

// (19:2) <Content id="{id}-content">
function create_default_slot_6$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*content*/ ctx[5]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*content*/ 32) set_data_dev(t, /*content*/ ctx[5]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(19:2) <Content id=\\\"{id}-content\\\">",
		ctx
	});

	return block;
}

// (21:29) <Label>
function create_default_slot_5$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label1*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label1*/ 4) set_data_dev(t, /*label1*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(21:29) <Label>",
		ctx
	});

	return block;
}

// (21:4) <Button action={label1}>
function create_default_slot_4$2(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope, label1*/ 516) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(21:4) <Button action={label1}>",
		ctx
	});

	return block;
}

// (22:58) <Label>
function create_default_slot_3$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*label2*/ ctx[3]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label2*/ 8) set_data_dev(t, /*label2*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(22:58) <Label>",
		ctx
	});

	return block;
}

// (22:4) <Button action={label2} default use={[InitialFocus]}>
function create_default_slot_2$6(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope, label2*/ 520) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$6.name,
		type: "slot",
		source: "(22:4) <Button action={label2} default use={[InitialFocus]}>",
		ctx
	});

	return block;
}

// (20:2) <Actions>
function create_default_slot_1$6(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button_1({
			props: {
				action: /*label1*/ ctx[2],
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button_1({
			props: {
				action: /*label2*/ ctx[3],
				default: true,
				use: [InitialFocus],
				$$slots: { default: [create_default_slot_2$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*label1*/ 4) button0_changes.action = /*label1*/ ctx[2];

			if (dirty & /*$$scope, label1*/ 516) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*label2*/ 8) button1_changes.action = /*label2*/ ctx[3];

			if (dirty & /*$$scope, label2*/ 520) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(20:2) <Actions>",
		ctx
	});

	return block;
}

// (11:0) <Dialog    bind:this={dialog}      aria-labelledby="{id}-title"    aria-describedby="{id}-content"    on:MDCDialog:closed={sendAction} >
function create_default_slot$b(ctx) {
	let title_1;
	let t0;
	let content_1;
	let t1;
	let actions;
	let current;

	title_1 = new Title({
			props: {
				id: "" + (/*id*/ ctx[1] + "-title"),
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	content_1 = new Content({
			props: {
				id: "" + (/*id*/ ctx[1] + "-content"),
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	actions = new Actions({
			props: {
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(title_1.$$.fragment);
			t0 = space();
			create_component(content_1.$$.fragment);
			t1 = space();
			create_component(actions.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(title_1, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(content_1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(actions, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const title_1_changes = {};
			if (dirty & /*id*/ 2) title_1_changes.id = "" + (/*id*/ ctx[1] + "-title");

			if (dirty & /*$$scope, title*/ 528) {
				title_1_changes.$$scope = { dirty, ctx };
			}

			title_1.$set(title_1_changes);
			const content_1_changes = {};
			if (dirty & /*id*/ 2) content_1_changes.id = "" + (/*id*/ ctx[1] + "-content");

			if (dirty & /*$$scope, content*/ 544) {
				content_1_changes.$$scope = { dirty, ctx };
			}

			content_1.$set(content_1_changes);
			const actions_changes = {};

			if (dirty & /*$$scope, label2, label1*/ 524) {
				actions_changes.$$scope = { dirty, ctx };
			}

			actions.$set(actions_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_1.$$.fragment, local);
			transition_in(content_1.$$.fragment, local);
			transition_in(actions.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_1.$$.fragment, local);
			transition_out(content_1.$$.fragment, local);
			transition_out(actions.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(title_1, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(content_1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(actions, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(11:0) <Dialog    bind:this={dialog}      aria-labelledby=\\\"{id}-title\\\"    aria-describedby=\\\"{id}-content\\\"    on:MDCDialog:closed={sendAction} >",
		ctx
	});

	return block;
}

function create_fragment$L(ctx) {
	let dialog_1;
	let current;

	let dialog_1_props = {
		"aria-labelledby": "" + (/*id*/ ctx[1] + "-title"),
		"aria-describedby": "" + (/*id*/ ctx[1] + "-content"),
		$$slots: { default: [create_default_slot$b] },
		$$scope: { ctx }
	};

	dialog_1 = new Dialog({ props: dialog_1_props, $$inline: true });
	/*dialog_1_binding*/ ctx[7](dialog_1);
	dialog_1.$on("MDCDialog:closed", /*sendAction*/ ctx[6]);

	const block = {
		c: function create() {
			create_component(dialog_1.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog_1, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dialog_1_changes = {};
			if (dirty & /*id*/ 2) dialog_1_changes["aria-labelledby"] = "" + (/*id*/ ctx[1] + "-title");
			if (dirty & /*id*/ 2) dialog_1_changes["aria-describedby"] = "" + (/*id*/ ctx[1] + "-content");

			if (dirty & /*$$scope, label2, label1, id, content, title*/ 574) {
				dialog_1_changes.$$scope = { dirty, ctx };
			}

			dialog_1.$set(dialog_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*dialog_1_binding*/ ctx[7](null);
			destroy_component(dialog_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$L($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomDialog", slots, []);

	let { dialog = "" } = $$props,
		{ id = "dialog" } = $$props,
		{ label1 = "Yes" } = $$props,
		{ label2 = "Cancel" } = $$props,
		{ title = "" } = $$props,
		{ content = "" } = $$props;

	const dispatch = createEventDispatcher();

	function sendAction(e) {
		dispatch("response", { action: e.detail.action });
	}

	const writable_props = ["dialog", "id", "label1", "label2", "title", "content"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomDialog> was created with unknown prop '${key}'`);
	});

	function dialog_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			dialog = $$value;
			$$invalidate(0, dialog);
		});
	}

	$$self.$$set = $$props => {
		if ("dialog" in $$props) $$invalidate(0, dialog = $$props.dialog);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("label1" in $$props) $$invalidate(2, label1 = $$props.label1);
		if ("label2" in $$props) $$invalidate(3, label2 = $$props.label2);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
		if ("content" in $$props) $$invalidate(5, content = $$props.content);
	};

	$$self.$capture_state = () => ({
		Dialog,
		Title,
		Content,
		Actions,
		InitialFocus,
		Button: Button_1,
		Label,
		createEventDispatcher,
		dialog,
		id,
		label1,
		label2,
		title,
		content,
		dispatch,
		sendAction
	});

	$$self.$inject_state = $$props => {
		if ("dialog" in $$props) $$invalidate(0, dialog = $$props.dialog);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("label1" in $$props) $$invalidate(2, label1 = $$props.label1);
		if ("label2" in $$props) $$invalidate(3, label2 = $$props.label2);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
		if ("content" in $$props) $$invalidate(5, content = $$props.content);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [dialog, id, label1, label2, title, content, sendAction, dialog_1_binding];
}

class CustomDialog extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
			dialog: 0,
			id: 1,
			label1: 2,
			label2: 3,
			title: 4,
			content: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomDialog",
			options,
			id: create_fragment$L.name
		});
	}

	get dialog() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dialog(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label1() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label1(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label2() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label2(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<CustomDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<CustomDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\Powerfile.svelte generated by Svelte v3.31.2 */

const { console: console_1$3 } = globals;
const file$H = "src\\Pages\\Powerfile.svelte";

// (96:72) <Label>
function create_default_slot_5$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Browse");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(96:72) <Label>",
		ctx
	});

	return block;
}

// (96:12) <Fab class="is-pulled-right" on:click={openFolder} extended>
function create_default_slot_4$3(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 268435456) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(96:12) <Fab class=\\\"is-pulled-right\\\" on:click={openFolder} extended>",
		ctx
	});

	return block;
}

// (105:16) <span slot="label">
function create_label_slot$1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Convert to µm";
			attr_dev(span, "slot", "label");
			add_location(span, file$H, 104, 16, 3958);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot$1.name,
		type: "slot",
		source: "(105:16) <span slot=\\\"label\\\">",
		ctx
	});

	return block;
}

// (103:12) <FormField>
function create_default_slot_3$3(ctx) {
	let checkbox;
	let updating_checked;
	let t;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[19].call(null, value);
	}

	let checkbox_props = {
		indeterminate: /*convert*/ ctx[2] === null
	};

	if (/*convert*/ ctx[2] !== void 0) {
		checkbox_props.checked = /*convert*/ ctx[2];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*convert*/ 4) checkbox_changes.indeterminate = /*convert*/ ctx[2] === null;

			if (!updating_checked && dirty & /*convert*/ 4) {
				updating_checked = true;
				checkbox_changes.checked = /*convert*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(103:12) <FormField>",
		ctx
	});

	return block;
}

// (111:8) <HelperText id="powercontent_help">
function create_default_slot_2$7(ctx) {
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = text("Enter powerfile measured for ");
			t1 = text(/*filename*/ ctx[4]);
			t2 = text(".felix file (wavenumber power-in mJ)");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*filename*/ 16) set_data_dev(t1, /*filename*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$7.name,
		type: "slot",
		source: "(111:8) <HelperText id=\\\"powercontent_help\\\">",
		ctx
	});

	return block;
}

// (112:64) <Label>
function create_default_slot_1$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(112:64) <Label>",
		ctx
	});

	return block;
}

// (112:8) <Fab style="margin:2em 0;" on:click={savefile} extended>
function create_default_slot$c(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 268435456) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$c.name,
		type: "slot",
		source: "(112:8) <Fab style=\\\"margin:2em 0;\\\" on:click={savefile} extended>",
		ctx
	});

	return block;
}

function create_fragment$M(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let customdialog;
	let updating_dialog;
	let t1;
	let section;
	let div2;
	let div0;
	let textfield0;
	let updating_value;
	let t2;
	let fab0;
	let t3;
	let div1;
	let textfield1;
	let updating_value_1;
	let t4;
	let textfield2;
	let updating_value_2;
	let t5;
	let textfield3;
	let updating_value_3;
	let t6;
	let formfield;
	let t7;
	let textfield4;
	let updating_value_4;
	let t8;
	let helpertext;
	let t9;
	let fab1;
	let current;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[12].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[7] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[7];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));

	function customdialog_dialog_binding(value) {
		/*customdialog_dialog_binding*/ ctx[13].call(null, value);
	}

	let customdialog_props = {
		id: "powerfile-overwrite",
		title: "Overwrite?",
		content: `${/*filename*/ ctx[4]} already exists. Do you want to overwrite it?`
	};

	if (/*overwrite_dialog*/ ctx[6] !== void 0) {
		customdialog_props.dialog = /*overwrite_dialog*/ ctx[6];
	}

	customdialog = new CustomDialog({
			props: customdialog_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customdialog, "dialog", customdialog_dialog_binding));
	customdialog.$on("response", /*handleOverwrite*/ ctx[10]);

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[14].call(null, value);
	}

	let textfield0_props = {
		style: "width:90%",
		label: "Current Location"
	};

	if (/*location*/ ctx[3] !== void 0) {
		textfield0_props.value = /*location*/ ctx[3];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	fab0 = new Fab({
			props: {
				class: "is-pulled-right",
				extended: true,
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*openFolder*/ ctx[9]);

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[15].call(null, value);
	}

	let textfield1_props = { style: "width:20%", label: "Filename" };

	if (/*filename*/ ctx[4] !== void 0) {
		textfield1_props.value = /*filename*/ ctx[4];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[16].call(null, value);
	}

	let textfield2_props = { style: "width:20%", label: "FELIX Shots" };

	if (/*felixShots*/ ctx[1] !== void 0) {
		textfield2_props.value = /*felixShots*/ ctx[1];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));
	textfield2.$on("change", /*change_handler*/ ctx[17]);

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[18].call(null, value);
	}

	let textfield3_props = { style: "width:20%", label: "FELIX Hz" };

	if (/*felixHz*/ ctx[0] !== void 0) {
		textfield3_props.value = /*felixHz*/ ctx[0];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));

	formfield = new FormField({
			props: {
				$$slots: {
					default: [create_default_slot_3$3],
					label: [create_label_slot$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[20].call(null, value);
	}

	let textfield4_props = {
		textarea: true,
		label: "Powerfile contents",
		"input$aria-controls": "powercontent_help",
		"input$aria-describedby": "powercontent_help"
	};

	if (/*powerfileContent*/ ctx[5] !== void 0) {
		textfield4_props.value = /*powerfileContent*/ ctx[5];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));

	helpertext = new HelperText({
			props: {
				id: "powercontent_help",
				$$slots: { default: [create_default_slot_2$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1 = new Fab({
			props: {
				style: "margin:2em 0;",
				extended: true,
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*savefile*/ ctx[8]);

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			create_component(customdialog.$$.fragment);
			t1 = space();
			section = element("section");
			div2 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t2 = space();
			create_component(fab0.$$.fragment);
			t3 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			t4 = space();
			create_component(textfield2.$$.fragment);
			t5 = space();
			create_component(textfield3.$$.fragment);
			t6 = space();
			create_component(formfield.$$.fragment);
			t7 = space();
			create_component(textfield4.$$.fragment);
			t8 = space();
			create_component(helpertext.$$.fragment);
			t9 = space();
			create_component(fab1.$$.fragment);
			set_style(div0, "margin-bottom", "2em");
			add_location(div0, file$H, 93, 8, 3246);
			set_style(div1, "margin-bottom", "2em");
			add_location(div1, file$H, 98, 8, 3500);
			attr_dev(div2, "class", "container svelte-sxoy95");
			attr_dev(div2, "id", "powfileContainer");
			add_location(div2, file$H, 91, 4, 3189);
			attr_dev(section, "class", "section svelte-sxoy95");
			attr_dev(section, "id", "Powerfile");
			set_style(section, "display", "none");
			add_location(section, file$H, 90, 0, 3122);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(customdialog, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div2);
			append_dev(div2, div0);
			mount_component(textfield0, div0, null);
			append_dev(div0, t2);
			mount_component(fab0, div0, null);
			append_dev(div2, t3);
			append_dev(div2, div1);
			mount_component(textfield1, div1, null);
			append_dev(div1, t4);
			mount_component(textfield2, div1, null);
			append_dev(div1, t5);
			mount_component(textfield3, div1, null);
			append_dev(div1, t6);
			mount_component(formfield, div1, null);
			append_dev(div2, t7);
			mount_component(textfield4, div2, null);
			append_dev(div2, t8);
			mount_component(helpertext, div2, null);
			append_dev(div2, t9);
			mount_component(fab1, div2, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const premodal_changes = {};

			if (!updating_preModal && dirty & /*preModal*/ 128) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[7];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);
			const customdialog_changes = {};
			if (dirty & /*filename*/ 16) customdialog_changes.content = `${/*filename*/ ctx[4]} already exists. Do you want to overwrite it?`;

			if (!updating_dialog && dirty & /*overwrite_dialog*/ 64) {
				updating_dialog = true;
				customdialog_changes.dialog = /*overwrite_dialog*/ ctx[6];
				add_flush_callback(() => updating_dialog = false);
			}

			customdialog.$set(customdialog_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty & /*location*/ 8) {
				updating_value = true;
				textfield0_changes.value = /*location*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 268435456) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*filename*/ 16) {
				updating_value_1 = true;
				textfield1_changes.value = /*filename*/ ctx[4];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty & /*felixShots*/ 2) {
				updating_value_2 = true;
				textfield2_changes.value = /*felixShots*/ ctx[1];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty & /*felixHz*/ 1) {
				updating_value_3 = true;
				textfield3_changes.value = /*felixHz*/ ctx[0];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const formfield_changes = {};

			if (dirty & /*$$scope, convert*/ 268435460) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty & /*powerfileContent*/ 32) {
				updating_value_4 = true;
				textfield4_changes.value = /*powerfileContent*/ ctx[5];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);
			const helpertext_changes = {};

			if (dirty & /*$$scope, filename*/ 268435472) {
				helpertext_changes.$$scope = { dirty, ctx };
			}

			helpertext.$set(helpertext_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 268435456) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(customdialog.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(fab0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(formfield.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);
			transition_in(helpertext.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(customdialog.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(fab0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(formfield.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			transition_out(helpertext.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(customdialog, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(section);
			destroy_component(textfield0);
			destroy_component(fab0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(formfield);
			destroy_component(textfield4);
			destroy_component(helpertext);
			destroy_component(fab1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props, $$invalidate) {
	let powfile;
	let conversion;
	let initContent;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Powerfile", slots, []);

	const writePowfile = () => {
		let contents = `${initContent}\n${powerfileContent}`;

		fs.writeFile(powfile, contents, function (err) {
			if (err) {
				return window.createToast("Power file couldn't be saved.", "danger");
			}

			window.createToast("Power file saved", "success");
		});
	};

	async function savefile() {
		if (location.length == 0) {
			return openFolder({ save: true });
		}

		const overwrite = await fs.existsSync(powfile);
		overwrite ? overwrite_dialog.open() : writePowfile();
	}

	function openFolder({ save = false } = {}) {
		browse({ dir: true }).then(result => {
			if (!result.canceled) {
				$$invalidate(3, location = localStorage["powerfile_location"] = result.filePaths[0]);
				window.createToast("Location updated", "success");
				if (save) savefile();
			}
		}).catch(err => {
			$$invalidate(7, preModal.modalContent = err.stack, preModal);
			$$invalidate(7, preModal.open = true, preModal);
		});
	}

	let powerfileContent = "", felixHz = 10, felixShots = 16, convert = null;
	let location = localStorage["powerfile_location"] || "";
	let overwrite_dialog;
	let today = new Date();
	const dd = String(today.getDate()).padStart(2, "0");
	const mm = String(today.getMonth() + 1).padStart(2, "0");
	const yy = today.getFullYear().toString().substr(2);
	let filename = `${dd}_${mm}_${yy}-#`;

	const handleOverwrite = e => {
		let action = e.detail.action;
		if (action === "Cancel" || action === "close") window.createToast("Powerfile saving cancelled", "warning");
		if (action === "Yes") writePowfile();
	};

	let preModal = {};
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Powerfile> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(7, preModal);
	}

	function customdialog_dialog_binding(value) {
		overwrite_dialog = value;
		$$invalidate(6, overwrite_dialog);
	}

	function textfield0_value_binding(value) {
		location = value;
		$$invalidate(3, location);
	}

	function textfield1_value_binding(value) {
		filename = value;
		$$invalidate(4, filename);
	}

	function textfield2_value_binding(value) {
		felixShots = value;
		$$invalidate(1, felixShots);
	}

	const change_handler = () => {
		console.log(felixShots);
	};

	function textfield3_value_binding(value) {
		felixHz = value;
		$$invalidate(0, felixHz);
	}

	function checkbox_checked_binding(value) {
		convert = value;
		$$invalidate(2, convert);
	}

	function textfield4_value_binding(value) {
		powerfileContent = value;
		$$invalidate(5, powerfileContent);
	}

	$$self.$capture_state = () => ({
		Textfield,
		HelperText,
		Fab,
		Label,
		Checkbox,
		FormField,
		browse,
		CustomDialog,
		PreModal,
		writePowfile,
		savefile,
		openFolder,
		powerfileContent,
		felixHz,
		felixShots,
		convert,
		location,
		overwrite_dialog,
		today,
		dd,
		mm,
		yy,
		filename,
		handleOverwrite,
		preModal,
		initContent,
		powfile,
		conversion
	});

	$$self.$inject_state = $$props => {
		if ("powerfileContent" in $$props) $$invalidate(5, powerfileContent = $$props.powerfileContent);
		if ("felixHz" in $$props) $$invalidate(0, felixHz = $$props.felixHz);
		if ("felixShots" in $$props) $$invalidate(1, felixShots = $$props.felixShots);
		if ("convert" in $$props) $$invalidate(2, convert = $$props.convert);
		if ("location" in $$props) $$invalidate(3, location = $$props.location);
		if ("overwrite_dialog" in $$props) $$invalidate(6, overwrite_dialog = $$props.overwrite_dialog);
		if ("today" in $$props) today = $$props.today;
		if ("filename" in $$props) $$invalidate(4, filename = $$props.filename);
		if ("preModal" in $$props) $$invalidate(7, preModal = $$props.preModal);
		if ("initContent" in $$props) initContent = $$props.initContent;
		if ("powfile" in $$props) powfile = $$props.powfile;
		if ("conversion" in $$props) $$invalidate(11, conversion = $$props.conversion);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*location, filename*/ 24) {
			 powfile = path.resolve(location, `${filename}.pow`);
		}

		if ($$self.$$.dirty & /*convert*/ 4) {
			 convert
			? $$invalidate(11, conversion = "_")
			: $$invalidate(11, conversion = "_no_");
		}

		if ($$self.$$.dirty & /*felixHz, felixShots, conversion*/ 2051) {
			 initContent = `#POWER file\n` + `# ${felixHz} Hz FELIX\n` + `#SHOTS=${felixShots}\n` + `#INTERP=linear\n` + `#    IN${conversion}UM (if one deletes the no the firs number will be in \mu m\n` + `# wavelength/cm-1      energy/pulse/mJ\n`;
		}
	};

	 $$invalidate(11, conversion = "_no_");

	return [
		felixHz,
		felixShots,
		convert,
		location,
		filename,
		powerfileContent,
		overwrite_dialog,
		preModal,
		savefile,
		openFolder,
		handleOverwrite,
		conversion,
		premodal_preModal_binding,
		customdialog_dialog_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		textfield2_value_binding,
		change_handler,
		textfield3_value_binding,
		checkbox_checked_binding,
		textfield4_value_binding
	];
}

class Powerfile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Powerfile",
			options,
			id: create_fragment$M.name
		});
	}
}

const felixIndex = writable([]);
const felixPeakTable = writable([]);

const felixOutputName = writable("");
const opoMode = writable(false);
const Ngauss_sigma = writable(5);
const dataTable = writable([]);

const dataTable_avg = writable([]);

const opoData = writable({});

const felixData = writable({});

const normMethodDatas = derived([opoMode, felixData, opoData], ([$opoMode, $felixData, $opoData]) => { return $opoMode ? $opoData : $felixData });
const felixopoLocation = writable("");

const filedetails = writable([]);
const felixPlotAnnotations = writable([]);
const plotlyEventCreatedFELIX = writable(false);
const plotlyEventCreatedOPO = writable(false);
const toggleRow = writable(false);
const graphDiv = derived(opoMode, $opoMode => { return $opoMode ? "opoRelPlot" : "avgplot" });

const baseGraphDiv = derived(opoMode, $opoMode => { return $opoMode ? "opoplot" : "bplot" });

const expfittedLines = writable([]);
const expfittedLinesCollectedData = writable([]);
const collectData = writable(false);
const avgfittedLineCount = writable(0);
const fittedTraceCount = writable(0);
const felixAnnotationColor = writable("black");

const normMethod = writable("Relative");

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$j = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control',
};
var cssClasses$h = {
    DISABLED: 'mdc-radio--disabled',
    ROOT: 'mdc-radio',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRadioFoundation = /** @class */ (function (_super) {
    __extends(MDCRadioFoundation, _super);
    function MDCRadioFoundation(adapter) {
        return _super.call(this, __assign({}, MDCRadioFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCRadioFoundation, "cssClasses", {
        get: function () {
            return cssClasses$h;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadioFoundation, "strings", {
        get: function () {
            return strings$j;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadioFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                setNativeControlDisabled: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    MDCRadioFoundation.prototype.setDisabled = function (disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
        this.adapter_.setNativeControlDisabled(disabled);
        if (disabled) {
            this.adapter_.addClass(DISABLED);
        }
        else {
            this.adapter_.removeClass(DISABLED);
        }
    };
    return MDCRadioFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRadio = /** @class */ (function (_super) {
    __extends(MDCRadio, _super);
    function MDCRadio() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ripple_ = _this.createRipple_();
        return _this;
    }
    MDCRadio.attachTo = function (root) {
        return new MDCRadio(root);
    };
    Object.defineProperty(MDCRadio.prototype, "checked", {
        get: function () {
            return this.nativeControl_.checked;
        },
        set: function (checked) {
            this.nativeControl_.checked = checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "disabled", {
        get: function () {
            return this.nativeControl_.disabled;
        },
        set: function (disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "value", {
        get: function () {
            return this.nativeControl_.value;
        },
        set: function (value) {
            this.nativeControl_.value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCRadio.prototype, "ripple", {
        get: function () {
            return this.ripple_;
        },
        enumerable: true,
        configurable: true
    });
    MDCRadio.prototype.destroy = function () {
        this.ripple_.destroy();
        _super.prototype.destroy.call(this);
    };
    MDCRadio.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            setNativeControlDisabled: function (disabled) { return _this.nativeControl_.disabled = disabled; },
        };
        return new MDCRadioFoundation(adapter);
    };
    MDCRadio.prototype.createRipple_ = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign({}, MDCRipple.createAdapter(this), { registerInteractionHandler: function (evtType, handler) { return _this.nativeControl_.addEventListener(evtType, handler, applyPassive()); }, deregisterInteractionHandler: function (evtType, handler) { return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive()); }, 
            // Radio buttons technically go "active" whenever there is *any* keyboard interaction.
            // This is not the UI we desire.
            isSurfaceActive: function () { return false; }, isUnbounded: function () { return true; } });
        // tslint:enable:object-literal-sort-keys
        return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
    };
    Object.defineProperty(MDCRadio.prototype, "nativeControl_", {
        get: function () {
            var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
            var el = this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
            if (!el) {
                throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
            }
            return el;
        },
        enumerable: true,
        configurable: true
    });
    return MDCRadio;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\radio\Radio.svelte generated by Svelte v3.31.2 */
const file$I = "node_modules\\@smui\\radio\\Radio.svelte";

function create_fragment$N(ctx) {
	let div3;
	let input;
	let input_value_value;
	let input_class_value;
	let useActions_action;
	let t0;
	let div2;
	let div0;
	let t1;
	let div1;
	let div3_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let mounted;
	let dispose;

	let input_levels = [
		{
			value: input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
			? /*value*/ ctx[3]
			: /*valueKey*/ ctx[4]
		},
		{ type: "radio" },
		/*inputProps*/ ctx[11],
		{ disabled: /*disabled*/ ctx[2] },
		{
			class: input_class_value = "mdc-radio__native-control " + /*input$class*/ ctx[6]
		},
		{ checked: /*checked*/ ctx[7] },
		exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	let div3_levels = [
		{
			class: div3_class_value = "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-radio--disabled" : "") + "\n  "
		},
		exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "value", "valueKey", "input$"])
	];

	let div3_data = {};

	for (let i = 0; i < div3_levels.length; i += 1) {
		div3_data = assign(div3_data, div3_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			input = element("input");
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			t1 = space();
			div1 = element("div");
			set_attributes(input, input_data);
			add_location(input, file$I, 11, 2, 256);
			attr_dev(div0, "class", "mdc-radio__outer-circle");
			add_location(div0, file$I, 24, 4, 642);
			attr_dev(div1, "class", "mdc-radio__inner-circle");
			add_location(div1, file$I, 25, 4, 690);
			attr_dev(div2, "class", "mdc-radio__background");
			add_location(div2, file$I, 23, 2, 602);
			set_attributes(div3, div3_data);
			add_location(div3, file$I, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, input);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			/*div3_binding*/ ctx[19](div3);

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[5])),
					listen_dev(input, "change", /*handleChange*/ ctx[12], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[17], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[18], false, false, false),
					action_destroyer(useActions_action_1 = useActions.call(null, div3, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[9].call(null, div3))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty & /*valueKey, value*/ 24 && input_value_value !== (input_value_value = /*valueKey*/ ctx[4] === /*uninitializedValue*/ ctx[10]
				? /*value*/ ctx[3]
				: /*valueKey*/ ctx[4]) && { value: input_value_value },
				{ type: "radio" },
				/*inputProps*/ ctx[11],
				dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] },
				dirty & /*input$class*/ 64 && input_class_value !== (input_class_value = "mdc-radio__native-control " + /*input$class*/ ctx[6]) && { class: input_class_value },
				dirty & /*checked*/ 128 && { checked: /*checked*/ ctx[7] },
				dirty & /*$$props*/ 8192 && exclude(prefixFilter(/*$$props*/ ctx[13], "input$"), ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*input$use*/ 32) useActions_action.update.call(null, /*input$use*/ ctx[5]);

			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
				dirty & /*className, disabled*/ 6 && div3_class_value !== (div3_class_value = "\n    mdc-radio\n    " + /*className*/ ctx[1] + "\n    " + (/*disabled*/ ctx[2] ? "mdc-radio--disabled" : "") + "\n  ") && { class: div3_class_value },
				dirty & /*$$props*/ 8192 && exclude(/*$$props*/ ctx[13], ["use", "class", "disabled", "group", "value", "valueKey", "input$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			/*div3_binding*/ ctx[19](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props, $$invalidate) {
	let checked;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, []);
	const forwardEvents = forwardEventsBuilder(get_current_component());

	let uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { disabled = false } = $$props;
	let { group = null } = $$props;
	let { value = null } = $$props;
	let { valueKey = uninitializedValue } = $$props;
	let { input$use = [] } = $$props;
	let { input$class = "" } = $$props;
	let element;
	let radio;
	let formField = getContext("SMUI:form-field");
	let inputProps = getContext("SMUI:generic:input:props") || {};
	let setChecked = getContext("SMUI:generic:input:setChecked");

	onMount(() => {
		$$invalidate(16, radio = new MDCRadio(element));

		if (formField && formField()) {
			formField().input = radio;
		}
	});

	onDestroy(() => {
		radio && radio.destroy();
	});

	function handleChange(e) {
		if (radio.checked) {
			$$invalidate(14, group = value);
		}
	}

	function getId() {
		return inputProps && inputProps.id;
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(8, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$new_props) $$invalidate(14, group = $$new_props.group);
		if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$new_props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$new_props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$new_props) $$invalidate(6, input$class = $$new_props.input$class);
	};

	$$self.$capture_state = () => ({
		MDCRadio,
		onMount,
		onDestroy,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		disabled,
		group,
		value,
		valueKey,
		input$use,
		input$class,
		element,
		radio,
		formField,
		inputProps,
		setChecked,
		handleChange,
		getId,
		checked
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("uninitializedValue" in $$props) $$invalidate(10, uninitializedValue = $$new_props.uninitializedValue);
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ("group" in $$props) $$invalidate(14, group = $$new_props.group);
		if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
		if ("valueKey" in $$props) $$invalidate(4, valueKey = $$new_props.valueKey);
		if ("input$use" in $$props) $$invalidate(5, input$use = $$new_props.input$use);
		if ("input$class" in $$props) $$invalidate(6, input$class = $$new_props.input$class);
		if ("element" in $$props) $$invalidate(8, element = $$new_props.element);
		if ("radio" in $$props) $$invalidate(16, radio = $$new_props.radio);
		if ("formField" in $$props) formField = $$new_props.formField;
		if ("inputProps" in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
		if ("setChecked" in $$props) $$invalidate(21, setChecked = $$new_props.setChecked);
		if ("checked" in $$props) $$invalidate(7, checked = $$new_props.checked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*group, value*/ 16392) {
			 $$invalidate(7, checked = group === value);
		}

		if ($$self.$$.dirty & /*checked*/ 128) {
			 if (setChecked) {
				setChecked(checked);
			}
		}

		if ($$self.$$.dirty & /*radio, checked*/ 65664) {
			 if (radio && radio.checked !== checked) {
				$$invalidate(16, radio.checked = checked, radio);
			}
		}

		if ($$self.$$.dirty & /*radio, disabled*/ 65540) {
			 if (radio && radio.disabled !== disabled) {
				$$invalidate(16, radio.disabled = disabled, radio);
			}
		}

		if ($$self.$$.dirty & /*radio, valueKey, value*/ 65560) {
			 if (radio && valueKey === uninitializedValue && radio.value !== value) {
				$$invalidate(16, radio.value = value, radio);
			}
		}

		if ($$self.$$.dirty & /*radio, valueKey*/ 65552) {
			 if (radio && valueKey !== uninitializedValue && radio.value !== valueKey) {
				$$invalidate(16, radio.value = valueKey, radio);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		disabled,
		value,
		valueKey,
		input$use,
		input$class,
		checked,
		element,
		forwardEvents,
		uninitializedValue,
		inputProps,
		handleChange,
		$$props,
		group,
		getId,
		radio,
		change_handler,
		input_handler,
		div3_binding
	];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
			use: 0,
			class: 1,
			disabled: 2,
			group: 14,
			value: 3,
			valueKey: 4,
			input$use: 5,
			input$class: 6,
			getId: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$N.name
		});
	}

	get use() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueKey() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueKey(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$use() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$use(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$class() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$class(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getId() {
		return this.$$.ctx[15];
	}

	set getId(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomRadio.svelte generated by Svelte v3.31.2 */
const file$J = "src\\components\\CustomRadio.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (12:8) <span slot="label">
function create_label_slot$2(ctx) {
	let span;
	let t_value = /*option*/ ctx[5] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			attr_dev(span, "slot", "label");
			add_location(span, file$J, 11, 8, 295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[5] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot$2.name,
		type: "slot",
		source: "(12:8) <span slot=\\\"label\\\">",
		ctx
	});

	return block;
}

// (10:4) <FormField {style}>
function create_default_slot$d(ctx) {
	let radio;
	let updating_group;
	let t0;
	let t1;
	let current;

	function radio_group_binding(value) {
		/*radio_group_binding*/ ctx[3].call(null, value);
	}

	let radio_props = { value: /*option*/ ctx[5] };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));
	radio.$on("change", /*change_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};
			if (dirty & /*options*/ 2) radio_changes.value = /*option*/ ctx[5];

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$d.name,
		type: "slot",
		source: "(10:4) <FormField {style}>",
		ctx
	});

	return block;
}

// (9:0) {#each options as option}
function create_each_block$3(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				style: /*style*/ ctx[2],
				$$slots: {
					default: [create_default_slot$d],
					label: [create_label_slot$2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formfield_changes = {};
			if (dirty & /*style*/ 4) formfield_changes.style = /*style*/ ctx[2];

			if (dirty & /*$$scope, options, selected*/ 259) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(9:0) {#each options as option}",
		ctx
	});

	return block;
}

function create_fragment$O(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*options*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*style, options, selected*/ 7) {
				each_value = /*options*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$O($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomRadio", slots, []);

	let { options = [] } = $$props,
		{ selected = "" } = $$props,
		{ style = "" } = $$props;

	const writable_props = ["options", "selected", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomRadio> was created with unknown prop '${key}'`);
	});

	function radio_group_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$capture_state = () => ({
		Radio,
		FormField,
		options,
		selected,
		style
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected, options, style, radio_group_binding, change_handler];
}

class CustomRadio extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$O, create_fragment$O, safe_not_equal, { options: 1, selected: 0, style: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomRadio",
			options,
			id: create_fragment$O.name
		});
	}

	get options() {
		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomCheckbox.svelte generated by Svelte v3.31.2 */
const file$K = "src\\components\\CustomCheckbox.svelte";

// (11:2) <span slot="label">
function create_label_slot$3(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*label*/ ctx[1]);
			attr_dev(span, "slot", "label");
			add_location(span, file$K, 10, 2, 236);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot$3.name,
		type: "slot",
		source: "(11:2) <span slot=\\\"label\\\">",
		ctx
	});

	return block;
}

// (9:0) <FormField {style}>
function create_default_slot$e(ctx) {
	let checkbox;
	let updating_checked;
	let t;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[3].call(null, value);
	}

	let checkbox_props = {};

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.checked = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*selected*/ 1) {
				updating_checked = true;
				checkbox_changes.checked = /*selected*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$e.name,
		type: "slot",
		source: "(9:0) <FormField {style}>",
		ctx
	});

	return block;
}

function create_fragment$P(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				style: /*style*/ ctx[2],
				$$slots: {
					default: [create_default_slot$e],
					label: [create_label_slot$3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const formfield_changes = {};
			if (dirty & /*style*/ 4) formfield_changes.style = /*style*/ ctx[2];

			if (dirty & /*$$scope, label, selected*/ 19) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomCheckbox", slots, []);

	let { selected = false } = $$props,
		{ label = "Check me" } = $$props,
		{ style = "" } = $$props;

	const writable_props = ["selected", "label", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomCheckbox> was created with unknown prop '${key}'`);
	});

	function checkbox_checked_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	$$self.$$set = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$capture_state = () => ({
		Checkbox,
		FormField,
		selected,
		label,
		style
	});

	$$self.$inject_state = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected, label, style, checkbox_checked_binding];
}

class CustomCheckbox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$P, create_fragment$P, safe_not_equal, { selected: 0, label: 1, style: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomCheckbox",
			options,
			id: create_fragment$P.name
		});
	}

	get selected() {
		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$i = {
    ANCHOR: 'mdc-menu-surface--anchor',
    ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
    ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
    FIXED: 'mdc-menu-surface--fixed',
    OPEN: 'mdc-menu-surface--open',
    ROOT: 'mdc-menu-surface',
};
// tslint:disable:object-literal-sort-keys
var strings$k = {
    CLOSED_EVENT: 'MDCMenuSurface:closed',
    OPENED_EVENT: 'MDCMenuSurface:opened',
    FOCUSABLE_ELEMENTS: [
        'button:not(:disabled)', '[href]:not([aria-disabled="true"])', 'input:not(:disabled)',
        'select:not(:disabled)', 'textarea:not(:disabled)', '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])',
    ].join(', '),
};
// tslint:enable:object-literal-sort-keys
var numbers$7 = {
    /** Total duration of menu-surface open animation. */
    TRANSITION_OPEN_DURATION: 120,
    /** Total duration of menu-surface close animation. */
    TRANSITION_CLOSE_DURATION: 75,
    /** Margin left to the edge of the viewport when menu-surface is at maximum possible height. */
    MARGIN_TO_EDGE: 32,
    /** Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning. */
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
};
/**
 * Enum for bits in the {@see Corner) bitmap.
 */
var CornerBit;
(function (CornerBit) {
    CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
    CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
    CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
    CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
/**
 * Enum for representing an element corner for positioning the menu-surface.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 */
var Corner;
(function (Corner) {
    Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
    Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
    Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
    Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
    Corner[Corner["TOP_START"] = 8] = "TOP_START";
    Corner[Corner["TOP_END"] = 12] = "TOP_END";
    Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
    Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCMenuSurfaceFoundation = /** @class */ (function (_super) {
    __extends(MDCMenuSurfaceFoundation, _super);
    function MDCMenuSurfaceFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCMenuSurfaceFoundation.defaultAdapter, adapter)) || this;
        _this.isOpen_ = false;
        _this.isQuickOpen_ = false;
        _this.isHoistedElement_ = false;
        _this.isFixedPosition_ = false;
        _this.openAnimationEndTimerId_ = 0;
        _this.closeAnimationEndTimerId_ = 0;
        _this.animationRequestId_ = 0;
        _this.anchorCorner_ = Corner.TOP_START;
        _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
        _this.position_ = { x: 0, y: 0 };
        return _this;
    }
    Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
        get: function () {
            return cssClasses$i;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
        get: function () {
            return strings$k;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
        get: function () {
            return numbers$7;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
        get: function () {
            return Corner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
        /**
         * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                hasAnchor: function () { return false; },
                isElementInContainer: function () { return false; },
                isFocused: function () { return false; },
                isRtl: function () { return false; },
                getInnerDimensions: function () { return ({ height: 0, width: 0 }); },
                getAnchorDimensions: function () { return null; },
                getWindowDimensions: function () { return ({ height: 0, width: 0 }); },
                getBodyDimensions: function () { return ({ height: 0, width: 0 }); },
                getWindowScroll: function () { return ({ x: 0, y: 0 }); },
                setPosition: function () { return undefined; },
                setMaxHeight: function () { return undefined; },
                setTransformOrigin: function () { return undefined; },
                saveFocus: function () { return undefined; },
                restoreFocus: function () { return undefined; },
                notifyClose: function () { return undefined; },
                notifyOpen: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCMenuSurfaceFoundation.prototype.init = function () {
        var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
        if (!this.adapter_.hasClass(ROOT)) {
            throw new Error(ROOT + " class required in root element.");
        }
        if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
        }
    };
    MDCMenuSurfaceFoundation.prototype.destroy = function () {
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
    };
    /**
     * @param corner Default anchor corner alignment of top-left menu surface corner.
     */
    MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {
        this.anchorCorner_ = corner;
    };
    /**
     * @param margin Set of margin values from anchor.
     */
    MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {
        this.anchorMargin_.top = margin.top || 0;
        this.anchorMargin_.right = margin.right || 0;
        this.anchorMargin_.bottom = margin.bottom || 0;
        this.anchorMargin_.left = margin.left || 0;
    };
    /** Used to indicate if the menu-surface is hoisted to the body. */
    MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {
        this.isHoistedElement_ = isHoisted;
    };
    /** Used to set the menu-surface calculations based on a fixed position menu. */
    MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {
        this.isFixedPosition_ = isFixedPosition;
    };
    /** Sets the menu-surface position on the page. */
    MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {
        this.position_.x = this.isFinite_(x) ? x : 0;
        this.position_.y = this.isFinite_(y) ? y : 0;
    };
    MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {
        this.isQuickOpen_ = quickOpen;
    };
    MDCMenuSurfaceFoundation.prototype.isOpen = function () {
        return this.isOpen_;
    };
    /**
     * Open the menu surface.
     */
    MDCMenuSurfaceFoundation.prototype.open = function () {
        var _this = this;
        this.adapter_.saveFocus();
        if (!this.isQuickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
        }
        this.animationRequestId_ = requestAnimationFrame(function () {
            _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
            _this.dimensions_ = _this.adapter_.getInnerDimensions();
            _this.autoPosition_();
            if (_this.isQuickOpen_) {
                _this.adapter_.notifyOpen();
            }
            else {
                _this.openAnimationEndTimerId_ = setTimeout(function () {
                    _this.openAnimationEndTimerId_ = 0;
                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                    _this.adapter_.notifyOpen();
                }, numbers$7.TRANSITION_OPEN_DURATION);
            }
        });
        this.isOpen_ = true;
    };
    /**
     * Closes the menu surface.
     */
    MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {
        var _this = this;
        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
        if (!this.isQuickOpen_) {
            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
        }
        requestAnimationFrame(function () {
            _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
            if (_this.isQuickOpen_) {
                _this.adapter_.notifyClose();
            }
            else {
                _this.closeAnimationEndTimerId_ = setTimeout(function () {
                    _this.closeAnimationEndTimerId_ = 0;
                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                    _this.adapter_.notifyClose();
                }, numbers$7.TRANSITION_CLOSE_DURATION);
            }
        });
        this.isOpen_ = false;
        if (!skipRestoreFocus) {
            this.maybeRestoreFocus_();
        }
    };
    /** Handle clicks and close if not within menu-surface element. */
    MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {
        var el = evt.target;
        if (this.adapter_.isElementInContainer(el)) {
            return;
        }
        this.close();
    };
    /** Handle keys that close the surface. */
    MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {
        var keyCode = evt.keyCode, key = evt.key;
        var isEscape = key === 'Escape' || keyCode === 27;
        if (isEscape) {
            this.close();
        }
    };
    MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {
        var _a;
        // Compute measurements for autoposition methods reuse.
        this.measurements_ = this.getAutoLayoutMeasurements_();
        var corner = this.getOriginCorner_();
        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
        var verticalAlignment = this.hasBit_(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';
        var horizontalAlignment = this.hasBit_(corner, CornerBit.RIGHT) ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var _b = this.measurements_, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
        var position = (_a = {},
            _a[horizontalAlignment] = horizontalOffset,
            _a[verticalAlignment] = verticalOffset,
            _a);
        // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.
        if (anchorSize.width / surfaceSize.width > numbers$7.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
            horizontalAlignment = 'center';
        }
        // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element
        if (this.isHoistedElement_ || this.isFixedPosition_) {
            this.adjustPositionForHoistedElement_(position);
        }
        this.adapter_.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');
    };
    /**
     * @return Measurements used to position menu surface popup.
     */
    MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var bodySize = this.adapter_.getBodyDimensions();
        var viewportSize = this.adapter_.getWindowDimensions();
        var windowScroll = this.adapter_.getWindowScroll();
        if (!anchorRect) {
            // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
            anchorRect = {
                top: this.position_.y,
                right: this.position_.x,
                bottom: this.position_.y,
                left: this.position_.x,
                width: 0,
                height: 0,
            };
            // tslint:enable:object-literal-sort-keys
        }
        return {
            anchorSize: anchorRect,
            bodySize: bodySize,
            surfaceSize: this.dimensions_,
            viewportDistance: {
                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
                top: anchorRect.top,
                right: viewportSize.width - anchorRect.right,
                bottom: viewportSize.height - anchorRect.bottom,
                left: anchorRect.left,
            },
            viewportSize: viewportSize,
            windowScroll: windowScroll,
        };
    };
    /**
     * Computes the corner of the anchor from which to animate and position the menu surface.
     */
    MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;
        var _a = this.measurements_, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
        var isBottomAligned = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorSize.height + this.anchorMargin_.bottom
            : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom
            : viewportDistance.bottom + anchorSize.height - this.anchorMargin_.top;
        var topOverflow = surfaceSize.height - availableTop;
        var bottomOverflow = surfaceSize.height - availableBottom;
        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
            corner = this.setBit_(corner, CornerBit.BOTTOM);
        }
        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = this.hasBit_(this.anchorCorner_, CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
        var isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||
            (!avoidHorizontalOverlap && isFlipRtl && isRtl);
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorSize.width + this.anchorMargin_.right :
            viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :
            viewportDistance.right + anchorSize.width - this.anchorMargin_.left;
        var leftOverflow = surfaceSize.width - availableLeft;
        var rightOverflow = surfaceSize.width - availableRight;
        if ((leftOverflow < 0 && isAlignedRight && isRtl) ||
            (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||
            (rightOverflow > 0 && leftOverflow < rightOverflow)) {
            corner = this.setBit_(corner, CornerBit.RIGHT);
        }
        return corner;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.
     */
    MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {
        var viewportDistance = this.measurements_.viewportDistance;
        var maxHeight = 0;
        var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
        var isBottomAnchored = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
        // When maximum height is not specified, it is handled from CSS.
        if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;
            if (!isBottomAnchored) {
                maxHeight += this.measurements_.anchorSize.height;
            }
        }
        else {
            maxHeight =
                viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;
            if (isBottomAnchored) {
                maxHeight -= this.measurements_.anchorSize.height;
            }
        }
        return maxHeight;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.
     */
    MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {
        var anchorSize = this.measurements_.anchorSize;
        // isRightAligned corresponds to using the 'right' property on the surface.
        var isRightAligned = this.hasBit_(corner, CornerBit.RIGHT);
        var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);
        if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right;
            // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
            // the right property is correct.
            if (this.isHoistedElement_ || this.isFixedPosition_) {
                return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);
            }
            return rightOffset;
        }
        return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;
    };
    /**
     * @param corner Origin corner of the menu surface.
     * @return Vertical offset of menu surface origin corner from corresponding anchor corner.
     */
    MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {
        var anchorSize = this.measurements_.anchorSize;
        var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);
        var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);
        var y = 0;
        if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        }
        else {
            y = avoidVerticalOverlap ? (anchorSize.height + this.anchorMargin_.bottom) : this.anchorMargin_.top;
        }
        return y;
    };
    /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */
    MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {
        var e_1, _a;
        var _b = this.measurements_, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;
        var props = Object.keys(position);
        try {
            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                var prop = props_1_1.value;
                var value = position[prop] || 0;
                // Hoisted surfaces need to have the anchor elements location on the page added to the
                // position properties for proper alignment on the body.
                value += viewportDistance[prop];
                // Surfaces that are absolutely positioned need to have additional calculations for scroll
                // and bottom positioning.
                if (!this.isFixedPosition_) {
                    if (prop === 'top') {
                        value += windowScroll.y;
                    }
                    else if (prop === 'bottom') {
                        value -= windowScroll.y;
                    }
                    else if (prop === 'left') {
                        value += windowScroll.x;
                    }
                    else { // prop === 'right'
                        value -= windowScroll.x;
                    }
                }
                position[prop] = value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * The last focused element when the menu surface was opened should regain focus, if the user is
     * focused on or within the menu surface when it is closed.
     */
    MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {
        var isRootFocused = this.adapter_.isFocused();
        var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);
        if (isRootFocused || childHasFocus) {
            this.adapter_.restoreFocus();
        }
    };
    MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {
        return Boolean(corner & bit); // tslint:disable-line:no-bitwise
    };
    MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {
        return corner | bit; // tslint:disable-line:no-bitwise
    };
    /**
     * isFinite that doesn't force conversion to number type.
     * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
     */
    MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {
        return typeof num === 'number' && isFinite(num);
    };
    return MDCMenuSurfaceFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cachedCssTransformPropertyName_;
/**
 * Returns the name of the correct transform property to use on the current browser.
 */
function getTransformPropertyName(globalObj, forceRefresh) {
    if (forceRefresh === void 0) { forceRefresh = false; }
    if (cachedCssTransformPropertyName_ === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        cachedCssTransformPropertyName_ = 'transform' in el.style ? 'transform' : 'webkitTransform';
    }
    return cachedCssTransformPropertyName_;
}
//# sourceMappingURL=util.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCMenuSurface = /** @class */ (function (_super) {
    __extends(MDCMenuSurface, _super);
    function MDCMenuSurface() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenuSurface.attachTo = function (root) {
        return new MDCMenuSurface(root);
    };
    MDCMenuSurface.prototype.initialSyncWithDOM = function () {
        var _this = this;
        var parentEl = this.root_.parentElement;
        this.anchorElement = parentEl && parentEl.classList.contains(cssClasses$i.ANCHOR) ? parentEl : null;
        if (this.root_.classList.contains(cssClasses$i.FIXED)) {
            this.setFixedPosition(true);
        }
        this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
        this.handleBodyClick_ = function (evt) { return _this.foundation_.handleBodyClick(evt); };
        this.registerBodyClickListener_ = function () { return document.body.addEventListener('click', _this.handleBodyClick_); };
        this.deregisterBodyClickListener_ = function () { return document.body.removeEventListener('click', _this.handleBodyClick_); };
        this.listen('keydown', this.handleKeydown_);
        this.listen(strings$k.OPENED_EVENT, this.registerBodyClickListener_);
        this.listen(strings$k.CLOSED_EVENT, this.deregisterBodyClickListener_);
    };
    MDCMenuSurface.prototype.destroy = function () {
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(strings$k.OPENED_EVENT, this.registerBodyClickListener_);
        this.unlisten(strings$k.CLOSED_EVENT, this.deregisterBodyClickListener_);
        _super.prototype.destroy.call(this);
    };
    MDCMenuSurface.prototype.isOpen = function () {
        return this.foundation_.isOpen();
    };
    MDCMenuSurface.prototype.open = function () {
        this.foundation_.open();
    };
    MDCMenuSurface.prototype.close = function (skipRestoreFocus) {
        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }
        this.foundation_.close(skipRestoreFocus);
    };
    Object.defineProperty(MDCMenuSurface.prototype, "quickOpen", {
        set: function (quickOpen) {
            this.foundation_.setQuickOpen(quickOpen);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Removes the menu-surface from it's current location and appends it to the
     * body to overcome any overflow:hidden issues.
     */
    MDCMenuSurface.prototype.hoistMenuToBody = function () {
        document.body.appendChild(this.root_);
        this.setIsHoisted(true);
    };
    /** Sets the foundation to use page offsets for an positioning when the menu is hoisted to the body. */
    MDCMenuSurface.prototype.setIsHoisted = function (isHoisted) {
        this.foundation_.setIsHoisted(isHoisted);
    };
    /** Sets the element that the menu-surface is anchored to. */
    MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function (element) {
        this.anchorElement = element;
    };
    /** Sets the menu-surface to position: fixed. */
    MDCMenuSurface.prototype.setFixedPosition = function (isFixed) {
        if (isFixed) {
            this.root_.classList.add(cssClasses$i.FIXED);
        }
        else {
            this.root_.classList.remove(cssClasses$i.FIXED);
        }
        this.foundation_.setFixedPosition(isFixed);
    };
    /** Sets the absolute x/y position to position based on. Requires the menu to be hoisted. */
    MDCMenuSurface.prototype.setAbsolutePosition = function (x, y) {
        this.foundation_.setAbsolutePosition(x, y);
        this.setIsHoisted(true);
    };
    /**
     * @param corner Default anchor corner alignment of top-left surface corner.
     */
    MDCMenuSurface.prototype.setAnchorCorner = function (corner) {
        this.foundation_.setAnchorCorner(corner);
    };
    MDCMenuSurface.prototype.setAnchorMargin = function (margin) {
        this.foundation_.setAnchorMargin(margin);
    };
    MDCMenuSurface.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            hasAnchor: function () { return !!_this.anchorElement; },
            notifyClose: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {}); },
            notifyOpen: function () { return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {}); },
            isElementInContainer: function (el) { return _this.root_.contains(el); },
            isRtl: function () { return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl'; },
            setTransformOrigin: function (origin) {
                var propertyName = getTransformPropertyName(window) + "-origin";
                _this.root_.style.setProperty(propertyName, origin);
            },
            isFocused: function () { return document.activeElement === _this.root_; },
            saveFocus: function () {
                _this.previousFocus_ = document.activeElement;
            },
            restoreFocus: function () {
                if (_this.root_.contains(document.activeElement)) {
                    if (_this.previousFocus_ && _this.previousFocus_.focus) {
                        _this.previousFocus_.focus();
                    }
                }
            },
            getInnerDimensions: function () {
                return { width: _this.root_.offsetWidth, height: _this.root_.offsetHeight };
            },
            getAnchorDimensions: function () { return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null; },
            getWindowDimensions: function () {
                return { width: window.innerWidth, height: window.innerHeight };
            },
            getBodyDimensions: function () {
                return { width: document.body.clientWidth, height: document.body.clientHeight };
            },
            getWindowScroll: function () {
                return { x: window.pageXOffset, y: window.pageYOffset };
            },
            setPosition: function (position) {
                _this.root_.style.left = 'left' in position ? position.left + "px" : '';
                _this.root_.style.right = 'right' in position ? position.right + "px" : '';
                _this.root_.style.top = 'top' in position ? position.top + "px" : '';
                _this.root_.style.bottom = 'bottom' in position ? position.bottom + "px" : '';
            },
            setMaxHeight: function (height) {
                _this.root_.style.maxHeight = height;
            },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCMenuSurfaceFoundation(adapter);
    };
    return MDCMenuSurface;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$j = {
    MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
    MENU_SELECTION_GROUP: 'mdc-menu__selection-group',
    ROOT: 'mdc-menu',
};
var strings$l = {
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_DISABLED_ATTR: 'aria-disabled',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    LIST_SELECTOR: '.mdc-list',
    SELECTED_EVENT: 'MDCMenu:selected',
};
var numbers$8 = {
    FOCUS_ROOT_INDEX: -1,
};
var DefaultFocusState;
(function (DefaultFocusState) {
    DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
    DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
    DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
    DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCMenuFoundation = /** @class */ (function (_super) {
    __extends(MDCMenuFoundation, _super);
    function MDCMenuFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCMenuFoundation.defaultAdapter, adapter)) || this;
        _this.closeAnimationEndTimerId_ = 0;
        _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
        return _this;
    }
    Object.defineProperty(MDCMenuFoundation, "cssClasses", {
        get: function () {
            return cssClasses$j;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "strings", {
        get: function () {
            return strings$l;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "numbers", {
        get: function () {
            return numbers$8;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
        /**
         * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClassToElementAtIndex: function () { return undefined; },
                removeClassFromElementAtIndex: function () { return undefined; },
                addAttributeToElementAtIndex: function () { return undefined; },
                removeAttributeFromElementAtIndex: function () { return undefined; },
                elementContainsClass: function () { return false; },
                closeSurface: function () { return undefined; },
                getElementIndex: function () { return -1; },
                notifySelected: function () { return undefined; },
                getMenuItemCount: function () { return 0; },
                focusItemAtIndex: function () { return undefined; },
                focusListRoot: function () { return undefined; },
                getSelectedSiblingOfItemAtIndex: function () { return -1; },
                isSelectableItemAtIndex: function () { return false; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCMenuFoundation.prototype.destroy = function () {
        if (this.closeAnimationEndTimerId_) {
            clearTimeout(this.closeAnimationEndTimerId_);
        }
        this.adapter_.closeSurface();
    };
    MDCMenuFoundation.prototype.handleKeydown = function (evt) {
        var key = evt.key, keyCode = evt.keyCode;
        var isTab = key === 'Tab' || keyCode === 9;
        if (isTab) {
            this.adapter_.closeSurface(/** skipRestoreFocus */ true);
        }
    };
    MDCMenuFoundation.prototype.handleItemAction = function (listItem) {
        var _this = this;
        var index = this.adapter_.getElementIndex(listItem);
        if (index < 0) {
            return;
        }
        this.adapter_.notifySelected({ index: index });
        this.adapter_.closeSurface();
        // Wait for the menu to close before adding/removing classes that affect styles.
        this.closeAnimationEndTimerId_ = setTimeout(function () {
            // Recompute the index in case the menu contents have changed.
            var recomputedIndex = _this.adapter_.getElementIndex(listItem);
            if (_this.adapter_.isSelectableItemAtIndex(recomputedIndex)) {
                _this.setSelectedIndex(recomputedIndex);
            }
        }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function () {
        switch (this.defaultFocusState_) {
            case DefaultFocusState.FIRST_ITEM:
                this.adapter_.focusItemAtIndex(0);
                break;
            case DefaultFocusState.LAST_ITEM:
                this.adapter_.focusItemAtIndex(this.adapter_.getMenuItemCount() - 1);
                break;
            case DefaultFocusState.NONE:
                // Do nothing.
                break;
            default:
                this.adapter_.focusListRoot();
                break;
        }
    };
    /**
     * Sets default focus state where the menu should focus every time when menu
     * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
     * default.
     */
    MDCMenuFoundation.prototype.setDefaultFocusState = function (focusState) {
        this.defaultFocusState_ = focusState;
    };
    /**
     * Selects the list item at `index` within the menu.
     * @param index Index of list item within the menu.
     */
    MDCMenuFoundation.prototype.setSelectedIndex = function (index) {
        this.validatedIndex_(index);
        if (!this.adapter_.isSelectableItemAtIndex(index)) {
            throw new Error('MDCMenuFoundation: No selection group at specified index.');
        }
        var prevSelectedIndex = this.adapter_.getSelectedSiblingOfItemAtIndex(index);
        if (prevSelectedIndex >= 0) {
            this.adapter_.removeAttributeFromElementAtIndex(prevSelectedIndex, strings$l.ARIA_CHECKED_ATTR);
            this.adapter_.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses$j.MENU_SELECTED_LIST_ITEM);
        }
        this.adapter_.addClassToElementAtIndex(index, cssClasses$j.MENU_SELECTED_LIST_ITEM);
        this.adapter_.addAttributeToElementAtIndex(index, strings$l.ARIA_CHECKED_ATTR, 'true');
    };
    /**
     * Sets the enabled state to isEnabled for the menu item at the given index.
     * @param index Index of the menu item
     * @param isEnabled The desired enabled state of the menu item.
     */
    MDCMenuFoundation.prototype.setEnabled = function (index, isEnabled) {
        this.validatedIndex_(index);
        if (isEnabled) {
            this.adapter_.removeClassFromElementAtIndex(index, cssClasses$f.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.addAttributeToElementAtIndex(index, strings$l.ARIA_DISABLED_ATTR, 'false');
        }
        else {
            this.adapter_.addClassToElementAtIndex(index, cssClasses$f.LIST_ITEM_DISABLED_CLASS);
            this.adapter_.addAttributeToElementAtIndex(index, strings$l.ARIA_DISABLED_ATTR, 'true');
        }
    };
    MDCMenuFoundation.prototype.validatedIndex_ = function (index) {
        var menuSize = this.adapter_.getMenuItemCount();
        var isIndexInRange = index >= 0 && index < menuSize;
        if (!isIndexInRange) {
            throw new Error('MDCMenuFoundation: No list item at specified index.');
        }
    };
    return MDCMenuFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCMenu = /** @class */ (function (_super) {
    __extends(MDCMenu, _super);
    function MDCMenu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenu.attachTo = function (root) {
        return new MDCMenu(root);
    };
    MDCMenu.prototype.initialize = function (menuSurfaceFactory, listFactory) {
        if (menuSurfaceFactory === void 0) { menuSurfaceFactory = function (el) { return new MDCMenuSurface(el); }; }
        if (listFactory === void 0) { listFactory = function (el) { return new MDCList(el); }; }
        this.menuSurfaceFactory_ = menuSurfaceFactory;
        this.listFactory_ = listFactory;
    };
    MDCMenu.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.menuSurface_ = this.menuSurfaceFactory_(this.root_);
        var list = this.root_.querySelector(strings$l.LIST_SELECTOR);
        if (list) {
            this.list_ = this.listFactory_(list);
            this.list_.wrapFocus = true;
        }
        else {
            this.list_ = null;
        }
        this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
        this.handleItemAction_ = function (evt) { return _this.foundation_.handleItemAction(_this.items[evt.detail.index]); };
        this.handleMenuSurfaceOpened_ = function () { return _this.foundation_.handleMenuSurfaceOpened(); };
        this.menuSurface_.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
        this.listen('keydown', this.handleKeydown_);
        this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
    };
    MDCMenu.prototype.destroy = function () {
        if (this.list_) {
            this.list_.destroy();
        }
        this.menuSurface_.destroy();
        this.menuSurface_.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
        this.unlisten('keydown', this.handleKeydown_);
        this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
        _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCMenu.prototype, "open", {
        get: function () {
            return this.menuSurface_.isOpen();
        },
        set: function (value) {
            if (value) {
                this.menuSurface_.open();
            }
            else {
                this.menuSurface_.close();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "wrapFocus", {
        get: function () {
            return this.list_ ? this.list_.wrapFocus : false;
        },
        set: function (value) {
            if (this.list_) {
                this.list_.wrapFocus = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "items", {
        /**
         * Return the items within the menu. Note that this only contains the set of elements within
         * the items container that are proper list items, and not supplemental / presentational DOM
         * elements.
         */
        get: function () {
            return this.list_ ? this.list_.listElements : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCMenu.prototype, "quickOpen", {
        set: function (quickOpen) {
            this.menuSurface_.quickOpen = quickOpen;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets default focus state where the menu should focus every time when menu
     * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
     * default.
     * @param focusState Default focus state.
     */
    MDCMenu.prototype.setDefaultFocusState = function (focusState) {
        this.foundation_.setDefaultFocusState(focusState);
    };
    /**
     * @param corner Default anchor corner alignment of top-left menu corner.
     */
    MDCMenu.prototype.setAnchorCorner = function (corner) {
        this.menuSurface_.setAnchorCorner(corner);
    };
    MDCMenu.prototype.setAnchorMargin = function (margin) {
        this.menuSurface_.setAnchorMargin(margin);
    };
    /**
     * Sets the list item as the selected row at the specified index.
     * @param index Index of list item within menu.
     */
    MDCMenu.prototype.setSelectedIndex = function (index) {
        this.foundation_.setSelectedIndex(index);
    };
    /**
     * Sets the enabled state to isEnabled for the menu item at the given index.
     * @param index Index of the menu item
     * @param isEnabled The desired enabled state of the menu item.
     */
    MDCMenu.prototype.setEnabled = function (index, isEnabled) {
        this.foundation_.setEnabled(index, isEnabled);
    };
    /**
     * @return The item within the menu at the index specified.
     */
    MDCMenu.prototype.getOptionByIndex = function (index) {
        var items = this.items;
        if (index < items.length) {
            return this.items[index];
        }
        else {
            return null;
        }
    };
    MDCMenu.prototype.setFixedPosition = function (isFixed) {
        this.menuSurface_.setFixedPosition(isFixed);
    };
    MDCMenu.prototype.hoistMenuToBody = function () {
        this.menuSurface_.hoistMenuToBody();
    };
    MDCMenu.prototype.setIsHoisted = function (isHoisted) {
        this.menuSurface_.setIsHoisted(isHoisted);
    };
    MDCMenu.prototype.setAbsolutePosition = function (x, y) {
        this.menuSurface_.setAbsolutePosition(x, y);
    };
    /**
     * Sets the element that the menu-surface is anchored to.
     */
    MDCMenu.prototype.setAnchorElement = function (element) {
        this.menuSurface_.anchorElement = element;
    };
    MDCMenu.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClassToElementAtIndex: function (index, className) {
                var list = _this.items;
                list[index].classList.add(className);
            },
            removeClassFromElementAtIndex: function (index, className) {
                var list = _this.items;
                list[index].classList.remove(className);
            },
            addAttributeToElementAtIndex: function (index, attr, value) {
                var list = _this.items;
                list[index].setAttribute(attr, value);
            },
            removeAttributeFromElementAtIndex: function (index, attr) {
                var list = _this.items;
                list[index].removeAttribute(attr);
            },
            elementContainsClass: function (element, className) { return element.classList.contains(className); },
            closeSurface: function (skipRestoreFocus) { return _this.menuSurface_.close(skipRestoreFocus); },
            getElementIndex: function (element) { return _this.items.indexOf(element); },
            notifySelected: function (evtData) { return _this.emit(strings$l.SELECTED_EVENT, {
                index: evtData.index,
                item: _this.items[evtData.index],
            }); },
            getMenuItemCount: function () { return _this.items.length; },
            focusItemAtIndex: function (index) { return _this.items[index].focus(); },
            focusListRoot: function () { return _this.root_.querySelector(strings$l.LIST_SELECTOR).focus(); },
            isSelectableItemAtIndex: function (index) { return !!closest(_this.items[index], "." + cssClasses$j.MENU_SELECTION_GROUP); },
            getSelectedSiblingOfItemAtIndex: function (index) {
                var selectionGroupEl = closest(_this.items[index], "." + cssClasses$j.MENU_SELECTION_GROUP);
                var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses$j.MENU_SELECTED_LIST_ITEM);
                return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
            },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCMenuFoundation(adapter);
    };
    return MDCMenu;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$k = {
    ACTIVATED: 'mdc-select--activated',
    DISABLED: 'mdc-select--disabled',
    FOCUSED: 'mdc-select--focused',
    INVALID: 'mdc-select--invalid',
    OUTLINED: 'mdc-select--outlined',
    REQUIRED: 'mdc-select--required',
    ROOT: 'mdc-select',
    SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
    WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
};
var strings$m = {
    ARIA_CONTROLS: 'aria-controls',
    ARIA_SELECTED_ATTR: 'aria-selected',
    CHANGE_EVENT: 'MDCSelect:change',
    ENHANCED_VALUE_ATTR: 'data-value',
    HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
    LABEL_SELECTOR: '.mdc-floating-label',
    LEADING_ICON_SELECTOR: '.mdc-select__icon',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    MENU_SELECTOR: '.mdc-select__menu',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    SELECTED_ITEM_SELECTOR: "." + cssClasses$k.SELECTED_ITEM_CLASS,
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
};
var numbers$9 = {
    LABEL_SCALE: 0.75,
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSelectFoundation = /** @class */ (function (_super) {
    __extends(MDCSelectFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCSelectFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) { foundationMap = {}; }
        var _this = _super.call(this, __assign({}, MDCSelectFoundation.defaultAdapter, adapter)) || this;
        _this.leadingIcon_ = foundationMap.leadingIcon;
        _this.helperText_ = foundationMap.helperText;
        return _this;
    }
    Object.defineProperty(MDCSelectFoundation, "cssClasses", {
        get: function () {
            return cssClasses$k;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "numbers", {
        get: function () {
            return numbers$9;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "strings", {
        get: function () {
            return strings$m;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                activateBottomLine: function () { return undefined; },
                deactivateBottomLine: function () { return undefined; },
                setValue: function () { return undefined; },
                getValue: function () { return ''; },
                floatLabel: function () { return undefined; },
                getLabelWidth: function () { return 0; },
                hasOutline: function () { return false; },
                notchOutline: function () { return undefined; },
                closeOutline: function () { return undefined; },
                openMenu: function () { return undefined; },
                closeMenu: function () { return undefined; },
                isMenuOpen: function () { return false; },
                setSelectedIndex: function () { return undefined; },
                setDisabled: function () { return undefined; },
                setRippleCenter: function () { return undefined; },
                notifyChange: function () { return undefined; },
                checkValidity: function () { return false; },
                setValid: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectFoundation.prototype.setSelectedIndex = function (index) {
        this.adapter_.setSelectedIndex(index);
        this.adapter_.closeMenu();
        var didChange = true;
        this.handleChange(didChange);
    };
    MDCSelectFoundation.prototype.setValue = function (value) {
        this.adapter_.setValue(value);
        var didChange = true;
        this.handleChange(didChange);
    };
    MDCSelectFoundation.prototype.getValue = function () {
        return this.adapter_.getValue();
    };
    MDCSelectFoundation.prototype.setDisabled = function (isDisabled) {
        if (isDisabled) {
            this.adapter_.addClass(cssClasses$k.DISABLED);
        }
        else {
            this.adapter_.removeClass(cssClasses$k.DISABLED);
        }
        this.adapter_.setDisabled(isDisabled);
        this.adapter_.closeMenu();
        if (this.leadingIcon_) {
            this.leadingIcon_.setDisabled(isDisabled);
        }
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCSelectFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText_) {
            this.helperText_.setContent(content);
        }
    };
    MDCSelectFoundation.prototype.layout = function () {
        var openNotch = this.getValue().length > 0;
        this.notchOutline(openNotch);
    };
    MDCSelectFoundation.prototype.handleMenuOpened = function () {
        this.adapter_.addClass(cssClasses$k.ACTIVATED);
    };
    MDCSelectFoundation.prototype.handleMenuClosed = function () {
        this.adapter_.removeClass(cssClasses$k.ACTIVATED);
    };
    /**
     * Handles value changes, via change event or programmatic updates.
     */
    MDCSelectFoundation.prototype.handleChange = function (didChange) {
        if (didChange === void 0) { didChange = true; }
        var value = this.getValue();
        var optionHasValue = value.length > 0;
        var isRequired = this.adapter_.hasClass(cssClasses$k.REQUIRED);
        this.notchOutline(optionHasValue);
        if (!this.adapter_.hasClass(cssClasses$k.FOCUSED)) {
            this.adapter_.floatLabel(optionHasValue);
        }
        if (didChange) {
            this.adapter_.notifyChange(value);
            if (isRequired) {
                this.setValid(this.isValid());
                if (this.helperText_) {
                    this.helperText_.setValidity(this.isValid());
                }
            }
        }
    };
    /**
     * Handles focus events from select element.
     */
    MDCSelectFoundation.prototype.handleFocus = function () {
        this.adapter_.addClass(cssClasses$k.FOCUSED);
        this.adapter_.floatLabel(true);
        this.notchOutline(true);
        this.adapter_.activateBottomLine();
        if (this.helperText_) {
            this.helperText_.showToScreenReader();
        }
    };
    /**
     * Handles blur events from select element.
     */
    MDCSelectFoundation.prototype.handleBlur = function () {
        if (this.adapter_.isMenuOpen()) {
            return;
        }
        this.adapter_.removeClass(cssClasses$k.FOCUSED);
        this.handleChange(false);
        this.adapter_.deactivateBottomLine();
        var isRequired = this.adapter_.hasClass(cssClasses$k.REQUIRED);
        if (isRequired) {
            this.setValid(this.isValid());
            if (this.helperText_) {
                this.helperText_.setValidity(this.isValid());
            }
        }
    };
    MDCSelectFoundation.prototype.handleClick = function (normalizedX) {
        if (this.adapter_.isMenuOpen()) {
            return;
        }
        this.adapter_.setRippleCenter(normalizedX);
        this.adapter_.openMenu();
    };
    MDCSelectFoundation.prototype.handleKeydown = function (event) {
        if (this.adapter_.isMenuOpen()) {
            return;
        }
        var isEnter = event.key === 'Enter' || event.keyCode === 13;
        var isSpace = event.key === 'Space' || event.keyCode === 32;
        var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
        var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
        if (this.adapter_.hasClass(cssClasses$k.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
            this.adapter_.openMenu();
            event.preventDefault();
        }
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCSelectFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter_.hasOutline()) {
            return;
        }
        var isFocused = this.adapter_.hasClass(cssClasses$k.FOCUSED);
        if (openNotch) {
            var labelScale = numbers$9.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            this.adapter_.notchOutline(labelWidth);
        }
        else if (!isFocused) {
            this.adapter_.closeOutline();
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon_) {
            this.leadingIcon_.setContent(content);
        }
    };
    MDCSelectFoundation.prototype.setValid = function (isValid) {
        this.adapter_.setValid(isValid);
    };
    MDCSelectFoundation.prototype.isValid = function () {
        return this.adapter_.checkValidity();
    };
    return MDCSelectFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$n = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role',
};
var cssClasses$l = {
    HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSelectHelperTextFoundation = /** @class */ (function (_super) {
    __extends(MDCSelectHelperTextFoundation, _super);
    function MDCSelectHelperTextFoundation(adapter) {
        return _super.call(this, __assign({}, MDCSelectHelperTextFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCSelectHelperTextFoundation, "cssClasses", {
        get: function () {
            return cssClasses$l;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation, "strings", {
        get: function () {
            return strings$n;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectHelperTextAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                setAttr: function () { return undefined; },
                removeAttr: function () { return undefined; },
                setContent: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the content of the helper text field.
     */
    MDCSelectHelperTextFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    /**
     *  Sets the persistency of the helper text.
     */
    MDCSelectHelperTextFoundation.prototype.setPersistent = function (isPersistent) {
        if (isPersistent) {
            this.adapter_.addClass(cssClasses$l.HELPER_TEXT_PERSISTENT);
        }
        else {
            this.adapter_.removeClass(cssClasses$l.HELPER_TEXT_PERSISTENT);
        }
    };
    /**
     * @param isValidation True to make the helper text act as an error validation message.
     */
    MDCSelectHelperTextFoundation.prototype.setValidation = function (isValidation) {
        if (isValidation) {
            this.adapter_.addClass(cssClasses$l.HELPER_TEXT_VALIDATION_MSG);
        }
        else {
            this.adapter_.removeClass(cssClasses$l.HELPER_TEXT_VALIDATION_MSG);
        }
    };
    /**
     * Makes the helper text visible to screen readers.
     */
    MDCSelectHelperTextFoundation.prototype.showToScreenReader = function () {
        this.adapter_.removeAttr(strings$n.ARIA_HIDDEN);
    };
    /**
     * Sets the validity of the helper text based on the select validity.
     */
    MDCSelectHelperTextFoundation.prototype.setValidity = function (selectIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$l.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$l.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;
        if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings$n.ROLE, 'alert');
        }
        else {
            this.adapter_.removeAttr(strings$n.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
        }
    };
    /**
     * Hides the help text from screen readers.
     */
    MDCSelectHelperTextFoundation.prototype.hide_ = function () {
        this.adapter_.setAttr(strings$n.ARIA_HIDDEN, 'true');
    };
    return MDCSelectHelperTextFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSelectHelperText = /** @class */ (function (_super) {
    __extends(MDCSelectHelperText, _super);
    function MDCSelectHelperText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectHelperText.attachTo = function (root) {
        return new MDCSelectHelperText(root);
    };
    Object.defineProperty(MDCSelectHelperText.prototype, "foundation", {
        get: function () {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectHelperText.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
            removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
            setContent: function (content) {
                _this.root_.textContent = content;
            },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCSelectHelperTextFoundation(adapter);
    };
    return MDCSelectHelperText;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$o = {
    ICON_EVENT: 'MDCSelect:icon',
    ICON_ROLE: 'button',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var INTERACTION_EVENTS$2 = ['click', 'keydown'];
var MDCSelectIconFoundation = /** @class */ (function (_super) {
    __extends(MDCSelectIconFoundation, _super);
    function MDCSelectIconFoundation(adapter) {
        var _this = _super.call(this, __assign({}, MDCSelectIconFoundation.defaultAdapter, adapter)) || this;
        _this.savedTabIndex_ = null;
        _this.interactionHandler_ = function (evt) { return _this.handleInteraction(evt); };
        return _this;
    }
    Object.defineProperty(MDCSelectIconFoundation, "strings", {
        get: function () {
            return strings$o;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelectIconFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectIconAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                getAttr: function () { return null; },
                setAttr: function () { return undefined; },
                removeAttr: function () { return undefined; },
                setContent: function () { return undefined; },
                registerInteractionHandler: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
                notifyIconAction: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectIconFoundation.prototype.init = function () {
        var _this = this;
        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        INTERACTION_EVENTS$2.forEach(function (evtType) {
            _this.adapter_.registerInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCSelectIconFoundation.prototype.destroy = function () {
        var _this = this;
        INTERACTION_EVENTS$2.forEach(function (evtType) {
            _this.adapter_.deregisterInteractionHandler(evtType, _this.interactionHandler_);
        });
    };
    MDCSelectIconFoundation.prototype.setDisabled = function (disabled) {
        if (!this.savedTabIndex_) {
            return;
        }
        if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
        }
        else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$o.ICON_ROLE);
        }
    };
    MDCSelectIconFoundation.prototype.setAriaLabel = function (label) {
        this.adapter_.setAttr('aria-label', label);
    };
    MDCSelectIconFoundation.prototype.setContent = function (content) {
        this.adapter_.setContent(content);
    };
    MDCSelectIconFoundation.prototype.handleInteraction = function (evt) {
        var isEnterKey = evt.key === 'Enter' || evt.keyCode === 13;
        if (evt.type === 'click' || isEnterKey) {
            this.adapter_.notifyIconAction();
        }
    };
    return MDCSelectIconFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSelectIcon = /** @class */ (function (_super) {
    __extends(MDCSelectIcon, _super);
    function MDCSelectIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectIcon.attachTo = function (root) {
        return new MDCSelectIcon(root);
    };
    Object.defineProperty(MDCSelectIcon.prototype, "foundation", {
        get: function () {
            return this.foundation_;
        },
        enumerable: true,
        configurable: true
    });
    MDCSelectIcon.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            getAttr: function (attr) { return _this.root_.getAttribute(attr); },
            setAttr: function (attr, value) { return _this.root_.setAttribute(attr, value); },
            removeAttr: function (attr) { return _this.root_.removeAttribute(attr); },
            setContent: function (content) {
                _this.root_.textContent = content;
            },
            registerInteractionHandler: function (evtType, handler) { return _this.listen(evtType, handler); },
            deregisterInteractionHandler: function (evtType, handler) { return _this.unlisten(evtType, handler); },
            notifyIconAction: function () { return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {} /* evtData */, true /* shouldBubble */); },
        };
        // tslint:enable:object-literal-sort-keys
        return new MDCSelectIconFoundation(adapter);
    };
    return MDCSelectIcon;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var VALIDATION_ATTR_WHITELIST$1 = ['required', 'aria-required'];
var MDCSelect = /** @class */ (function (_super) {
    __extends(MDCSelect, _super);
    function MDCSelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelect.attachTo = function (root) {
        return new MDCSelect(root);
    };
    MDCSelect.prototype.initialize = function (labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
        if (labelFactory === void 0) { labelFactory = function (el) { return new MDCFloatingLabel(el); }; }
        if (lineRippleFactory === void 0) { lineRippleFactory = function (el) { return new MDCLineRipple(el); }; }
        if (outlineFactory === void 0) { outlineFactory = function (el) { return new MDCNotchedOutline(el); }; }
        if (menuFactory === void 0) { menuFactory = function (el) { return new MDCMenu(el); }; }
        if (iconFactory === void 0) { iconFactory = function (el) { return new MDCSelectIcon(el); }; }
        if (helperTextFactory === void 0) { helperTextFactory = function (el) { return new MDCSelectHelperText(el); }; }
        this.isMenuOpen_ = false;
        this.nativeControl_ = this.root_.querySelector(strings$m.NATIVE_CONTROL_SELECTOR);
        this.selectedText_ = this.root_.querySelector(strings$m.SELECTED_TEXT_SELECTOR);
        var targetElement = this.nativeControl_ || this.selectedText_;
        if (!targetElement) {
            throw new Error('MDCSelect: Missing required element: Exactly one of the following selectors must be present: ' +
                ("'" + strings$m.NATIVE_CONTROL_SELECTOR + "' or '" + strings$m.SELECTED_TEXT_SELECTOR + "'"));
        }
        this.targetElement_ = targetElement;
        if (this.targetElement_.hasAttribute(strings$m.ARIA_CONTROLS)) {
            var helperTextElement = document.getElementById(this.targetElement_.getAttribute(strings$m.ARIA_CONTROLS));
            if (helperTextElement) {
                this.helperText_ = helperTextFactory(helperTextElement);
            }
        }
        if (this.selectedText_) {
            this.enhancedSelectSetup_(menuFactory);
        }
        var labelElement = this.root_.querySelector(strings$m.LABEL_SELECTOR);
        this.label_ = labelElement ? labelFactory(labelElement) : null;
        var lineRippleElement = this.root_.querySelector(strings$m.LINE_RIPPLE_SELECTOR);
        this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
        var outlineElement = this.root_.querySelector(strings$m.OUTLINE_SELECTOR);
        this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
        var leadingIcon = this.root_.querySelector(strings$m.LEADING_ICON_SELECTOR);
        if (leadingIcon) {
            this.root_.classList.add(cssClasses$k.WITH_LEADING_ICON);
            this.leadingIcon_ = iconFactory(leadingIcon);
            if (this.menuElement_) {
                this.menuElement_.classList.add(cssClasses$k.WITH_LEADING_ICON);
            }
        }
        if (!this.root_.classList.contains(cssClasses$k.OUTLINED)) {
            this.ripple = this.createRipple_();
        }
        // The required state needs to be sync'd before the mutation observer is added.
        this.initialSyncRequiredState_();
        this.addMutationObserverForRequired_();
    };
    /**
     * Initializes the select's event listeners and internal state based
     * on the environment's state.
     */
    MDCSelect.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.handleChange_ = function () { return _this.foundation_.handleChange(/* didChange */ true); };
        this.handleFocus_ = function () { return _this.foundation_.handleFocus(); };
        this.handleBlur_ = function () { return _this.foundation_.handleBlur(); };
        this.handleClick_ = function (evt) {
            if (_this.selectedText_) {
                _this.selectedText_.focus();
            }
            _this.foundation_.handleClick(_this.getNormalizedXCoordinate_(evt));
        };
        this.handleKeydown_ = function (evt) { return _this.foundation_.handleKeydown(evt); };
        this.handleMenuSelected_ = function (evtData) { return _this.selectedIndex = evtData.detail.index; };
        this.handleMenuOpened_ = function () {
            _this.foundation_.handleMenuOpened();
            if (_this.menu_.items.length === 0) {
                return;
            }
            // Menu should open to the last selected element, should open to first menu item otherwise.
            var focusItemIndex = _this.selectedIndex >= 0 ? _this.selectedIndex : 0;
            var focusItemEl = _this.menu_.items[focusItemIndex];
            focusItemEl.focus();
        };
        this.handleMenuClosed_ = function () {
            _this.foundation_.handleMenuClosed();
            // isMenuOpen_ is used to track the state of the menu opening or closing since the menu.open function
            // will return false if the menu is still closing and this method listens to the closed event which
            // occurs after the menu is already closed.
            _this.isMenuOpen_ = false;
            _this.selectedText_.removeAttribute('aria-expanded');
            if (document.activeElement !== _this.selectedText_) {
                _this.foundation_.handleBlur();
            }
        };
        this.targetElement_.addEventListener('change', this.handleChange_);
        this.targetElement_.addEventListener('focus', this.handleFocus_);
        this.targetElement_.addEventListener('blur', this.handleBlur_);
        this.targetElement_.addEventListener('click', this.handleClick_);
        if (this.menuElement_) {
            this.selectedText_.addEventListener('keydown', this.handleKeydown_);
            this.menu_.listen(strings$k.CLOSED_EVENT, this.handleMenuClosed_);
            this.menu_.listen(strings$k.OPENED_EVENT, this.handleMenuOpened_);
            this.menu_.listen(strings$l.SELECTED_EVENT, this.handleMenuSelected_);
            if (this.hiddenInput_ && this.hiddenInput_.value) {
                // If the hidden input already has a value, use it to restore the select's value.
                // This can happen e.g. if the user goes back or (in some browsers) refreshes the page.
                var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
                enhancedAdapterMethods.setValue(this.hiddenInput_.value);
            }
            else if (this.menuElement_.querySelector(strings$m.SELECTED_ITEM_SELECTOR)) {
                // If an element is selected, the select should set the initial selected text.
                var enhancedAdapterMethods = this.getEnhancedSelectAdapterMethods_();
                enhancedAdapterMethods.setValue(enhancedAdapterMethods.getValue());
            }
        }
        // Initially sync floating label
        this.foundation_.handleChange(/* didChange */ false);
        if (this.root_.classList.contains(cssClasses$k.DISABLED)
            || (this.nativeControl_ && this.nativeControl_.disabled)) {
            this.disabled = true;
        }
    };
    MDCSelect.prototype.destroy = function () {
        this.targetElement_.removeEventListener('change', this.handleChange_);
        this.targetElement_.removeEventListener('focus', this.handleFocus_);
        this.targetElement_.removeEventListener('blur', this.handleBlur_);
        this.targetElement_.removeEventListener('keydown', this.handleKeydown_);
        this.targetElement_.removeEventListener('click', this.handleClick_);
        if (this.menu_) {
            this.menu_.unlisten(strings$k.CLOSED_EVENT, this.handleMenuClosed_);
            this.menu_.unlisten(strings$k.OPENED_EVENT, this.handleMenuOpened_);
            this.menu_.unlisten(strings$l.SELECTED_EVENT, this.handleMenuSelected_);
            this.menu_.destroy();
        }
        if (this.ripple) {
            this.ripple.destroy();
        }
        if (this.outline_) {
            this.outline_.destroy();
        }
        if (this.leadingIcon_) {
            this.leadingIcon_.destroy();
        }
        if (this.helperText_) {
            this.helperText_.destroy();
        }
        if (this.validationObserver_) {
            this.validationObserver_.disconnect();
        }
        _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCSelect.prototype, "value", {
        get: function () {
            return this.foundation_.getValue();
        },
        set: function (value) {
            this.foundation_.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "selectedIndex", {
        get: function () {
            var selectedIndex = -1;
            if (this.menuElement_ && this.menu_) {
                var selectedEl = this.menuElement_.querySelector(strings$m.SELECTED_ITEM_SELECTOR);
                selectedIndex = this.menu_.items.indexOf(selectedEl);
            }
            else if (this.nativeControl_) {
                selectedIndex = this.nativeControl_.selectedIndex;
            }
            return selectedIndex;
        },
        set: function (selectedIndex) {
            this.foundation_.setSelectedIndex(selectedIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "disabled", {
        get: function () {
            return this.root_.classList.contains(cssClasses$k.DISABLED) ||
                (this.nativeControl_ ? this.nativeControl_.disabled : false);
        },
        set: function (disabled) {
            this.foundation_.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "leadingIconAriaLabel", {
        set: function (label) {
            this.foundation_.setLeadingIconAriaLabel(label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "leadingIconContent", {
        /**
         * Sets the text content of the leading icon.
         */
        set: function (content) {
            this.foundation_.setLeadingIconContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "helperTextContent", {
        /**
         * Sets the text content of the helper text.
         */
        set: function (content) {
            this.foundation_.setHelperTextContent(content);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "valid", {
        /**
         * Checks if the select is in a valid state.
         */
        get: function () {
            return this.foundation_.isValid();
        },
        /**
         * Sets the current invalid state of the select.
         */
        set: function (isValid) {
            this.foundation_.setValid(isValid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MDCSelect.prototype, "required", {
        /**
         * Returns whether the select is required.
         */
        get: function () {
            if (this.nativeControl_) {
                return this.nativeControl_.required;
            }
            else {
                return this.selectedText_.getAttribute('aria-required') === 'true';
            }
        },
        /**
         * Sets the control to the required state.
         */
        set: function (isRequired) {
            if (this.nativeControl_) {
                this.nativeControl_.required = isRequired;
            }
            else {
                if (isRequired) {
                    this.selectedText_.setAttribute('aria-required', isRequired.toString());
                }
                else {
                    this.selectedText_.removeAttribute('aria-required');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Recomputes the outline SVG path for the outline element.
     */
    MDCSelect.prototype.layout = function () {
        this.foundation_.layout();
    };
    MDCSelect.prototype.getDefaultFoundation = function () {
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        var adapter = __assign({}, (this.nativeControl_ ? this.getNativeSelectAdapterMethods_() : this.getEnhancedSelectAdapterMethods_()), this.getCommonAdapterMethods_(), this.getOutlineAdapterMethods_(), this.getLabelAdapterMethods_());
        return new MDCSelectFoundation(adapter, this.getFoundationMap_());
    };
    /**
     * Handles setup for the enhanced menu.
     */
    MDCSelect.prototype.enhancedSelectSetup_ = function (menuFactory) {
        var isDisabled = this.root_.classList.contains(cssClasses$k.DISABLED);
        this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
        this.hiddenInput_ = this.root_.querySelector(strings$m.HIDDEN_INPUT_SELECTOR);
        this.menuElement_ = this.root_.querySelector(strings$m.MENU_SELECTOR);
        this.menu_ = menuFactory(this.menuElement_);
        this.menu_.hoistMenuToBody();
        this.menu_.setAnchorElement(this.root_);
        this.menu_.setAnchorCorner(Corner.BOTTOM_START);
        this.menu_.wrapFocus = false;
    };
    MDCSelect.prototype.createRipple_ = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = __assign({}, MDCRipple.createAdapter(this), { registerInteractionHandler: function (evtType, handler) { return _this.targetElement_.addEventListener(evtType, handler); }, deregisterInteractionHandler: function (evtType, handler) { return _this.targetElement_.removeEventListener(evtType, handler); } });
        // tslint:enable:object-literal-sort-keys
        return new MDCRipple(this.root_, new MDCRippleFoundation(adapter));
    };
    MDCSelect.prototype.getNativeSelectAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            getValue: function () { return _this.nativeControl_.value; },
            setValue: function (value) {
                _this.nativeControl_.value = value;
            },
            openMenu: function () { return undefined; },
            closeMenu: function () { return undefined; },
            isMenuOpen: function () { return false; },
            setSelectedIndex: function (index) {
                _this.nativeControl_.selectedIndex = index;
            },
            setDisabled: function (isDisabled) {
                _this.nativeControl_.disabled = isDisabled;
            },
            setValid: function (isValid) {
                if (isValid) {
                    _this.root_.classList.remove(cssClasses$k.INVALID);
                }
                else {
                    _this.root_.classList.add(cssClasses$k.INVALID);
                }
            },
            checkValidity: function () { return _this.nativeControl_.checkValidity(); },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getEnhancedSelectAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            getValue: function () {
                var listItem = _this.menuElement_.querySelector(strings$m.SELECTED_ITEM_SELECTOR);
                if (listItem && listItem.hasAttribute(strings$m.ENHANCED_VALUE_ATTR)) {
                    return listItem.getAttribute(strings$m.ENHANCED_VALUE_ATTR) || '';
                }
                return '';
            },
            setValue: function (value) {
                var element = _this.menuElement_.querySelector("[" + strings$m.ENHANCED_VALUE_ATTR + "=\"" + value + "\"]");
                _this.setEnhancedSelectedIndex_(element ? _this.menu_.items.indexOf(element) : -1);
            },
            openMenu: function () {
                if (_this.menu_ && !_this.menu_.open) {
                    _this.menu_.open = true;
                    _this.isMenuOpen_ = true;
                    _this.selectedText_.setAttribute('aria-expanded', 'true');
                }
            },
            closeMenu: function () {
                if (_this.menu_ && _this.menu_.open) {
                    _this.menu_.open = false;
                }
            },
            isMenuOpen: function () { return Boolean(_this.menu_) && _this.isMenuOpen_; },
            setSelectedIndex: function (index) { return _this.setEnhancedSelectedIndex_(index); },
            setDisabled: function (isDisabled) {
                _this.selectedText_.setAttribute('tabindex', isDisabled ? '-1' : '0');
                _this.selectedText_.setAttribute('aria-disabled', isDisabled.toString());
                if (_this.hiddenInput_) {
                    _this.hiddenInput_.disabled = isDisabled;
                }
            },
            checkValidity: function () {
                var classList = _this.root_.classList;
                if (classList.contains(cssClasses$k.REQUIRED) && !classList.contains(cssClasses$k.DISABLED)) {
                    // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
                    // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
                    return _this.selectedIndex !== -1 && (_this.selectedIndex !== 0 || Boolean(_this.value));
                }
                else {
                    return true;
                }
            },
            setValid: function (isValid) {
                _this.selectedText_.setAttribute('aria-invalid', (!isValid).toString());
                if (isValid) {
                    _this.root_.classList.remove(cssClasses$k.INVALID);
                }
                else {
                    _this.root_.classList.add(cssClasses$k.INVALID);
                }
            },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getCommonAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            addClass: function (className) { return _this.root_.classList.add(className); },
            removeClass: function (className) { return _this.root_.classList.remove(className); },
            hasClass: function (className) { return _this.root_.classList.contains(className); },
            setRippleCenter: function (normalizedX) { return _this.lineRipple_ && _this.lineRipple_.setRippleCenter(normalizedX); },
            activateBottomLine: function () { return _this.lineRipple_ && _this.lineRipple_.activate(); },
            deactivateBottomLine: function () { return _this.lineRipple_ && _this.lineRipple_.deactivate(); },
            notifyChange: function (value) {
                var index = _this.selectedIndex;
                _this.emit(strings$m.CHANGE_EVENT, { value: value, index: index }, true /* shouldBubble  */);
            },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getOutlineAdapterMethods_ = function () {
        var _this = this;
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        return {
            hasOutline: function () { return Boolean(_this.outline_); },
            notchOutline: function (labelWidth) { return _this.outline_ && _this.outline_.notch(labelWidth); },
            closeOutline: function () { return _this.outline_ && _this.outline_.closeNotch(); },
        };
        // tslint:enable:object-literal-sort-keys
    };
    MDCSelect.prototype.getLabelAdapterMethods_ = function () {
        var _this = this;
        return {
            floatLabel: function (shouldFloat) { return _this.label_ && _this.label_.float(shouldFloat); },
            getLabelWidth: function () { return _this.label_ ? _this.label_.getWidth() : 0; },
        };
    };
    /**
     * Calculates where the line ripple should start based on the x coordinate within the component.
     */
    MDCSelect.prototype.getNormalizedXCoordinate_ = function (evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var xCoordinate = this.isTouchEvent_(evt) ? evt.touches[0].clientX : evt.clientX;
        return xCoordinate - targetClientRect.left;
    };
    MDCSelect.prototype.isTouchEvent_ = function (evt) {
        return Boolean(evt.touches);
    };
    /**
     * Returns a map of all subcomponents to subfoundations.
     */
    MDCSelect.prototype.getFoundationMap_ = function () {
        return {
            helperText: this.helperText_ ? this.helperText_.foundation : undefined,
            leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundation : undefined,
        };
    };
    MDCSelect.prototype.setEnhancedSelectedIndex_ = function (index) {
        var selectedItem = this.menu_.items[index];
        this.selectedText_.textContent = selectedItem ? selectedItem.textContent.trim() : '';
        var previouslySelected = this.menuElement_.querySelector(strings$m.SELECTED_ITEM_SELECTOR);
        if (previouslySelected) {
            previouslySelected.classList.remove(cssClasses$k.SELECTED_ITEM_CLASS);
            previouslySelected.removeAttribute(strings$m.ARIA_SELECTED_ATTR);
        }
        if (selectedItem) {
            selectedItem.classList.add(cssClasses$k.SELECTED_ITEM_CLASS);
            selectedItem.setAttribute(strings$m.ARIA_SELECTED_ATTR, 'true');
        }
        // Synchronize hidden input's value with data-value attribute of selected item.
        // This code path is also followed when setting value directly, so this covers all cases.
        if (this.hiddenInput_) {
            this.hiddenInput_.value = selectedItem ? selectedItem.getAttribute(strings$m.ENHANCED_VALUE_ATTR) || '' : '';
        }
        this.layout();
    };
    MDCSelect.prototype.initialSyncRequiredState_ = function () {
        var isRequired = this.targetElement_.required
            || this.targetElement_.getAttribute('aria-required') === 'true'
            || this.root_.classList.contains(cssClasses$k.REQUIRED);
        if (isRequired) {
            if (this.nativeControl_) {
                this.nativeControl_.required = true;
            }
            else {
                this.selectedText_.setAttribute('aria-required', 'true');
            }
            this.root_.classList.add(cssClasses$k.REQUIRED);
        }
    };
    MDCSelect.prototype.addMutationObserverForRequired_ = function () {
        var _this = this;
        var observerHandler = function (attributesList) {
            attributesList.some(function (attributeName) {
                if (VALIDATION_ATTR_WHITELIST$1.indexOf(attributeName) === -1) {
                    return false;
                }
                if (_this.selectedText_) {
                    if (_this.selectedText_.getAttribute('aria-required') === 'true') {
                        _this.root_.classList.add(cssClasses$k.REQUIRED);
                    }
                    else {
                        _this.root_.classList.remove(cssClasses$k.REQUIRED);
                    }
                }
                else {
                    if (_this.nativeControl_.required) {
                        _this.root_.classList.add(cssClasses$k.REQUIRED);
                    }
                    else {
                        _this.root_.classList.remove(cssClasses$k.REQUIRED);
                    }
                }
                return true;
            });
        };
        var getAttributesList = function (mutationsList) {
            return mutationsList
                .map(function (mutation) { return mutation.attributeName; })
                .filter(function (attributeName) { return attributeName; });
        };
        var observer = new MutationObserver(function (mutationsList) { return observerHandler(getAttributesList(mutationsList)); });
        observer.observe(this.targetElement_, { attributes: true });
        this.validationObserver_ = observer;
    };
    return MDCSelect;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\menu-surface\MenuSurface.svelte generated by Svelte v3.31.2 */
const file$L = "node_modules\\@smui\\menu-surface\\MenuSurface.svelte";

function create_fragment$Q(ctx) {
	let div;
	let div_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

	let div_levels = [
		{
			class: div_class_value = "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? "mdc-menu-surface--fixed" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "mdc-menu-surface--open" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "smui-menu-surface--static" : "") + "\n  "
		},
		exclude(/*$$props*/ ctx[7], [
			"use",
			"class",
			"static",
			"anchor",
			"fixed",
			"open",
			"quickOpen",
			"anchorElement",
			"anchorCorner",
			"element"
		])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$L, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[26](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[2])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div)),
					listen_dev(div, "MDCMenuSurface:closed", /*updateOpen*/ ctx[6], false, false, false),
					listen_dev(div, "MDCMenuSurface:opened", /*updateOpen*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16777216) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[24], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*className, fixed, isStatic*/ 25 && div_class_value !== (div_class_value = "\n    mdc-menu-surface\n    " + /*className*/ ctx[3] + "\n    " + (/*fixed*/ ctx[0] ? "mdc-menu-surface--fixed" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "mdc-menu-surface--open" : "") + "\n    " + (/*isStatic*/ ctx[4] ? "smui-menu-surface--static" : "") + "\n  ")) && { class: div_class_value },
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], [
					"use",
					"class",
					"static",
					"anchor",
					"fixed",
					"open",
					"quickOpen",
					"anchorElement",
					"anchorCorner",
					"element"
				])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[26](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("MenuSurface", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCMenuSurface:closed", "MDCMenuSurface:opened"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { static: isStatic = false } = $$props;
	let { anchor = true } = $$props;
	let { fixed = false } = $$props;
	let { open = isStatic } = $$props;
	let { quickOpen = false } = $$props;
	let { anchorElement = null } = $$props;
	let { anchorCorner = null } = $$props;
	let { element = undefined } = $$props; // This is exported because Menu needs it.
	let menuSurface;
	let instantiate = getContext("SMUI:menu-surface:instantiate");
	let getInstance = getContext("SMUI:menu-surface:getInstance");
	setContext("SMUI:list:role", "menu");
	setContext("SMUI:list:item:role", "menuitem");
	let oldFixed = null;

	onMount(async () => {
		if (instantiate !== false) {
			$$invalidate(22, menuSurface = new MDCMenuSurface(element));
		} else {
			$$invalidate(22, menuSurface = await getInstance());
		}
	});

	onDestroy(() => {
		if (anchor) {
			element && element.parentNode.classList.remove("mdc-menu-surface--anchor");
		}

		let isHoisted = false;

		if (menuSurface) {
			isHoisted = menuSurface.foundation_.isHoistedElement_;

			if (instantiate !== false) {
				menuSurface.destroy();
			}
		}

		if (isHoisted) {
			element.parentNode.removeChild(element);
		}
	});

	function updateOpen() {
		if (menuSurface) {
			if (isStatic) {
				$$invalidate(8, open = true);
			} else {
				$$invalidate(8, open = menuSurface.isOpen());
			}
		}
	}

	function setOpen(value) {
		$$invalidate(8, open = value);
	}

	function setAnchorCorner(...args) {
		return menuSurface.setAnchorCorner(...args);
	}

	function setAnchorMargin(...args) {
		return menuSurface.setAnchorMargin(...args);
	}

	function setFixedPosition(isFixed, ...args) {
		$$invalidate(0, fixed = isFixed);
		return menuSurface.setFixedPosition(isFixed, ...args);
	}

	function setAbsolutePosition(...args) {
		return menuSurface.setAbsolutePosition(...args);
	}

	function setMenuSurfaceAnchorElement(...args) {
		return menuSurface.setMenuSurfaceAnchorElement(...args);
	}

	function hoistMenuToBody(...args) {
		return menuSurface.hoistMenuToBody(...args);
	}

	function setIsHoisted(...args) {
		return menuSurface.setIsHoisted(...args);
	}

	function getDefaultFoundation(...args) {
		return menuSurface.getDefaultFoundation(...args);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(2, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("static" in $$new_props) $$invalidate(4, isStatic = $$new_props.static);
		if ("anchor" in $$new_props) $$invalidate(10, anchor = $$new_props.anchor);
		if ("fixed" in $$new_props) $$invalidate(0, fixed = $$new_props.fixed);
		if ("open" in $$new_props) $$invalidate(8, open = $$new_props.open);
		if ("quickOpen" in $$new_props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
		if ("anchorElement" in $$new_props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
		if ("anchorCorner" in $$new_props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
		if ("element" in $$new_props) $$invalidate(1, element = $$new_props.element);
		if ("$$scope" in $$new_props) $$invalidate(24, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Corner,
		CornerBit,
		MDCMenuSurface,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		isStatic,
		anchor,
		fixed,
		open,
		quickOpen,
		anchorElement,
		anchorCorner,
		element,
		menuSurface,
		instantiate,
		getInstance,
		oldFixed,
		updateOpen,
		setOpen,
		setAnchorCorner,
		setAnchorMargin,
		setFixedPosition,
		setAbsolutePosition,
		setMenuSurfaceAnchorElement,
		hoistMenuToBody,
		setIsHoisted,
		getDefaultFoundation
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(2, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("isStatic" in $$props) $$invalidate(4, isStatic = $$new_props.isStatic);
		if ("anchor" in $$props) $$invalidate(10, anchor = $$new_props.anchor);
		if ("fixed" in $$props) $$invalidate(0, fixed = $$new_props.fixed);
		if ("open" in $$props) $$invalidate(8, open = $$new_props.open);
		if ("quickOpen" in $$props) $$invalidate(11, quickOpen = $$new_props.quickOpen);
		if ("anchorElement" in $$props) $$invalidate(9, anchorElement = $$new_props.anchorElement);
		if ("anchorCorner" in $$props) $$invalidate(12, anchorCorner = $$new_props.anchorCorner);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
		if ("menuSurface" in $$props) $$invalidate(22, menuSurface = $$new_props.menuSurface);
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
		if ("oldFixed" in $$props) $$invalidate(23, oldFixed = $$new_props.oldFixed);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*element, anchor*/ 1026) {
			 if (element && anchor && !element.parentNode.classList.contains("mdc-menu-surface--anchor")) {
				element.parentNode.classList.add("mdc-menu-surface--anchor");
				$$invalidate(9, anchorElement = element.parentNode);
			}
		}

		if ($$self.$$.dirty & /*menuSurface, quickOpen*/ 4196352) {
			 if (menuSurface && menuSurface.quickOpen !== quickOpen) {
				$$invalidate(22, menuSurface.quickOpen = quickOpen, menuSurface);
			}
		}

		if ($$self.$$.dirty & /*menuSurface, anchorElement*/ 4194816) {
			 if (menuSurface && menuSurface.anchorElement !== anchorElement) {
				$$invalidate(22, menuSurface.anchorElement = anchorElement, menuSurface);
			}
		}

		if ($$self.$$.dirty & /*menuSurface, open*/ 4194560) {
			 if (menuSurface && menuSurface.isOpen() !== open) {
				if (open) {
					menuSurface.open();
				} else {
					menuSurface.close();
				}
			}
		}

		if ($$self.$$.dirty & /*menuSurface, oldFixed, fixed*/ 12582913) {
			 if (menuSurface && oldFixed !== fixed) {
				menuSurface.setFixedPosition(fixed);
				$$invalidate(23, oldFixed = fixed);
			}
		}

		if ($$self.$$.dirty & /*menuSurface, anchorCorner*/ 4198400) {
			 if (menuSurface && anchorCorner != null) {
				if (Corner.hasOwnProperty(anchorCorner)) {
					menuSurface.setAnchorCorner(Corner[anchorCorner]);
				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
					menuSurface.setAnchorCorner(Corner[anchorCorner]);
				} else {
					menuSurface.setAnchorCorner(anchorCorner);
				}
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		fixed,
		element,
		use,
		className,
		isStatic,
		forwardEvents,
		updateOpen,
		$$props,
		open,
		anchorElement,
		anchor,
		quickOpen,
		anchorCorner,
		setOpen,
		setAnchorCorner,
		setAnchorMargin,
		setFixedPosition,
		setAbsolutePosition,
		setMenuSurfaceAnchorElement,
		hoistMenuToBody,
		setIsHoisted,
		getDefaultFoundation,
		menuSurface,
		oldFixed,
		$$scope,
		slots,
		div_binding
	];
}

class MenuSurface extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
			use: 2,
			class: 3,
			static: 4,
			anchor: 10,
			fixed: 0,
			open: 8,
			quickOpen: 11,
			anchorElement: 9,
			anchorCorner: 12,
			element: 1,
			setOpen: 13,
			setAnchorCorner: 14,
			setAnchorMargin: 15,
			setFixedPosition: 16,
			setAbsolutePosition: 17,
			setMenuSurfaceAnchorElement: 18,
			hoistMenuToBody: 19,
			setIsHoisted: 20,
			getDefaultFoundation: 21
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MenuSurface",
			options,
			id: create_fragment$Q.name
		});
	}

	get use() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get static() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set static(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get anchor() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set anchor(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get quickOpen() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set quickOpen(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get anchorElement() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set anchorElement(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get anchorCorner() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set anchorCorner(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setOpen() {
		return this.$$.ctx[13];
	}

	set setOpen(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAnchorCorner() {
		return this.$$.ctx[14];
	}

	set setAnchorCorner(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAnchorMargin() {
		return this.$$.ctx[15];
	}

	set setAnchorMargin(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setFixedPosition() {
		return this.$$.ctx[16];
	}

	set setFixedPosition(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAbsolutePosition() {
		return this.$$.ctx[17];
	}

	set setAbsolutePosition(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setMenuSurfaceAnchorElement() {
		return this.$$.ctx[18];
	}

	set setMenuSurfaceAnchorElement(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoistMenuToBody() {
		return this.$$.ctx[19];
	}

	set hoistMenuToBody(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setIsHoisted() {
		return this.$$.ctx[20];
	}

	set setIsHoisted(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getDefaultFoundation() {
		return this.$$.ctx[21];
	}

	set getDefaultFoundation(value) {
		throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\menu\Menu.svelte generated by Svelte v3.31.2 */

// (1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class="mdc-menu {className}"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >
function create_default_slot$f(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$f.name,
		type: "slot",
		source: "(1:0) <MenuSurface   bind:element   use={[forwardEvents, ...use]}   class=\\\"mdc-menu {className}\\\"   on:MDCMenu:selected={updateOpen}   on:MDCMenuSurface:closed={updateOpen} on:MDCMenuSurface:opened={updateOpen}   {...exclude($$props, ['use', 'class', 'wrapFocus'])} >",
		ctx
	});

	return block;
}

function create_fragment$R(ctx) {
	let menusurface;
	let updating_element;
	let current;

	const menusurface_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
		},
		{
			class: "mdc-menu " + /*className*/ ctx[1]
		},
		exclude(/*$$props*/ ctx[5], ["use", "class", "wrapFocus"])
	];

	function menusurface_element_binding(value) {
		/*menusurface_element_binding*/ ctx[27].call(null, value);
	}

	let menusurface_props = {
		$$slots: { default: [create_default_slot$f] },
		$$scope: { ctx }
	};

	for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
		menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
	}

	if (/*element*/ ctx[2] !== void 0) {
		menusurface_props.element = /*element*/ ctx[2];
	}

	menusurface = new MenuSurface({ props: menusurface_props, $$inline: true });
	binding_callbacks.push(() => bind(menusurface, "element", menusurface_element_binding));
	menusurface.$on("MDCMenu:selected", /*updateOpen*/ ctx[4]);
	menusurface.$on("MDCMenuSurface:closed", /*updateOpen*/ ctx[4]);
	menusurface.$on("MDCMenuSurface:opened", /*updateOpen*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(menusurface.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(menusurface, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const menusurface_changes = (dirty[0] & /*forwardEvents, use, className, $$props*/ 43)
			? get_spread_update(menusurface_spread_levels, [
					dirty[0] & /*forwardEvents, use*/ 9 && {
						use: [/*forwardEvents*/ ctx[3], .../*use*/ ctx[0]]
					},
					dirty[0] & /*className*/ 2 && {
						class: "mdc-menu " + /*className*/ ctx[1]
					},
					dirty[0] & /*$$props*/ 32 && get_spread_object(exclude(/*$$props*/ ctx[5], ["use", "class", "wrapFocus"]))
				])
			: {};

			if (dirty[0] & /*$$scope*/ 268435456) {
				menusurface_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*element*/ 4) {
				updating_element = true;
				menusurface_changes.element = /*element*/ ctx[2];
				add_flush_callback(() => updating_element = false);
			}

			menusurface.$set(menusurface_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menusurface.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menusurface.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menusurface, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), ["MDCMenu:selected", "MDCMenuSurface:closed", "MDCMenuSurface:opened"]);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { static: isStatic = false } = $$props;
	let { open = isStatic } = $$props; // Purposely omitted from the exclude call above.
	let { quickOpen = false } = $$props; // Purposely omitted from the exclude call above.
	let { anchorCorner = null } = $$props; // Purposely omitted from the exclude call above.
	let { wrapFocus = false } = $$props;
	let element;
	let menu;
	let instantiate = getContext("SMUI:menu:instantiate");
	let getInstance = getContext("SMUI:menu:getInstance");
	let menuSurfacePromiseResolve;
	let menuSurfacePromise = new Promise(resolve => menuSurfacePromiseResolve = resolve);
	let listPromiseResolve;
	let listPromise = new Promise(resolve => listPromiseResolve = resolve);
	setContext("SMUI:menu-surface:instantiate", false);
	setContext("SMUI:menu-surface:getInstance", getMenuSurfaceInstancePromise);
	setContext("SMUI:list:instantiate", false);
	setContext("SMUI:list:getInstance", getListInstancePromise);

	onMount(async () => {
		if (instantiate !== false) {
			$$invalidate(25, menu = new MDCMenu(element));
		} else {
			$$invalidate(25, menu = await getInstance());
		}

		menuSurfacePromiseResolve(menu.menuSurface_);
		listPromiseResolve(menu.list_);
	});

	onDestroy(() => {
		if (instantiate !== false) {
			menu && menu.destroy();
		}
	});

	function getMenuSurfaceInstancePromise() {
		return menuSurfacePromise;
	}

	function getListInstancePromise() {
		return listPromise;
	}

	function updateOpen() {
		$$invalidate(6, open = menu.open);
	}

	function setOpen(value) {
		$$invalidate(6, open = value);
	}

	function getItems() {
		return menu.items;
	}

	function setDefaultFocusState(...args) {
		return menu.setDefaultFocusState(...args);
	}

	function setAnchorCorner(...args) {
		return menu.setAnchorCorner(...args);
	}

	function setAnchorMargin(...args) {
		return menu.setAnchorMargin(...args);
	}

	function setSelectedIndex(...args) {
		return menu.setSelectedIndex(...args);
	}

	function setEnabled(...args) {
		return menu.setEnabled(...args);
	}

	function getOptionByIndex(...args) {
		return menu.getOptionByIndex(...args);
	}

	function setFixedPosition(...args) {
		return menu.setFixedPosition(...args);
	}

	function hoistMenuToBody(...args) {
		return menu.hoistMenuToBody(...args);
	}

	function setIsHoisted(...args) {
		return menu.setIsHoisted(...args);
	}

	function setAbsolutePosition(...args) {
		return menu.setAbsolutePosition(...args);
	}

	function setAnchorElement(...args) {
		return menu.setAnchorElement(...args);
	}

	function getDefaultFoundation(...args) {
		return menu.getDefaultFoundation(...args);
	}

	function menusurface_element_binding(value) {
		element = value;
		$$invalidate(2, element);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("static" in $$new_props) $$invalidate(7, isStatic = $$new_props.static);
		if ("open" in $$new_props) $$invalidate(6, open = $$new_props.open);
		if ("quickOpen" in $$new_props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
		if ("anchorCorner" in $$new_props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
		if ("wrapFocus" in $$new_props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCMenu,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		MenuSurface,
		Corner,
		CornerBit,
		forwardEvents,
		use,
		className,
		isStatic,
		open,
		quickOpen,
		anchorCorner,
		wrapFocus,
		element,
		menu,
		instantiate,
		getInstance,
		menuSurfacePromiseResolve,
		menuSurfacePromise,
		listPromiseResolve,
		listPromise,
		getMenuSurfaceInstancePromise,
		getListInstancePromise,
		updateOpen,
		setOpen,
		getItems,
		setDefaultFocusState,
		setAnchorCorner,
		setAnchorMargin,
		setSelectedIndex,
		setEnabled,
		getOptionByIndex,
		setFixedPosition,
		hoistMenuToBody,
		setIsHoisted,
		setAbsolutePosition,
		setAnchorElement,
		getDefaultFoundation
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("isStatic" in $$props) $$invalidate(7, isStatic = $$new_props.isStatic);
		if ("open" in $$props) $$invalidate(6, open = $$new_props.open);
		if ("quickOpen" in $$props) $$invalidate(8, quickOpen = $$new_props.quickOpen);
		if ("anchorCorner" in $$props) $$invalidate(9, anchorCorner = $$new_props.anchorCorner);
		if ("wrapFocus" in $$props) $$invalidate(10, wrapFocus = $$new_props.wrapFocus);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("menu" in $$props) $$invalidate(25, menu = $$new_props.menu);
		if ("instantiate" in $$props) instantiate = $$new_props.instantiate;
		if ("getInstance" in $$props) getInstance = $$new_props.getInstance;
		if ("menuSurfacePromiseResolve" in $$props) menuSurfacePromiseResolve = $$new_props.menuSurfacePromiseResolve;
		if ("menuSurfacePromise" in $$props) menuSurfacePromise = $$new_props.menuSurfacePromise;
		if ("listPromiseResolve" in $$props) listPromiseResolve = $$new_props.listPromiseResolve;
		if ("listPromise" in $$props) listPromise = $$new_props.listPromise;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*menu, open, isStatic*/ 33554624) {
			 if (menu && menu.open !== open) {
				if (isStatic) {
					$$invalidate(6, open = true);
				}

				$$invalidate(25, menu.open = open, menu);
			}
		}

		if ($$self.$$.dirty[0] & /*menu, wrapFocus*/ 33555456) {
			 if (menu && menu.wrapFocus !== wrapFocus) {
				$$invalidate(25, menu.wrapFocus = wrapFocus, menu);
			}
		}

		if ($$self.$$.dirty[0] & /*menu, quickOpen*/ 33554688) {
			 if (menu) {
				$$invalidate(25, menu.quickOpen = quickOpen, menu);
			}
		}

		if ($$self.$$.dirty[0] & /*menu, anchorCorner*/ 33554944) {
			 if (menu && anchorCorner != null) {
				if (Corner.hasOwnProperty(anchorCorner)) {
					menu.setAnchorCorner(Corner[anchorCorner]);
				} else if (CornerBit.hasOwnProperty(anchorCorner)) {
					menu.setAnchorCorner(Corner[anchorCorner]);
				} else {
					menu.setAnchorCorner(anchorCorner);
				}
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		element,
		forwardEvents,
		updateOpen,
		$$props,
		open,
		isStatic,
		quickOpen,
		anchorCorner,
		wrapFocus,
		setOpen,
		getItems,
		setDefaultFocusState,
		setAnchorCorner,
		setAnchorMargin,
		setSelectedIndex,
		setEnabled,
		getOptionByIndex,
		setFixedPosition,
		hoistMenuToBody,
		setIsHoisted,
		setAbsolutePosition,
		setAnchorElement,
		getDefaultFoundation,
		menu,
		slots,
		menusurface_element_binding,
		$$scope
	];
}

class Menu$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$R,
			create_fragment$R,
			safe_not_equal,
			{
				use: 0,
				class: 1,
				static: 7,
				open: 6,
				quickOpen: 8,
				anchorCorner: 9,
				wrapFocus: 10,
				setOpen: 11,
				getItems: 12,
				setDefaultFocusState: 13,
				setAnchorCorner: 14,
				setAnchorMargin: 15,
				setSelectedIndex: 16,
				setEnabled: 17,
				getOptionByIndex: 18,
				setFixedPosition: 19,
				hoistMenuToBody: 20,
				setIsHoisted: 21,
				setAbsolutePosition: 22,
				setAnchorElement: 23,
				getDefaultFoundation: 24
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment$R.name
		});
	}

	get use() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get static() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set static(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get quickOpen() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set quickOpen(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get anchorCorner() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set anchorCorner(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrapFocus() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrapFocus(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setOpen() {
		return this.$$.ctx[11];
	}

	set setOpen(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getItems() {
		return this.$$.ctx[12];
	}

	set getItems(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setDefaultFocusState() {
		return this.$$.ctx[13];
	}

	set setDefaultFocusState(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAnchorCorner() {
		return this.$$.ctx[14];
	}

	set setAnchorCorner(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAnchorMargin() {
		return this.$$.ctx[15];
	}

	set setAnchorMargin(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setSelectedIndex() {
		return this.$$.ctx[16];
	}

	set setSelectedIndex(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setEnabled() {
		return this.$$.ctx[17];
	}

	set setEnabled(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getOptionByIndex() {
		return this.$$.ctx[18];
	}

	set getOptionByIndex(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setFixedPosition() {
		return this.$$.ctx[19];
	}

	set setFixedPosition(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hoistMenuToBody() {
		return this.$$.ctx[20];
	}

	set hoistMenuToBody(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setIsHoisted() {
		return this.$$.ctx[21];
	}

	set setIsHoisted(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAbsolutePosition() {
		return this.$$.ctx[22];
	}

	set setAbsolutePosition(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setAnchorElement() {
		return this.$$.ctx[23];
	}

	set setAnchorElement(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getDefaultFoundation() {
		return this.$$.ctx[24];
	}

	set getDefaultFoundation(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\select\Select.svelte generated by Svelte v3.31.2 */
const file$M = "node_modules\\@smui\\select\\Select.svelte";
const get_label_slot_changes_1$1 = dirty => ({});
const get_label_slot_context_1$1 = ctx => ({});
const get_label_slot_changes$2 = dirty => ({});
const get_label_slot_context$2 = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (50:2) {:else}
function create_else_block$7(ctx) {
	let select_1;
	let select_1_class_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[29].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[40], null);

	let select_1_levels = [
		{
			class: select_1_class_value = "mdc-select__native-control " + /*input$class*/ ctx[15]
		},
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[12] },
		{ id: /*inputId*/ ctx[13] },
		exclude(prefixFilter(/*$$props*/ ctx[22], "input$"), ["use", "class"])
	];

	let select_1_data = {};

	for (let i = 0; i < select_1_levels.length; i += 1) {
		select_1_data = assign(select_1_data, select_1_levels[i]);
	}

	const block = {
		c: function create() {
			select_1 = element("select");
			if (default_slot) default_slot.c();
			set_attributes(select_1, select_1_data);
			add_location(select_1, file$M, 50, 4, 1663);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select_1, anchor);

			if (default_slot) {
				default_slot.m(select_1, null);
			}

			if (select_1_data.multiple) select_options(select_1, select_1_data.value);
			/*select_1_binding*/ ctx[38](select_1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, select_1, /*input$use*/ ctx[14])),
					listen_dev(select_1, "blur", /*blur_handler_1*/ ctx[33], false, false, false),
					listen_dev(select_1, "change", /*change_handler_1*/ ctx[34], false, false, false),
					listen_dev(select_1, "input", /*input_handler_1*/ ctx[35], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[40], dirty, null, null);
				}
			}

			set_attributes(select_1, select_1_data = get_spread_update(select_1_levels, [
				(!current || dirty[0] & /*input$class*/ 32768 && select_1_class_value !== (select_1_class_value = "mdc-select__native-control " + /*input$class*/ ctx[15])) && { class: select_1_class_value },
				(!current || dirty[0] & /*disabled*/ 32) && { disabled: /*disabled*/ ctx[5] },
				(!current || dirty[0] & /*required*/ 4096) && { required: /*required*/ ctx[12] },
				(!current || dirty[0] & /*inputId*/ 8192) && { id: /*inputId*/ ctx[13] },
				dirty[0] & /*$$props*/ 4194304 && exclude(prefixFilter(/*$$props*/ ctx[22], "input$"), ["use", "class"])
			]));

			if (dirty[0] & /*input$class, disabled, required, inputId, $$props*/ 4239392 && select_1_data.multiple) select_options(select_1, select_1_data.value);
			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 16384) useActions_action.update.call(null, /*input$use*/ ctx[14]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select_1);
			if (default_slot) default_slot.d(detaching);
			/*select_1_binding*/ ctx[38](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(50:2) {:else}",
		ctx
	});

	return block;
}

// (19:2) {#if enhanced}
function create_if_block_5$2(ctx) {
	let input;
	let useActions_action;
	let t0;
	let div;
	let t1;
	let div_id_value;
	let div_aria_labelledby_value;
	let div_aria_required_value;
	let t2;
	let menu;
	let updating_anchorElement;
	let current;
	let mounted;
	let dispose;

	let input_levels = [
		{ id: /*inputId*/ ctx[13] },
		exclude(prefixFilter(/*$$props*/ ctx[22], "input$"), ["use"]),
		{ type: "hidden" },
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[12] },
		{ value: /*value*/ ctx[0] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const menu_spread_levels = [
		{
			class: "mdc-select__menu " + /*menu$class*/ ctx[17]
		},
		{ role: "listbox" },
		{ anchor: false },
		exclude(prefixFilter(/*$$props*/ ctx[22], "menu$"), ["class"])
	];

	function menu_anchorElement_binding(value) {
		/*menu_anchorElement_binding*/ ctx[37].call(null, value);
	}

	let menu_props = {
		$$slots: { default: [create_default_slot_3$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < menu_spread_levels.length; i += 1) {
		menu_props = assign(menu_props, menu_spread_levels[i]);
	}

	if (/*element*/ ctx[18] !== void 0) {
		menu_props.anchorElement = /*element*/ ctx[18];
	}

	menu = new Menu$1({ props: menu_props, $$inline: true });
	binding_callbacks.push(() => bind(menu, "anchorElement", menu_anchorElement_binding));

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			div = element("div");
			t1 = text(/*selectedText*/ ctx[11]);
			t2 = space();
			create_component(menu.$$.fragment);
			set_attributes(input, input_data);
			add_location(input, file$M, 19, 4, 794);
			attr_dev(div, "id", div_id_value = /*inputId*/ ctx[13] + "-smui-selected-text");
			attr_dev(div, "class", "mdc-select__selected-text");
			attr_dev(div, "role", "button");
			attr_dev(div, "aria-haspopup", "listbox");
			attr_dev(div, "aria-labelledby", div_aria_labelledby_value = "" + (/*inputId*/ ctx[13] + "-smui-label" + " " + (/*inputId*/ ctx[13] + "-smui-selected-text")));
			attr_dev(div, "aria-required", div_aria_required_value = /*required*/ ctx[12] ? "true" : "false");
			add_location(div, file$M, 32, 4, 1075);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			/*input_binding*/ ctx[36](input);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, t1);
			insert_dev(target, t2, anchor);
			mount_component(menu, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, input, /*input$use*/ ctx[14])),
					listen_dev(input, "blur", /*blur_handler*/ ctx[30], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[31], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[32], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				(!current || dirty[0] & /*inputId*/ 8192) && { id: /*inputId*/ ctx[13] },
				dirty[0] & /*$$props*/ 4194304 && exclude(prefixFilter(/*$$props*/ ctx[22], "input$"), ["use"]),
				{ type: "hidden" },
				(!current || dirty[0] & /*disabled*/ 32) && { disabled: /*disabled*/ ctx[5] },
				(!current || dirty[0] & /*required*/ 4096) && { required: /*required*/ ctx[12] },
				(!current || dirty[0] & /*value*/ 1) && { value: /*value*/ ctx[0] }
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/ 16384) useActions_action.update.call(null, /*input$use*/ ctx[14]);
			if (!current || dirty[0] & /*selectedText*/ 2048) set_data_dev(t1, /*selectedText*/ ctx[11]);

			if (!current || dirty[0] & /*inputId*/ 8192 && div_id_value !== (div_id_value = /*inputId*/ ctx[13] + "-smui-selected-text")) {
				attr_dev(div, "id", div_id_value);
			}

			if (!current || dirty[0] & /*inputId*/ 8192 && div_aria_labelledby_value !== (div_aria_labelledby_value = "" + (/*inputId*/ ctx[13] + "-smui-label" + " " + (/*inputId*/ ctx[13] + "-smui-selected-text")))) {
				attr_dev(div, "aria-labelledby", div_aria_labelledby_value);
			}

			if (!current || dirty[0] & /*required*/ 4096 && div_aria_required_value !== (div_aria_required_value = /*required*/ ctx[12] ? "true" : "false")) {
				attr_dev(div, "aria-required", div_aria_required_value);
			}

			const menu_changes = (dirty[0] & /*menu$class, $$props*/ 4325376)
			? get_spread_update(menu_spread_levels, [
					dirty[0] & /*menu$class*/ 131072 && {
						class: "mdc-select__menu " + /*menu$class*/ ctx[17]
					},
					menu_spread_levels[1],
					menu_spread_levels[2],
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], "menu$"), ["class"]))
				])
			: {};

			if (dirty[0] & /*$$props*/ 4194304 | dirty[1] & /*$$scope*/ 512) {
				menu_changes.$$scope = { dirty, ctx };
			}

			if (!updating_anchorElement && dirty[0] & /*element*/ 262144) {
				updating_anchorElement = true;
				menu_changes.anchorElement = /*element*/ ctx[18];
				add_flush_callback(() => updating_anchorElement = false);
			}

			menu.$set(menu_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[36](null);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t2);
			destroy_component(menu, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$2.name,
		type: "if",
		source: "(19:2) {#if enhanced}",
		ctx
	});

	return block;
}

// (48:6) <List {...prefixFilter($$props, 'list$')}>
function create_default_slot_4$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[29].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[40], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[40], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$4.name,
		type: "slot",
		source: "(48:6) <List {...prefixFilter($$props, 'list$')}>",
		ctx
	});

	return block;
}

// (41:4) <Menu       class="mdc-select__menu {menu$class}"       role="listbox"       anchor={false}       bind:anchorElement={element}       {...exclude(prefixFilter($$props, 'menu$'), ['class'])}     >
function create_default_slot_3$4(ctx) {
	let list;
	let current;
	const list_spread_levels = [prefixFilter(/*$$props*/ ctx[22], "list$")];

	let list_props = {
		$$slots: { default: [create_default_slot_4$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < list_spread_levels.length; i += 1) {
		list_props = assign(list_props, list_spread_levels[i]);
	}

	list = new List({ props: list_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = (dirty[0] & /*$$props*/ 4194304)
			? get_spread_update(list_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], "list$"))])
			: {};

			if (dirty[1] & /*$$scope*/ 512) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(41:4) <Menu       class=\\\"mdc-select__menu {menu$class}\\\"       role=\\\"listbox\\\"       anchor={false}       bind:anchorElement={element}       {...exclude(prefixFilter($$props, 'menu$'), ['class'])}     >",
		ctx
	});

	return block;
}

// (64:2) {#if variant !== 'outlined'}
function create_if_block_2$4(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = !/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null && create_if_block_4$2(ctx);
	let if_block1 = /*ripple*/ ctx[4] && create_if_block_3$3(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*noLabel, label*/ 1536) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*ripple*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*ripple*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(64:2) {#if variant !== 'outlined'}",
		ctx
	});

	return block;
}

// (65:4) {#if !noLabel && label != null}
function create_if_block_4$2(ctx) {
	let floatinglabel;
	let current;

	const floatinglabel_spread_levels = [
		{ for: /*inputId*/ ctx[13] },
		{ id: /*inputId*/ ctx[13] + "-smui-label" },
		{
			class: "" + ((/*value*/ ctx[0] !== ""
			? "mdc-floating-label--float-above"
			: "") + " " + /*label$class*/ ctx[16])
		},
		exclude(prefixFilter(/*$$props*/ ctx[22], "label$"), ["class"])
	];

	let floatinglabel_props = {
		$$slots: { default: [create_default_slot_2$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
	}

	floatinglabel = new FloatingLabel({
			props: floatinglabel_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(floatinglabel.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(floatinglabel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const floatinglabel_changes = (dirty[0] & /*inputId, value, label$class, $$props*/ 4268033)
			? get_spread_update(floatinglabel_spread_levels, [
					dirty[0] & /*inputId*/ 8192 && { for: /*inputId*/ ctx[13] },
					dirty[0] & /*inputId*/ 8192 && { id: /*inputId*/ ctx[13] + "-smui-label" },
					dirty[0] & /*value, label$class*/ 65537 && {
						class: "" + ((/*value*/ ctx[0] !== ""
						? "mdc-floating-label--float-above"
						: "") + " " + /*label$class*/ ctx[16])
					},
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], "label$"), ["class"]))
				])
			: {};

			if (dirty[0] & /*label*/ 1024 | dirty[1] & /*$$scope*/ 512) {
				floatinglabel_changes.$$scope = { dirty, ctx };
			}

			floatinglabel.$set(floatinglabel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(floatinglabel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(floatinglabel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(floatinglabel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(65:4) {#if !noLabel && label != null}",
		ctx
	});

	return block;
}

// (66:6) <FloatingLabel         for={inputId}         id={inputId+'-smui-label'}         class="{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}"         {...exclude(prefixFilter($$props, 'label$'), ['class'])}       >
function create_default_slot_2$8(ctx) {
	let t;
	let current;
	const label_slot_template = /*#slots*/ ctx[29].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[40], get_label_slot_context$2);

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[10]);
			if (label_slot) label_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);

			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*label*/ 1024) set_data_dev(t, /*label*/ ctx[10]);

			if (label_slot) {
				if (label_slot.p && dirty[1] & /*$$scope*/ 512) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_label_slot_changes$2, get_label_slot_context$2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$8.name,
		type: "slot",
		source: "(66:6) <FloatingLabel         for={inputId}         id={inputId+'-smui-label'}         class=\\\"{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}\\\"         {...exclude(prefixFilter($$props, 'label$'), ['class'])}       >",
		ctx
	});

	return block;
}

// (73:4) {#if ripple}
function create_if_block_3$3(ctx) {
	let lineripple;
	let current;
	const lineripple_spread_levels = [prefixFilter(/*$$props*/ ctx[22], "ripple$")];
	let lineripple_props = {};

	for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
		lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
	}

	lineripple = new LineRipple({ props: lineripple_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(lineripple.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(lineripple, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const lineripple_changes = (dirty[0] & /*$$props*/ 4194304)
			? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(/*$$props*/ ctx[22], "ripple$"))])
			: {};

			lineripple.$set(lineripple_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(lineripple.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(lineripple.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(lineripple, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(73:4) {#if ripple}",
		ctx
	});

	return block;
}

// (77:2) {#if variant === 'outlined'}
function create_if_block$d(ctx) {
	let notchedoutline;
	let current;

	const notchedoutline_spread_levels = [
		{
			noLabel: /*noLabel*/ ctx[9] || /*label*/ ctx[10] == null
		},
		prefixFilter(/*$$props*/ ctx[22], "outline$")
	];

	let notchedoutline_props = {
		$$slots: { default: [create_default_slot$g] },
		$$scope: { ctx }
	};

	for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
		notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
	}

	notchedoutline = new NotchedOutline({
			props: notchedoutline_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(notchedoutline.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(notchedoutline, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const notchedoutline_changes = (dirty[0] & /*noLabel, label, $$props*/ 4195840)
			? get_spread_update(notchedoutline_spread_levels, [
					dirty[0] & /*noLabel, label*/ 1536 && {
						noLabel: /*noLabel*/ ctx[9] || /*label*/ ctx[10] == null
					},
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(prefixFilter(/*$$props*/ ctx[22], "outline$"))
				])
			: {};

			if (dirty[0] & /*inputId, value, label$class, $$props, label, noLabel*/ 4269569 | dirty[1] & /*$$scope*/ 512) {
				notchedoutline_changes.$$scope = { dirty, ctx };
			}

			notchedoutline.$set(notchedoutline_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(notchedoutline.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(notchedoutline.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(notchedoutline, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(77:2) {#if variant === 'outlined'}",
		ctx
	});

	return block;
}

// (79:6) {#if !noLabel && label != null}
function create_if_block_1$6(ctx) {
	let floatinglabel;
	let current;

	const floatinglabel_spread_levels = [
		{ for: /*inputId*/ ctx[13] },
		{
			class: "" + ((/*value*/ ctx[0] !== ""
			? "mdc-floating-label--float-above"
			: "") + " " + /*label$class*/ ctx[16])
		},
		exclude(prefixFilter(/*$$props*/ ctx[22], "label$"), ["class"])
	];

	let floatinglabel_props = {
		$$slots: { default: [create_default_slot_1$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
		floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
	}

	floatinglabel = new FloatingLabel({
			props: floatinglabel_props,
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(floatinglabel.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(floatinglabel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const floatinglabel_changes = (dirty[0] & /*inputId, value, label$class, $$props*/ 4268033)
			? get_spread_update(floatinglabel_spread_levels, [
					dirty[0] & /*inputId*/ 8192 && { for: /*inputId*/ ctx[13] },
					dirty[0] & /*value, label$class*/ 65537 && {
						class: "" + ((/*value*/ ctx[0] !== ""
						? "mdc-floating-label--float-above"
						: "") + " " + /*label$class*/ ctx[16])
					},
					dirty[0] & /*$$props*/ 4194304 && get_spread_object(exclude(prefixFilter(/*$$props*/ ctx[22], "label$"), ["class"]))
				])
			: {};

			if (dirty[0] & /*label*/ 1024 | dirty[1] & /*$$scope*/ 512) {
				floatinglabel_changes.$$scope = { dirty, ctx };
			}

			floatinglabel.$set(floatinglabel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(floatinglabel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(floatinglabel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(floatinglabel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(79:6) {#if !noLabel && label != null}",
		ctx
	});

	return block;
}

// (80:8) <FloatingLabel           for={inputId}           class="{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}"           {...exclude(prefixFilter($$props, 'label$'), ['class'])}         >
function create_default_slot_1$8(ctx) {
	let t;
	let current;
	const label_slot_template = /*#slots*/ ctx[29].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[40], get_label_slot_context_1$1);

	const block = {
		c: function create() {
			t = text(/*label*/ ctx[10]);
			if (label_slot) label_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);

			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*label*/ 1024) set_data_dev(t, /*label*/ ctx[10]);

			if (label_slot) {
				if (label_slot.p && dirty[1] & /*$$scope*/ 512) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_label_slot_changes_1$1, get_label_slot_context_1$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$8.name,
		type: "slot",
		source: "(80:8) <FloatingLabel           for={inputId}           class=\\\"{value !== '' ? 'mdc-floating-label--float-above' : ''} {label$class}\\\"           {...exclude(prefixFilter($$props, 'label$'), ['class'])}         >",
		ctx
	});

	return block;
}

// (78:4) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>
function create_default_slot$g(ctx) {
	let if_block_anchor;
	let current;
	let if_block = !/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!/*noLabel*/ ctx[9] && /*label*/ ctx[10] != null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*noLabel, label*/ 1536) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$g.name,
		type: "slot",
		source: "(78:4) <NotchedOutline noLabel={noLabel || label == null} {...prefixFilter($$props, 'outline$')}>",
		ctx
	});

	return block;
}

function create_fragment$S(ctx) {
	let div;
	let t0;
	let i;
	let t1;
	let current_block_type_index;
	let if_block0;
	let t2;
	let t3;
	let div_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[29].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[40], get_icon_slot_context);
	const if_block_creators = [create_if_block_5$2, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*enhanced*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*variant*/ ctx[7] !== "outlined" && create_if_block_2$4(ctx);
	let if_block2 = /*variant*/ ctx[7] === "outlined" && create_if_block$d(ctx);

	let div_levels = [
		{
			class: div_class_value = "\n    mdc-select\n    " + /*className*/ ctx[3] + "\n    " + (/*disabled*/ ctx[5] ? "mdc-select--disabled" : "") + "\n    " + (/*variant*/ ctx[7] === "outlined"
			? "mdc-select--outlined"
			: "") + "\n    " + (/*variant*/ ctx[7] === "standard"
			? "smui-select--standard"
			: "") + "\n    " + (/*withLeadingIcon*/ ctx[8]
			? "mdc-select--with-leading-icon"
			: "") + "\n    " + (/*invalid*/ ctx[1] ? "mdc-select--invalid" : "") + "\n  "
		},
		exclude(/*$$props*/ ctx[22], [
			"use",
			"class",
			"ripple",
			"disabled",
			"enhanced",
			"variant",
			"noLabel",
			"withLeadingIcon",
			"label",
			"value",
			"selectedIndex",
			"selectedText",
			"dirty",
			"invalid",
			"updateInvalid",
			"required",
			"input$",
			"label$",
			"ripple$",
			"outline$",
			"menu$",
			"list$"
		])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (icon_slot) icon_slot.c();
			t0 = space();
			i = element("i");
			t1 = space();
			if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			attr_dev(i, "class", "mdc-select__dropdown-icon");
			add_location(i, file$M, 17, 2, 731);
			set_attributes(div, div_data);
			add_location(div, file$M, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (icon_slot) {
				icon_slot.m(div, null);
			}

			append_dev(div, t0);
			append_dev(div, i);
			append_dev(div, t1);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			/*div_binding*/ ctx[39](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[2])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[20].call(null, div)),
					listen_dev(div, "MDCSelect:change", /*changeHandler*/ ctx[21], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && dirty[1] & /*$$scope*/ 512) {
					update_slot(icon_slot, icon_slot_template, ctx, /*$$scope*/ ctx[40], dirty, get_icon_slot_changes, get_icon_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t2);
			}

			if (/*variant*/ ctx[7] !== "outlined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*variant*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*variant*/ ctx[7] === "outlined") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*variant*/ 128) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$d(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*className, disabled, variant, withLeadingIcon, invalid*/ 426 && div_class_value !== (div_class_value = "\n    mdc-select\n    " + /*className*/ ctx[3] + "\n    " + (/*disabled*/ ctx[5] ? "mdc-select--disabled" : "") + "\n    " + (/*variant*/ ctx[7] === "outlined"
				? "mdc-select--outlined"
				: "") + "\n    " + (/*variant*/ ctx[7] === "standard"
				? "smui-select--standard"
				: "") + "\n    " + (/*withLeadingIcon*/ ctx[8]
				? "mdc-select--with-leading-icon"
				: "") + "\n    " + (/*invalid*/ ctx[1] ? "mdc-select--invalid" : "") + "\n  ")) && { class: div_class_value },
				dirty[0] & /*$$props*/ 4194304 && exclude(/*$$props*/ ctx[22], [
					"use",
					"class",
					"ripple",
					"disabled",
					"enhanced",
					"variant",
					"noLabel",
					"withLeadingIcon",
					"label",
					"value",
					"selectedIndex",
					"selectedText",
					"dirty",
					"invalid",
					"updateInvalid",
					"required",
					"input$",
					"label$",
					"ripple$",
					"outline$",
					"menu$",
					"list$"
				])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (icon_slot) icon_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div_binding*/ ctx[39](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let counter$2 = 0;

function instance$S($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Select", slots, ['icon','default','label']);
	const forwardEvents = forwardEventsBuilder(get_current_component(), "MDCSelect:change");

	const uninitializedValue = () => {
		
	};

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { ripple = true } = $$props;
	let { disabled = false } = $$props;
	let { enhanced = false } = $$props;
	let { variant = "standard" } = $$props;
	let { withLeadingIcon = false } = $$props;
	let { noLabel = false } = $$props;
	let { label = null } = $$props;
	let { value = "" } = $$props;
	let { selectedIndex = uninitializedValue } = $$props;
	let { selectedText = "" } = $$props;
	let { dirty = false } = $$props;
	let { invalid = uninitializedValue } = $$props;
	let { updateInvalid = invalid === uninitializedValue } = $$props;
	let { required = false } = $$props;
	let { inputId = "SMUI-select-" + counter$2++ } = $$props;
	let { input$use = [] } = $$props;
	let { input$class = "" } = $$props;
	let { label$class = "" } = $$props;
	let { menu$class = "" } = $$props;
	let element;
	let select;
	let inputElement;
	let menuPromiseResolve;
	let menuPromise = new Promise(resolve => menuPromiseResolve = resolve);
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;
	setContext("SMUI:menu:instantiate", false);
	setContext("SMUI:menu:getInstance", getMenuInstancePromise);
	setContext("SMUI:list:role", "listbox");
	setContext("SMUI:select:option:enhanced", enhanced);

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	onMount(async () => {
		$$invalidate(28, select = new MDCSelect(element));
		menuPromiseResolve(select.menu_);

		if (!ripple && select.ripple) {
			select.ripple.destroy();
		}

		if (updateInvalid) {
			$$invalidate(1, invalid = inputElement.matches(":invalid"));
		}
	});

	onDestroy(() => {
		select && select.destroy();

		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function getMenuInstancePromise() {
		return menuPromise;
	}

	function changeHandler(e) {
		$$invalidate(0, value = e.detail.value);
		$$invalidate(23, selectedIndex = e.detail.index);
		$$invalidate(24, dirty = true);

		if (updateInvalid) {
			$$invalidate(1, invalid = inputElement.matches(":invalid"));
		}
	}

	function focus(...args) {
		return inputElement.focus(...args);
	}

	function layout(...args) {
		return select.layout(...args);
	}

	function blur_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_handler(event) {
		bubble($$self, event);
	}

	function blur_handler_1(event) {
		bubble($$self, event);
	}

	function change_handler_1(event) {
		bubble($$self, event);
	}

	function input_handler_1(event) {
		bubble($$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputElement = $$value;
			$$invalidate(19, inputElement);
		});
	}

	function menu_anchorElement_binding(value) {
		element = value;
		$$invalidate(18, element);
	}

	function select_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputElement = $$value;
			$$invalidate(19, inputElement);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(18, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(2, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("ripple" in $$new_props) $$invalidate(4, ripple = $$new_props.ripple);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("enhanced" in $$new_props) $$invalidate(6, enhanced = $$new_props.enhanced);
		if ("variant" in $$new_props) $$invalidate(7, variant = $$new_props.variant);
		if ("withLeadingIcon" in $$new_props) $$invalidate(8, withLeadingIcon = $$new_props.withLeadingIcon);
		if ("noLabel" in $$new_props) $$invalidate(9, noLabel = $$new_props.noLabel);
		if ("label" in $$new_props) $$invalidate(10, label = $$new_props.label);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("selectedIndex" in $$new_props) $$invalidate(23, selectedIndex = $$new_props.selectedIndex);
		if ("selectedText" in $$new_props) $$invalidate(11, selectedText = $$new_props.selectedText);
		if ("dirty" in $$new_props) $$invalidate(24, dirty = $$new_props.dirty);
		if ("invalid" in $$new_props) $$invalidate(1, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$new_props) $$invalidate(25, updateInvalid = $$new_props.updateInvalid);
		if ("required" in $$new_props) $$invalidate(12, required = $$new_props.required);
		if ("inputId" in $$new_props) $$invalidate(13, inputId = $$new_props.inputId);
		if ("input$use" in $$new_props) $$invalidate(14, input$use = $$new_props.input$use);
		if ("input$class" in $$new_props) $$invalidate(15, input$class = $$new_props.input$class);
		if ("label$class" in $$new_props) $$invalidate(16, label$class = $$new_props.label$class);
		if ("menu$class" in $$new_props) $$invalidate(17, menu$class = $$new_props.menu$class);
		if ("$$scope" in $$new_props) $$invalidate(40, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		counter: counter$2,
		MDCSelect,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		Menu: Menu$1,
		List,
		FloatingLabel,
		LineRipple,
		NotchedOutline,
		forwardEvents,
		uninitializedValue,
		use,
		className,
		ripple,
		disabled,
		enhanced,
		variant,
		withLeadingIcon,
		noLabel,
		label,
		value,
		selectedIndex,
		selectedText,
		dirty,
		invalid,
		updateInvalid,
		required,
		inputId,
		input$use,
		input$class,
		label$class,
		menu$class,
		element,
		select,
		inputElement,
		menuPromiseResolve,
		menuPromise,
		addLayoutListener,
		removeLayoutListener,
		getMenuInstancePromise,
		changeHandler,
		focus,
		layout
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(2, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("ripple" in $$props) $$invalidate(4, ripple = $$new_props.ripple);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("enhanced" in $$props) $$invalidate(6, enhanced = $$new_props.enhanced);
		if ("variant" in $$props) $$invalidate(7, variant = $$new_props.variant);
		if ("withLeadingIcon" in $$props) $$invalidate(8, withLeadingIcon = $$new_props.withLeadingIcon);
		if ("noLabel" in $$props) $$invalidate(9, noLabel = $$new_props.noLabel);
		if ("label" in $$props) $$invalidate(10, label = $$new_props.label);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("selectedIndex" in $$props) $$invalidate(23, selectedIndex = $$new_props.selectedIndex);
		if ("selectedText" in $$props) $$invalidate(11, selectedText = $$new_props.selectedText);
		if ("dirty" in $$props) $$invalidate(24, dirty = $$new_props.dirty);
		if ("invalid" in $$props) $$invalidate(1, invalid = $$new_props.invalid);
		if ("updateInvalid" in $$props) $$invalidate(25, updateInvalid = $$new_props.updateInvalid);
		if ("required" in $$props) $$invalidate(12, required = $$new_props.required);
		if ("inputId" in $$props) $$invalidate(13, inputId = $$new_props.inputId);
		if ("input$use" in $$props) $$invalidate(14, input$use = $$new_props.input$use);
		if ("input$class" in $$props) $$invalidate(15, input$class = $$new_props.input$class);
		if ("label$class" in $$props) $$invalidate(16, label$class = $$new_props.label$class);
		if ("menu$class" in $$props) $$invalidate(17, menu$class = $$new_props.menu$class);
		if ("element" in $$props) $$invalidate(18, element = $$new_props.element);
		if ("select" in $$props) $$invalidate(28, select = $$new_props.select);
		if ("inputElement" in $$props) $$invalidate(19, inputElement = $$new_props.inputElement);
		if ("menuPromiseResolve" in $$props) menuPromiseResolve = $$new_props.menuPromiseResolve;
		if ("menuPromise" in $$props) menuPromise = $$new_props.menuPromise;
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*select, value*/ 268435457) {
			 if (select && select.value !== value) {
				$$invalidate(28, select.value = value, select);
			}
		}

		if ($$self.$$.dirty[0] & /*select, selectedIndex*/ 276824064) {
			 if (select && select.selectedIndex !== selectedIndex) {
				if (selectedIndex === uninitializedValue) {
					$$invalidate(23, selectedIndex = select.selectedIndex);
				} else {
					$$invalidate(28, select.selectedIndex = selectedIndex, select);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*select, disabled*/ 268435488) {
			 if (select && select.disabled !== disabled) {
				$$invalidate(28, select.disabled = disabled, select);
			}
		}

		if ($$self.$$.dirty[0] & /*select, invalid, updateInvalid*/ 301989890) {
			 if (select && select.valid !== !invalid) {
				if (updateInvalid) {
					$$invalidate(1, invalid = !select.valid);
				} else {
					$$invalidate(28, select.valid = !invalid, select);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*select, required*/ 268439552) {
			 if (select && select.required !== required) {
				$$invalidate(28, select.required = required, select);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		invalid,
		use,
		className,
		ripple,
		disabled,
		enhanced,
		variant,
		withLeadingIcon,
		noLabel,
		label,
		selectedText,
		required,
		inputId,
		input$use,
		input$class,
		label$class,
		menu$class,
		element,
		inputElement,
		forwardEvents,
		changeHandler,
		$$props,
		selectedIndex,
		dirty,
		updateInvalid,
		focus,
		layout,
		select,
		slots,
		blur_handler,
		change_handler,
		input_handler,
		blur_handler_1,
		change_handler_1,
		input_handler_1,
		input_binding,
		menu_anchorElement_binding,
		select_1_binding,
		div_binding,
		$$scope
	];
}

class Select extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$S,
			create_fragment$S,
			safe_not_equal,
			{
				use: 2,
				class: 3,
				ripple: 4,
				disabled: 5,
				enhanced: 6,
				variant: 7,
				withLeadingIcon: 8,
				noLabel: 9,
				label: 10,
				value: 0,
				selectedIndex: 23,
				selectedText: 11,
				dirty: 24,
				invalid: 1,
				updateInvalid: 25,
				required: 12,
				inputId: 13,
				input$use: 14,
				input$class: 15,
				label$class: 16,
				menu$class: 17,
				focus: 26,
				layout: 27
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Select",
			options,
			id: create_fragment$S.name
		});
	}

	get use() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get enhanced() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set enhanced(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variant() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withLeadingIcon() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withLeadingIcon(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noLabel() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noLabel(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedIndex() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedIndex(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedText() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedText(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dirty() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dirty(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateInvalid() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateInvalid(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$use() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$use(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input$class() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input$class(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label$class() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label$class(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get menu$class() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set menu$class(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx[26];
	}

	set focus(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[27];
	}

	set layout(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\select\Option.svelte generated by Svelte v3.31.2 */
const file$N = "node_modules\\@smui\\select\\Option.svelte";

// (8:0) {:else}
function create_else_block$8(ctx) {
	let option;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let option_levels = [{ __value: /*value*/ ctx[1] }, /*selectedProp*/ ctx[4], /*props*/ ctx[3]];
	let option_data = {};

	for (let i = 0; i < option_levels.length; i += 1) {
		option_data = assign(option_data, option_levels[i]);
	}

	const block = {
		c: function create() {
			option = element("option");
			if (default_slot) default_slot.c();
			set_attributes(option, option_data);
			add_location(option, file$N, 8, 2, 144);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);

			if (default_slot) {
				default_slot.m(option, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, option, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, option))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(option, option_data = get_spread_update(option_levels, [
				(!current || dirty & /*value*/ 2) && { __value: /*value*/ ctx[1] },
				dirty & /*selectedProp*/ 16 && /*selectedProp*/ ctx[4],
				dirty & /*props*/ 8 && /*props*/ ctx[3]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(8:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if enhanced}
function create_if_block$e(ctx) {
	let item;
	let current;

	const item_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
		},
		{ "data-value": /*value*/ ctx[1] },
		{ selected: /*selected*/ ctx[2] },
		/*props*/ ctx[3]
	];

	let item_props = {
		$$slots: { default: [create_default_slot$h] },
		$$scope: { ctx }
	};

	for (let i = 0; i < item_spread_levels.length; i += 1) {
		item_props = assign(item_props, item_spread_levels[i]);
	}

	item = new Item({ props: item_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = (dirty & /*forwardEvents, use, value, selected, props*/ 47)
			? get_spread_update(item_spread_levels, [
					dirty & /*forwardEvents, use*/ 33 && {
						use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
					},
					dirty & /*value*/ 2 && { "data-value": /*value*/ ctx[1] },
					dirty & /*selected*/ 4 && { selected: /*selected*/ ctx[2] },
					dirty & /*props*/ 8 && get_spread_object(/*props*/ ctx[3])
				])
			: {};

			if (dirty & /*$$scope*/ 512) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(1:0) {#if enhanced}",
		ctx
	});

	return block;
}

// (2:2) <Item     use={[forwardEvents, ...use]}     data-value={value}     {selected}     {...props}   >
function create_default_slot$h(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$h.name,
		type: "slot",
		source: "(2:2) <Item     use={[forwardEvents, ...use]}     data-value={value}     {selected}     {...props}   >",
		ctx
	});

	return block;
}

function create_fragment$T(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$e, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*enhanced*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$T($$self, $$props, $$invalidate) {
	let props;
	let selectedProp;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Option", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	const className = "";
	let { value = "" } = $$props;
	let { selected = false } = $$props;
	let element;
	let enhanced = getContext("SMUI:select:option:enhanced");
	setContext("SMUI:list:item:role", "option");

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ("selected" in $$new_props) $$invalidate(2, selected = $$new_props.selected);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		Item,
		forwardEvents,
		use,
		className,
		value,
		selected,
		element,
		enhanced,
		props,
		selectedProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
		if ("selected" in $$props) $$invalidate(2, selected = $$new_props.selected);
		if ("element" in $$props) element = $$new_props.element;
		if ("enhanced" in $$props) $$invalidate(6, enhanced = $$new_props.enhanced);
		if ("props" in $$props) $$invalidate(3, props = $$new_props.props);
		if ("selectedProp" in $$props) $$invalidate(4, selectedProp = $$new_props.selectedProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, props = exclude($$props, ["use", "value", "selected"]));

		if ($$self.$$.dirty & /*selected*/ 4) {
			 $$invalidate(4, selectedProp = !enhanced && selected ? { selected: true } : {});
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		value,
		selected,
		props,
		selectedProp,
		forwardEvents,
		enhanced,
		className,
		slots,
		$$scope
	];
}

class Option extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$T, create_fragment$T, safe_not_equal, { use: 0, class: 7, value: 1, selected: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Option",
			options,
			id: create_fragment$T.name
		});
	}

	get use() {
		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		return this.$$.ctx[7];
	}

	set class(value) {
		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Editor.svelte generated by Svelte v3.31.2 */
const file$O = "src\\components\\Editor.svelte";

function create_fragment$U(ctx) {
	let div2;
	let div0;
	let span0;
	let select0;
	let t0;
	let select1;
	let t1;
	let span1;
	let button0;
	let t2;
	let button1;
	let t3;
	let button2;
	let t4;
	let button3;
	let t5;
	let span2;
	let select2;
	let t6;
	let select3;
	let t7;
	let span3;
	let button4;
	let t8;
	let button5;
	let t9;
	let span4;
	let button6;
	let t10;
	let button7;
	let t11;
	let button8;
	let t12;
	let button9;
	let t13;
	let span5;
	let button10;
	let t14;
	let button11;
	let t15;
	let button12;
	let t16;
	let button13;
	let t17;
	let span6;
	let button14;
	let t18;
	let select4;
	let t19;
	let span7;
	let button15;
	let t20;
	let button16;
	let t21;
	let button17;
	let t22;
	let button18;
	let t23;
	let span8;
	let button19;
	let div0_id_value;
	let t24;
	let div1;
	let div1_id_value;
	let div2_id_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			span0 = element("span");
			select0 = element("select");
			t0 = space();
			select1 = element("select");
			t1 = space();
			span1 = element("span");
			button0 = element("button");
			t2 = space();
			button1 = element("button");
			t3 = space();
			button2 = element("button");
			t4 = space();
			button3 = element("button");
			t5 = space();
			span2 = element("span");
			select2 = element("select");
			t6 = space();
			select3 = element("select");
			t7 = space();
			span3 = element("span");
			button4 = element("button");
			t8 = space();
			button5 = element("button");
			t9 = space();
			span4 = element("span");
			button6 = element("button");
			t10 = space();
			button7 = element("button");
			t11 = space();
			button8 = element("button");
			t12 = space();
			button9 = element("button");
			t13 = space();
			span5 = element("span");
			button10 = element("button");
			t14 = space();
			button11 = element("button");
			t15 = space();
			button12 = element("button");
			t16 = space();
			button13 = element("button");
			t17 = space();
			span6 = element("span");
			button14 = element("button");
			t18 = space();
			select4 = element("select");
			t19 = space();
			span7 = element("span");
			button15 = element("button");
			t20 = space();
			button16 = element("button");
			t21 = space();
			button17 = element("button");
			t22 = space();
			button18 = element("button");
			t23 = space();
			span8 = element("span");
			button19 = element("button");
			t24 = space();
			div1 = element("div");
			attr_dev(select0, "class", "ql-font");
			add_location(select0, file$O, 52, 6, 1189);
			attr_dev(select1, "class", "ql-size");
			add_location(select1, file$O, 53, 6, 1230);
			attr_dev(span0, "class", "ql-formats");
			add_location(span0, file$O, 51, 4, 1156);
			attr_dev(button0, "class", "ql-bold");
			add_location(button0, file$O, 56, 6, 1315);
			attr_dev(button1, "class", "ql-italic");
			add_location(button1, file$O, 57, 6, 1356);
			attr_dev(button2, "class", "ql-underline");
			add_location(button2, file$O, 58, 6, 1399);
			attr_dev(button3, "class", "ql-strike");
			add_location(button3, file$O, 59, 6, 1445);
			attr_dev(span1, "class", "ql-formats");
			add_location(span1, file$O, 55, 4, 1282);
			attr_dev(select2, "class", "ql-color");
			add_location(select2, file$O, 62, 6, 1532);
			attr_dev(select3, "class", "ql-background");
			add_location(select3, file$O, 63, 6, 1574);
			attr_dev(span2, "class", "ql-formats");
			add_location(span2, file$O, 61, 4, 1499);
			attr_dev(button4, "class", "ql-script");
			button4.value = "sub";
			add_location(button4, file$O, 66, 6, 1665);
			attr_dev(button5, "class", "ql-script");
			button5.value = "super";
			add_location(button5, file$O, 67, 6, 1720);
			attr_dev(span3, "class", "ql-formats");
			add_location(span3, file$O, 65, 4, 1632);
			attr_dev(button6, "class", "ql-header");
			button6.value = "1";
			add_location(button6, file$O, 70, 6, 1821);
			attr_dev(button7, "class", "ql-header");
			button7.value = "2";
			add_location(button7, file$O, 71, 6, 1874);
			attr_dev(button8, "class", "ql-blockquote");
			add_location(button8, file$O, 72, 6, 1927);
			attr_dev(button9, "class", "ql-code-block");
			add_location(button9, file$O, 73, 6, 1974);
			attr_dev(span4, "class", "ql-formats");
			add_location(span4, file$O, 69, 4, 1788);
			attr_dev(button10, "class", "ql-list");
			button10.value = "ordered";
			add_location(button10, file$O, 76, 6, 2065);
			attr_dev(button11, "class", "ql-list");
			button11.value = "bullet";
			add_location(button11, file$O, 77, 6, 2122);
			attr_dev(button12, "class", "ql-indent");
			button12.value = "-1";
			add_location(button12, file$O, 78, 6, 2178);
			attr_dev(button13, "class", "ql-indent");
			button13.value = "+1";
			add_location(button13, file$O, 79, 6, 2232);
			attr_dev(span5, "class", "ql-formats");
			add_location(span5, file$O, 75, 4, 2032);
			attr_dev(button14, "class", "ql-direction");
			button14.value = "rtl";
			add_location(button14, file$O, 82, 6, 2330);
			attr_dev(select4, "class", "ql-align");
			add_location(select4, file$O, 83, 6, 2388);
			attr_dev(span6, "class", "ql-formats");
			add_location(span6, file$O, 81, 4, 2297);
			attr_dev(button15, "class", "ql-link");
			add_location(button15, file$O, 86, 6, 2474);
			attr_dev(button16, "class", "ql-image");
			add_location(button16, file$O, 87, 6, 2515);
			attr_dev(button17, "class", "ql-video");
			add_location(button17, file$O, 88, 6, 2557);
			attr_dev(button18, "class", "ql-formula");
			add_location(button18, file$O, 89, 6, 2599);
			attr_dev(span7, "class", "ql-formats");
			add_location(span7, file$O, 85, 4, 2441);
			attr_dev(button19, "class", "ql-clean");
			add_location(button19, file$O, 92, 6, 2687);
			attr_dev(span8, "class", "ql-formats");
			add_location(span8, file$O, 91, 4, 2654);
			attr_dev(div0, "id", div0_id_value = "" + (/*id*/ ctx[0] + "-toolbar-container"));
			attr_dev(div0, "class", "toolbar-container");
			add_location(div0, file$O, 50, 2, 1091);
			attr_dev(div1, "id", div1_id_value = "" + (/*id*/ ctx[0] + "-editor-container"));
			attr_dev(div1, "class", "text-container");
			add_location(div1, file$O, 96, 2, 2756);
			attr_dev(div2, "id", div2_id_value = "" + (/*id*/ ctx[0] + "-standalone-container"));
			attr_dev(div2, "class", "align editor-container");
			set_style(div2, "background-color", "#fafafa");
			set_style(div2, "width", "75%");
			add_location(div2, file$O, 49, 0, 973);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, span0);
			append_dev(span0, select0);
			append_dev(span0, t0);
			append_dev(span0, select1);
			append_dev(div0, t1);
			append_dev(div0, span1);
			append_dev(span1, button0);
			append_dev(span1, t2);
			append_dev(span1, button1);
			append_dev(span1, t3);
			append_dev(span1, button2);
			append_dev(span1, t4);
			append_dev(span1, button3);
			append_dev(div0, t5);
			append_dev(div0, span2);
			append_dev(span2, select2);
			append_dev(span2, t6);
			append_dev(span2, select3);
			append_dev(div0, t7);
			append_dev(div0, span3);
			append_dev(span3, button4);
			append_dev(span3, t8);
			append_dev(span3, button5);
			append_dev(div0, t9);
			append_dev(div0, span4);
			append_dev(span4, button6);
			append_dev(span4, t10);
			append_dev(span4, button7);
			append_dev(span4, t11);
			append_dev(span4, button8);
			append_dev(span4, t12);
			append_dev(span4, button9);
			append_dev(div0, t13);
			append_dev(div0, span5);
			append_dev(span5, button10);
			append_dev(span5, t14);
			append_dev(span5, button11);
			append_dev(span5, t15);
			append_dev(span5, button12);
			append_dev(span5, t16);
			append_dev(span5, button13);
			append_dev(div0, t17);
			append_dev(div0, span6);
			append_dev(span6, button14);
			append_dev(span6, t18);
			append_dev(span6, select4);
			append_dev(div0, t19);
			append_dev(div0, span7);
			append_dev(span7, button15);
			append_dev(span7, t20);
			append_dev(span7, button16);
			append_dev(span7, t21);
			append_dev(span7, button17);
			append_dev(span7, t22);
			append_dev(span7, button18);
			append_dev(div0, t23);
			append_dev(div0, span8);
			append_dev(span8, button19);
			append_dev(div2, t24);
			append_dev(div2, div1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*id*/ 1 && div0_id_value !== (div0_id_value = "" + (/*id*/ ctx[0] + "-toolbar-container"))) {
				attr_dev(div0, "id", div0_id_value);
			}

			if (dirty & /*id*/ 1 && div1_id_value !== (div1_id_value = "" + (/*id*/ ctx[0] + "-editor-container"))) {
				attr_dev(div1, "id", div1_id_value);
			}

			if (dirty & /*id*/ 1 && div2_id_value !== (div2_id_value = "" + (/*id*/ ctx[0] + "-standalone-container"))) {
				attr_dev(div2, "id", div2_id_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$U($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Editor", slots, []);
	let { id = "report" } = $$props, { reportEditor } = $$props;

	onMount(() => {
		$$invalidate(1, reportEditor = new Quill(`#${id}-editor-container`,
		{
				modules: {
					formula: true,
					syntax: true,
					toolbar: `#${id}-toolbar-container`
				},
				// placeholder: 'Compose an epic...',
				theme: "snow"
			}));
	});

	const writable_props = ["id", "reportEditor"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Editor> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("reportEditor" in $$props) $$invalidate(1, reportEditor = $$props.reportEditor);
	};

	$$self.$capture_state = () => ({ onMount, id, reportEditor });

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("reportEditor" in $$props) $$invalidate(1, reportEditor = $$props.reportEditor);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id, reportEditor];
}

class Editor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$U, create_fragment$U, safe_not_equal, { id: 0, reportEditor: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Editor",
			options,
			id: create_fragment$U.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*reportEditor*/ ctx[1] === undefined && !("reportEditor" in props)) {
			console.warn("<Editor> was created without expected prop 'reportEditor'");
		}
	}

	get id() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reportEditor() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reportEditor(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\ReportLayout.svelte generated by Svelte v3.31.2 */

const { console: console_1$4 } = globals;
const file$P = "src\\components\\ReportLayout.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i].id;
	child_ctx[49] = list[i].include;
	child_ctx[50] = list[i].label;
	child_ctx[51] = list;
	child_ctx[52] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i].id;
	child_ctx[49] = list[i].include;
	child_ctx[50] = list[i].label;
	child_ctx[53] = list;
	child_ctx[54] = i;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	return child_ctx;
}

// (286:20) <span slot="label" style="color:{method.color}">
function create_label_slot_1(ctx) {
	let span;
	let t_value = /*method*/ ctx[46].name + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			attr_dev(span, "slot", "label");
			set_style(span, "color", /*method*/ ctx[46].color);
			add_location(span, file$P, 285, 20, 10414);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot_1.name,
		type: "slot",
		source: "(286:20) <span slot=\\\"label\\\" style=\\\"color:{method.color}\\\">",
		ctx
	});

	return block;
}

// (283:16) <FormField >
function create_default_slot_3$5(ctx) {
	let radio;
	let updating_group;
	let t0;
	let t1;
	let current;

	function radio_group_binding(value) {
		/*radio_group_binding*/ ctx[23].call(null, value);
	}

	let radio_props = { value: /*method*/ ctx[46].name };

	if (/*reportMethod*/ ctx[5] !== void 0) {
		radio_props.group = /*reportMethod*/ ctx[5];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
			t0 = space();
			t1 = space();
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty[0] & /*reportMethod*/ 32) {
				updating_group = true;
				radio_changes.group = /*reportMethod*/ ctx[5];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$5.name,
		type: "slot",
		source: "(283:16) <FormField >",
		ctx
	});

	return block;
}

// (282:12) {#each notificationMethod as method}
function create_each_block_4(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				$$slots: {
					default: [create_default_slot_3$5],
					label: [create_label_slot_1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formfield_changes = {};

			if (dirty[0] & /*reportMethod*/ 32 | dirty[1] & /*$$scope*/ 67108864) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(282:12) {#each notificationMethod as method}",
		ctx
	});

	return block;
}

// (291:8) {#if includeTablesInReports.length>0}
function create_if_block$f(ctx) {
	let div1;
	let div0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value_3 = /*includeTablesInReports*/ ctx[1];
	validate_each_argument(each_value_3);
	const get_key = ctx => /*id*/ ctx[2];
	validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_3(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", " svelte-sep7zy");
			add_location(div0, file$P, 292, 16, 10656);
			attr_dev(div1, "class", "addToReport  svelte-sep7zy");
			add_location(div1, file$P, 291, 12, 10612);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*includeTablesInReports*/ 2) {
				each_value_3 = /*includeTablesInReports*/ ctx[1];
				validate_each_argument(each_value_3);
				group_outros();
				validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_3, each_1_lookup, div0, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(291:8) {#if includeTablesInReports.length>0}",
		ctx
	});

	return block;
}

// (294:20) {#each includeTablesInReports as {id, include, label}
function create_each_block_3(key_1, ctx) {
	let first;
	let customcheckbox;
	let updating_selected;
	let current;

	function customcheckbox_selected_binding(value) {
		/*customcheckbox_selected_binding*/ ctx[24].call(null, value, /*include*/ ctx[49], /*each_value_3*/ ctx[53], /*each_index_1*/ ctx[54]);
	}

	let customcheckbox_props = { label: /*label*/ ctx[50] };

	if (/*include*/ ctx[49] !== void 0) {
		customcheckbox_props.selected = /*include*/ ctx[49];
	}

	customcheckbox = new CustomCheckbox({
			props: customcheckbox_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox, "selected", customcheckbox_selected_binding));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(customcheckbox.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(customcheckbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const customcheckbox_changes = {};
			if (dirty[0] & /*includeTablesInReports*/ 2) customcheckbox_changes.label = /*label*/ ctx[50];

			if (!updating_selected && dirty[0] & /*includeTablesInReports*/ 2) {
				updating_selected = true;
				customcheckbox_changes.selected = /*include*/ ctx[49];
				add_flush_callback(() => updating_selected = false);
			}

			customcheckbox.$set(customcheckbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customcheckbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customcheckbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(customcheckbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(294:20) {#each includeTablesInReports as {id, include, label}",
		ctx
	});

	return block;
}

// (305:16) {#each includePlotsInReport as {id, include, label}
function create_each_block_2(key_1, ctx) {
	let first;
	let customcheckbox;
	let updating_selected;
	let current;

	function customcheckbox_selected_binding_1(value) {
		/*customcheckbox_selected_binding_1*/ ctx[25].call(null, value, /*include*/ ctx[49], /*each_value_2*/ ctx[51], /*each_index*/ ctx[52]);
	}

	let customcheckbox_props = { label: /*label*/ ctx[50] };

	if (/*include*/ ctx[49] !== void 0) {
		customcheckbox_props.selected = /*include*/ ctx[49];
	}

	customcheckbox = new CustomCheckbox({
			props: customcheckbox_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox, "selected", customcheckbox_selected_binding_1));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(customcheckbox.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(customcheckbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const customcheckbox_changes = {};
			if (dirty[0] & /*includePlotsInReport*/ 1) customcheckbox_changes.label = /*label*/ ctx[50];

			if (!updating_selected && dirty[0] & /*includePlotsInReport*/ 1) {
				updating_selected = true;
				customcheckbox_changes.selected = /*include*/ ctx[49];
				add_flush_callback(() => updating_selected = false);
			}

			customcheckbox.$set(customcheckbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customcheckbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customcheckbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(customcheckbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(305:16) {#each includePlotsInReport as {id, include, label}",
		ctx
	});

	return block;
}

// (336:20) <span slot="label" style="color:{method}">
function create_label_slot$4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*method*/ ctx[46]);
			attr_dev(span, "slot", "label");
			set_style(span, "color", /*method*/ ctx[46]);
			add_location(span, file$P, 335, 20, 12264);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot$4.name,
		type: "slot",
		source: "(336:20) <span slot=\\\"label\\\" style=\\\"color:{method}\\\">",
		ctx
	});

	return block;
}

// (332:16) <FormField >
function create_default_slot_2$9(ctx) {
	let radio;
	let updating_group;
	let t;
	let current;

	function radio_group_binding_1(value) {
		/*radio_group_binding_1*/ ctx[31].call(null, value);
	}

	let radio_props = { value: /*method*/ ctx[46] };

	if (/*exportMethod*/ ctx[10] !== void 0) {
		radio_props.group = /*exportMethod*/ ctx[10];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_1));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty[0] & /*exportMethod*/ 1024) {
				updating_group = true;
				radio_changes.group = /*exportMethod*/ ctx[10];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$9.name,
		type: "slot",
		source: "(332:16) <FormField >",
		ctx
	});

	return block;
}

// (330:12) {#each ["landscape", "portrait"] as method}
function create_each_block_1(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				$$slots: {
					default: [create_default_slot_2$9],
					label: [create_label_slot$4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formfield_changes = {};

			if (dirty[0] & /*exportMethod*/ 1024 | dirty[1] & /*$$scope*/ 67108864) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(330:12) {#each [\\\"landscape\\\", \\\"portrait\\\"] as method}",
		ctx
	});

	return block;
}

// (343:20) <Option value={file} selected={pageSize  === file}>
function create_default_slot_1$9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*file*/ ctx[43]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$9.name,
		type: "slot",
		source: "(343:20) <Option value={file} selected={pageSize  === file}>",
		ctx
	});

	return block;
}

// (342:16) {#each ["A3", "A4", "A5", "Legal", "Letter"] as file}
function create_each_block$4(ctx) {
	let option;
	let current;

	option = new Option({
			props: {
				value: /*file*/ ctx[43],
				selected: /*pageSize*/ ctx[11] === /*file*/ ctx[43],
				$$slots: { default: [create_default_slot_1$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(option.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(option, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const option_changes = {};
			if (dirty[0] & /*pageSize*/ 2048) option_changes.selected = /*pageSize*/ ctx[11] === /*file*/ ctx[43];

			if (dirty[1] & /*$$scope*/ 67108864) {
				option_changes.$$scope = { dirty, ctx };
			}

			option.$set(option_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(option.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(option.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(option, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(342:16) {#each [\\\"A3\\\", \\\"A4\\\", \\\"A5\\\", \\\"Legal\\\", \\\"Letter\\\"] as file}",
		ctx
	});

	return block;
}

// (341:12) <Select bind:value={pageSize} label="pageSize" style="margin-left:1em;">
function create_default_slot$i(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ["A3", "A4", "A5", "Legal", "Letter"];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < 5; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < 5; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < 5; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*pageSize*/ 2048) {
				each_value = ["A3", "A4", "A5", "Legal", "Letter"];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < 5; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = 5; i < 5; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < 5; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 5; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$i.name,
		type: "slot",
		source: "(341:12) <Select bind:value={pageSize} label=\\\"pageSize\\\" style=\\\"margin-left:1em;\\\">",
		ctx
	});

	return block;
}

function create_fragment$V(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let div1;
	let div0;
	let t2;
	let hamburger1;
	let updating_active;
	let t3;
	let div9;
	let div2;
	let textfield0;
	let updating_value;
	let t4;
	let button0;
	let t6;
	let div8;
	let div3;
	let t7;
	let t8;
	let div5;
	let div4;
	let each_blocks_1 = [];
	let each1_lookup = new Map();
	let t9;
	let textfield1;
	let updating_value_1;
	let t10;
	let editor;
	let updating_reportEditor;
	let t11;
	let div6;
	let button1;
	let t13;
	let button2;
	let t15;
	let div7;
	let textfield2;
	let updating_value_2;
	let t16;
	let textfield3;
	let updating_value_3;
	let t17;
	let button3;
	let t19;
	let t20;
	let select;
	let updating_value_4;
	let current;
	let mounted;
	let dispose;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[19].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[6] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[6];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));

	function hamburger1_active_binding(value) {
		/*hamburger1_active_binding*/ ctx[20].call(null, value);
	}

	let hamburger1_props = {};

	if (/*toggle*/ ctx[13] !== void 0) {
		hamburger1_props.active = /*toggle*/ ctx[13];
	}

	hamburger1 = new Hamburger1({ props: hamburger1_props, $$inline: true });
	binding_callbacks.push(() => bind(hamburger1, "active", hamburger1_active_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[21].call(null, value);
	}

	let textfield0_props = {
		style: "height:3em; width:20em;",
		variant: "outlined",
		label: "Molecule Name"
	};

	if (/*reportMolecule*/ ctx[3] !== void 0) {
		textfield0_props.value = /*reportMolecule*/ ctx[3];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));
	let each_value_4 = /*notificationMethod*/ ctx[17];
	validate_each_argument(each_value_4);
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks_2[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out = i => transition_out(each_blocks_2[i], 1, 1, () => {
		each_blocks_2[i] = null;
	});

	let if_block = /*includeTablesInReports*/ ctx[1].length > 0 && create_if_block$f(ctx);
	let each_value_2 = /*includePlotsInReport*/ ctx[0];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*id*/ ctx[2];
	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks_1[i] = create_each_block_2(key, child_ctx));
	}

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[26].call(null, value);
	}

	let textfield1_props = {
		style: "height:3em; margin-bottom:1em;",
		variant: "outlined",
		label: "Title"
	};

	if (/*reportTitle*/ ctx[4] !== void 0) {
		textfield1_props.value = /*reportTitle*/ ctx[4];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function editor_reportEditor_binding(value) {
		/*editor_reportEditor_binding*/ ctx[27].call(null, value);
	}

	let editor_props = { id: /*id*/ ctx[2] };

	if (/*reportEditor*/ ctx[9] !== void 0) {
		editor_props.reportEditor = /*reportEditor*/ ctx[9];
	}

	editor = new Editor({ props: editor_props, $$inline: true });
	binding_callbacks.push(() => bind(editor, "reportEditor", editor_reportEditor_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[28].call(null, value);
	}

	let textfield2_props = {
		style: "width:7em;",
		variant: "outlined",
		label: "plotWidth"
	};

	if (/*plotWidth*/ ctx[7] !== void 0) {
		textfield2_props.value = /*plotWidth*/ ctx[7];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[29].call(null, value);
	}

	let textfield3_props = {
		style: "width:7em;",
		variant: "outlined",
		label: "plotHeight"
	};

	if (/*plotHeight*/ ctx[8] !== void 0) {
		textfield3_props.value = /*plotHeight*/ ctx[8];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));
	let each_value_1 = ["landscape", "portrait"];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < 2; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[32].call(null, value);
	}

	let select_props = {
		label: "pageSize",
		style: "margin-left:1em;",
		$$slots: { default: [create_default_slot$i] },
		$$scope: { ctx }
	};

	if (/*pageSize*/ ctx[11] !== void 0) {
		select_props.value = /*pageSize*/ ctx[11];
	}

	select = new Select({ props: select_props, $$inline: true });
	binding_callbacks.push(() => bind(select, "value", select_value_binding));

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Add to report";
			t2 = space();
			create_component(hamburger1.$$.fragment);
			t3 = space();
			div9 = element("div");
			div2 = element("div");
			create_component(textfield0.$$.fragment);
			t4 = space();
			button0 = element("button");
			button0.textContent = "Reset Report";
			t6 = space();
			div8 = element("div");
			div3 = element("div");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t7 = space();
			if (if_block) if_block.c();
			t8 = space();
			div5 = element("div");
			div4 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t9 = space();
			create_component(textfield1.$$.fragment);
			t10 = space();
			create_component(editor.$$.fragment);
			t11 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = "Add to Report";
			t13 = space();
			button2 = element("button");
			button2.textContent = "Show Report";
			t15 = space();
			div7 = element("div");
			create_component(textfield2.$$.fragment);
			t16 = space();
			create_component(textfield3.$$.fragment);
			t17 = space();
			button3 = element("button");
			button3.textContent = "EXPORT to PDF";
			t19 = space();

			for (let i = 0; i < 2; i += 1) {
				each_blocks[i].c();
			}

			t20 = space();
			create_component(select.$$.fragment);
			attr_dev(div0, "class", "title notification is-link svelte-sep7zy");
			add_location(div0, file$P, 266, 4, 9604);
			attr_dev(div1, "class", "content align heading svelte-sep7zy");
			add_location(div1, file$P, 265, 0, 9563);
			attr_dev(button0, "class", "button is-pulled-right is-warning svelte-sep7zy");
			add_location(button0, file$P, 276, 8, 9943);
			set_style(div2, "margin-bottom", "1em");
			add_location(div2, file$P, 274, 4, 9777);
			attr_dev(div3, "class", "");
			add_location(div3, file$P, 280, 8, 10198);
			attr_dev(div4, "class", " svelte-sep7zy");
			add_location(div4, file$P, 303, 12, 10985);
			attr_dev(div5, "class", "addToReport  svelte-sep7zy");
			add_location(div5, file$P, 301, 8, 10943);
			attr_dev(button1, "class", "button is-link svelte-sep7zy");
			add_location(button1, file$P, 317, 12, 11476);
			attr_dev(button2, "class", "button is-link svelte-sep7zy");
			add_location(button2, file$P, 318, 12, 11564);
			attr_dev(div6, "class", "align svelte-sep7zy");
			set_style(div6, "margin-top", "1em");
			add_location(div6, file$P, 316, 8, 11419);
			attr_dev(button3, "class", "button is-link svelte-sep7zy");
			add_location(button3, file$P, 327, 12, 11950);
			attr_dev(div7, "class", "align svelte-sep7zy");
			add_location(div7, file$P, 322, 8, 11675);
			attr_dev(div8, "class", "align report svelte-sep7zy");
			attr_dev(div8, "id", /*id*/ ctx[2]);
			add_location(div8, file$P, 279, 4, 10156);
			attr_dev(div9, "class", "animated fadeIn svelte-sep7zy");
			toggle_class(div9, "hide", !/*toggle*/ ctx[13]);
			add_location(div9, file$P, 271, 0, 9717);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t2);
			mount_component(hamburger1, div1, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div9, anchor);
			append_dev(div9, div2);
			mount_component(textfield0, div2, null);
			append_dev(div2, t4);
			append_dev(div2, button0);
			append_dev(div9, t6);
			append_dev(div9, div8);
			append_dev(div8, div3);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div3, null);
			}

			append_dev(div8, t7);
			if (if_block) if_block.m(div8, null);
			append_dev(div8, t8);
			append_dev(div8, div5);
			append_dev(div5, div4);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div4, null);
			}

			append_dev(div8, t9);
			mount_component(textfield1, div8, null);
			append_dev(div8, t10);
			mount_component(editor, div8, null);
			append_dev(div8, t11);
			append_dev(div8, div6);
			append_dev(div6, button1);
			append_dev(div6, t13);
			append_dev(div6, button2);
			append_dev(div8, t15);
			append_dev(div8, div7);
			mount_component(textfield2, div7, null);
			append_dev(div7, t16);
			mount_component(textfield3, div7, null);
			append_dev(div7, t17);
			append_dev(div7, button3);
			append_dev(div7, t19);

			for (let i = 0; i < 2; i += 1) {
				each_blocks[i].m(div7, null);
			}

			append_dev(div7, t20);
			mount_component(select, div7, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[22], false, false, false),
					listen_dev(button1, "click", /*addReport*/ ctx[15], false, false, false),
					listen_dev(button2, "click", /*showReport*/ ctx[16], false, false, false),
					listen_dev(button3, "click", /*click_handler_1*/ ctx[30], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const premodal_changes = {};

			if (!updating_preModal && dirty[0] & /*preModal*/ 64) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[6];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);
			const hamburger1_changes = {};

			if (!updating_active && dirty[0] & /*toggle*/ 8192) {
				updating_active = true;
				hamburger1_changes.active = /*toggle*/ ctx[13];
				add_flush_callback(() => updating_active = false);
			}

			hamburger1.$set(hamburger1_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*reportMolecule*/ 8) {
				updating_value = true;
				textfield0_changes.value = /*reportMolecule*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);

			if (dirty[0] & /*notificationMethod, reportMethod*/ 131104) {
				each_value_4 = /*notificationMethod*/ ctx[17];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
						transition_in(each_blocks_2[i], 1);
					} else {
						each_blocks_2[i] = create_each_block_4(child_ctx);
						each_blocks_2[i].c();
						transition_in(each_blocks_2[i], 1);
						each_blocks_2[i].m(div3, null);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks_2.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*includeTablesInReports*/ ctx[1].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*includeTablesInReports*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div8, t8);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*includePlotsInReport*/ 1) {
				each_value_2 = /*includePlotsInReport*/ ctx[0];
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_2, each1_lookup, div4, outro_and_destroy_block, create_each_block_2, null, get_each_context_2);
				check_outros();
			}

			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*reportTitle*/ 16) {
				updating_value_1 = true;
				textfield1_changes.value = /*reportTitle*/ ctx[4];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const editor_changes = {};
			if (dirty[0] & /*id*/ 4) editor_changes.id = /*id*/ ctx[2];

			if (!updating_reportEditor && dirty[0] & /*reportEditor*/ 512) {
				updating_reportEditor = true;
				editor_changes.reportEditor = /*reportEditor*/ ctx[9];
				add_flush_callback(() => updating_reportEditor = false);
			}

			editor.$set(editor_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*plotWidth*/ 128) {
				updating_value_2 = true;
				textfield2_changes.value = /*plotWidth*/ ctx[7];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*plotHeight*/ 256) {
				updating_value_3 = true;
				textfield3_changes.value = /*plotHeight*/ ctx[8];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);

			if (dirty[0] & /*exportMethod*/ 1024) {
				each_value_1 = ["landscape", "portrait"];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < 2; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div7, t20);
					}
				}

				group_outros();

				for (i = 2; i < 2; i += 1) {
					out_1(i);
				}

				check_outros();
			}

			const select_changes = {};

			if (dirty[0] & /*pageSize*/ 2048 | dirty[1] & /*$$scope*/ 67108864) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value_4 && dirty[0] & /*pageSize*/ 2048) {
				updating_value_4 = true;
				select_changes.value = /*pageSize*/ ctx[11];
				add_flush_callback(() => updating_value_4 = false);
			}

			select.$set(select_changes);

			if (!current || dirty[0] & /*id*/ 4) {
				attr_dev(div8, "id", /*id*/ ctx[2]);
			}

			if (dirty[0] & /*toggle*/ 8192) {
				toggle_class(div9, "hide", !/*toggle*/ ctx[13]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(hamburger1.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			transition_in(if_block);

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(textfield1.$$.fragment, local);
			transition_in(editor.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);

			for (let i = 0; i < 2; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(hamburger1.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			each_blocks_2 = each_blocks_2.filter(Boolean);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			transition_out(if_block);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(textfield1.$$.fragment, local);
			transition_out(editor.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 2; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(hamburger1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div9);
			destroy_component(textfield0);
			destroy_each(each_blocks_2, detaching);
			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			destroy_component(textfield1);
			destroy_component(editor);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_each(each_blocks, detaching);
			destroy_component(select);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$V($$self, $$props, $$invalidate) {
	let reportFile;
	let reportHTMLTemplate;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ReportLayout", slots, []);
	const { BrowserWindow } = remote;

	let { currentLocation = "" } = $$props,
		{ id = "report" } = $$props,
		{ includePlotsInReport = [] } = $$props,
		{ includeTablesInReports = [] } = $$props;

	let reportTitle = "", reportMethod = "info", reportMolecule = "";

	// const reportExist = fs.existsSync(reportFile)
	const stylesheet1 = path.resolve(__dirname, `assets/reports/report.css`);

	const stylesheet2 = path.resolve(__dirname, `assets/reports/template.css`);
	const reportHTML = document.createElement("html");
	let preModal = {};

	function init_report() {
		reportHTML.innerHTML = fs.existsSync(reportFile)
		? fs.readFileSync(reportFile)
		: reportHTMLTemplate;

		console.log("ReportHTML: ", reportHTML);
		$$invalidate(12, reportMainContainer = reportHTML.querySelector("#mainSection"));
		const reportDir = path.resolve(currentLocation, "reports");

		if (!fs.existsSync(reportDir)) {
			fs.mkdir(reportDir, { recursive: true }, err => {
				if (err) return window.createToast("No write access for making report", "danger");
				console.log("reports directory created");
			});
		}
	}

	let plotWidth = 750, plotHeight = 500;

	function getImage(imgID) {
		return new Promise(resolve => {
				Plotly.toImage(imgID, {
					format: "png",
					width: plotWidth,
					height: plotHeight
				}).then(dataURL => {
					resolve(dataURL);
				});
			});
	}

	const exprtToHtml = async content => {
		fs.writeFile(reportFile, content || reportHTMLTemplate, function (err) {
			if (err) {
				window.createToast("Report couldn't be added.", "danger");
				return console.log(err);
			}

			window.createToast("Report added", "success");
			console.log("Exported to HTML");
		});

		$$invalidate(4, reportTitle = "");
	};

	const addTablesToReport = () => {
		const tableDiv = document.createElement("div");
		tableDiv.setAttribute("class", "content reportTable");

		includeTablesInReports.forEach(tb => {
			if (tb.include) {
				try {
					let tableContent = document.getElementById(tb.id).innerHTML;
					let tableElement = document.createElement("table");
					tableElement.setAttribute("class", "table is-bordered is-hoverable");
					tableElement.innerHTML = tableContent;
					let tableHeading = document.createElement("h1");
					tableHeading.setAttribute("class", "title");
					tableHeading.textContent = tb.label;
					tableDiv.appendChild(tableHeading);
					tableDiv.appendChild(tableElement);
				} catch(err) {
					window.createToast(`${tb.label} is not visible`, "danger");
				}
			}
		});

		console.log("tableDiv created", tableDiv);
		return tableDiv;
	};

	const addPlotImagesToReport = async () => {
		const plotDiv = document.createElement("div");
		plotDiv.setAttribute("class", "content reportPlots");

		await asyncForEach(includePlotsInReport, async plot => {
			if (plot.include) {
				console.log("Request Image URL for ", plot.id);
				let imgURL = await getImage(plot.id);
				console.log(`Received Image URL for ${plot.id}\n`);
				let imgElement = document.createElement("img");
				imgElement.setAttribute("src", imgURL);
				plotDiv.appendChild(imgElement);
				console.log(`${plot.id} Included in HTML`);
			}
		});

		console.log("plotDiv created", plotDiv);
		return Promise.resolve(plotDiv);
	};

	let reportEditor;

	const addReport = async () => {
		if (!fs.existsSync(reportFile)) {
			init_report();
		}

		const tableDiv = addTablesToReport();
		const plotDiv = await addPlotImagesToReport();
		const reportMainHeading = document.createElement("h1");
		reportMainHeading.setAttribute("class", `notification is-${reportMethod} reportHeading`);
		reportMainHeading.textContent = reportTitle;
		const reportComment = document.createElement("div");
		reportComment.setAttribute("class", "reportComments");
		reportComment.innerHTML = reportEditor.root.outerHTML;
		const reportDiv = document.createElement("div");
		reportDiv.setAttribute("class", "content reportCount");
		reportDiv.appendChild(reportMainHeading);
		reportDiv.appendChild(reportComment);
		reportDiv.appendChild(plotDiv);
		reportDiv.appendChild(tableDiv);
		console.log("reportDiv div created", reportDiv);
		reportMainContainer.appendChild(reportDiv);
		console.log("reportMainContainer div created", reportMainContainer);
		console.log("Full report\n", reportHTML);
		exprtToHtml(reportHTML.innerHTML);
	};

	let exportMethod = "landscape", pageSize = "A4";

	const showReport = ({ export_pdf = false } = {}) => {
		let reportWindow = new BrowserWindow({
				width: 1200,
				minWidth: 600,
				height: 600,
				parent: remote.getCurrentWindow(),
				show: !export_pdf
			});

		reportWindow.on("closed", () => {
			reportWindow = null;
			console.log("Report window closed");
		});

		reportWindow.loadURL(reportFile);

		reportWindow.webContents.on("did-finish-load", () => {
			console.log("Report loaded");

			if (export_pdf) {
				let landscape;

				exportMethod == "landscape"
				? landscape = true
				: landscape = false;

				if (process.versions.electron >= "7") {
					reportWindow.webContents.printToPDF({
						printBackground: true,
						landscape,
						pageSize
					}).then(data => {
						fs.writeFile(reportFile.replace(".html", ".pdf"), data, err => {
							if (err) {
								$$invalidate(6, preModal.modalContent = err.stack, preModal);
								$$invalidate(6, preModal.open = true, preModal);
								return;
							}

							window.createToast("Write PDF successfully.", "success");
						});
					}).catch(err => {
						$$invalidate(6, preModal.modalContent = err.stack, preModal);
						$$invalidate(6, preModal.open = true, preModal);
					});
				} else {
					reportWindow.webContents.printToPDF(
						{
							printBackground: true,
							landscape,
							pageSize
						},
						(err, data) => {
							if (err) {
								$$invalidate(6, preModal.modalContent = err.stack, preModal);
								$$invalidate(6, preModal.open = true, preModal);
								return;
							}

							fs.writeFile(reportFile.replace(".html", ".pdf"), data, err => {
								if (err) {
									$$invalidate(6, preModal.modalContent = err.stack, preModal);
									$$invalidate(6, preModal.open = true, preModal);
									return;
								}

								window.createToast("Write PDF successfully.", "success");
							});
						}
					);
				}
			}
		});
	};

	const notificationMethod = [
		{ name: "info", color: "white" },
		{ name: "success", color: "#00ff00" },
		{ name: "warning", color: "yellow" },
		{ name: "danger", color: "red" }
	];

	let reportMainContainer;

	onMount(() => {
		init_report();
	});

	let toggle = false;
	const writable_props = ["currentLocation", "id", "includePlotsInReport", "includeTablesInReports"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<ReportLayout> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(6, preModal);
	}

	function hamburger1_active_binding(value) {
		toggle = value;
		$$invalidate(13, toggle);
	}

	function textfield0_value_binding(value) {
		reportMolecule = value;
		$$invalidate(3, reportMolecule);
	}

	const click_handler = () => {
		$$invalidate(12, reportMainContainer.innerHTML = "", reportMainContainer);
		exprtToHtml("");
		window.createToast("Report resetted", "warning");
	};

	function radio_group_binding(value) {
		reportMethod = value;
		$$invalidate(5, reportMethod);
	}

	function customcheckbox_selected_binding(value, include, each_value_3, each_index_1) {
		each_value_3[each_index_1].include = value;
		$$invalidate(1, includeTablesInReports);
	}

	function customcheckbox_selected_binding_1(value, include, each_value_2, each_index) {
		each_value_2[each_index].include = value;
		$$invalidate(0, includePlotsInReport);
	}

	function textfield1_value_binding(value) {
		reportTitle = value;
		$$invalidate(4, reportTitle);
	}

	function editor_reportEditor_binding(value) {
		reportEditor = value;
		$$invalidate(9, reportEditor);
	}

	function textfield2_value_binding(value) {
		plotWidth = value;
		$$invalidate(7, plotWidth);
	}

	function textfield3_value_binding(value) {
		plotHeight = value;
		$$invalidate(8, plotHeight);
	}

	const click_handler_1 = () => showReport({ export_pdf: true });

	function radio_group_binding_1(value) {
		exportMethod = value;
		$$invalidate(10, exportMethod);
	}

	function select_value_binding(value) {
		pageSize = value;
		$$invalidate(11, pageSize);
	}

	$$self.$$set = $$props => {
		if ("currentLocation" in $$props) $$invalidate(18, currentLocation = $$props.currentLocation);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("includePlotsInReport" in $$props) $$invalidate(0, includePlotsInReport = $$props.includePlotsInReport);
		if ("includeTablesInReports" in $$props) $$invalidate(1, includeTablesInReports = $$props.includeTablesInReports);
	};

	$$self.$capture_state = () => ({
		Radio,
		FormField,
		CustomCheckbox,
		Textfield,
		Select,
		Option,
		onMount,
		Hamburger1,
		PreModal,
		Editor,
		BrowserWindow,
		currentLocation,
		id,
		includePlotsInReport,
		includeTablesInReports,
		reportTitle,
		reportMethod,
		reportMolecule,
		stylesheet1,
		stylesheet2,
		reportHTML,
		preModal,
		init_report,
		plotWidth,
		plotHeight,
		getImage,
		exprtToHtml,
		addTablesToReport,
		addPlotImagesToReport,
		reportEditor,
		addReport,
		exportMethod,
		pageSize,
		showReport,
		notificationMethod,
		reportMainContainer,
		toggle,
		reportFile,
		reportHTMLTemplate
	});

	$$self.$inject_state = $$props => {
		if ("currentLocation" in $$props) $$invalidate(18, currentLocation = $$props.currentLocation);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("includePlotsInReport" in $$props) $$invalidate(0, includePlotsInReport = $$props.includePlotsInReport);
		if ("includeTablesInReports" in $$props) $$invalidate(1, includeTablesInReports = $$props.includeTablesInReports);
		if ("reportTitle" in $$props) $$invalidate(4, reportTitle = $$props.reportTitle);
		if ("reportMethod" in $$props) $$invalidate(5, reportMethod = $$props.reportMethod);
		if ("reportMolecule" in $$props) $$invalidate(3, reportMolecule = $$props.reportMolecule);
		if ("preModal" in $$props) $$invalidate(6, preModal = $$props.preModal);
		if ("plotWidth" in $$props) $$invalidate(7, plotWidth = $$props.plotWidth);
		if ("plotHeight" in $$props) $$invalidate(8, plotHeight = $$props.plotHeight);
		if ("reportEditor" in $$props) $$invalidate(9, reportEditor = $$props.reportEditor);
		if ("exportMethod" in $$props) $$invalidate(10, exportMethod = $$props.exportMethod);
		if ("pageSize" in $$props) $$invalidate(11, pageSize = $$props.pageSize);
		if ("reportMainContainer" in $$props) $$invalidate(12, reportMainContainer = $$props.reportMainContainer);
		if ("toggle" in $$props) $$invalidate(13, toggle = $$props.toggle);
		if ("reportFile" in $$props) reportFile = $$props.reportFile;
		if ("reportHTMLTemplate" in $$props) reportHTMLTemplate = $$props.reportHTMLTemplate;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentLocation, reportMolecule*/ 262152) {
			 reportFile = path.resolve(currentLocation, `reports/${reportMolecule}_report.html`);
		}

		if ($$self.$$.dirty[0] & /*reportMolecule*/ 8) {
			 reportHTMLTemplate = `<!DOCTYPE html>
                                <html lang="en">
                                    <head>
                                        <meta charset='utf8'>
                                        <meta name="viewport" content="width=device-width, initial-scale=1">
                                        <meta http-equiv="X-UA-Compatible" content="ie=edge">
                                        <title>${reportMolecule} Reports</title>
                                        <link rel="stylesheet" type='text/css' href="${stylesheet1}">
                                        <link rel="stylesheet" type='text/css' href="${stylesheet2}">
                                    </head>

                                    <body>
                                        <section class="section" id="mainSection"></section>
                                    </body>
                                </html>`;
		}
	};

	return [
		includePlotsInReport,
		includeTablesInReports,
		id,
		reportMolecule,
		reportTitle,
		reportMethod,
		preModal,
		plotWidth,
		plotHeight,
		reportEditor,
		exportMethod,
		pageSize,
		reportMainContainer,
		toggle,
		exprtToHtml,
		addReport,
		showReport,
		notificationMethod,
		currentLocation,
		premodal_preModal_binding,
		hamburger1_active_binding,
		textfield0_value_binding,
		click_handler,
		radio_group_binding,
		customcheckbox_selected_binding,
		customcheckbox_selected_binding_1,
		textfield1_value_binding,
		editor_reportEditor_binding,
		textfield2_value_binding,
		textfield3_value_binding,
		click_handler_1,
		radio_group_binding_1,
		select_value_binding
	];
}

class ReportLayout extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$V,
			create_fragment$V,
			safe_not_equal,
			{
				currentLocation: 18,
				id: 2,
				includePlotsInReport: 0,
				includeTablesInReports: 1
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ReportLayout",
			options,
			id: create_fragment$V.name
		});
	}

	get currentLocation() {
		throw new Error("<ReportLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<ReportLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<ReportLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<ReportLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get includePlotsInReport() {
		throw new Error("<ReportLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set includePlotsInReport(value) {
		throw new Error("<ReportLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get includeTablesInReports() {
		throw new Error("<ReportLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set includeTablesInReports(value) {
		throw new Error("<ReportLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\modals\AddFilesToPlot.svelte generated by Svelte v3.31.2 */
const file$Q = "src\\Pages\\normline\\modals\\AddFilesToPlot.svelte";

// (41:0) {#if active}
function create_if_block$g(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[13].call(null, value);
	}

	let modal_props = {
		title: "Add file to plot",
		$$slots: {
			default: [create_default_slot$j],
			footerbtn: [create_footerbtn_slot],
			content: [create_content_slot$1]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, addedFileScale, addedFileCol*/ 32774) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(41:0) {#if active}",
		ctx
	});

	return block;
}

// (45:8) <div slot="content" >
function create_content_slot$1(ctx) {
	let div;
	let textfield0;
	let updating_value;
	let t0;
	let textfield1;
	let updating_value_1;
	let t1;
	let button;
	let current;
	let mounted;
	let dispose;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[10].call(null, value);
	}

	let textfield0_props = {
		style: "width:7em; margin:0 0.5em;",
		label: "Columns"
	};

	if (/*addedFileCol*/ ctx[1] !== void 0) {
		textfield0_props.value = /*addedFileCol*/ ctx[1];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[11].call(null, value);
	}

	let textfield1_props = {
		style: "width:7em; margin:0 0.5em;",
		label: "ScaleY"
	};

	if (/*addedFileScale*/ ctx[2] !== void 0) {
		textfield1_props.value = /*addedFileScale*/ ctx[2];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			create_component(textfield1.$$.fragment);
			t1 = space();
			button = element("button");
			button.textContent = "Browse";
			attr_dev(button, "class", "button is-link");
			add_location(button, file$Q, 47, 12, 1640);
			attr_dev(div, "slot", "content");
			add_location(div, file$Q, 44, 8, 1398);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield0, div, null);
			append_dev(div, t0);
			mount_component(textfield1, div, null);
			append_dev(div, t1);
			append_dev(div, button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*addFileSelection*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty & /*addedFileCol*/ 2) {
				updating_value = true;
				textfield0_changes.value = /*addedFileCol*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*addedFileScale*/ 4) {
				updating_value_1 = true;
				textfield1_changes.value = /*addedFileScale*/ ctx[2];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield0);
			destroy_component(textfield1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$1.name,
		type: "slot",
		source: "(45:8) <div slot=\\\"content\\\" >",
		ctx
	});

	return block;
}

// (51:8) <button slot="footerbtn" class="button is-link" on:click="{(e)=>plotData({e:e})}" >
function create_footerbtn_slot(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "Add";
			attr_dev(button, "slot", "footerbtn");
			attr_dev(button, "class", "button is-link");
			add_location(button, file$Q, 50, 8, 1742);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot.name,
		type: "slot",
		source: "(51:8) <button slot=\\\"footerbtn\\\" class=\\\"button is-link\\\" on:click=\\\"{(e)=>plotData({e:e})}\\\" >",
		ctx
	});

	return block;
}

// (43:4) <Modal bind:active title="Add file to plot">
function create_default_slot$j(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$j.name,
		type: "slot",
		source: "(43:4) <Modal bind:active title=\\\"Add file to plot\\\">",
		ctx
	});

	return block;
}

function create_fragment$W(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$g(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props, $$invalidate) {
	let $graphDiv;
	validate_store(graphDiv, "graphDiv");
	component_subscribe($$self, graphDiv, $$value => $$invalidate(14, $graphDiv = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AddFilesToPlot", slots, []);

	let { active = false } = $$props,
		{ fileChecked = [] } = $$props,
		{ addedFileCol = 1 } = $$props,
		{ addedFileScale = 1000 } = $$props,
		{ addedfiles = [] } = $$props,
		{ addedFile = {} } = $$props,
		{ extrafileAdded = 0 } = $$props,
		{ preModal } = $$props;

	function addFileSelection() {
		browse({ dir: false }).then(result => {
			if (!result.canceled) {
				$$invalidate(5, addedfiles = $$invalidate(6, addedFile["files"] = result.filePaths, addedFile));
			}
		});
	}

	function plotData({ e = null } = {}) {
		let pyfile = "addTrace.py", args;
		if (addedFile.files < 1) return window.createToast("No files selected", "danger");
		($$invalidate(6, addedFile["col"] = addedFileCol, addedFile), $$invalidate(6, addedFile["N"] = fileChecked.length + extrafileAdded, addedFile));
		$$invalidate(6, addedFile["scale"] = addedFileScale, addedFile);
		args = [JSON.stringify(addedFile)];

		computePy_func({ e, pyfile, args }).then(dataFromPython => {
			addFileModal = false;
			Plotly.addTraces($graphDiv, dataFromPython);
			$$invalidate(7, extrafileAdded += addedfiles.length);
			window.createToast("Graph Plotted", "success");
		}).catch(err => {
			$$invalidate(8, preModal.modalContent = err, preModal);
			$$invalidate(8, preModal.open = true, preModal);
		});
	}

	const writable_props = [
		"active",
		"fileChecked",
		"addedFileCol",
		"addedFileScale",
		"addedfiles",
		"addedFile",
		"extrafileAdded",
		"preModal"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddFilesToPlot> was created with unknown prop '${key}'`);
	});

	function textfield0_value_binding(value) {
		addedFileCol = value;
		$$invalidate(1, addedFileCol);
	}

	function textfield1_value_binding(value) {
		addedFileScale = value;
		$$invalidate(2, addedFileScale);
	}

	const click_handler = e => plotData({ e });

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("fileChecked" in $$props) $$invalidate(9, fileChecked = $$props.fileChecked);
		if ("addedFileCol" in $$props) $$invalidate(1, addedFileCol = $$props.addedFileCol);
		if ("addedFileScale" in $$props) $$invalidate(2, addedFileScale = $$props.addedFileScale);
		if ("addedfiles" in $$props) $$invalidate(5, addedfiles = $$props.addedfiles);
		if ("addedFile" in $$props) $$invalidate(6, addedFile = $$props.addedFile);
		if ("extrafileAdded" in $$props) $$invalidate(7, extrafileAdded = $$props.extrafileAdded);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
	};

	$$self.$capture_state = () => ({
		graphDiv,
		Modal,
		Textfield,
		browse,
		active,
		fileChecked,
		addedFileCol,
		addedFileScale,
		addedfiles,
		addedFile,
		extrafileAdded,
		preModal,
		addFileSelection,
		plotData,
		$graphDiv
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("fileChecked" in $$props) $$invalidate(9, fileChecked = $$props.fileChecked);
		if ("addedFileCol" in $$props) $$invalidate(1, addedFileCol = $$props.addedFileCol);
		if ("addedFileScale" in $$props) $$invalidate(2, addedFileScale = $$props.addedFileScale);
		if ("addedfiles" in $$props) $$invalidate(5, addedfiles = $$props.addedfiles);
		if ("addedFile" in $$props) $$invalidate(6, addedFile = $$props.addedFile);
		if ("extrafileAdded" in $$props) $$invalidate(7, extrafileAdded = $$props.extrafileAdded);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		addedFileCol,
		addedFileScale,
		addFileSelection,
		plotData,
		addedfiles,
		addedFile,
		extrafileAdded,
		preModal,
		fileChecked,
		textfield0_value_binding,
		textfield1_value_binding,
		click_handler,
		modal_active_binding
	];
}

class AddFilesToPlot extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
			active: 0,
			fileChecked: 9,
			addedFileCol: 1,
			addedFileScale: 2,
			addedfiles: 5,
			addedFile: 6,
			extrafileAdded: 7,
			preModal: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddFilesToPlot",
			options,
			id: create_fragment$W.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*preModal*/ ctx[8] === undefined && !("preModal" in props)) {
			console.warn("<AddFilesToPlot> was created without expected prop 'preModal'");
		}
	}

	get active() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fileChecked() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addedFileCol() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedFileCol(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addedFileScale() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedFileScale(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addedfiles() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedfiles(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addedFile() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedFile(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get extrafileAdded() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set extrafileAdded(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<AddFilesToPlot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<AddFilesToPlot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$m = {
    CELL: 'mdc-data-table__cell',
    CELL_NUMERIC: 'mdc-data-table__cell--numeric',
    CONTENT: 'mdc-data-table__content',
    HEADER_ROW: 'mdc-data-table__header-row',
    HEADER_ROW_CHECKBOX: 'mdc-data-table__header-row-checkbox',
    ROOT: 'mdc-data-table',
    ROW: 'mdc-data-table__row',
    ROW_CHECKBOX: 'mdc-data-table__row-checkbox',
    ROW_SELECTED: 'mdc-data-table__row--selected',
};
var strings$p = {
    ARIA_SELECTED: 'aria-selected',
    DATA_ROW_ID_ATTR: 'data-row-id',
    HEADER_ROW_CHECKBOX_SELECTOR: "." + cssClasses$m.HEADER_ROW_CHECKBOX,
    ROW_CHECKBOX_SELECTOR: "." + cssClasses$m.ROW_CHECKBOX,
    ROW_SELECTED_SELECTOR: "." + cssClasses$m.ROW_SELECTED,
    ROW_SELECTOR: "." + cssClasses$m.ROW,
};
var events = {
    ROW_SELECTION_CHANGED: 'MDCDataTable:rowSelectionChanged',
    SELECTED_ALL: 'MDCDataTable:selectedAll',
    UNSELECTED_ALL: 'MDCDataTable:unselectedAll',
};
//# sourceMappingURL=constants.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCDataTableFoundation = /** @class */ (function (_super) {
    __extends(MDCDataTableFoundation, _super);
    function MDCDataTableFoundation(adapter) {
        return _super.call(this, __assign({}, MDCDataTableFoundation.defaultAdapter, adapter)) || this;
    }
    Object.defineProperty(MDCDataTableFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClassAtRowIndex: function () { return undefined; },
                getRowCount: function () { return 0; },
                getRowElements: function () { return []; },
                getRowIdAtIndex: function () { return ''; },
                getRowIndexByChildElement: function () { return 0; },
                getSelectedRowCount: function () { return 0; },
                isCheckboxAtRowIndexChecked: function () { return false; },
                isHeaderRowCheckboxChecked: function () { return false; },
                isRowsSelectable: function () { return false; },
                notifyRowSelectionChanged: function () { return undefined; },
                notifySelectedAll: function () { return undefined; },
                notifyUnselectedAll: function () { return undefined; },
                registerHeaderRowCheckbox: function () { return undefined; },
                registerRowCheckboxes: function () { return undefined; },
                removeClassAtRowIndex: function () { return undefined; },
                setAttributeAtRowIndex: function () { return undefined; },
                setHeaderRowCheckboxChecked: function () { return undefined; },
                setHeaderRowCheckboxIndeterminate: function () { return undefined; },
                setRowCheckboxCheckedAtIndex: function () { return undefined; },
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is synchronous.
     */
    MDCDataTableFoundation.prototype.layout = function () {
        if (this.adapter_.isRowsSelectable()) {
            this.adapter_.registerHeaderRowCheckbox();
            this.adapter_.registerRowCheckboxes();
            this.setHeaderRowCheckboxState_();
        }
    };
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is asynchronous.
     */
    MDCDataTableFoundation.prototype.layoutAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.adapter_.isRowsSelectable()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.adapter_.registerHeaderRowCheckbox()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.adapter_.registerRowCheckboxes()];
                    case 2:
                        _a.sent();
                        this.setHeaderRowCheckboxState_();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @return Returns array of row elements.
     */
    MDCDataTableFoundation.prototype.getRows = function () {
        return this.adapter_.getRowElements();
    };
    /**
     * Sets selected row ids. Overwrites previously selected rows.
     * @param rowIds Array of row ids that needs to be selected.
     */
    MDCDataTableFoundation.prototype.setSelectedRowIds = function (rowIds) {
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
            var isSelected = false;
            if (rowId && rowIds.indexOf(rowId) >= 0) {
                isSelected = true;
            }
            this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
            this.selectRowAtIndex_(rowIndex, isSelected);
        }
        this.setHeaderRowCheckboxState_();
    };
    /**
     * @return Returns array of selected row ids.
     */
    MDCDataTableFoundation.prototype.getSelectedRowIds = function () {
        var selectedRowIds = [];
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            if (this.adapter_.isCheckboxAtRowIndexChecked(rowIndex)) {
                selectedRowIds.push(this.adapter_.getRowIdAtIndex(rowIndex));
            }
        }
        return selectedRowIds;
    };
    /**
     * Handles header row checkbox change event.
     */
    MDCDataTableFoundation.prototype.handleHeaderRowCheckboxChange = function () {
        var isHeaderChecked = this.adapter_.isHeaderRowCheckboxChecked();
        for (var rowIndex = 0; rowIndex < this.adapter_.getRowCount(); rowIndex++) {
            this.adapter_.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
            this.selectRowAtIndex_(rowIndex, isHeaderChecked);
        }
        if (isHeaderChecked) {
            this.adapter_.notifySelectedAll();
        }
        else {
            this.adapter_.notifyUnselectedAll();
        }
    };
    /**
     * Handles change event originated from row checkboxes.
     */
    MDCDataTableFoundation.prototype.handleRowCheckboxChange = function (event) {
        var rowIndex = this.adapter_.getRowIndexByChildElement(event.target);
        if (rowIndex === -1) {
            return;
        }
        var selected = this.adapter_.isCheckboxAtRowIndexChecked(rowIndex);
        this.selectRowAtIndex_(rowIndex, selected);
        this.setHeaderRowCheckboxState_();
        var rowId = this.adapter_.getRowIdAtIndex(rowIndex);
        this.adapter_.notifyRowSelectionChanged({ rowId: rowId, rowIndex: rowIndex, selected: selected });
    };
    /**
     * Updates header row checkbox state based on number of rows selected.
     */
    MDCDataTableFoundation.prototype.setHeaderRowCheckboxState_ = function () {
        if (this.adapter_.getSelectedRowCount() === this.adapter_.getRowCount()) {
            this.adapter_.setHeaderRowCheckboxChecked(true);
            this.adapter_.setHeaderRowCheckboxIndeterminate(false);
        }
        else if (this.adapter_.getSelectedRowCount() === 0) {
            this.adapter_.setHeaderRowCheckboxIndeterminate(false);
            this.adapter_.setHeaderRowCheckboxChecked(false);
        }
        else {
            this.adapter_.setHeaderRowCheckboxIndeterminate(true);
            this.adapter_.setHeaderRowCheckboxChecked(false);
        }
    };
    /**
     * Sets the attributes of row element based on selection state.
     */
    MDCDataTableFoundation.prototype.selectRowAtIndex_ = function (rowIndex, selected) {
        if (selected) {
            this.adapter_.addClassAtRowIndex(rowIndex, cssClasses$m.ROW_SELECTED);
            this.adapter_.setAttributeAtRowIndex(rowIndex, strings$p.ARIA_SELECTED, 'true');
        }
        else {
            this.adapter_.removeClassAtRowIndex(rowIndex, cssClasses$m.ROW_SELECTED);
            this.adapter_.setAttributeAtRowIndex(rowIndex, strings$p.ARIA_SELECTED, 'false');
        }
    };
    return MDCDataTableFoundation;
}(MDCFoundation));
//# sourceMappingURL=foundation.js.map

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCDataTable = /** @class */ (function (_super) {
    __extends(MDCDataTable, _super);
    function MDCDataTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCDataTable.attachTo = function (root) {
        return new MDCDataTable(root);
    };
    MDCDataTable.prototype.initialize = function (checkboxFactory) {
        if (checkboxFactory === void 0) { checkboxFactory = function (el) { return new MDCCheckbox(el); }; }
        this.checkboxFactory_ = checkboxFactory;
    };
    MDCDataTable.prototype.initialSyncWithDOM = function () {
        var _this = this;
        this.headerRow_ = this.root_.querySelector("." + cssClasses$m.HEADER_ROW);
        this.handleHeaderRowCheckboxChange_ = function () { return _this.foundation_.handleHeaderRowCheckboxChange(); };
        this.headerRow_.addEventListener('change', this.handleHeaderRowCheckboxChange_);
        this.content_ = this.root_.querySelector("." + cssClasses$m.CONTENT);
        this.handleRowCheckboxChange_ = function (event) { return _this.foundation_.handleRowCheckboxChange(event); };
        this.content_.addEventListener('change', this.handleRowCheckboxChange_);
        this.layout();
    };
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     */
    MDCDataTable.prototype.layout = function () {
        this.foundation_.layout();
    };
    /**
     * @return Returns array of row elements.
     */
    MDCDataTable.prototype.getRows = function () {
        return this.foundation_.getRows();
    };
    /**
     * @return Returns array of selected row ids.
     */
    MDCDataTable.prototype.getSelectedRowIds = function () {
        return this.foundation_.getSelectedRowIds();
    };
    /**
     * Sets selected row ids. Overwrites previously selected rows.
     * @param rowIds Array of row ids that needs to be selected.
     */
    MDCDataTable.prototype.setSelectedRowIds = function (rowIds) {
        this.foundation_.setSelectedRowIds(rowIds);
    };
    MDCDataTable.prototype.destroy = function () {
        this.headerRow_.removeEventListener('change', this.handleHeaderRowCheckboxChange_);
        this.content_.removeEventListener('change', this.handleRowCheckboxChange_);
        this.headerRowCheckbox_.destroy();
        this.rowCheckboxList_.forEach(function (checkbox) { return checkbox.destroy(); });
    };
    MDCDataTable.prototype.getDefaultFoundation = function () {
        var _this = this;
        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.
        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.
        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
        var adapter = {
            addClassAtRowIndex: function (rowIndex, className) { return _this.getRows()[rowIndex].classList.add(className); },
            getRowCount: function () { return _this.getRows().length; },
            getRowElements: function () { return [].slice.call(_this.root_.querySelectorAll(strings$p.ROW_SELECTOR)); },
            getRowIdAtIndex: function (rowIndex) { return _this.getRows()[rowIndex].getAttribute(strings$p.DATA_ROW_ID_ATTR); },
            getRowIndexByChildElement: function (el) {
                return _this.getRows().indexOf(closest(el, strings$p.ROW_SELECTOR));
            },
            getSelectedRowCount: function () { return _this.root_.querySelectorAll(strings$p.ROW_SELECTED_SELECTOR).length; },
            isCheckboxAtRowIndexChecked: function (rowIndex) { return _this.rowCheckboxList_[rowIndex].checked; },
            isHeaderRowCheckboxChecked: function () { return _this.headerRowCheckbox_.checked; },
            isRowsSelectable: function () { return !!_this.root_.querySelector(strings$p.ROW_CHECKBOX_SELECTOR); },
            notifyRowSelectionChanged: function (data) {
                _this.emit(events.ROW_SELECTION_CHANGED, {
                    row: _this.getRowByIndex_(data.rowIndex),
                    rowId: _this.getRowIdByIndex_(data.rowIndex),
                    rowIndex: data.rowIndex,
                    selected: data.selected,
                }, 
                /** shouldBubble */ true);
            },
            notifySelectedAll: function () { return _this.emit(events.SELECTED_ALL, {}, /** shouldBubble */ true); },
            notifyUnselectedAll: function () { return _this.emit(events.UNSELECTED_ALL, {}, /** shouldBubble */ true); },
            registerHeaderRowCheckbox: function () {
                if (_this.headerRowCheckbox_) {
                    _this.headerRowCheckbox_.destroy();
                }
                var checkboxEl = _this.root_.querySelector(strings$p.HEADER_ROW_CHECKBOX_SELECTOR);
                _this.headerRowCheckbox_ = _this.checkboxFactory_(checkboxEl);
            },
            registerRowCheckboxes: function () {
                if (_this.rowCheckboxList_) {
                    _this.rowCheckboxList_.forEach(function (checkbox) { return checkbox.destroy(); });
                }
                _this.rowCheckboxList_ = [];
                _this.getRows().forEach(function (rowEl) {
                    var checkbox = _this.checkboxFactory_(rowEl.querySelector(strings$p.ROW_CHECKBOX_SELECTOR));
                    _this.rowCheckboxList_.push(checkbox);
                });
            },
            removeClassAtRowIndex: function (rowIndex, className) {
                _this.getRows()[rowIndex].classList.remove(className);
            },
            setAttributeAtRowIndex: function (rowIndex, attr, value) {
                _this.getRows()[rowIndex].setAttribute(attr, value);
            },
            setHeaderRowCheckboxChecked: function (checked) {
                _this.headerRowCheckbox_.checked = checked;
            },
            setHeaderRowCheckboxIndeterminate: function (indeterminate) {
                _this.headerRowCheckbox_.indeterminate = indeterminate;
            },
            setRowCheckboxCheckedAtIndex: function (rowIndex, checked) {
                _this.rowCheckboxList_[rowIndex].checked = checked;
            },
        };
        return new MDCDataTableFoundation(adapter);
    };
    MDCDataTable.prototype.getRowByIndex_ = function (index) {
        return this.getRows()[index];
    };
    MDCDataTable.prototype.getRowIdByIndex_ = function (index) {
        return this.getRowByIndex_(index).getAttribute(strings$p.DATA_ROW_ID_ATTR);
    };
    return MDCDataTable;
}(MDCComponent));
//# sourceMappingURL=component.js.map

/* node_modules\@smui\data-table\DataTable.svelte generated by Svelte v3.31.2 */

const { Error: Error_1$2 } = globals;
const file$R = "node_modules\\@smui\\data-table\\DataTable.svelte";

function create_fragment$X(ctx) {
	let div;
	let table;
	let table_class_value;
	let useActions_action;
	let div_class_value;
	let useActions_action_1;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	let table_levels = [
		{
			class: table_class_value = "mdc-data-table__table " + /*table$class*/ ctx[3]
		},
		prefixFilter(/*$$props*/ ctx[7], "table$")
	];

	let table_data = {};

	for (let i = 0; i < table_levels.length; i += 1) {
		table_data = assign(table_data, table_levels[i]);
	}

	let div_levels = [
		{
			class: div_class_value = "mdc-data-table " + /*className*/ ctx[1]
		},
		exclude(/*$$props*/ ctx[7], ["use", "class", "table$"])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			table = element("table");
			if (default_slot) default_slot.c();
			set_attributes(table, table_data);
			add_location(table, file$R, 10, 2, 308);
			set_attributes(div, div_data);
			add_location(div, file$R, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, table);

			if (default_slot) {
				default_slot.m(table, null);
			}

			/*div_binding*/ ctx[14](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, table, /*table$use*/ ctx[2])),
					action_destroyer(useActions_action_1 = useActions.call(null, div, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[5].call(null, div)),
					listen_dev(div, "MDCDataTable:rowSelectionChanged", /*handleChange*/ ctx[6], false, false, false),
					listen_dev(div, "MDCDataTable:selectedAll", /*handleChange*/ ctx[6], false, false, false),
					listen_dev(div, "MDCDataTable:unselectedAll", /*handleChange*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			set_attributes(table, table_data = get_spread_update(table_levels, [
				(!current || dirty & /*table$class*/ 8 && table_class_value !== (table_class_value = "mdc-data-table__table " + /*table$class*/ ctx[3])) && { class: table_class_value },
				dirty & /*$$props*/ 128 && prefixFilter(/*$$props*/ ctx[7], "table$")
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*table$use*/ 4) useActions_action.update.call(null, /*table$use*/ ctx[2]);

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "mdc-data-table " + /*className*/ ctx[1])) && { class: div_class_value },
				dirty & /*$$props*/ 128 && exclude(/*$$props*/ ctx[7], ["use", "class", "table$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DataTable", slots, ['default']);

	if (events.ROW_SELECTION_CHANGED !== "MDCDataTable:rowSelectionChanged" || events.SELECTED_ALL !== "MDCDataTable:selectedAll" || events.UNSELECTED_ALL !== "MDCDataTable:unselectedAll") {
		throw new Error("MDC API has changed!");
	}

	const forwardEvents = forwardEventsBuilder(get_current_component(), [
		"MDCDataTable:rowSelectionChanged",
		"MDCDataTable:selectedAll",
		"MDCDataTable:unselectedAll"
	]);

	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { table$use = [] } = $$props;
	let { table$class = "" } = $$props;
	let element;
	let dataTable;
	let changeHandlers = [];
	let checkBoxHeaderPromiseResolve;
	let checkBoxHeaderPromise = new Promise(resolve => checkBoxHeaderPromiseResolve = resolve);
	let checkBoxListPromiseResolve;
	let checkBoxListPromise = new Promise(resolve => checkBoxListPromiseResolve = resolve);
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;
	setContext("SMUI:generic:input:addChangeHandler", addChangeHandler);
	setContext("SMUI:checkbox:context", "data-table");
	setContext("SMUI:checkbox:instantiate", false);
	setContext("SMUI:checkbox:getInstance", getCheckboxInstancePromise);

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	onMount(async () => {
		dataTable = new MDCDataTable(element);
		checkBoxHeaderPromiseResolve(dataTable.headerRowCheckbox_);
		checkBoxListPromiseResolve(dataTable.rowCheckboxList_);

		// Workaround for a bug in MDC DataTable where a table with no checkboxes
		// calls destroy on them anyway.
		if (!dataTable.headerRowCheckbox_) {
			dataTable.headerRowCheckbox_ = {
				destroy() {
					
				}
			};
		}

		if (!dataTable.rowCheckboxList_) {
			dataTable.rowCheckboxList_ = [];
		}
	});

	onDestroy(() => {
		dataTable && dataTable.destroy();

		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function getCheckboxInstancePromise(header) {
		return header ? checkBoxHeaderPromise : checkBoxListPromise;
	}

	function handleChange() {
		for (let i = 0; i < changeHandlers.length; i++) {
			changeHandlers[i]();
		}
	}

	function addChangeHandler(handler) {
		changeHandlers.push(handler);
	}

	function layout(...args) {
		return dataTable.layout(...args);
	}

	function getRows(...args) {
		return dataTable.getRows(...args);
	}

	function getSelectedRowIds(...args) {
		return dataTable.getSelectedRowIds(...args);
	}

	function setSelectedRowIds(...args) {
		return dataTable.setSelectedRowIds(...args);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("table$use" in $$new_props) $$invalidate(2, table$use = $$new_props.table$use);
		if ("table$class" in $$new_props) $$invalidate(3, table$class = $$new_props.table$class);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCDataTable,
		events,
		onMount,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		table$use,
		table$class,
		element,
		dataTable,
		changeHandlers,
		checkBoxHeaderPromiseResolve,
		checkBoxHeaderPromise,
		checkBoxListPromiseResolve,
		checkBoxListPromise,
		addLayoutListener,
		removeLayoutListener,
		getCheckboxInstancePromise,
		handleChange,
		addChangeHandler,
		layout,
		getRows,
		getSelectedRowIds,
		setSelectedRowIds
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("table$use" in $$props) $$invalidate(2, table$use = $$new_props.table$use);
		if ("table$class" in $$props) $$invalidate(3, table$class = $$new_props.table$class);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("dataTable" in $$props) dataTable = $$new_props.dataTable;
		if ("changeHandlers" in $$props) changeHandlers = $$new_props.changeHandlers;
		if ("checkBoxHeaderPromiseResolve" in $$props) checkBoxHeaderPromiseResolve = $$new_props.checkBoxHeaderPromiseResolve;
		if ("checkBoxHeaderPromise" in $$props) checkBoxHeaderPromise = $$new_props.checkBoxHeaderPromise;
		if ("checkBoxListPromiseResolve" in $$props) checkBoxListPromiseResolve = $$new_props.checkBoxListPromiseResolve;
		if ("checkBoxListPromise" in $$props) checkBoxListPromise = $$new_props.checkBoxListPromise;
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		table$use,
		table$class,
		element,
		forwardEvents,
		handleChange,
		$$props,
		layout,
		getRows,
		getSelectedRowIds,
		setSelectedRowIds,
		$$scope,
		slots,
		div_binding
	];
}

class DataTable extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
			use: 0,
			class: 1,
			table$use: 2,
			table$class: 3,
			layout: 8,
			getRows: 9,
			getSelectedRowIds: 10,
			setSelectedRowIds: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DataTable",
			options,
			id: create_fragment$X.name
		});
	}

	get use() {
		throw new Error_1$2("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error_1$2("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table$use() {
		throw new Error_1$2("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table$use(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table$class() {
		throw new Error_1$2("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table$class(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[8];
	}

	set layout(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getRows() {
		return this.$$.ctx[9];
	}

	set getRows(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getSelectedRowIds() {
		return this.$$.ctx[10];
	}

	set getSelectedRowIds(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setSelectedRowIds() {
		return this.$$.ctx[11];
	}

	set setSelectedRowIds(value) {
		throw new Error_1$2("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Head.svelte generated by Svelte v3.31.2 */
const file$S = "node_modules\\@smui\\data-table\\Head.svelte";

function create_fragment$Y(ctx) {
	let thead;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let thead_levels = [exclude(/*$$props*/ ctx[2], ["use"])];
	let thead_data = {};

	for (let i = 0; i < thead_levels.length; i += 1) {
		thead_data = assign(thead_data, thead_levels[i]);
	}

	const block = {
		c: function create() {
			thead = element("thead");
			if (default_slot) default_slot.c();
			set_attributes(thead, thead_data);
			add_location(thead, file$S, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, thead, anchor);

			if (default_slot) {
				default_slot.m(thead, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, thead, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[1].call(null, thead))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$props*/ 4 && exclude(/*$$props*/ ctx[2], ["use"])]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(thead);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Head", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	setContext("SMUI:data-table:row:header", true);

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, forwardEvents, $$props, $$scope, slots];
}

class Head extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Head",
			options,
			id: create_fragment$Y.name
		});
	}

	get use() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Body.svelte generated by Svelte v3.31.2 */
const file$T = "node_modules\\@smui\\data-table\\Body.svelte";

function create_fragment$Z(ctx) {
	let tbody;
	let tbody_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let tbody_levels = [
		{
			class: tbody_class_value = "mdc-data-table__content " + /*className*/ ctx[1]
		},
		exclude(/*$$props*/ ctx[3], ["use", "class"])
	];

	let tbody_data = {};

	for (let i = 0; i < tbody_levels.length; i += 1) {
		tbody_data = assign(tbody_data, tbody_levels[i]);
	}

	const block = {
		c: function create() {
			tbody = element("tbody");
			if (default_slot) default_slot.c();
			set_attributes(tbody, tbody_data);
			add_location(tbody, file$T, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, tbody, anchor);

			if (default_slot) {
				default_slot.m(tbody, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, tbody, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[2].call(null, tbody))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
				(!current || dirty & /*className*/ 2 && tbody_class_value !== (tbody_class_value = "mdc-data-table__content " + /*className*/ ctx[1])) && { class: tbody_class_value },
				dirty & /*$$props*/ 8 && exclude(/*$$props*/ ctx[3], ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tbody);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Z($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Body", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	setContext("SMUI:data-table:row:header", false);

	$$self.$$set = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [use, className, forwardEvents, $$props, $$scope, slots];
}

class Body extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { use: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Body",
			options,
			id: create_fragment$Z.name
		});
	}

	get use() {
		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Row.svelte generated by Svelte v3.31.2 */
const file$U = "node_modules\\@smui\\data-table\\Row.svelte";

function create_fragment$_(ctx) {
	let tr;
	let tr_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let tr_levels = [
		{
			class: tr_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*header*/ ctx[5] ? "mdc-data-table__header-row" : "") + "\n    " + (!/*header*/ ctx[5] ? "mdc-data-table__row" : "") + "\n    " + (!/*header*/ ctx[5] && /*selected*/ ctx[3]
			? "mdc-data-table__row--selected"
			: "") + "\n  "
		},
		/*selected*/ ctx[3] !== undefined
		? {
				"aria-selected": /*selected*/ ctx[3] ? "true" : "false"
			}
		: {},
		exclude(/*$$props*/ ctx[6], ["use", "class"])
	];

	let tr_data = {};

	for (let i = 0; i < tr_levels.length; i += 1) {
		tr_data = assign(tr_data, tr_levels[i]);
	}

	const block = {
		c: function create() {
			tr = element("tr");
			if (default_slot) default_slot.c();
			set_attributes(tr, tr_data);
			add_location(tr, file$U, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			/*tr_binding*/ ctx[9](tr);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, tr, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[4].call(null, tr))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(tr, tr_data = get_spread_update(tr_levels, [
				(!current || dirty & /*className, selected*/ 10 && tr_class_value !== (tr_class_value = "\n    " + /*className*/ ctx[1] + "\n    " + (/*header*/ ctx[5] ? "mdc-data-table__header-row" : "") + "\n    " + (!/*header*/ ctx[5] ? "mdc-data-table__row" : "") + "\n    " + (!/*header*/ ctx[5] && /*selected*/ ctx[3]
				? "mdc-data-table__row--selected"
				: "") + "\n  ")) && { class: tr_class_value },
				dirty & /*selected*/ 8 && (/*selected*/ ctx[3] !== undefined
				? {
						"aria-selected": /*selected*/ ctx[3] ? "true" : "false"
					}
				: {}),
				dirty & /*$$props*/ 64 && exclude(/*$$props*/ ctx[6], ["use", "class"])
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if (default_slot) default_slot.d(detaching);
			/*tr_binding*/ ctx[9](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Row", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let header = getContext("SMUI:data-table:row:header");
	let selected = undefined;
	setContext("SMUI:data-table:row:getIndex", getIndex);
	setContext("SMUI:generic:input:setChecked", setChecked);

	function setChecked(checked) {
		$$invalidate(3, selected = checked);
	}

	function getIndex() {
		let i = 0;

		if (element) {
			let el = element;

			while (el.previousSibling) {
				el = el.previousSibling;

				if (el.nodeType === 1) {
					i++;
				}
			}
		}

		return i;
	}

	function tr_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		use,
		className,
		element,
		header,
		selected,
		setChecked,
		getIndex
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("header" in $$props) $$invalidate(5, header = $$new_props.header);
		if ("selected" in $$props) $$invalidate(3, selected = $$new_props.selected);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		element,
		selected,
		forwardEvents,
		header,
		$$props,
		$$scope,
		slots,
		tr_binding
	];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$_, create_fragment$_, safe_not_equal, { use: 0, class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$_.name
		});
	}

	get use() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Cell.svelte generated by Svelte v3.31.2 */
const file$V = "node_modules\\@smui\\data-table\\Cell.svelte";

// (14:0) {:else}
function create_else_block$9(ctx) {
	let td;
	let td_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let td_levels = [
		{
			class: td_class_value = "\n      mdc-data-table__cell\n      " + /*className*/ ctx[1] + "\n      " + (/*numeric*/ ctx[2]
			? "mdc-data-table__cell--numeric"
			: "") + "\n      " + (/*checkbox*/ ctx[3]
			? "mdc-data-table__cell--checkbox"
			: "") + "\n    "
		},
		/*roleProp*/ ctx[5],
		/*scopeProp*/ ctx[6],
		/*props*/ ctx[4]
	];

	let td_data = {};

	for (let i = 0; i < td_levels.length; i += 1) {
		td_data = assign(td_data, td_levels[i]);
	}

	const block = {
		c: function create() {
			td = element("td");
			if (default_slot) default_slot.c();
			set_attributes(td, td_data);
			add_location(td, file$V, 14, 2, 284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);

			if (default_slot) {
				default_slot.m(td, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, td, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, td))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(td, td_data = get_spread_update(td_levels, [
				(!current || dirty & /*className, numeric, checkbox*/ 14 && td_class_value !== (td_class_value = "\n      mdc-data-table__cell\n      " + /*className*/ ctx[1] + "\n      " + (/*numeric*/ ctx[2]
				? "mdc-data-table__cell--numeric"
				: "") + "\n      " + (/*checkbox*/ ctx[3]
				? "mdc-data-table__cell--checkbox"
				: "") + "\n    ")) && { class: td_class_value },
				dirty & /*roleProp*/ 32 && /*roleProp*/ ctx[5],
				dirty & /*scopeProp*/ 64 && /*scopeProp*/ ctx[6],
				dirty & /*props*/ 16 && /*props*/ ctx[4]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$9.name,
		type: "else",
		source: "(14:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if header}
function create_if_block$h(ctx) {
	let th;
	let th_class_value;
	let useActions_action;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let th_levels = [
		{
			class: th_class_value = "\n      mdc-data-table__header-cell\n      " + /*className*/ ctx[1] + "\n      " + (/*checkbox*/ ctx[3]
			? "mdc-data-table__header-cell--checkbox"
			: "") + "\n    "
		},
		/*roleProp*/ ctx[5],
		/*scopeProp*/ ctx[6],
		/*props*/ ctx[4]
	];

	let th_data = {};

	for (let i = 0; i < th_levels.length; i += 1) {
		th_data = assign(th_data, th_levels[i]);
	}

	const block = {
		c: function create() {
			th = element("th");
			if (default_slot) default_slot.c();
			set_attributes(th, th_data);
			add_location(th, file$V, 1, 2, 15);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);

			if (default_slot) {
				default_slot.m(th, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, th, /*use*/ ctx[0])),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, th))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(th, th_data = get_spread_update(th_levels, [
				(!current || dirty & /*className, checkbox*/ 10 && th_class_value !== (th_class_value = "\n      mdc-data-table__header-cell\n      " + /*className*/ ctx[1] + "\n      " + (/*checkbox*/ ctx[3]
				? "mdc-data-table__header-cell--checkbox"
				: "") + "\n    ")) && { class: th_class_value },
				dirty & /*roleProp*/ 32 && /*roleProp*/ ctx[5],
				dirty & /*scopeProp*/ 64 && /*scopeProp*/ ctx[6],
				dirty & /*props*/ 16 && /*props*/ ctx[4]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(1:0) {#if header}",
		ctx
	});

	return block;
}

function create_fragment$$(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$h, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*header*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$$($$self, $$props, $$invalidate) {
	let props;
	let roleProp;
	let scopeProp;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Cell", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let header = getContext("SMUI:data-table:row:header");
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { role = header ? "columnheader" : undefined } = $$props;
	let { scope = header ? "col" : undefined } = $$props;
	let { numeric = false } = $$props;
	let { checkbox = false } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("role" in $$new_props) $$invalidate(9, role = $$new_props.role);
		if ("scope" in $$new_props) $$invalidate(10, scope = $$new_props.scope);
		if ("numeric" in $$new_props) $$invalidate(2, numeric = $$new_props.numeric);
		if ("checkbox" in $$new_props) $$invalidate(3, checkbox = $$new_props.checkbox);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		exclude,
		useActions,
		forwardEvents,
		header,
		use,
		className,
		role,
		scope,
		numeric,
		checkbox,
		props,
		roleProp,
		scopeProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("header" in $$props) $$invalidate(8, header = $$new_props.header);
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("role" in $$props) $$invalidate(9, role = $$new_props.role);
		if ("scope" in $$props) $$invalidate(10, scope = $$new_props.scope);
		if ("numeric" in $$props) $$invalidate(2, numeric = $$new_props.numeric);
		if ("checkbox" in $$props) $$invalidate(3, checkbox = $$new_props.checkbox);
		if ("props" in $$props) $$invalidate(4, props = $$new_props.props);
		if ("roleProp" in $$props) $$invalidate(5, roleProp = $$new_props.roleProp);
		if ("scopeProp" in $$props) $$invalidate(6, scopeProp = $$new_props.scopeProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, props = exclude($$props, ["use", "class", "numeric", "checkbox"]));

		if ($$self.$$.dirty & /*role*/ 512) {
			 $$invalidate(5, roleProp = role ? { role } : {});
		}

		if ($$self.$$.dirty & /*scope*/ 1024) {
			 $$invalidate(6, scopeProp = scope ? { scope } : {});
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		numeric,
		checkbox,
		props,
		roleProp,
		scopeProp,
		forwardEvents,
		header,
		role,
		scope,
		$$scope,
		slots
	];
}

class Cell extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			use: 0,
			class: 1,
			role: 9,
			scope: 10,
			numeric: 2,
			checkbox: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cell",
			options,
			id: create_fragment$$.name
		});
	}

	get use() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get role() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set role(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scope() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scope(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get numeric() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set numeric(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checkbox() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checkbox(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\components\FrequencyTable.svelte generated by Svelte v3.31.2 */

const { console: console_1$5 } = globals;
const file$W = "src\\Pages\\normline\\components\\FrequencyTable.svelte";

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_3$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	return child_ctx;
}

// (50:20) <Cell>
function create_default_slot_31(ctx) {
	let t_value = /*item*/ ctx[21] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_31.name,
		type: "slot",
		source: "(50:20) <Cell>",
		ctx
	});

	return block;
}

// (49:16) {#each dataTableHead as item}
function create_each_block_3$1(ctx) {
	let cell;
	let current;

	cell = new Cell({
			props: {
				$$slots: { default: [create_default_slot_31] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cell, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				cell_changes.$$scope = { dirty, ctx };
			}

			cell.$set(cell_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$1.name,
		type: "each",
		source: "(49:16) {#each dataTableHead as item}",
		ctx
	});

	return block;
}

// (47:12) <Row>
function create_default_slot_30(ctx) {
	let cell0;
	let t0;
	let t1;
	let cell1;
	let current;

	cell0 = new Cell({
			props: { style: "width: 2em;" },
			$$inline: true
		});

	let each_value_3 = /*dataTableHead*/ ctx[6];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	cell1 = new Cell({
			props: { style: "width: 2em;" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			create_component(cell1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t1, anchor);
			mount_component(cell1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTableHead*/ 64) {
				each_value_3 = /*dataTableHead*/ ctx[6];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t1.parentNode, t1);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(cell1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(cell1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_30.name,
		type: "slot",
		source: "(47:12) <Row>",
		ctx
	});

	return block;
}

// (46:8) <Head >
function create_default_slot_29(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_30] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_29.name,
		type: "slot",
		source: "(46:8) <Head >",
		ctx
	});

	return block;
}

// (86:12) {:else}
function create_else_block$a(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value_2 = /*$dataTable*/ ctx[3];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*table*/ ctx[16].id;
	validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable, window*/ 8) {
				each_value_2 = /*$dataTable*/ ctx[3];
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2$1, each_1_anchor, get_each_context_2$1);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$a.name,
		type: "else",
		source: "(86:12) {:else}",
		ctx
	});

	return block;
}

// (71:93) 
function create_if_block_1$7(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value_1 = /*$dataTable_avg*/ ctx[2];
	validate_each_argument(each_value_1);
	const get_key = ctx => /*table*/ ctx[16].id;
	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg, window*/ 4) {
				each_value_1 = /*$dataTable_avg*/ ctx[2];
				validate_each_argument(each_value_1);
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$1, each_1_anchor, get_each_context_1$1);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(71:93) ",
		ctx
	});

	return block;
}

// (56:12) {#if show_dataTable_only_weighted_averaged}
function create_if_block$i(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*dataTable_weighted_avg*/ ctx[1];
	validate_each_argument(each_value);
	const get_key = ctx => /*table*/ ctx[16].id;
	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$5(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg, window*/ 2) {
				each_value = /*dataTable_weighted_avg*/ ctx[1];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$5, each_1_anchor, get_each_context$5);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(56:12) {#if show_dataTable_only_weighted_averaged}",
		ctx
	});

	return block;
}

// (90:24) <Cell style="width: 2em;">
function create_default_slot_28(ctx) {
	let t_value = /*index*/ ctx[18] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_28.name,
		type: "slot",
		source: "(90:24) <Cell style=\\\"width: 2em;\\\">",
		ctx
	});

	return block;
}

// (91:24) <Cell>
function create_default_slot_27(ctx) {
	let t_value = /*table*/ ctx[16].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_27.name,
		type: "slot",
		source: "(91:24) <Cell>",
		ctx
	});

	return block;
}

// (92:24) <Cell>
function create_default_slot_26(ctx) {
	let t_value = /*table*/ ctx[16].freq + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_26.name,
		type: "slot",
		source: "(92:24) <Cell>",
		ctx
	});

	return block;
}

// (93:24) <Cell>
function create_default_slot_25(ctx) {
	let t_value = /*table*/ ctx[16].amp + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_25.name,
		type: "slot",
		source: "(93:24) <Cell>",
		ctx
	});

	return block;
}

// (94:24) <Cell>
function create_default_slot_24(ctx) {
	let t_value = /*table*/ ctx[16].fwhm + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_24.name,
		type: "slot",
		source: "(94:24) <Cell>",
		ctx
	});

	return block;
}

// (95:24) <Cell>
function create_default_slot_23(ctx) {
	let t_value = /*table*/ ctx[16].sig + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable*/ 8 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_23.name,
		type: "slot",
		source: "(95:24) <Cell>",
		ctx
	});

	return block;
}

// (97:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {$dataTable = window._.filter($dataTable, (tb)=>tb.id != e.target.id)}}">
function create_default_slot_22(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(97:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {$dataTable = window._.filter($dataTable, (tb)=>tb.id != e.target.id)}}\\\">",
		ctx
	});

	return block;
}

// (96:24) <Cell style="background: #f14668; cursor: pointer;">
function create_default_slot_21(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				id: /*table*/ ctx[16].id,
				class: "material-icons",
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*click_handler_2*/ ctx[13]);

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$dataTable*/ 8) icon_changes.id = /*table*/ ctx[16].id;

			if (dirty & /*$$scope*/ 16777216) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(96:24) <Cell style=\\\"background: #f14668; cursor: pointer;\\\">",
		ctx
	});

	return block;
}

// (89:20) <Row style="background-color: {table.color};" class={table.className}>
function create_default_slot_20(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let cell5;
	let t5;
	let cell6;
	let t6;
	let current;

	cell0 = new Cell({
			props: {
				style: "width: 2em;",
				$$slots: { default: [create_default_slot_28] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_27] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_26] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_25] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_24] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell5 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_23] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell6 = new Cell({
			props: {
				style: "background: #f14668; cursor: pointer;",
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
			create_component(cell5.$$.fragment);
			t5 = space();
			create_component(cell6.$$.fragment);
			t6 = space();
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(cell5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(cell6, target, anchor);
			insert_dev(target, t6, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
			const cell5_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell5_changes.$$scope = { dirty, ctx };
			}

			cell5.$set(cell5_changes);
			const cell6_changes = {};

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				cell6_changes.$$scope = { dirty, ctx };
			}

			cell6.$set(cell6_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			transition_in(cell5.$$.fragment, local);
			transition_in(cell6.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			transition_out(cell5.$$.fragment, local);
			transition_out(cell6.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(cell5, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(cell6, detaching);
			if (detaching) detach_dev(t6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(89:20) <Row style=\\\"background-color: {table.color};\\\" class={table.className}>",
		ctx
	});

	return block;
}

// (88:16) {#each $dataTable as table, index (table.id)}
function create_each_block_2$1(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				style: "background-color: " + /*table*/ ctx[16].color + ";",
				class: /*table*/ ctx[16].className,
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};
			if (dirty & /*$dataTable*/ 8) row_changes.style = "background-color: " + /*table*/ ctx[16].color + ";";
			if (dirty & /*$dataTable*/ 8) row_changes.class = /*table*/ ctx[16].className;

			if (dirty & /*$$scope, $dataTable*/ 16777224) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$1.name,
		type: "each",
		source: "(88:16) {#each $dataTable as table, index (table.id)}",
		ctx
	});

	return block;
}

// (74:24) <Cell style="width: 2em;">
function create_default_slot_19(ctx) {
	let t_value = /*index*/ ctx[18] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(74:24) <Cell style=\\\"width: 2em;\\\">",
		ctx
	});

	return block;
}

// (75:24) <Cell>
function create_default_slot_18(ctx) {
	let t_value = /*table*/ ctx[16].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(75:24) <Cell>",
		ctx
	});

	return block;
}

// (76:24) <Cell>
function create_default_slot_17(ctx) {
	let t_value = /*table*/ ctx[16].freq + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(76:24) <Cell>",
		ctx
	});

	return block;
}

// (77:24) <Cell>
function create_default_slot_16(ctx) {
	let t_value = /*table*/ ctx[16].amp + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(77:24) <Cell>",
		ctx
	});

	return block;
}

// (78:24) <Cell>
function create_default_slot_15(ctx) {
	let t_value = /*table*/ ctx[16].fwhm + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(78:24) <Cell>",
		ctx
	});

	return block;
}

// (79:24) <Cell>
function create_default_slot_14(ctx) {
	let t_value = /*table*/ ctx[16].sig + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$dataTable_avg*/ 4 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(79:24) <Cell>",
		ctx
	});

	return block;
}

// (81:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {$dataTable_avg = window._.filter($dataTable_avg, (tb)=>tb.id != e.target.id)}}">
function create_default_slot_13(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(81:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {$dataTable_avg = window._.filter($dataTable_avg, (tb)=>tb.id != e.target.id)}}\\\">",
		ctx
	});

	return block;
}

// (80:24) <Cell style="background: #f14668; cursor: pointer; width: 2em;">
function create_default_slot_12(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				id: /*table*/ ctx[16].id,
				class: "material-icons",
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*click_handler_1*/ ctx[12]);

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$dataTable_avg*/ 4) icon_changes.id = /*table*/ ctx[16].id;

			if (dirty & /*$$scope*/ 16777216) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(80:24) <Cell style=\\\"background: #f14668; cursor: pointer; width: 2em;\\\">",
		ctx
	});

	return block;
}

// (73:20) <Row>
function create_default_slot_11(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let cell5;
	let t5;
	let cell6;
	let t6;
	let current;

	cell0 = new Cell({
			props: {
				style: "width: 2em;",
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell5 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell6 = new Cell({
			props: {
				style: "background: #f14668; cursor: pointer; width: 2em;",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
			create_component(cell5.$$.fragment);
			t5 = space();
			create_component(cell6.$$.fragment);
			t6 = space();
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(cell5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(cell6, target, anchor);
			insert_dev(target, t6, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
			const cell5_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell5_changes.$$scope = { dirty, ctx };
			}

			cell5.$set(cell5_changes);
			const cell6_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				cell6_changes.$$scope = { dirty, ctx };
			}

			cell6.$set(cell6_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			transition_in(cell5.$$.fragment, local);
			transition_in(cell6.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			transition_out(cell5.$$.fragment, local);
			transition_out(cell6.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(cell5, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(cell6, detaching);
			if (detaching) detach_dev(t6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(73:20) <Row>",
		ctx
	});

	return block;
}

// (72:16) {#each $dataTable_avg as table, index (table.id)}
function create_each_block_1$1(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, $dataTable_avg*/ 16777220) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(72:16) {#each $dataTable_avg as table, index (table.id)}",
		ctx
	});

	return block;
}

// (59:24) <Cell style="width: 2em;">
function create_default_slot_10(ctx) {
	let t_value = /*index*/ ctx[18] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*index*/ ctx[18] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(59:24) <Cell style=\\\"width: 2em;\\\">",
		ctx
	});

	return block;
}

// (60:24) <Cell>
function create_default_slot_9(ctx) {
	let t0;
	let t1_value = /*index*/ ctx[18] + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text("Line #");
			t1 = text(t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t1_value !== (t1_value = /*index*/ ctx[18] + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(60:24) <Cell>",
		ctx
	});

	return block;
}

// (61:24) <Cell>
function create_default_slot_8(ctx) {
	let t_value = /*table*/ ctx[16].freq + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].freq + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(61:24) <Cell>",
		ctx
	});

	return block;
}

// (62:24) <Cell>
function create_default_slot_7$1(ctx) {
	let t_value = /*table*/ ctx[16].amp + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].amp + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(62:24) <Cell>",
		ctx
	});

	return block;
}

// (63:24) <Cell>
function create_default_slot_6$2(ctx) {
	let t_value = /*table*/ ctx[16].fwhm + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].fwhm + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(63:24) <Cell>",
		ctx
	});

	return block;
}

// (64:24) <Cell>
function create_default_slot_5$3(ctx) {
	let t_value = /*table*/ ctx[16].sig + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*dataTable_weighted_avg*/ 2 && t_value !== (t_value = /*table*/ ctx[16].sig + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(64:24) <Cell>",
		ctx
	});

	return block;
}

// (66:28) <Icon id="{table.id}" class="material-icons"                                   on:click="{(e)=> {dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, (tb)=>tb.id != e.target.id)}}">
function create_default_slot_4$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$5.name,
		type: "slot",
		source: "(66:28) <Icon id=\\\"{table.id}\\\" class=\\\"material-icons\\\"                                   on:click=\\\"{(e)=> {dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, (tb)=>tb.id != e.target.id)}}\\\">",
		ctx
	});

	return block;
}

// (65:24) <Cell style="background: #f14668; cursor: pointer;">
function create_default_slot_3$6(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				id: /*table*/ ctx[16].id,
				class: "material-icons",
				$$slots: { default: [create_default_slot_4$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*click_handler*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*dataTable_weighted_avg*/ 2) icon_changes.id = /*table*/ ctx[16].id;

			if (dirty & /*$$scope*/ 16777216) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$6.name,
		type: "slot",
		source: "(65:24) <Cell style=\\\"background: #f14668; cursor: pointer;\\\">",
		ctx
	});

	return block;
}

// (58:20) <Row>
function create_default_slot_2$a(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let cell5;
	let t5;
	let cell6;
	let t6;
	let current;

	cell0 = new Cell({
			props: {
				style: "width: 2em;",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell5 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell6 = new Cell({
			props: {
				style: "background: #f14668; cursor: pointer;",
				$$slots: { default: [create_default_slot_3$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
			create_component(cell5.$$.fragment);
			t5 = space();
			create_component(cell6.$$.fragment);
			t6 = space();
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(cell5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(cell6, target, anchor);
			insert_dev(target, t6, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
			const cell5_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell5_changes.$$scope = { dirty, ctx };
			}

			cell5.$set(cell5_changes);
			const cell6_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				cell6_changes.$$scope = { dirty, ctx };
			}

			cell6.$set(cell6_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			transition_in(cell5.$$.fragment, local);
			transition_in(cell6.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			transition_out(cell5.$$.fragment, local);
			transition_out(cell6.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(cell5, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(cell6, detaching);
			if (detaching) detach_dev(t6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$a.name,
		type: "slot",
		source: "(58:20) <Row>",
		ctx
	});

	return block;
}

// (57:16) {#each dataTable_weighted_avg as table, index (table.id)}
function create_each_block$5(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg*/ 16777218) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(57:16) {#each dataTable_weighted_avg as table, index (table.id)}",
		ctx
	});

	return block;
}

// (55:8) <Body>
function create_default_slot_1$a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$i, create_if_block_1$7, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*show_dataTable_only_weighted_averaged*/ ctx[4]) return 0;
		if (/*show_dataTable_only_averaged*/ ctx[5] && !/*show_dataTable_only_weighted_averaged*/ ctx[4]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$a.name,
		type: "slot",
		source: "(55:8) <Body>",
		ctx
	});

	return block;
}

// (44:4) <DataTable table$aria-label="felix-tableAriaLabel" table$id="felixTable" id="felixTableContainer" class="tableContainer">
function create_default_slot$k(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_29] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg, show_dataTable_only_weighted_averaged, $dataTable_avg, show_dataTable_only_averaged, $dataTable*/ 16777278) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$k.name,
		type: "slot",
		source: "(44:4) <DataTable table$aria-label=\\\"felix-tableAriaLabel\\\" table$id=\\\"felixTable\\\" id=\\\"felixTableContainer\\\" class=\\\"tableContainer\\\">",
		ctx
	});

	return block;
}

function create_fragment$10(ctx) {
	let div1;
	let div0;
	let t1;
	let customcheckbox0;
	let updating_selected;
	let t2;
	let customcheckbox1;
	let updating_selected_1;
	let t3;
	let customcheckbox2;
	let updating_selected_2;
	let t4;
	let button;
	let t6;
	let div2;
	let datatable;
	let current;
	let mounted;
	let dispose;

	function customcheckbox0_selected_binding(value) {
		/*customcheckbox0_selected_binding*/ ctx[8].call(null, value);
	}

	let customcheckbox0_props = { label: "Only Averaged" };

	if (/*show_dataTable_only_averaged*/ ctx[5] !== void 0) {
		customcheckbox0_props.selected = /*show_dataTable_only_averaged*/ ctx[5];
	}

	customcheckbox0 = new CustomCheckbox({
			props: customcheckbox0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox0, "selected", customcheckbox0_selected_binding));

	function customcheckbox1_selected_binding(value) {
		/*customcheckbox1_selected_binding*/ ctx[9].call(null, value);
	}

	let customcheckbox1_props = { label: "Only weighted Averaged" };

	if (/*show_dataTable_only_weighted_averaged*/ ctx[4] !== void 0) {
		customcheckbox1_props.selected = /*show_dataTable_only_weighted_averaged*/ ctx[4];
	}

	customcheckbox1 = new CustomCheckbox({
			props: customcheckbox1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox1, "selected", customcheckbox1_selected_binding));

	function customcheckbox2_selected_binding(value) {
		/*customcheckbox2_selected_binding*/ ctx[10].call(null, value);
	}

	let customcheckbox2_props = { label: "Keep table" };

	if (/*keepTable*/ ctx[0] !== void 0) {
		customcheckbox2_props.selected = /*keepTable*/ ctx[0];
	}

	customcheckbox2 = new CustomCheckbox({
			props: customcheckbox2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox2, "selected", customcheckbox2_selected_binding));

	datatable = new DataTable({
			props: {
				"table$aria-label": "felix-tableAriaLabel",
				table$id: "felixTable",
				id: "felixTableContainer",
				class: "tableContainer",
				$$slots: { default: [create_default_slot$k] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Frequency table";
			t1 = space();
			create_component(customcheckbox0.$$.fragment);
			t2 = space();
			create_component(customcheckbox1.$$.fragment);
			t3 = space();
			create_component(customcheckbox2.$$.fragment);
			t4 = space();
			button = element("button");
			button.textContent = "Clear Table";
			t6 = space();
			div2 = element("div");
			create_component(datatable.$$.fragment);
			attr_dev(div0, "class", "title notification is-link svelte-297dl0");
			add_location(div0, file$W, 33, 4, 1191);
			attr_dev(button, "class", "button is-danger is-pulled-right");
			add_location(button, file$W, 39, 4, 1531);
			attr_dev(div1, "class", "content");
			add_location(div1, file$W, 32, 0, 1164);
			attr_dev(div2, "class", "dataTable svelte-297dl0");
			add_location(div2, file$W, 42, 1, 1637);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t1);
			mount_component(customcheckbox0, div1, null);
			append_dev(div1, t2);
			mount_component(customcheckbox1, div1, null);
			append_dev(div1, t3);
			mount_component(customcheckbox2, div1, null);
			append_dev(div1, t4);
			append_dev(div1, button);
			insert_dev(target, t6, anchor);
			insert_dev(target, div2, anchor);
			mount_component(datatable, div2, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*clearTable*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const customcheckbox0_changes = {};

			if (!updating_selected && dirty & /*show_dataTable_only_averaged*/ 32) {
				updating_selected = true;
				customcheckbox0_changes.selected = /*show_dataTable_only_averaged*/ ctx[5];
				add_flush_callback(() => updating_selected = false);
			}

			customcheckbox0.$set(customcheckbox0_changes);
			const customcheckbox1_changes = {};

			if (!updating_selected_1 && dirty & /*show_dataTable_only_weighted_averaged*/ 16) {
				updating_selected_1 = true;
				customcheckbox1_changes.selected = /*show_dataTable_only_weighted_averaged*/ ctx[4];
				add_flush_callback(() => updating_selected_1 = false);
			}

			customcheckbox1.$set(customcheckbox1_changes);
			const customcheckbox2_changes = {};

			if (!updating_selected_2 && dirty & /*keepTable*/ 1) {
				updating_selected_2 = true;
				customcheckbox2_changes.selected = /*keepTable*/ ctx[0];
				add_flush_callback(() => updating_selected_2 = false);
			}

			customcheckbox2.$set(customcheckbox2_changes);
			const datatable_changes = {};

			if (dirty & /*$$scope, dataTable_weighted_avg, show_dataTable_only_weighted_averaged, $dataTable_avg, show_dataTable_only_averaged, $dataTable*/ 16777278) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customcheckbox0.$$.fragment, local);
			transition_in(customcheckbox1.$$.fragment, local);
			transition_in(customcheckbox2.$$.fragment, local);
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customcheckbox0.$$.fragment, local);
			transition_out(customcheckbox1.$$.fragment, local);
			transition_out(customcheckbox2.$$.fragment, local);
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(customcheckbox0);
			destroy_component(customcheckbox1);
			destroy_component(customcheckbox2);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div2);
			destroy_component(datatable);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props, $$invalidate) {
	let dataTable_weighted_avg;
	let $dataTable_avg;
	let $dataTable;
	let $avgfittedLineCount;
	let $expfittedLinesCollectedData;
	validate_store(dataTable_avg, "dataTable_avg");
	component_subscribe($$self, dataTable_avg, $$value => $$invalidate(2, $dataTable_avg = $$value));
	validate_store(dataTable, "dataTable");
	component_subscribe($$self, dataTable, $$value => $$invalidate(3, $dataTable = $$value));
	validate_store(avgfittedLineCount, "avgfittedLineCount");
	component_subscribe($$self, avgfittedLineCount, $$value => $$invalidate(14, $avgfittedLineCount = $$value));
	validate_store(expfittedLinesCollectedData, "expfittedLinesCollectedData");
	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(15, $expfittedLinesCollectedData = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FrequencyTable", slots, []);
	let { keepTable = true } = $$props;
	const dataTableHead = ["Filename", "Frequency (cm-1)", "Amplitude", "FWHM", "Sigma"];

	let show_dataTable_only_weighted_averaged = false,
		show_dataTable_only_averaged = false;

	function clearTable() {
		set_store_value(dataTable, $dataTable = set_store_value(dataTable_avg, $dataTable_avg = [], $dataTable_avg), $dataTable);
		set_store_value(avgfittedLineCount, $avgfittedLineCount = 0, $avgfittedLineCount);
		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData);
		window.createToast("Table cleared", "warning");
	}

	const writable_props = ["keepTable"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<FrequencyTable> was created with unknown prop '${key}'`);
	});

	function customcheckbox0_selected_binding(value) {
		show_dataTable_only_averaged = value;
		$$invalidate(5, show_dataTable_only_averaged);
	}

	function customcheckbox1_selected_binding(value) {
		show_dataTable_only_weighted_averaged = value;
		$$invalidate(4, show_dataTable_only_weighted_averaged);
	}

	function customcheckbox2_selected_binding(value) {
		keepTable = value;
		$$invalidate(0, keepTable);
	}

	const click_handler = e => {
		$$invalidate(1, dataTable_weighted_avg = window._.filter(dataTable_weighted_avg, tb => tb.id != e.target.id));
	};

	const click_handler_1 = e => {
		set_store_value(dataTable_avg, $dataTable_avg = window._.filter($dataTable_avg, tb => tb.id != e.target.id), $dataTable_avg);
	};

	const click_handler_2 = e => {
		set_store_value(dataTable, $dataTable = window._.filter($dataTable, tb => tb.id != e.target.id), $dataTable);
	};

	$$self.$$set = $$props => {
		if ("keepTable" in $$props) $$invalidate(0, keepTable = $$props.keepTable);
	};

	$$self.$capture_state = () => ({
		dataTable_avg,
		dataTable,
		expfittedLinesCollectedData,
		avgfittedLineCount,
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		Icon,
		CustomCheckbox,
		keepTable,
		dataTableHead,
		show_dataTable_only_weighted_averaged,
		show_dataTable_only_averaged,
		clearTable,
		dataTable_weighted_avg,
		$dataTable_avg,
		$dataTable,
		$avgfittedLineCount,
		$expfittedLinesCollectedData
	});

	$$self.$inject_state = $$props => {
		if ("keepTable" in $$props) $$invalidate(0, keepTable = $$props.keepTable);
		if ("show_dataTable_only_weighted_averaged" in $$props) $$invalidate(4, show_dataTable_only_weighted_averaged = $$props.show_dataTable_only_weighted_averaged);
		if ("show_dataTable_only_averaged" in $$props) $$invalidate(5, show_dataTable_only_averaged = $$props.show_dataTable_only_averaged);
		if ("dataTable_weighted_avg" in $$props) $$invalidate(1, dataTable_weighted_avg = $$props.dataTable_weighted_avg);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$dataTable_avg*/ 4) {
			 $$invalidate(1, dataTable_weighted_avg = $dataTable_avg.filter(file => file.name == "weighted_mean"));
		}

		if ($$self.$$.dirty & /*$dataTable*/ 8) {
			 console.log("dataTable", $dataTable);
		}

		if ($$self.$$.dirty & /*$dataTable_avg*/ 4) {
			 console.log("dataTable_avg", $dataTable_avg);
		}

		if ($$self.$$.dirty & /*dataTable_weighted_avg*/ 2) {
			 console.log("dataTable_weighted_avg", dataTable_weighted_avg);
		}
	};

	return [
		keepTable,
		dataTable_weighted_avg,
		$dataTable_avg,
		$dataTable,
		show_dataTable_only_weighted_averaged,
		show_dataTable_only_averaged,
		dataTableHead,
		clearTable,
		customcheckbox0_selected_binding,
		customcheckbox1_selected_binding,
		customcheckbox2_selected_binding,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class FrequencyTable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$10, create_fragment$10, safe_not_equal, { keepTable: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FrequencyTable",
			options,
			id: create_fragment$10.name
		});
	}

	get keepTable() {
		throw new Error("<FrequencyTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keepTable(value) {
		throw new Error("<FrequencyTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomCheckList.svelte generated by Svelte v3.31.2 */
const file$X = "src\\components\\CustomCheckList.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (14:20) <Label>
function create_default_slot_3$7(ctx) {
	let t_value = /*item*/ ctx[5].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 2 && t_value !== (t_value = /*item*/ ctx[5].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$7.name,
		type: "slot",
		source: "(14:20) <Label>",
		ctx
	});

	return block;
}

// (16:20) <Meta>
function create_default_slot_2$b(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding(value) {
		/*checkbox_group_binding*/ ctx[3].call(null, value);
	}

	let checkbox_props = { value: /*item*/ ctx[5].name };

	if (/*fileChecked*/ ctx[0] !== void 0) {
		checkbox_props.group = /*fileChecked*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding));
	checkbox.$on("click", /*click_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*items*/ 2) checkbox_changes.value = /*item*/ ctx[5].name;

			if (!updating_group && dirty & /*fileChecked*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$b.name,
		type: "slot",
		source: "(16:20) <Meta>",
		ctx
	});

	return block;
}

// (12:16) <Item style="height:2.5em;">
function create_default_slot_1$b(ctx) {
	let label;
	let t0;
	let meta;
	let t1;
	let current;

	label = new Label$1({
			props: {
				$$slots: { default: [create_default_slot_3$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_2$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t0 = space();
			create_component(meta.$$.fragment);
			t1 = space();
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(meta, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope, items*/ 258) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, items, fileChecked*/ 259) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(meta, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$b.name,
		type: "slot",
		source: "(12:16) <Item style=\\\"height:2.5em;\\\">",
		ctx
	});

	return block;
}

// (11:12) {#each items as item}
function create_each_block$6(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				style: "height:2.5em;",
				$$slots: { default: [create_default_slot_1$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope, items, fileChecked*/ 259) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(11:12) {#each items as item}",
		ctx
	});

	return block;
}

// (10:8) <List checklist>
function create_default_slot$l(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items, fileChecked*/ 3) {
				each_value = /*items*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$l.name,
		type: "slot",
		source: "(10:8) <List checklist>",
		ctx
	});

	return block;
}

function create_fragment$11(ctx) {
	let div;
	let list;
	let current;

	list = new List({
			props: {
				checklist: true,
				$$slots: { default: [create_default_slot$l] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			attr_dev(div, "style", /*style*/ ctx[2]);
			add_location(div, file$X, 8, 0, 184);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, items, fileChecked*/ 259) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);

			if (!current || dirty & /*style*/ 4) {
				attr_dev(div, "style", /*style*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$11($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomCheckList", slots, []);

	let { items = [] } = $$props,
		{ fileChecked = [] } = $$props,
		{ style = "" } = $$props;

	const writable_props = ["items", "fileChecked", "style"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomCheckList> was created with unknown prop '${key}'`);
	});

	function checkbox_group_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$capture_state = () => ({
		List,
		Item,
		Meta,
		Label: Label$1,
		Checkbox,
		items,
		fileChecked,
		style
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [fileChecked, items, style, checkbox_group_binding, click_handler];
}

class CustomCheckList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$11, create_fragment$11, safe_not_equal, { items: 1, fileChecked: 0, style: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomCheckList",
			options,
			id: create_fragment$11.name
		});
	}

	get items() {
		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fileChecked() {
		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomCheckList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomCheckList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\modals\FelixPlotWidgets.svelte generated by Svelte v3.31.2 */
const file$Y = "src\\Pages\\normline\\modals\\FelixPlotWidgets.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].label;
	child_ctx[12] = list[i].value;
	child_ctx[13] = list[i].id;
	child_ctx[14] = list;
	child_ctx[15] = i;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].label;
	child_ctx[12] = list[i].value;
	child_ctx[16] = list[i].step;
	child_ctx[13] = list[i].id;
	child_ctx[17] = list;
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].label;
	child_ctx[12] = list[i].value;
	child_ctx[13] = list[i].id;
	child_ctx[19] = list;
	child_ctx[20] = i;
	return child_ctx;
}

function get_each_context_3$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].label;
	child_ctx[21] = list[i].options;
	child_ctx[22] = list[i].selected;
	child_ctx[23] = list[i].style;
	child_ctx[13] = list[i].id;
	child_ctx[24] = list;
	child_ctx[25] = i;
	return child_ctx;
}

// (54:8) {#each felixPlotCheckboxes as {label, options, selected, style, id}
function create_each_block_3$2(key_1, ctx) {
	let div1;
	let div0;
	let t0_value = /*label*/ ctx[11] + "";
	let t0;
	let t1;
	let customchecklist;
	let updating_fileChecked;
	let updating_items;
	let t2;
	let div1_style_value;
	let current;

	function customchecklist_fileChecked_binding(value) {
		/*customchecklist_fileChecked_binding*/ ctx[3].call(null, value, /*selected*/ ctx[22], /*each_value_3*/ ctx[24], /*each_index_3*/ ctx[25]);
	}

	function customchecklist_items_binding(value) {
		/*customchecklist_items_binding*/ ctx[4].call(null, value, /*options*/ ctx[21], /*each_value_3*/ ctx[24], /*each_index_3*/ ctx[25]);
	}

	let customchecklist_props = {
		style: "background: #836ac05c; border-radius: 20px; margin:1em 0;  height:20em; overflow:auto;"
	};

	if (/*selected*/ ctx[22] !== void 0) {
		customchecklist_props.fileChecked = /*selected*/ ctx[22];
	}

	if (/*options*/ ctx[21] !== void 0) {
		customchecklist_props.items = /*options*/ ctx[21];
	}

	customchecklist = new CustomCheckList({
			props: customchecklist_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customchecklist, "fileChecked", customchecklist_fileChecked_binding));
	binding_callbacks.push(() => bind(customchecklist, "items", customchecklist_items_binding));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			create_component(customchecklist.$$.fragment);
			t2 = space();
			attr_dev(div0, "class", "subtitle felix_tkplot_filelist_header svelte-2s0963");
			add_location(div0, file$Y, 55, 16, 1136);
			attr_dev(div1, "style", div1_style_value = "flex-grow:1; " + /*style*/ ctx[23]);
			attr_dev(div1, "class", "felix_tkplot_filelist_div svelte-2s0963");
			add_location(div1, file$Y, 54, 12, 1050);
			this.first = div1;
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
			mount_component(customchecklist, div1, null);
			append_dev(div1, t2);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*felixPlotCheckboxes*/ 1) && t0_value !== (t0_value = /*label*/ ctx[11] + "")) set_data_dev(t0, t0_value);
			const customchecklist_changes = {};

			if (!updating_fileChecked && dirty & /*felixPlotCheckboxes*/ 1) {
				updating_fileChecked = true;
				customchecklist_changes.fileChecked = /*selected*/ ctx[22];
				add_flush_callback(() => updating_fileChecked = false);
			}

			if (!updating_items && dirty & /*felixPlotCheckboxes*/ 1) {
				updating_items = true;
				customchecklist_changes.items = /*options*/ ctx[21];
				add_flush_callback(() => updating_items = false);
			}

			customchecklist.$set(customchecklist_changes);

			if (!current || dirty & /*felixPlotCheckboxes*/ 1 && div1_style_value !== (div1_style_value = "flex-grow:1; " + /*style*/ ctx[23])) {
				attr_dev(div1, "style", div1_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customchecklist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customchecklist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(customchecklist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$2.name,
		type: "each",
		source: "(54:8) {#each felixPlotCheckboxes as {label, options, selected, style, id}",
		ctx
	});

	return block;
}

// (68:12) {#each felixPlotWidgets.text as {label, value, id}
function create_each_block_2$2(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[5].call(null, value, /*value*/ ctx[12], /*each_value_2*/ ctx[19], /*each_index_2*/ ctx[20]);
	}

	let textfield_props = {
		style: "width:12em; margin-bottom:1em;",
		variant: "outlined",
		type: "text",
		label: /*label*/ ctx[11]
	};

	if (/*value*/ ctx[12] !== void 0) {
		textfield_props.value = /*value*/ ctx[12];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*felixPlotWidgets*/ 2) textfield_changes.label = /*label*/ ctx[11];

			if (!updating_value && dirty & /*felixPlotWidgets*/ 2) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[12];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$2.name,
		type: "each",
		source: "(68:12) {#each felixPlotWidgets.text as {label, value, id}",
		ctx
	});

	return block;
}

// (83:12) {#each felixPlotWidgets.number as {label, value, step, id}
function create_each_block_1$2(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_1(value) {
		/*textfield_value_binding_1*/ ctx[7].call(null, value, /*value*/ ctx[12], /*each_value_1*/ ctx[17], /*each_index_1*/ ctx[18]);
	}

	let textfield_props = {
		style: "width:12em; margin-bottom:1em;",
		type: "number",
		step: /*step*/ ctx[16],
		label: /*label*/ ctx[11]
	};

	if (/*value*/ ctx[12] !== void 0) {
		textfield_props.value = /*value*/ ctx[12];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*felixPlotWidgets*/ 2) textfield_changes.step = /*step*/ ctx[16];
			if (dirty & /*felixPlotWidgets*/ 2) textfield_changes.label = /*label*/ ctx[11];

			if (!updating_value && dirty & /*felixPlotWidgets*/ 2) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[12];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(83:12) {#each felixPlotWidgets.number as {label, value, step, id}",
		ctx
	});

	return block;
}

// (96:12) {#each felixPlotWidgets.boolean as {label, value, id}
function create_each_block$7(key_1, ctx) {
	let first;
	let customcheckbox;
	let updating_selected;
	let current;

	function customcheckbox_selected_binding(value) {
		/*customcheckbox_selected_binding*/ ctx[9].call(null, value, /*value*/ ctx[12], /*each_value*/ ctx[14], /*each_index*/ ctx[15]);
	}

	let customcheckbox_props = {
		style: "width:12em; margin-bottom:1em;",
		label: /*label*/ ctx[11]
	};

	if (/*value*/ ctx[12] !== void 0) {
		customcheckbox_props.selected = /*value*/ ctx[12];
	}

	customcheckbox = new CustomCheckbox({
			props: customcheckbox_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox, "selected", customcheckbox_selected_binding));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(customcheckbox.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(customcheckbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const customcheckbox_changes = {};
			if (dirty & /*felixPlotWidgets*/ 2) customcheckbox_changes.label = /*label*/ ctx[11];

			if (!updating_selected && dirty & /*felixPlotWidgets*/ 2) {
				updating_selected = true;
				customcheckbox_changes.selected = /*value*/ ctx[12];
				add_flush_callback(() => updating_selected = false);
			}

			customcheckbox.$set(customcheckbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customcheckbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customcheckbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(customcheckbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(96:12) {#each felixPlotWidgets.boolean as {label, value, id}",
		ctx
	});

	return block;
}

function create_fragment$12(ctx) {
	let div7;
	let div0;
	let each_blocks_3 = [];
	let each0_lookup = new Map();
	let t0;
	let div2;
	let h10;
	let t2;
	let div1;
	let each_blocks_2 = [];
	let each1_lookup = new Map();
	let t3;
	let button0;
	let t5;
	let div4;
	let h11;
	let t7;
	let div3;
	let each_blocks_1 = [];
	let each2_lookup = new Map();
	let t8;
	let button1;
	let t10;
	let div6;
	let h12;
	let t12;
	let div5;
	let each_blocks = [];
	let each3_lookup = new Map();
	let t13;
	let button2;
	let current;
	let mounted;
	let dispose;
	let each_value_3 = /*felixPlotCheckboxes*/ ctx[0];
	validate_each_argument(each_value_3);
	const get_key = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key);

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3$2(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_3[i] = create_each_block_3$2(key, child_ctx));
	}

	let each_value_2 = /*felixPlotWidgets*/ ctx[1].text;
	validate_each_argument(each_value_2);
	const get_key_1 = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key_1);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$2(ctx, each_value_2, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_2[i] = create_each_block_2$2(key, child_ctx));
	}

	let each_value_1 = /*felixPlotWidgets*/ ctx[1].number;
	validate_each_argument(each_value_1);
	const get_key_2 = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key_2);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1$2(key, child_ctx));
	}

	let each_value = /*felixPlotWidgets*/ ctx[1].boolean;
	validate_each_argument(each_value);
	const get_key_3 = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value, get_each_context$7, get_key_3);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$7(ctx, each_value, i);
		let key = get_key_3(child_ctx);
		each3_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
	}

	const block = {
		c: function create() {
			div7 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t0 = space();
			div2 = element("div");
			h10 = element("h1");
			h10.textContent = "Text Widgets";
			t2 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t3 = space();
			button0 = element("button");
			button0.textContent = "Add widget";
			t5 = space();
			div4 = element("div");
			h11 = element("h1");
			h11.textContent = "Number Widgets";
			t7 = space();
			div3 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t8 = space();
			button1 = element("button");
			button1.textContent = "Add widget";
			t10 = space();
			div6 = element("div");
			h12 = element("h1");
			h12.textContent = "Boolean Widgets";
			t12 = space();
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t13 = space();
			button2 = element("button");
			button2.textContent = "Add widget";
			set_style(div0, "display", "flex");
			set_style(div0, "flex-wrap", "wrap");
			add_location(div0, file$Y, 51, 4, 909);
			attr_dev(h10, "class", "subtitle");
			add_location(h10, file$Y, 64, 8, 1484);
			attr_dev(div1, "class", "widgets");
			add_location(div1, file$Y, 65, 8, 1532);
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$Y, 74, 8, 1796);
			attr_dev(div2, "class", "felix_plotting_div svelte-2s0963");
			add_location(div2, file$Y, 62, 4, 1440);
			attr_dev(h11, "class", "subtitle");
			add_location(h11, file$Y, 80, 8, 1968);
			attr_dev(div3, "class", "widgets");
			add_location(div3, file$Y, 81, 8, 2018);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$Y, 87, 8, 2274);
			attr_dev(div4, "class", "felix_plotting_div svelte-2s0963");
			add_location(div4, file$Y, 78, 4, 1924);
			attr_dev(h12, "class", "subtitle");
			add_location(h12, file$Y, 93, 8, 2452);
			attr_dev(div5, "class", "widgets");
			add_location(div5, file$Y, 94, 8, 2503);
			attr_dev(button2, "class", "button is-link");
			add_location(button2, file$Y, 99, 8, 2748);
			attr_dev(div6, "class", "felix_plotting_div svelte-2s0963");
			add_location(div6, file$Y, 91, 4, 2404);
			attr_dev(div7, "class", "");
			add_location(div7, file$Y, 49, 0, 887);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div7, anchor);
			append_dev(div7, div0);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(div0, null);
			}

			append_dev(div7, t0);
			append_dev(div7, div2);
			append_dev(div2, h10);
			append_dev(div2, t2);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div1, null);
			}

			append_dev(div2, t3);
			append_dev(div2, button0);
			append_dev(div7, t5);
			append_dev(div7, div4);
			append_dev(div4, h11);
			append_dev(div4, t7);
			append_dev(div4, div3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div3, null);
			}

			append_dev(div4, t8);
			append_dev(div4, button1);
			append_dev(div7, t10);
			append_dev(div7, div6);
			append_dev(div6, h12);
			append_dev(div6, t12);
			append_dev(div6, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div6, t13);
			append_dev(div6, button2);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[8], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[10], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*felixPlotCheckboxes*/ 1) {
				each_value_3 = /*felixPlotCheckboxes*/ ctx[0];
				validate_each_argument(each_value_3);
				group_outros();
				validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key);
				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3$2, null, get_each_context_3$2);
				check_outros();
			}

			if (dirty & /*felixPlotWidgets*/ 2) {
				each_value_2 = /*felixPlotWidgets*/ ctx[1].text;
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key_1);
				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div1, outro_and_destroy_block, create_each_block_2$2, null, get_each_context_2$2);
				check_outros();
			}

			if (dirty & /*felixPlotWidgets*/ 2) {
				each_value_1 = /*felixPlotWidgets*/ ctx[1].number;
				validate_each_argument(each_value_1);
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key_2);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx, each_value_1, each2_lookup, div3, outro_and_destroy_block, create_each_block_1$2, null, get_each_context_1$2);
				check_outros();
			}

			if (dirty & /*felixPlotWidgets*/ 2) {
				each_value = /*felixPlotWidgets*/ ctx[1].boolean;
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$7, get_key_3);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_3, 1, ctx, each_value, each3_lookup, div5, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div7);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].d();
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d();
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$12($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FelixPlotWidgets", slots, []);
	let { felixPlotCheckboxes } = $$props, { felixPlotWidgets } = $$props;
	const dispatch = createEventDispatcher();
	const writable_props = ["felixPlotCheckboxes", "felixPlotWidgets"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FelixPlotWidgets> was created with unknown prop '${key}'`);
	});

	function customchecklist_fileChecked_binding(value, selected, each_value_3, each_index_3) {
		each_value_3[each_index_3].selected = value;
		$$invalidate(0, felixPlotCheckboxes);
	}

	function customchecklist_items_binding(value, options, each_value_3, each_index_3) {
		each_value_3[each_index_3].options = value;
		$$invalidate(0, felixPlotCheckboxes);
	}

	function textfield_value_binding(value$1, value, each_value_2, each_index_2) {
		each_value_2[each_index_2].value = value$1;
		$$invalidate(1, felixPlotWidgets);
	}

	const click_handler = () => {
		dispatch("addWidget", { type: "text" });
	};

	function textfield_value_binding_1(value$1, value, each_value_1, each_index_1) {
		each_value_1[each_index_1].value = value$1;
		$$invalidate(1, felixPlotWidgets);
	}

	const click_handler_1 = () => {
		dispatch("addWidget", { type: "number" });
	};

	function customcheckbox_selected_binding(value$1, value, each_value, each_index) {
		each_value[each_index].value = value$1;
		$$invalidate(1, felixPlotWidgets);
	}

	const click_handler_2 = () => {
		dispatch("addWidget", { type: "boolean" });
	};

	$$self.$$set = $$props => {
		if ("felixPlotCheckboxes" in $$props) $$invalidate(0, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("felixPlotWidgets" in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
	};

	$$self.$capture_state = () => ({
		CustomCheckList,
		Textfield,
		CustomCheckbox,
		createEventDispatcher,
		felixPlotCheckboxes,
		felixPlotWidgets,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ("felixPlotCheckboxes" in $$props) $$invalidate(0, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("felixPlotWidgets" in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		felixPlotCheckboxes,
		felixPlotWidgets,
		dispatch,
		customchecklist_fileChecked_binding,
		customchecklist_items_binding,
		textfield_value_binding,
		click_handler,
		textfield_value_binding_1,
		click_handler_1,
		customcheckbox_selected_binding,
		click_handler_2
	];
}

class FelixPlotWidgets extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
			felixPlotCheckboxes: 0,
			felixPlotWidgets: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FelixPlotWidgets",
			options,
			id: create_fragment$12.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*felixPlotCheckboxes*/ ctx[0] === undefined && !("felixPlotCheckboxes" in props)) {
			console.warn("<FelixPlotWidgets> was created without expected prop 'felixPlotCheckboxes'");
		}

		if (/*felixPlotWidgets*/ ctx[1] === undefined && !("felixPlotWidgets" in props)) {
			console.warn("<FelixPlotWidgets> was created without expected prop 'felixPlotWidgets'");
		}
	}

	get felixPlotCheckboxes() {
		throw new Error("<FelixPlotWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixPlotCheckboxes(value) {
		throw new Error("<FelixPlotWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get felixPlotWidgets() {
		throw new Error("<FelixPlotWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixPlotWidgets(value) {
		throw new Error("<FelixPlotWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function savefile({file={}, name="", location=""}={}) {

    let filename = path.join(location || get_store_value(felixopoLocation), `${name}.json`);
    fs.writeFile(filename, JSON.stringify({file}), 'utf8', function (err) {

        if (err) {
            console.log("An error occured while writing to File.");
            return window.createToast("An error occured while writing to File.", "danger")
        }
        return window.createToast(`${name}.json has been saved.`, "success");
    });
}

function loadfile({name="", location=""}={}) {
    let filename = path.join( location || get_store_value(felixopoLocation), `${name}.json`);
    if(!fs.existsSync(filename)) {window.createToast(`${name}.json doesn't exist in DATA dir.`, "danger"); return {}}

    let loadedfile = JSON.parse(fs.readFileSync(filename)).file;

    window.createToast(`${name}.json has been loaded.`, "success");
    return loadedfile
}

function plotlySelection({graphDiv="avgplot", mode="felix"}={}) {

    const avgplot = document.getElementById(graphDiv);

    console.log("Creating plotly selection events for, ", avgplot);

    avgplot.on("plotly_selected", (data) => {

       try {
            console.log(data);
            mode === "felix" ? opoMode.set(false) : opoMode.set(true);


            const { range } = data;

            felixIndex.set(range.x);


            const output_name = data.points[0].data.name.split(".")[0];
            felixOutputName.set(output_name);
            console.log(`Selected file: ${get_store_value(felixOutputName)}`);

        } catch (error) { console.log("No data available to fit"); }

    });
}


function plotlyClick({graphDiv="avgplot", mode="felix"}={}){

    const avgplot = document.getElementById(graphDiv);
    console.log("Creating plotly click events for, ", avgplot);

    avgplot.on('plotly_click', (data)=>{
    
        console.log("Graph clicked: ", data);

        if (data.event.ctrlKey) {

            console.log("Data point length: ", data.points.length);


            for(let i=0; i<data.points.length; i++){

                console.log("Running cycle: ", i);

                let d = data.points[i];

                let name = d.data.name;
                mode === "felix" ? opoMode.set(false) : opoMode.set(true);

                let output_name = get_store_value(felixOutputName);

                if (name.includes(output_name)){

                    console.log("Filename: ", output_name);

                    let line_color = d.data.line.color;
                    console.log(name);
                    console.log(d, d.x, d.y);

                    let [freq, amp] = [parseFloat(d.x.toFixed(2)), parseFloat(d.y.toFixed(2))];
                    const annotation = { text: `(${freq}, ${amp})`, x: freq, y: amp, font:{color:line_color}, arrowcolor:line_color };
                    felixPlotAnnotations.update(annotate => _.uniqBy([...annotate, annotation], 'text'));
                    Plotly.relayout(graphDiv,{annotations: get_store_value(felixPlotAnnotations)});

                    felixPeakTable.update(table => [...table, {freq, amp, sig:get_store_value(Ngauss_sigma), id:getID()}]);
                    felixPeakTable.update(table => _.uniqBy(table, 'freq'));
                }
            }

            console.log("Running cycle ended");
        } 
    });

}

/* src\Pages\normline\modals\FelixPlotExtraWidgets.svelte generated by Svelte v3.31.2 */
const file$Z = "src\\Pages\\normline\\modals\\FelixPlotExtraWidgets.svelte";

// (14:0) {#if active}
function create_if_block$j(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[8].call(null, value);
	}

	let modal_props = {
		title: "Add widget",
		$$slots: {
			default: [create_default_slot$m],
			footerbtn: [create_footerbtn_slot$1],
			content: [create_content_slot$2]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, extraWidget, widgetType*/ 518) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(14:0) {#if active}",
		ctx
	});

	return block;
}

// (24:12) {#if widgetType === "number"}
function create_if_block_1$8(ctx) {
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[6].call(null, value);
	}

	let textfield_props = {
		style: "width:12em; margin-bottom:1em;",
		variant: "outlined",
		type: "number",
		label: "step"
	};

	if (/*extraWidget*/ ctx[1].step !== void 0) {
		textfield_props.value = /*extraWidget*/ ctx[1].step;
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};

			if (!updating_value && dirty & /*extraWidget*/ 2) {
				updating_value = true;
				textfield_changes.value = /*extraWidget*/ ctx[1].step;
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(24:12) {#if widgetType === \\\"number\\\"}",
		ctx
	});

	return block;
}

// (18:8) <div slot="content" style="display: grid; place-items: center;">
function create_content_slot$2(ctx) {
	let div;
	let textfield0;
	let updating_value;
	let t0;
	let textfield1;
	let updating_value_1;
	let t1;
	let current;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[4].call(null, value);
	}

	let textfield0_props = {
		style: "width:12em; margin-bottom:1em;",
		variant: "outlined",
		type: "text",
		label: "label"
	};

	if (/*extraWidget*/ ctx[1].label !== void 0) {
		textfield0_props.value = /*extraWidget*/ ctx[1].label;
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[5].call(null, value);
	}

	let textfield1_props = {
		style: "width:12em; margin-bottom:1em;",
		variant: "outlined",
		type: /*widgetType*/ ctx[2],
		label: "value"
	};

	if (/*extraWidget*/ ctx[1].value !== void 0) {
		textfield1_props.value = /*extraWidget*/ ctx[1].value;
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));
	let if_block = /*widgetType*/ ctx[2] === "number" && create_if_block_1$8(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			create_component(textfield1.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			attr_dev(div, "slot", "content");
			set_style(div, "display", "grid");
			set_style(div, "place-items", "center");
			add_location(div, file$Z, 17, 8, 405);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield0, div, null);
			append_dev(div, t0);
			mount_component(textfield1, div, null);
			append_dev(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty & /*extraWidget*/ 2) {
				updating_value = true;
				textfield0_changes.value = /*extraWidget*/ ctx[1].label;
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty & /*widgetType*/ 4) textfield1_changes.type = /*widgetType*/ ctx[2];

			if (!updating_value_1 && dirty & /*extraWidget*/ 2) {
				updating_value_1 = true;
				textfield1_changes.value = /*extraWidget*/ ctx[1].value;
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);

			if (/*widgetType*/ ctx[2] === "number") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*widgetType*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield0);
			destroy_component(textfield1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$2.name,
		type: "slot",
		source: "(18:8) <div slot=\\\"content\\\" style=\\\"display: grid; place-items: center;\\\">",
		ctx
	});

	return block;
}

// (31:8) <button slot="footerbtn" class="button is-link" on:click={()=>{dispatch("widgetadded")}} >
function create_footerbtn_slot$1(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "Submit";
			attr_dev(button, "slot", "footerbtn");
			attr_dev(button, "class", "button is-link");
			add_location(button, file$Z, 30, 8, 1010);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot$1.name,
		type: "slot",
		source: "(31:8) <button slot=\\\"footerbtn\\\" class=\\\"button is-link\\\" on:click={()=>{dispatch(\\\"widgetadded\\\")}} >",
		ctx
	});

	return block;
}

// (16:4) <Modal bind:active title="Add widget" >
function create_default_slot$m(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$m.name,
		type: "slot",
		source: "(16:4) <Modal bind:active title=\\\"Add widget\\\" >",
		ctx
	});

	return block;
}

function create_fragment$13(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$j(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$j(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FelixPlotExtraWidgets", slots, []);

	let { active = false } = $$props,
		{ extraWidget = { label: "", value: "", step: "" } } = $$props,
		{ widgetType = "text" } = $$props;

	const dispatch = createEventDispatcher();
	const writable_props = ["active", "extraWidget", "widgetType"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FelixPlotExtraWidgets> was created with unknown prop '${key}'`);
	});

	function textfield0_value_binding(value) {
		extraWidget.label = value;
		$$invalidate(1, extraWidget);
	}

	function textfield1_value_binding(value) {
		extraWidget.value = value;
		$$invalidate(1, extraWidget);
	}

	function textfield_value_binding(value) {
		extraWidget.step = value;
		$$invalidate(1, extraWidget);
	}

	const click_handler = () => {
		dispatch("widgetadded");
	};

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("extraWidget" in $$props) $$invalidate(1, extraWidget = $$props.extraWidget);
		if ("widgetType" in $$props) $$invalidate(2, widgetType = $$props.widgetType);
	};

	$$self.$capture_state = () => ({
		Modal,
		Textfield,
		createEventDispatcher,
		active,
		extraWidget,
		widgetType,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("extraWidget" in $$props) $$invalidate(1, extraWidget = $$props.extraWidget);
		if ("widgetType" in $$props) $$invalidate(2, widgetType = $$props.widgetType);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		extraWidget,
		widgetType,
		dispatch,
		textfield0_value_binding,
		textfield1_value_binding,
		textfield_value_binding,
		click_handler,
		modal_active_binding
	];
}

class FelixPlotExtraWidgets extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$13, create_fragment$13, safe_not_equal, { active: 0, extraWidget: 1, widgetType: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FelixPlotExtraWidgets",
			options,
			id: create_fragment$13.name
		});
	}

	get active() {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get extraWidget() {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set extraWidget(value) {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get widgetType() {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set widgetType(value) {
		throw new Error("<FelixPlotExtraWidgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\modals\FelixPlotting.svelte generated by Svelte v3.31.2 */

const { console: console_1$6 } = globals;
const file$_ = "src\\Pages\\normline\\modals\\FelixPlotting.svelte";

// (59:0) {#if active}
function create_if_block$k(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[14].call(null, value);
	}

	let modal_props = {
		title: "FELIX PLOTTING",
		$$slots: {
			default: [create_default_slot$n],
			footerbtn: [create_footerbtn_slot$2],
			content: [create_content_slot$3]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, felixPlotWidgets, felixPlotCheckboxes*/ 524294) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(59:0) {#if active}",
		ctx
	});

	return block;
}

// (63:8) <div slot="content" style="height:40vh;" use:loadExtraWidgets>
function create_content_slot$3(ctx) {
	let div;
	let felixplotwidgets;
	let updating_felixPlotWidgets;
	let updating_felixPlotCheckboxes;
	let loadExtraWidgets_action;
	let current;
	let mounted;
	let dispose;

	function felixplotwidgets_felixPlotWidgets_binding(value) {
		/*felixplotwidgets_felixPlotWidgets_binding*/ ctx[11].call(null, value);
	}

	function felixplotwidgets_felixPlotCheckboxes_binding(value) {
		/*felixplotwidgets_felixPlotCheckboxes_binding*/ ctx[12].call(null, value);
	}

	let felixplotwidgets_props = {};

	if (/*felixPlotWidgets*/ ctx[1] !== void 0) {
		felixplotwidgets_props.felixPlotWidgets = /*felixPlotWidgets*/ ctx[1];
	}

	if (/*felixPlotCheckboxes*/ ctx[2] !== void 0) {
		felixplotwidgets_props.felixPlotCheckboxes = /*felixPlotCheckboxes*/ ctx[2];
	}

	felixplotwidgets = new FelixPlotWidgets({
			props: felixplotwidgets_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(felixplotwidgets, "felixPlotWidgets", felixplotwidgets_felixPlotWidgets_binding));
	binding_callbacks.push(() => bind(felixplotwidgets, "felixPlotCheckboxes", felixplotwidgets_felixPlotCheckboxes_binding));
	felixplotwidgets.$on("addWidget", /*addExtraWidget*/ ctx[9]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(felixplotwidgets.$$.fragment);
			attr_dev(div, "slot", "content");
			set_style(div, "height", "40vh");
			add_location(div, file$_, 62, 8, 2207);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(felixplotwidgets, div, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(loadExtraWidgets_action = /*loadExtraWidgets*/ ctx[8].call(null, div));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const felixplotwidgets_changes = {};

			if (!updating_felixPlotWidgets && dirty & /*felixPlotWidgets*/ 2) {
				updating_felixPlotWidgets = true;
				felixplotwidgets_changes.felixPlotWidgets = /*felixPlotWidgets*/ ctx[1];
				add_flush_callback(() => updating_felixPlotWidgets = false);
			}

			if (!updating_felixPlotCheckboxes && dirty & /*felixPlotCheckboxes*/ 4) {
				updating_felixPlotCheckboxes = true;
				felixplotwidgets_changes.felixPlotCheckboxes = /*felixPlotCheckboxes*/ ctx[2];
				add_flush_callback(() => updating_felixPlotCheckboxes = false);
			}

			felixplotwidgets.$set(felixplotwidgets_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(felixplotwidgets.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(felixplotwidgets.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(felixplotwidgets);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$3.name,
		type: "slot",
		source: "(63:8) <div slot=\\\"content\\\" style=\\\"height:40vh;\\\" use:loadExtraWidgets>",
		ctx
	});

	return block;
}

// (68:8) <div class="" slot="footerbtn">
function create_footerbtn_slot$2(ctx) {
	let div;
	let button0;
	let t1;
	let button1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			button0.textContent = "Save Widgets";
			t1 = space();
			button1 = element("button");
			button1.textContent = "Submit";
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$_, 69, 12, 2456);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$_, 71, 12, 2550);
			attr_dev(div, "class", "");
			attr_dev(div, "slot", "footerbtn");
			add_location(div, file$_, 67, 8, 2409);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(div, t1);
			append_dev(div, button1);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*saveWidget*/ ctx[7], false, false, false),
					listen_dev(button1, "click", /*click_handler*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot$2.name,
		type: "slot",
		source: "(68:8) <div class=\\\"\\\" slot=\\\"footerbtn\\\">",
		ctx
	});

	return block;
}

// (61:4) <Modal bind:active title="FELIX PLOTTING">
function create_default_slot$n(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$n.name,
		type: "slot",
		source: "(61:4) <Modal bind:active title=\\\"FELIX PLOTTING\\\">",
		ctx
	});

	return block;
}

function create_fragment$14(ctx) {
	let t;
	let felixplotextrawidgets;
	let updating_active;
	let updating_extraWidget;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$k(ctx);

	function felixplotextrawidgets_active_binding(value) {
		/*felixplotextrawidgets_active_binding*/ ctx[15].call(null, value);
	}

	function felixplotextrawidgets_extraWidget_binding(value) {
		/*felixplotextrawidgets_extraWidget_binding*/ ctx[16].call(null, value);
	}

	let felixplotextrawidgets_props = { widgetType: /*widgetType*/ ctx[5] };

	if (/*extraWidgetModal*/ ctx[4] !== void 0) {
		felixplotextrawidgets_props.active = /*extraWidgetModal*/ ctx[4];
	}

	if (/*extraWidget*/ ctx[3] !== void 0) {
		felixplotextrawidgets_props.extraWidget = /*extraWidget*/ ctx[3];
	}

	felixplotextrawidgets = new FelixPlotExtraWidgets({
			props: felixplotextrawidgets_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(felixplotextrawidgets, "active", felixplotextrawidgets_active_binding));
	binding_callbacks.push(() => bind(felixplotextrawidgets, "extraWidget", felixplotextrawidgets_extraWidget_binding));
	felixplotextrawidgets.$on("widgetadded", /*widgetAdded*/ ctx[10]);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(felixplotextrawidgets.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			mount_component(felixplotextrawidgets, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$k(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const felixplotextrawidgets_changes = {};
			if (dirty & /*widgetType*/ 32) felixplotextrawidgets_changes.widgetType = /*widgetType*/ ctx[5];

			if (!updating_active && dirty & /*extraWidgetModal*/ 16) {
				updating_active = true;
				felixplotextrawidgets_changes.active = /*extraWidgetModal*/ ctx[4];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_extraWidget && dirty & /*extraWidget*/ 8) {
				updating_extraWidget = true;
				felixplotextrawidgets_changes.extraWidget = /*extraWidget*/ ctx[3];
				add_flush_callback(() => updating_extraWidget = false);
			}

			felixplotextrawidgets.$set(felixplotextrawidgets_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(felixplotextrawidgets.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(felixplotextrawidgets.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(felixplotextrawidgets, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const widgetFile = "felixplotWidgets";

function instance$14($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FelixPlotting", slots, []);

	let { active = false } = $$props,
		{ felixPlotWidgets = {} } = $$props,
		{ felixPlotCheckboxes } = $$props;

	const dispatch = createEventDispatcher();
	let extraWidgetCollection = { text: [], number: [], boolean: [] };
	let extraWidget = { label: "", value: "", step: "" };
	let extraWidgetModal = false, widgetType = "";
	const widgetLocation = path.resolve(__dirname, "config");

	function saveWidget() {
		savefile({
			file: extraWidgetCollection,
			name: widgetFile,
			location: widgetLocation
		});
	}

	function loadExtraWidgets() {
		const loadedContent = loadfile({
			name: widgetFile,
			location: widgetLocation
		});

		if (!loadedContent) {
			extraWidgetCollection = loadedContent;
			$$invalidate(1, felixPlotWidgets.text = [...felixPlotWidgets.text, extraWidgetCollection.text], felixPlotWidgets);
			$$invalidate(1, felixPlotWidgets.number = [...felixPlotWidgets.number, extraWidgetCollection.number], felixPlotWidgets);
			$$invalidate(1, felixPlotWidgets.boolean = [...felixPlotWidgets.boolean, extraWidgetCollection.boolean], felixPlotWidgets);
		}
	}

	const addExtraWidget = event => {
		$$invalidate(5, widgetType = event.detail.type);
		$$invalidate(4, extraWidgetModal = true);
	};

	const widgetAdded = () => {
		$$invalidate(3, extraWidget.id = window.getID(), extraWidget);
		$$invalidate(1, felixPlotWidgets[widgetType] = [...felixPlotWidgets[widgetType], extraWidget], felixPlotWidgets);
		console.log(felixPlotWidgets[widgetType]);
		extraWidgetCollection[widgetType] = [...extraWidgetCollection[widgetType], extraWidget];
		$$invalidate(3, extraWidget = { label: "", value: "", step: "" });
		$$invalidate(4, extraWidgetModal = false);
	};

	const writable_props = ["active", "felixPlotWidgets", "felixPlotCheckboxes"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<FelixPlotting> was created with unknown prop '${key}'`);
	});

	function felixplotwidgets_felixPlotWidgets_binding(value) {
		felixPlotWidgets = value;
		$$invalidate(1, felixPlotWidgets);
	}

	function felixplotwidgets_felixPlotCheckboxes_binding(value) {
		felixPlotCheckboxes = value;
		$$invalidate(2, felixPlotCheckboxes);
	}

	const click_handler = e => {
		dispatch("submit", { event: e });
	};

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	function felixplotextrawidgets_active_binding(value) {
		extraWidgetModal = value;
		$$invalidate(4, extraWidgetModal);
	}

	function felixplotextrawidgets_extraWidget_binding(value) {
		extraWidget = value;
		$$invalidate(3, extraWidget);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("felixPlotWidgets" in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
		if ("felixPlotCheckboxes" in $$props) $$invalidate(2, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
	};

	$$self.$capture_state = () => ({
		Modal,
		FelixPlotWidgets,
		CustomCheckList,
		Textfield,
		CustomCheckbox,
		loadfile,
		savefile,
		createEventDispatcher,
		FelixPlotExtraWidgets,
		active,
		felixPlotWidgets,
		felixPlotCheckboxes,
		dispatch,
		extraWidgetCollection,
		extraWidget,
		extraWidgetModal,
		widgetType,
		widgetLocation,
		widgetFile,
		saveWidget,
		loadExtraWidgets,
		addExtraWidget,
		widgetAdded
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("felixPlotWidgets" in $$props) $$invalidate(1, felixPlotWidgets = $$props.felixPlotWidgets);
		if ("felixPlotCheckboxes" in $$props) $$invalidate(2, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("extraWidgetCollection" in $$props) extraWidgetCollection = $$props.extraWidgetCollection;
		if ("extraWidget" in $$props) $$invalidate(3, extraWidget = $$props.extraWidget);
		if ("extraWidgetModal" in $$props) $$invalidate(4, extraWidgetModal = $$props.extraWidgetModal);
		if ("widgetType" in $$props) $$invalidate(5, widgetType = $$props.widgetType);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		felixPlotWidgets,
		felixPlotCheckboxes,
		extraWidget,
		extraWidgetModal,
		widgetType,
		dispatch,
		saveWidget,
		loadExtraWidgets,
		addExtraWidget,
		widgetAdded,
		felixplotwidgets_felixPlotWidgets_binding,
		felixplotwidgets_felixPlotCheckboxes_binding,
		click_handler,
		modal_active_binding,
		felixplotextrawidgets_active_binding,
		felixplotextrawidgets_extraWidget_binding
	];
}

class FelixPlotting extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$14, create_fragment$14, safe_not_equal, {
			active: 0,
			felixPlotWidgets: 1,
			felixPlotCheckboxes: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FelixPlotting",
			options,
			id: create_fragment$14.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*felixPlotCheckboxes*/ ctx[2] === undefined && !("felixPlotCheckboxes" in props)) {
			console_1$6.warn("<FelixPlotting> was created without expected prop 'felixPlotCheckboxes'");
		}
	}

	get active() {
		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get felixPlotWidgets() {
		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixPlotWidgets(value) {
		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get felixPlotCheckboxes() {
		throw new Error("<FelixPlotting>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixPlotCheckboxes(value) {
		throw new Error("<FelixPlotting>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function beforePlot({ delta, dataFromPython, graphDiv, baseGraphDiv } = {}) {

    felixOutputName.set("averaged"), felixIndex.set([]);

    let avgdataToPlot, signal_formula, ylabel;

    if (get_store_value(normMethod) === "Log") {
        avgdataToPlot = dataFromPython["average"];
        signal_formula = "Signal = -ln(C/B)/Power(in J)";
        ylabel = "Normalised Intensity per J";
    } else if (get_store_value(normMethod) == "Relative") {
        avgdataToPlot = dataFromPython["average_rel"];
        signal_formula = "Signal = (1-C/B)*100";
        ylabel = "Relative Depletion (%)";

    } else if (get_store_value(normMethod) == "IntensityPerPhoton") {

        avgdataToPlot = dataFromPython["average_per_photon"];

        signal_formula = "Signal = -ln(C/B)/#Photons";
        ylabel = "Normalised Intensity per photon";
    }
    const get_data = (data) => {
        let dataPlot = [];
        for (let x in data) { dataPlot.push(data[x]); }
        return dataPlot
    };
    let signal = {
        "rel": "Signal = (1-C/B)*100", "log": "Signal = -ln(C/B)/Power(in J)",
        "hv": "Signal = -ln(C/B)/#Photons"
    };

    const set_title = (method) => `Normalised and Averaged Spectrum (delta=${delta})<br>${signal[method]}; {C=Measured Count, B=Baseline Count}`;

    const normMethod_datas = {
        "Relative": {
            "data": get_data(dataFromPython["average_rel"]),
            "layout": {
                "title": set_title("rel"),
                "yaxis": { "title": "Relative Depletion (%)" },
                "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
            }
        },
        "Log": {
            "data": get_data(dataFromPython["average"]),
            "layout": {
                "title": set_title("log"),
                "yaxis": { "title": "Normalised Intensity per J" },
                "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
            }
        },
        "IntensityPerPhoton": {
            "data": get_data(dataFromPython["average_per_photon"]),
            "layout": {
                "title": set_title("hv"),
                "yaxis": { "title": "Normalised Intensity per photon" },
                "xaxis": { "title": "Calibrated Wavelength (cm-1)" }
            }

        }

    };


    if (get_store_value(opoMode)) { opoData.set(normMethod_datas); } else { { felixData.set(normMethod_datas); } }

    plot(
        "Baseline Corrected",
        "Wavelength (cm-1)",

        "Counts",
        dataFromPython["base"], baseGraphDiv
        
    );

    plot(
        `Normalised and Averaged Spectrum (delta=${delta})<br>${signal_formula}; {C=Measured Count, B=Baseline Count}`,
        "Calibrated Wavelength (cm-1)",
        ylabel,
        avgdataToPlot, graphDiv
    );


    return Promise.resolve()

}

async function felix_func({ normMethod, dataFromPython, delta } = {}) {

    await beforePlot({ delta, dataFromPython, graphDiv: "avgplot", baseGraphDiv:"bplot" });

    subplot(
        "Spectrum and Power Analyser",

        "Wavelength set (cm-1)",
        "SA (cm-1)",
        dataFromPython["SA"],

        "saPlot",

        "Wavelength (cm-1)",
        `Total Power (mJ)`,
        dataFromPython["pow"]
    );

    if (!get_store_value(plotlyEventCreatedFELIX)) {
        const plot = { graphDiv: "avgplot", mode: "felix" };
        plotlySelection(plot), plotlyClick(plot);

        plotlyEventCreatedFELIX.set(true);

    }
    console.log("Graph Plotted");

}

/* src\Pages\normline\widgets\preprocessing\InitFunctionRow.svelte generated by Svelte v3.31.2 */
const file$$ = "src\\Pages\\normline\\widgets\\preprocessing\\InitFunctionRow.svelte";

function create_fragment$15(ctx) {
	let felixplotting;
	let updating_active;
	let updating_felixPlotWidgets;
	let t0;
	let div;
	let button0;
	let t2;
	let button1;
	let t4;
	let textfield;
	let updating_value;
	let t5;
	let button2;
	let t7;
	let customiconswitch;
	let updating_toggler;
	let t8;
	let button3;
	let t10;
	let button4;
	let current;
	let mounted;
	let dispose;

	function felixplotting_active_binding(value) {
		/*felixplotting_active_binding*/ ctx[16].call(null, value);
	}

	function felixplotting_felixPlotWidgets_binding(value) {
		/*felixplotting_felixPlotWidgets_binding*/ ctx[17].call(null, value);
	}

	let felixplotting_props = {
		felixPlotCheckboxes: /*felixPlotCheckboxes*/ ctx[0]
	};

	if (/*active*/ ctx[1] !== void 0) {
		felixplotting_props.active = /*active*/ ctx[1];
	}

	if (/*felixPlotWidgets*/ ctx[4] !== void 0) {
		felixplotting_props.felixPlotWidgets = /*felixPlotWidgets*/ ctx[4];
	}

	felixplotting = new FelixPlotting({
			props: felixplotting_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(felixplotting, "active", felixplotting_active_binding));
	binding_callbacks.push(() => bind(felixplotting, "felixPlotWidgets", felixplotting_felixPlotWidgets_binding));
	felixplotting.$on("submit", /*submit_handler*/ ctx[18]);

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[21].call(null, value);
	}

	let textfield_props = {
		style: "width:7em",
		variant: "outlined",
		type: "number",
		step: "0.5",
		label: "Delta"
	};

	if (/*delta*/ ctx[3] !== void 0) {
		textfield_props.value = /*delta*/ ctx[3];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[23].call(null, value);
	}

	let customiconswitch_props = { icons: ["settings_ethernet", "code"] };

	if (/*openShell*/ ctx[2] !== void 0) {
		customiconswitch_props.toggler = /*openShell*/ ctx[2];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));

	const block = {
		c: function create() {
			create_component(felixplotting.$$.fragment);
			t0 = space();
			div = element("div");
			button0 = element("button");
			button0.textContent = "Create Baseline";
			t2 = space();
			button1 = element("button");
			button1.textContent = "FELIX Plot";
			t4 = space();
			create_component(textfield.$$.fragment);
			t5 = space();
			button2 = element("button");
			button2.textContent = "Open in Matplotlib";
			t7 = space();
			create_component(customiconswitch.$$.fragment);
			t8 = space();
			button3 = element("button");
			button3.textContent = "Add Theory";
			t10 = space();
			button4 = element("button");
			button4.textContent = "OPO";
			attr_dev(button0, "class", "button is-link");
			attr_dev(button0, "id", "create_baseline_btn");
			add_location(button0, file$$, 115, 4, 4705);
			attr_dev(button1, "class", "button is-link");
			attr_dev(button1, "id", "felix_plotting_btn");
			add_location(button1, file$$, 116, 4, 4847);
			attr_dev(button2, "class", "button is-link");
			add_location(button2, file$$, 118, 4, 5092);
			attr_dev(button3, "class", "button is-link");
			add_location(button3, file$$, 120, 4, 5276);
			attr_dev(button4, "class", "button is-link");
			add_location(button4, file$$, 121, 4, 5374);
			attr_dev(div, "class", "align");
			add_location(div, file$$, 113, 0, 4678);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(felixplotting, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(div, t2);
			append_dev(div, button1);
			append_dev(div, t4);
			mount_component(textfield, div, null);
			append_dev(div, t5);
			append_dev(div, button2);
			append_dev(div, t7);
			mount_component(customiconswitch, div, null);
			append_dev(div, t8);
			append_dev(div, button3);
			append_dev(div, t10);
			append_dev(div, button4);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[19], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[20], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[22], false, false, false),
					listen_dev(button3, "click", /*click_handler_3*/ ctx[24], false, false, false),
					listen_dev(button4, "click", /*click_handler_4*/ ctx[25], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const felixplotting_changes = {};
			if (dirty[0] & /*felixPlotCheckboxes*/ 1) felixplotting_changes.felixPlotCheckboxes = /*felixPlotCheckboxes*/ ctx[0];

			if (!updating_active && dirty[0] & /*active*/ 2) {
				updating_active = true;
				felixplotting_changes.active = /*active*/ ctx[1];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_felixPlotWidgets && dirty[0] & /*felixPlotWidgets*/ 16) {
				updating_felixPlotWidgets = true;
				felixplotting_changes.felixPlotWidgets = /*felixPlotWidgets*/ ctx[4];
				add_flush_callback(() => updating_felixPlotWidgets = false);
			}

			felixplotting.$set(felixplotting_changes);
			const textfield_changes = {};

			if (!updating_value && dirty[0] & /*delta*/ 8) {
				updating_value = true;
				textfield_changes.value = /*delta*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty[0] & /*openShell*/ 4) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*openShell*/ ctx[2];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(felixplotting.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(customiconswitch.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(felixplotting.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(customiconswitch.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(felixplotting, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_component(textfield);
			destroy_component(customiconswitch);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props, $$invalidate) {
	let $felixOutputName;
	let $felixPlotAnnotations;
	let $felixPeakTable;
	let $expfittedLines;
	let $expfittedLinesCollectedData;
	let $fittedTraceCount;
	let $opoMode;
	let $felixopoLocation;
	let $toggleRow;
	validate_store(felixOutputName, "felixOutputName");
	component_subscribe($$self, felixOutputName, $$value => $$invalidate(26, $felixOutputName = $$value));
	validate_store(felixPlotAnnotations, "felixPlotAnnotations");
	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(27, $felixPlotAnnotations = $$value));
	validate_store(felixPeakTable, "felixPeakTable");
	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(28, $felixPeakTable = $$value));
	validate_store(expfittedLines, "expfittedLines");
	component_subscribe($$self, expfittedLines, $$value => $$invalidate(29, $expfittedLines = $$value));
	validate_store(expfittedLinesCollectedData, "expfittedLinesCollectedData");
	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(30, $expfittedLinesCollectedData = $$value));
	validate_store(fittedTraceCount, "fittedTraceCount");
	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(31, $fittedTraceCount = $$value));
	validate_store(opoMode, "opoMode");
	component_subscribe($$self, opoMode, $$value => $$invalidate(5, $opoMode = $$value));
	validate_store(felixopoLocation, "felixopoLocation");
	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(32, $felixopoLocation = $$value));
	validate_store(toggleRow, "toggleRow");
	component_subscribe($$self, toggleRow, $$value => $$invalidate(6, $toggleRow = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InitFunctionRow", slots, []);

	let { felixPlotCheckboxes } = $$props,
		{ preModal } = $$props,
		{ felixfiles } = $$props,
		{ graphPlotted } = $$props,
		{ opofiles } = $$props,
		{ normMethod } = $$props,
		{ show_theoryplot } = $$props,
		{ removeExtraFile } = $$props,
		{ theoryLocation } = $$props;

	let active = false, openShell = false, delta = 1;

	let felixPlotWidgets = {
		text: [
			{
				label: "Fig. caption",
				value: " ",
				id: getID()
			},
			{
				label: "Fig. title",
				value: " ",
				id: getID()
			},
			{
				label: "Exp. title",
				value: " ",
				id: getID()
			},
			{
				label: "Exp. legend",
				value: " ",
				id: getID()
			},
			{
				label: "Cal. title",
				value: " ",
				id: getID()
			},
			{
				label: "markers",
				value: " ",
				id: getID()
			}
		],
		number: [
			{
				label: "Fig. Width",
				value: 7,
				step: 1,
				id: getID()
			},
			{
				label: "Fig. Height",
				value: 7,
				step: 1,
				id: getID()
			},
			{
				label: "Fig. DPI",
				value: 120,
				step: 5,
				id: getID()
			},
			{
				label: "freqScale",
				value: 1,
				step: 0.01,
				id: getID()
			},
			{
				label: "gridAlpha",
				value: 0,
				step: 0.1,
				id: getID()
			},
			{
				label: "theorySigma",
				value: 5,
				step: 1,
				id: getID()
			},
			{
				label: "Tick Interval",
				value: 200,
				step: 50,
				id: getID()
			}
		],
		boolean: [
			{
				label: "sameColor",
				value: true,
				id: getID()
			},
			{
				label: "Invert ax2",
				value: true,
				id: getID()
			},
			{
				label: "Only exp.",
				value: true,
				id: getID()
			},
			{
				label: "hide ax2 axis.",
				value: true,
				id: getID()
			},
			{
				label: "hide_all_axis",
				value: false,
				id: getID()
			},
			{
				label: "legend_visible",
				value: true,
				id: getID()
			}
		]
	};

	function plotData({ e = null, filetype = "felix" } = {}) {
		let pyfile = "", args;

		switch (filetype) {
			case "felix":
				if (felixfiles.length < 1) return window.createToast("No files selected", "danger");
				removeExtraFile();
				($$invalidate(9, graphPlotted = false), set_store_value(felixOutputName, $felixOutputName = "averaged", $felixOutputName), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations), set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable));
				(pyfile = "normline.py", args = [...felixfiles, delta]);
				computePy_func({ e, pyfile, args }).then(dataFromPython => {
					(set_store_value(expfittedLines, $expfittedLines = [], $expfittedLines), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations), set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount));
					$$invalidate(10, show_theoryplot = false);
					felix_func({ normMethod, dataFromPython, delta });
					window.createToast("Graph Plotted", "success");
					$$invalidate(9, graphPlotted = true);
				}).catch(err => {
					$$invalidate(8, preModal.modalContent = err, preModal);
					$$invalidate(8, preModal.open = true, preModal);
				});
				break;
			case "baseline":
				if ($opoMode) {
					if (opofiles.length < 1) return window.createToast("No OPO files selected", "danger");
				} else if (felixfiles.length < 1) {
					return window.createToast("No FELIX files selected", "danger");
				}
				(pyfile = "baseline.py", args = $opoMode ? opofiles : felixfiles);
				computePy_func({
					e,
					pyfile,
					args,
					general: true,
					openShell
				}).catch(err => {
					$$invalidate(8, preModal.modalContent = err, preModal);
					$$invalidate(8, preModal.open = true, preModal);
				});
				break;
			case "matplotlib":
				const numberWidgets = felixPlotWidgets.number.map(n => n.value);
				const textWidgets = felixPlotWidgets.text.map(n => n.value);
				const booleanWidgets = felixPlotWidgets.boolean.map(n => n.value);
				const selectedWidgets = felixPlotCheckboxes.map(n => n.selected);
				(pyfile = "felix_tkplot.py", args = [
					JSON.stringify({
						numberWidgets,
						textWidgets,
						booleanWidgets,
						selectedWidgets,
						location: $felixopoLocation,
						normMethod,
						theoryLocation
					})
				]);
				computePy_func({
					e,
					pyfile,
					args,
					general: true,
					openShell
				}).catch(err => {
					$$invalidate(8, preModal.modalContent = err, preModal);
					$$invalidate(8, preModal.open = true, preModal);
				});
		}
	}

	const writable_props = [
		"felixPlotCheckboxes",
		"preModal",
		"felixfiles",
		"graphPlotted",
		"opofiles",
		"normMethod",
		"show_theoryplot",
		"removeExtraFile",
		"theoryLocation"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InitFunctionRow> was created with unknown prop '${key}'`);
	});

	function felixplotting_active_binding(value) {
		active = value;
		$$invalidate(1, active);
	}

	function felixplotting_felixPlotWidgets_binding(value) {
		felixPlotWidgets = value;
		$$invalidate(4, felixPlotWidgets);
	}

	const submit_handler = e => plotData({
		e: e.detail.event,
		filetype: "matplotlib"
	});

	const click_handler = e => plotData({ e, filetype: "baseline" });
	const click_handler_1 = e => plotData({ e, filetype: "felix" });

	function textfield_value_binding(value) {
		delta = value;
		$$invalidate(3, delta);
	}

	const click_handler_2 = () => $$invalidate(1, active = true);

	function customiconswitch_toggler_binding(value) {
		openShell = value;
		$$invalidate(2, openShell);
	}

	const click_handler_3 = () => set_store_value(toggleRow, $toggleRow = !$toggleRow, $toggleRow);

	const click_handler_4 = () => {
		set_store_value(opoMode, $opoMode = !$opoMode, $opoMode);
	};

	$$self.$$set = $$props => {
		if ("felixPlotCheckboxes" in $$props) $$invalidate(0, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
		if ("felixfiles" in $$props) $$invalidate(11, felixfiles = $$props.felixfiles);
		if ("graphPlotted" in $$props) $$invalidate(9, graphPlotted = $$props.graphPlotted);
		if ("opofiles" in $$props) $$invalidate(12, opofiles = $$props.opofiles);
		if ("normMethod" in $$props) $$invalidate(13, normMethod = $$props.normMethod);
		if ("show_theoryplot" in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
		if ("removeExtraFile" in $$props) $$invalidate(14, removeExtraFile = $$props.removeExtraFile);
		if ("theoryLocation" in $$props) $$invalidate(15, theoryLocation = $$props.theoryLocation);
	};

	$$self.$capture_state = () => ({
		opoMode,
		toggleRow,
		felixOutputName,
		felixPlotAnnotations,
		felixPeakTable,
		expfittedLines,
		expfittedLinesCollectedData,
		fittedTraceCount,
		felixopoLocation,
		Textfield,
		CustomIconSwitch,
		FelixPlotting,
		felix_func,
		felixPlotCheckboxes,
		preModal,
		felixfiles,
		graphPlotted,
		opofiles,
		normMethod,
		show_theoryplot,
		removeExtraFile,
		theoryLocation,
		active,
		openShell,
		delta,
		felixPlotWidgets,
		plotData,
		$felixOutputName,
		$felixPlotAnnotations,
		$felixPeakTable,
		$expfittedLines,
		$expfittedLinesCollectedData,
		$fittedTraceCount,
		$opoMode,
		$felixopoLocation,
		$toggleRow
	});

	$$self.$inject_state = $$props => {
		if ("felixPlotCheckboxes" in $$props) $$invalidate(0, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
		if ("felixfiles" in $$props) $$invalidate(11, felixfiles = $$props.felixfiles);
		if ("graphPlotted" in $$props) $$invalidate(9, graphPlotted = $$props.graphPlotted);
		if ("opofiles" in $$props) $$invalidate(12, opofiles = $$props.opofiles);
		if ("normMethod" in $$props) $$invalidate(13, normMethod = $$props.normMethod);
		if ("show_theoryplot" in $$props) $$invalidate(10, show_theoryplot = $$props.show_theoryplot);
		if ("removeExtraFile" in $$props) $$invalidate(14, removeExtraFile = $$props.removeExtraFile);
		if ("theoryLocation" in $$props) $$invalidate(15, theoryLocation = $$props.theoryLocation);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
		if ("openShell" in $$props) $$invalidate(2, openShell = $$props.openShell);
		if ("delta" in $$props) $$invalidate(3, delta = $$props.delta);
		if ("felixPlotWidgets" in $$props) $$invalidate(4, felixPlotWidgets = $$props.felixPlotWidgets);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		felixPlotCheckboxes,
		active,
		openShell,
		delta,
		felixPlotWidgets,
		$opoMode,
		$toggleRow,
		plotData,
		preModal,
		graphPlotted,
		show_theoryplot,
		felixfiles,
		opofiles,
		normMethod,
		removeExtraFile,
		theoryLocation,
		felixplotting_active_binding,
		felixplotting_felixPlotWidgets_binding,
		submit_handler,
		click_handler,
		click_handler_1,
		textfield_value_binding,
		click_handler_2,
		customiconswitch_toggler_binding,
		click_handler_3,
		click_handler_4
	];
}

class InitFunctionRow extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$15,
			create_fragment$15,
			safe_not_equal,
			{
				felixPlotCheckboxes: 0,
				preModal: 8,
				felixfiles: 11,
				graphPlotted: 9,
				opofiles: 12,
				normMethod: 13,
				show_theoryplot: 10,
				removeExtraFile: 14,
				theoryLocation: 15
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InitFunctionRow",
			options,
			id: create_fragment$15.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*felixPlotCheckboxes*/ ctx[0] === undefined && !("felixPlotCheckboxes" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'felixPlotCheckboxes'");
		}

		if (/*preModal*/ ctx[8] === undefined && !("preModal" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'preModal'");
		}

		if (/*felixfiles*/ ctx[11] === undefined && !("felixfiles" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'felixfiles'");
		}

		if (/*graphPlotted*/ ctx[9] === undefined && !("graphPlotted" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'graphPlotted'");
		}

		if (/*opofiles*/ ctx[12] === undefined && !("opofiles" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'opofiles'");
		}

		if (/*normMethod*/ ctx[13] === undefined && !("normMethod" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'normMethod'");
		}

		if (/*show_theoryplot*/ ctx[10] === undefined && !("show_theoryplot" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'show_theoryplot'");
		}

		if (/*removeExtraFile*/ ctx[14] === undefined && !("removeExtraFile" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'removeExtraFile'");
		}

		if (/*theoryLocation*/ ctx[15] === undefined && !("theoryLocation" in props)) {
			console.warn("<InitFunctionRow> was created without expected prop 'theoryLocation'");
		}
	}

	get felixPlotCheckboxes() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixPlotCheckboxes(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get felixfiles() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixfiles(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get graphPlotted() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set graphPlotted(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opofiles() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opofiles(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get normMethod() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set normMethod(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_theoryplot() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_theoryplot(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get removeExtraFile() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set removeExtraFile(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theoryLocation() {
		throw new Error("<InitFunctionRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theoryLocation(value) {
		throw new Error("<InitFunctionRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomSelect.svelte generated by Svelte v3.31.2 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (10:8) <Option value={option} selected={picked === option}>
function create_default_slot_1$c(ctx) {
	let t_value = /*option*/ ctx[6] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[6] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$c.name,
		type: "slot",
		source: "(10:8) <Option value={option} selected={picked === option}>",
		ctx
	});

	return block;
}

// (9:4) {#each options as option}
function create_each_block$8(ctx) {
	let option;
	let current;

	option = new Option({
			props: {
				value: /*option*/ ctx[6],
				selected: /*picked*/ ctx[0] === /*option*/ ctx[6],
				$$slots: { default: [create_default_slot_1$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(option.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(option, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const option_changes = {};
			if (dirty & /*options*/ 2) option_changes.value = /*option*/ ctx[6];
			if (dirty & /*picked, options*/ 3) option_changes.selected = /*picked*/ ctx[0] === /*option*/ ctx[6];

			if (dirty & /*$$scope, options*/ 514) {
				option_changes.$$scope = { dirty, ctx };
			}

			option.$set(option_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(option.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(option.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(option, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$8.name,
		type: "each",
		source: "(9:4) {#each options as option}",
		ctx
	});

	return block;
}

// (7:0) <Select bind:value={picked} {label} {style} on:change>
function create_default_slot$o(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*options*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options, picked*/ 3) {
				each_value = /*options*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$o.name,
		type: "slot",
		source: "(7:0) <Select bind:value={picked} {label} {style} on:change>",
		ctx
	});

	return block;
}

function create_fragment$16(ctx) {
	let select;
	let updating_value;
	let current;

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[4].call(null, value);
	}

	let select_props = {
		label: /*label*/ ctx[3],
		style: /*style*/ ctx[2],
		$$slots: { default: [create_default_slot$o] },
		$$scope: { ctx }
	};

	if (/*picked*/ ctx[0] !== void 0) {
		select_props.value = /*picked*/ ctx[0];
	}

	select = new Select({ props: select_props, $$inline: true });
	binding_callbacks.push(() => bind(select, "value", select_value_binding));
	select.$on("change", /*change_handler*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(select.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const select_changes = {};
			if (dirty & /*label*/ 8) select_changes.label = /*label*/ ctx[3];
			if (dirty & /*style*/ 4) select_changes.style = /*style*/ ctx[2];

			if (dirty & /*$$scope, options, picked*/ 515) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty & /*picked*/ 1) {
				updating_value = true;
				select_changes.value = /*picked*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(select, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomSelect", slots, []);

	let { options = [] } = $$props,
		{ style = "" } = $$props,
		{ label = "" } = $$props,
		{ picked = "" } = $$props;

	const writable_props = ["options", "style", "label", "picked"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomSelect> was created with unknown prop '${key}'`);
	});

	function select_value_binding(value) {
		picked = value;
		$$invalidate(0, picked);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("picked" in $$props) $$invalidate(0, picked = $$props.picked);
	};

	$$self.$capture_state = () => ({
		Select,
		Option,
		options,
		style,
		label,
		picked
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("picked" in $$props) $$invalidate(0, picked = $$props.picked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [picked, options, style, label, select_value_binding, change_handler];
}

class CustomSelect extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$16, create_fragment$16, safe_not_equal, {
			options: 1,
			style: 2,
			label: 3,
			picked: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomSelect",
			options,
			id: create_fragment$16.name
		});
	}

	get options() {
		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get picked() {
		throw new Error("<CustomSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set picked(value) {
		throw new Error("<CustomSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\QuickView.svelte generated by Svelte v3.31.2 */
const file$10 = "src\\components\\QuickView.svelte";
const get_footer_slot_changes$1 = dirty => ({});
const get_footer_slot_context$1 = ctx => ({});

// (37:13) Contents
function fallback_block$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Contents");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(37:13) Contents",
		ctx
	});

	return block;
}

// (41:2) {#if footer}
function create_if_block$l(ctx) {
	let footer_1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[7].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context$1);

	const block = {
		c: function create() {
			footer_1 = element("footer");
			if (footer_slot) footer_slot.c();
			attr_dev(footer_1, "class", "quickview-footer svelte-18rgtvs");
			add_location(footer_1, file$10, 41, 4, 1131);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer_1, anchor);

			if (footer_slot) {
				footer_slot.m(footer_1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (footer_slot) {
				if (footer_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes$1, get_footer_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer_1);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(41:2) {#if footer}",
		ctx
	});

	return block;
}

function create_fragment$17(ctx) {
	let div3;
	let header;
	let button;
	let t1;
	let div0;
	let t2;
	let t3;
	let span;
	let t4;
	let div2;
	let div1;
	let t5;
	let div3_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);
	let if_block = /*footer*/ ctx[2] && create_if_block$l(ctx);

	const block = {
		c: function create() {
			div3 = element("div");
			header = element("header");
			button = element("button");
			button.textContent = "Browse";
			t1 = space();
			div0 = element("div");
			t2 = text(/*title*/ ctx[3]);
			t3 = space();
			span = element("span");
			t4 = space();
			div2 = element("div");
			div1 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t5 = space();
			if (if_block) if_block.c();
			attr_dev(button, "class", "button is-link");
			add_location(button, file$10, 28, 4, 728);
			attr_dev(div0, "class", "subtitle");
			set_style(div0, "margin", "0");
			add_location(div0, file$10, 29, 4, 805);
			attr_dev(span, "class", "delete is-pulled-right svelte-18rgtvs");
			attr_dev(span, "data-dismiss", "quickview");
			add_location(span, file$10, 30, 4, 864);
			attr_dev(header, "class", "quickview-header");
			add_location(header, file$10, 26, 2, 687);
			attr_dev(div1, "class", "quickview-block");
			add_location(div1, file$10, 35, 4, 1026);
			attr_dev(div2, "class", "quickview-body");
			attr_dev(div2, "style", /*style*/ ctx[1]);
			add_location(div2, file$10, 34, 2, 984);
			attr_dev(div3, "class", "quickview svelte-18rgtvs");
			toggle_class(div3, "is-active", /*active*/ ctx[0]);
			add_location(div3, file$10, 24, 0, 617);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, header);
			append_dev(header, button);
			append_dev(header, t1);
			append_dev(header, div0);
			append_dev(div0, t2);
			append_dev(header, t3);
			append_dev(header, span);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, div1);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div1, null);
			}

			append_dev(div3, t5);
			if (if_block) if_block.m(div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*browse_folder*/ ctx[4], false, false, false),
					listen_dev(span, "click", /*click_handler*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 8) set_data_dev(t2, /*title*/ ctx[3]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*style*/ 2) {
				attr_dev(div2, "style", /*style*/ ctx[1]);
			}

			if (/*footer*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*footer*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$l(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div3, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*active*/ 1) {
				toggle_class(div3, "is-active", /*active*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			transition_in(if_block);

			add_render_callback(() => {
				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, true);
				div3_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			transition_out(if_block);
			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, {}, false);
			div3_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			if (detaching && div3_transition) div3_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("QuickView", slots, ['default','footer']);

	let { active = false } = $$props,
		{ style = "" } = $$props,
		{ footer = true } = $$props,
		{ currentLocation = "" } = $$props,
		{ title = "" } = $$props;

	function browse_folder() {
		browse({ dir: true }).then(result => {
			if (!result.canceled) {
				$$invalidate(5, currentLocation = result.filePaths[0]);
				window.createToast("Location updated");
			}
		});
	}

	const writable_props = ["active", "style", "footer", "currentLocation", "title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<QuickView> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, active = false);

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("footer" in $$props) $$invalidate(2, footer = $$props.footer);
		if ("currentLocation" in $$props) $$invalidate(5, currentLocation = $$props.currentLocation);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		browse,
		fade,
		active,
		style,
		footer,
		currentLocation,
		title,
		browse_folder
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("footer" in $$props) $$invalidate(2, footer = $$props.footer);
		if ("currentLocation" in $$props) $$invalidate(5, currentLocation = $$props.currentLocation);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		style,
		footer,
		title,
		browse_folder,
		currentLocation,
		$$scope,
		slots,
		click_handler
	];
}

class QuickView extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$17, create_fragment$17, safe_not_equal, {
			active: 0,
			style: 1,
			footer: 2,
			currentLocation: 5,
			title: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "QuickView",
			options,
			id: create_fragment$17.name
		});
	}

	get active() {
		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footer() {
		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footer(value) {
		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLocation() {
		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<QuickView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<QuickView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\QuickBrowser.svelte generated by Svelte v3.31.2 */
const file$11 = "src\\components\\QuickBrowser.svelte";

// (16:4) <div slot="footer" style="margin:auto">
function create_footer_slot(ctx) {
	let div;
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			button.textContent = "Submit";
			attr_dev(button, "class", "button is-link");
			add_location(button, file$11, 17, 8, 586);
			attr_dev(div, "slot", "footer");
			set_style(div, "margin", "auto");
			add_location(div, file$11, 15, 4, 535);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(16:4) <div slot=\\\"footer\\\" style=\\\"margin:auto\\\">",
		ctx
	});

	return block;
}

// (14:0) <QuickView style="padding:1em;" bind:active bind:currentLocation {title}>
function create_default_slot$p(ctx) {
	let filebrowser;
	let updating_currentLocation;
	let updating_fileChecked;
	let t;
	let current;

	function filebrowser_currentLocation_binding(value) {
		/*filebrowser_currentLocation_binding*/ ctx[7].call(null, value);
	}

	function filebrowser_fileChecked_binding(value) {
		/*filebrowser_fileChecked_binding*/ ctx[8].call(null, value);
	}

	let filebrowser_props = { filetype: /*filetype*/ ctx[3] };

	if (/*currentLocation*/ ctx[1] !== void 0) {
		filebrowser_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	if (/*fileChecked*/ ctx[2] !== void 0) {
		filebrowser_props.fileChecked = /*fileChecked*/ ctx[2];
	}

	filebrowser = new FileBrowser({ props: filebrowser_props, $$inline: true });
	binding_callbacks.push(() => bind(filebrowser, "currentLocation", filebrowser_currentLocation_binding));
	binding_callbacks.push(() => bind(filebrowser, "fileChecked", filebrowser_fileChecked_binding));

	const block = {
		c: function create() {
			create_component(filebrowser.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(filebrowser, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const filebrowser_changes = {};
			if (dirty & /*filetype*/ 8) filebrowser_changes.filetype = /*filetype*/ ctx[3];

			if (!updating_currentLocation && dirty & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				filebrowser_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty & /*fileChecked*/ 4) {
				updating_fileChecked = true;
				filebrowser_changes.fileChecked = /*fileChecked*/ ctx[2];
				add_flush_callback(() => updating_fileChecked = false);
			}

			filebrowser.$set(filebrowser_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(filebrowser.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(filebrowser.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(filebrowser, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$p.name,
		type: "slot",
		source: "(14:0) <QuickView style=\\\"padding:1em;\\\" bind:active bind:currentLocation {title}>",
		ctx
	});

	return block;
}

function create_fragment$18(ctx) {
	let quickview;
	let updating_active;
	let updating_currentLocation;
	let current;
	let mounted;
	let dispose;

	function quickview_active_binding(value) {
		/*quickview_active_binding*/ ctx[10].call(null, value);
	}

	function quickview_currentLocation_binding(value) {
		/*quickview_currentLocation_binding*/ ctx[11].call(null, value);
	}

	let quickview_props = {
		style: "padding:1em;",
		title: /*title*/ ctx[4],
		$$slots: {
			default: [create_default_slot$p],
			footer: [create_footer_slot]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		quickview_props.active = /*active*/ ctx[0];
	}

	if (/*currentLocation*/ ctx[1] !== void 0) {
		quickview_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	quickview = new QuickView({ props: quickview_props, $$inline: true });
	binding_callbacks.push(() => bind(quickview, "active", quickview_active_binding));
	binding_callbacks.push(() => bind(quickview, "currentLocation", quickview_currentLocation_binding));

	const block = {
		c: function create() {
			create_component(quickview.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(quickview, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window, "keydown", /*keydown_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const quickview_changes = {};
			if (dirty & /*title*/ 16) quickview_changes.title = /*title*/ ctx[4];

			if (dirty & /*$$scope, filetype, currentLocation, fileChecked*/ 4110) {
				quickview_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				quickview_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_currentLocation && dirty & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				quickview_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			quickview.$set(quickview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(quickview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(quickview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(quickview, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("QuickBrowser", slots, []);

	let { active = false } = $$props,
		{ currentLocation } = $$props,
		{ fileChecked } = $$props,
		{ filetype = "" } = $$props,
		{ title = "" } = $$props;

	const dispatch = createEventDispatcher();
	const writable_props = ["active", "currentLocation", "fileChecked", "filetype", "title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<QuickBrowser> was created with unknown prop '${key}'`);
	});

	const keydown_handler = e => {
		if (e.keyCode === 27) $$invalidate(0, active = false);
	};

	function filebrowser_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function filebrowser_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(2, fileChecked);
	}

	const click_handler = e => {
		dispatch("submit", { event: e });
	};

	function quickview_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	function quickview_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("fileChecked" in $$props) $$invalidate(2, fileChecked = $$props.fileChecked);
		if ("filetype" in $$props) $$invalidate(3, filetype = $$props.filetype);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		QuickView,
		FileBrowser,
		createEventDispatcher,
		active,
		currentLocation,
		fileChecked,
		filetype,
		title,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("fileChecked" in $$props) $$invalidate(2, fileChecked = $$props.fileChecked);
		if ("filetype" in $$props) $$invalidate(3, filetype = $$props.filetype);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		currentLocation,
		fileChecked,
		filetype,
		title,
		dispatch,
		keydown_handler,
		filebrowser_currentLocation_binding,
		filebrowser_fileChecked_binding,
		click_handler,
		quickview_active_binding,
		quickview_currentLocation_binding
	];
}

class QuickBrowser extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			active: 0,
			currentLocation: 1,
			fileChecked: 2,
			filetype: 3,
			title: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "QuickBrowser",
			options,
			id: create_fragment$18.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*currentLocation*/ ctx[1] === undefined && !("currentLocation" in props)) {
			console.warn("<QuickBrowser> was created without expected prop 'currentLocation'");
		}

		if (/*fileChecked*/ ctx[2] === undefined && !("fileChecked" in props)) {
			console.warn("<QuickBrowser> was created without expected prop 'fileChecked'");
		}
	}

	get active() {
		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLocation() {
		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fileChecked() {
		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fileChecked(value) {
		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filetype() {
		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filetype(value) {
		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<QuickBrowser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<QuickBrowser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

async function opofile_func({ dataFromPython, delta } = {}) {

    await beforePlot({ delta, dataFromPython, graphDiv: "opoRelPlot", baseGraphDiv:"opoplot" });

    plot("OPO Calibration", "Set Wavenumber (cm-1)", "Measured Wavenumber (cm-1)", dataFromPython["SA"], "opoSA");


    if (!get_store_value(plotlyEventCreatedOPO)) {

        const plot = { graphDiv: "opoRelPlot", mode: "opo" };

        plotlySelection(plot), plotlyClick(plot);
        plotlyEventCreatedOPO.set(true);
    }
}

/* src\Pages\normline\widgets\preprocessing\OPORow.svelte generated by Svelte v3.31.2 */
const file$12 = "src\\Pages\\normline\\widgets\\preprocessing\\OPORow.svelte";

// (50:0) {#if $opoMode}
function create_if_block$m(ctx) {
	let div;
	let customselect;
	let updating_picked;
	let t0;
	let textfield0;
	let updating_value;
	let t1;
	let textfield1;
	let updating_value_1;
	let t2;
	let button0;
	let t4;
	let button1;
	let div_transition;
	let current;
	let mounted;
	let dispose;

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[17].call(null, value);
	}

	let customselect_props = {
		style: "width:7em;",
		label: "Calib. file",
		options: ["", .../*OPOcalibFiles*/ ctx[3]]
	};

	if (/*calibFile*/ ctx[5] !== void 0) {
		customselect_props.picked = /*calibFile*/ ctx[5];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[18].call(null, value);
	}

	let textfield0_props = {
		style: "width:7em; margin:0 0.5em;",
		type: "number",
		step: "0.02",
		min: "0",
		variant: "outlined",
		label: "Delta OPO"
	};

	if (/*deltaOPO*/ ctx[4] !== void 0) {
		textfield0_props.value = /*deltaOPO*/ ctx[4];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[19].call(null, value);
	}

	let textfield1_props = {
		style: "width:9em",
		type: "number",
		step: "0.1",
		min: "0",
		variant: "outlined",
		label: "Power (mJ)"
	};

	if (/*opoPower*/ ctx[6] !== void 0) {
		textfield1_props.value = /*opoPower*/ ctx[6];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(customselect.$$.fragment);
			t0 = space();
			create_component(textfield0.$$.fragment);
			t1 = space();
			create_component(textfield1.$$.fragment);
			t2 = space();
			button0 = element("button");
			button0.textContent = "Browse File";
			t4 = space();
			button1 = element("button");
			button1.textContent = "Replot";
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$12, 58, 8, 2373);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$12, 59, 8, 2484);
			attr_dev(div, "class", "align");
			add_location(div, file$12, 51, 4, 1910);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(customselect, div, null);
			append_dev(div, t0);
			mount_component(textfield0, div, null);
			append_dev(div, t1);
			mount_component(textfield1, div, null);
			append_dev(div, t2);
			append_dev(div, button0);
			append_dev(div, t4);
			append_dev(div, button1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[20], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[21], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const customselect_changes = {};
			if (dirty & /*OPOcalibFiles*/ 8) customselect_changes.options = ["", .../*OPOcalibFiles*/ ctx[3]];

			if (!updating_picked && dirty & /*calibFile*/ 32) {
				updating_picked = true;
				customselect_changes.picked = /*calibFile*/ ctx[5];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty & /*deltaOPO*/ 16) {
				updating_value = true;
				textfield0_changes.value = /*deltaOPO*/ ctx[4];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*opoPower*/ 64) {
				updating_value_1 = true;
				textfield1_changes.value = /*opoPower*/ ctx[6];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(customselect);
			destroy_component(textfield0);
			destroy_component(textfield1);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$m.name,
		type: "if",
		source: "(50:0) {#if $opoMode}",
		ctx
	});

	return block;
}

function create_fragment$19(ctx) {
	let quickbrowser;
	let updating_active;
	let updating_currentLocation;
	let updating_fileChecked;
	let t;
	let if_block_anchor;
	let current;

	function quickbrowser_active_binding(value) {
		/*quickbrowser_active_binding*/ ctx[13].call(null, value);
	}

	function quickbrowser_currentLocation_binding(value) {
		/*quickbrowser_currentLocation_binding*/ ctx[14].call(null, value);
	}

	function quickbrowser_fileChecked_binding(value) {
		/*quickbrowser_fileChecked_binding*/ ctx[15].call(null, value);
	}

	let quickbrowser_props = { title: "OPO files", filetype: "ofelix" };

	if (/*showOPOFiles*/ ctx[2] !== void 0) {
		quickbrowser_props.active = /*showOPOFiles*/ ctx[2];
	}

	if (/*OPOLocation*/ ctx[0] !== void 0) {
		quickbrowser_props.currentLocation = /*OPOLocation*/ ctx[0];
	}

	if (/*OPOfilesChecked*/ ctx[1] !== void 0) {
		quickbrowser_props.fileChecked = /*OPOfilesChecked*/ ctx[1];
	}

	quickbrowser = new QuickBrowser({
			props: quickbrowser_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(quickbrowser, "active", quickbrowser_active_binding));
	binding_callbacks.push(() => bind(quickbrowser, "currentLocation", quickbrowser_currentLocation_binding));
	binding_callbacks.push(() => bind(quickbrowser, "fileChecked", quickbrowser_fileChecked_binding));
	quickbrowser.$on("submit", /*submit_handler*/ ctx[16]);
	let if_block = /*$opoMode*/ ctx[7] && create_if_block$m(ctx);

	const block = {
		c: function create() {
			create_component(quickbrowser.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(quickbrowser, target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const quickbrowser_changes = {};

			if (!updating_active && dirty & /*showOPOFiles*/ 4) {
				updating_active = true;
				quickbrowser_changes.active = /*showOPOFiles*/ ctx[2];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_currentLocation && dirty & /*OPOLocation*/ 1) {
				updating_currentLocation = true;
				quickbrowser_changes.currentLocation = /*OPOLocation*/ ctx[0];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty & /*OPOfilesChecked*/ 2) {
				updating_fileChecked = true;
				quickbrowser_changes.fileChecked = /*OPOfilesChecked*/ ctx[1];
				add_flush_callback(() => updating_fileChecked = false);
			}

			quickbrowser.$set(quickbrowser_changes);

			if (/*$opoMode*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$opoMode*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$m(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(quickbrowser.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(quickbrowser.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(quickbrowser, detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props, $$invalidate) {
	let $opoMode;
	let $felixPlotAnnotations;
	validate_store(opoMode, "opoMode");
	component_subscribe($$self, opoMode, $$value => $$invalidate(7, $opoMode = $$value));
	validate_store(felixPlotAnnotations, "felixPlotAnnotations");
	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(22, $felixPlotAnnotations = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("OPORow", slots, []);

	let { OPOLocation } = $$props,
		{ opofiles } = $$props,
		{ OPOfilesChecked } = $$props,
		{ preModal } = $$props,
		{ graphPlotted } = $$props,
		{ removeExtraFile } = $$props;

	let showOPOFiles = false, OPOcalibFiles = [];
	let deltaOPO = 0.3, calibFile = "", opoPower = 1;

	function plotData({ e = null, tkplot = "run" } = {}) {
		let pyfile = "oposcan.py", args;
		removeExtraFile();
		if (opofiles.length < 1) return window.createToast("No files selected", "danger");
		(set_store_value(opoMode, $opoMode = true, $opoMode), set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations));

		let opo_args = {
			opofiles,
			tkplot,
			deltaOPO,
			calibFile,
			opoPower
		};

		args = [JSON.stringify(opo_args)];

		computePy_func({ e, pyfile, args }).then(dataFromPython => {
			opofile_func({ dataFromPython, delta: deltaOPO });
			window.createToast("Graph Plotted", "success");
			($$invalidate(11, graphPlotted = true), set_store_value(opoMode, $opoMode = true, $opoMode));
			localStorage["opoLocation"] = OPOLocation;
			$$invalidate(2, showOPOFiles = false);
		}).catch(err => {
			$$invalidate(10, preModal.modalContent = err, preModal);
			$$invalidate(10, preModal.open = true, preModal);
		});
	}

	const writable_props = [
		"OPOLocation",
		"opofiles",
		"OPOfilesChecked",
		"preModal",
		"graphPlotted",
		"removeExtraFile"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OPORow> was created with unknown prop '${key}'`);
	});

	function quickbrowser_active_binding(value) {
		showOPOFiles = value;
		$$invalidate(2, showOPOFiles);
	}

	function quickbrowser_currentLocation_binding(value) {
		OPOLocation = value;
		$$invalidate(0, OPOLocation);
	}

	function quickbrowser_fileChecked_binding(value) {
		OPOfilesChecked = value;
		$$invalidate(1, OPOfilesChecked);
	}

	const submit_handler = e => {
		plotData({ e: e.detail.event });
	};

	function customselect_picked_binding(value) {
		calibFile = value;
		$$invalidate(5, calibFile);
	}

	function textfield0_value_binding(value) {
		deltaOPO = value;
		$$invalidate(4, deltaOPO);
	}

	function textfield1_value_binding(value) {
		opoPower = value;
		$$invalidate(6, opoPower);
	}

	const click_handler = () => {
		$$invalidate(2, showOPOFiles = !showOPOFiles);
	};

	const click_handler_1 = e => plotData({ e });

	$$self.$$set = $$props => {
		if ("OPOLocation" in $$props) $$invalidate(0, OPOLocation = $$props.OPOLocation);
		if ("opofiles" in $$props) $$invalidate(9, opofiles = $$props.opofiles);
		if ("OPOfilesChecked" in $$props) $$invalidate(1, OPOfilesChecked = $$props.OPOfilesChecked);
		if ("preModal" in $$props) $$invalidate(10, preModal = $$props.preModal);
		if ("graphPlotted" in $$props) $$invalidate(11, graphPlotted = $$props.graphPlotted);
		if ("removeExtraFile" in $$props) $$invalidate(12, removeExtraFile = $$props.removeExtraFile);
	};

	$$self.$capture_state = () => ({
		opoMode,
		felixPlotAnnotations,
		Textfield,
		CustomSelect,
		QuickBrowser,
		fade,
		opofile_func,
		OPOLocation,
		opofiles,
		OPOfilesChecked,
		preModal,
		graphPlotted,
		removeExtraFile,
		showOPOFiles,
		OPOcalibFiles,
		deltaOPO,
		calibFile,
		opoPower,
		plotData,
		$opoMode,
		$felixPlotAnnotations
	});

	$$self.$inject_state = $$props => {
		if ("OPOLocation" in $$props) $$invalidate(0, OPOLocation = $$props.OPOLocation);
		if ("opofiles" in $$props) $$invalidate(9, opofiles = $$props.opofiles);
		if ("OPOfilesChecked" in $$props) $$invalidate(1, OPOfilesChecked = $$props.OPOfilesChecked);
		if ("preModal" in $$props) $$invalidate(10, preModal = $$props.preModal);
		if ("graphPlotted" in $$props) $$invalidate(11, graphPlotted = $$props.graphPlotted);
		if ("removeExtraFile" in $$props) $$invalidate(12, removeExtraFile = $$props.removeExtraFile);
		if ("showOPOFiles" in $$props) $$invalidate(2, showOPOFiles = $$props.showOPOFiles);
		if ("OPOcalibFiles" in $$props) $$invalidate(3, OPOcalibFiles = $$props.OPOcalibFiles);
		if ("deltaOPO" in $$props) $$invalidate(4, deltaOPO = $$props.deltaOPO);
		if ("calibFile" in $$props) $$invalidate(5, calibFile = $$props.calibFile);
		if ("opoPower" in $$props) $$invalidate(6, opoPower = $$props.opoPower);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*OPOLocation, OPOfilesChecked*/ 3) {
			 if (fs.existsSync(OPOLocation)) {
				$$invalidate(3, OPOcalibFiles = fs.readdirSync(OPOLocation).filter(file => file.endsWith(".calibOPO")));
				$$invalidate(9, opofiles = OPOfilesChecked.map(file => path.resolve(OPOLocation, file)));
			}
		}
	};

	return [
		OPOLocation,
		OPOfilesChecked,
		showOPOFiles,
		OPOcalibFiles,
		deltaOPO,
		calibFile,
		opoPower,
		$opoMode,
		plotData,
		opofiles,
		preModal,
		graphPlotted,
		removeExtraFile,
		quickbrowser_active_binding,
		quickbrowser_currentLocation_binding,
		quickbrowser_fileChecked_binding,
		submit_handler,
		customselect_picked_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		click_handler,
		click_handler_1
	];
}

class OPORow extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
			OPOLocation: 0,
			opofiles: 9,
			OPOfilesChecked: 1,
			preModal: 10,
			graphPlotted: 11,
			removeExtraFile: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OPORow",
			options,
			id: create_fragment$19.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*OPOLocation*/ ctx[0] === undefined && !("OPOLocation" in props)) {
			console.warn("<OPORow> was created without expected prop 'OPOLocation'");
		}

		if (/*opofiles*/ ctx[9] === undefined && !("opofiles" in props)) {
			console.warn("<OPORow> was created without expected prop 'opofiles'");
		}

		if (/*OPOfilesChecked*/ ctx[1] === undefined && !("OPOfilesChecked" in props)) {
			console.warn("<OPORow> was created without expected prop 'OPOfilesChecked'");
		}

		if (/*preModal*/ ctx[10] === undefined && !("preModal" in props)) {
			console.warn("<OPORow> was created without expected prop 'preModal'");
		}

		if (/*graphPlotted*/ ctx[11] === undefined && !("graphPlotted" in props)) {
			console.warn("<OPORow> was created without expected prop 'graphPlotted'");
		}

		if (/*removeExtraFile*/ ctx[12] === undefined && !("removeExtraFile" in props)) {
			console.warn("<OPORow> was created without expected prop 'removeExtraFile'");
		}
	}

	get OPOLocation() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set OPOLocation(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opofiles() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opofiles(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get OPOfilesChecked() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set OPOfilesChecked(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get graphPlotted() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set graphPlotted(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get removeExtraFile() {
		throw new Error("<OPORow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set removeExtraFile(value) {
		throw new Error("<OPORow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function theory_func({dataFromPython, normMethod}={}){
    let ylabel;
    if (normMethod === "Log") { ylabel = "Normalised Intensity per J"; }
    else if (normMethod === "Relative") { ylabel = "Relative Depletion (%)"; }
    else { ylabel = "Normalised Intensity per Photon"; }

    let theoryData = [];
    for (let x in dataFromPython["line_simulation"]) { theoryData.push(dataFromPython["line_simulation"][x]); }

    plot(
        "Experimental vs Theory",
        "Calibrated Wavelength (cm-1)",
        ylabel, [dataFromPython["averaged"], ...theoryData],
        "exp-theory-plot"

    );

    console.log("Graph Plotted");
}

/* src\Pages\normline\widgets\preprocessing\TheoryRow.svelte generated by Svelte v3.31.2 */
const file$13 = "src\\Pages\\normline\\widgets\\preprocessing\\TheoryRow.svelte";

// (34:0) {#if $toggleRow}
function create_if_block$n(ctx) {
	let div;
	let button0;
	let t1;
	let textfield0;
	let updating_value;
	let t2;
	let textfield1;
	let updating_value_1;
	let t3;
	let button1;
	let div_transition;
	let current;
	let mounted;
	let dispose;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[16].call(null, value);
	}

	let textfield0_props = {
		type: "number",
		style: "width:7em; margin-right:0.5em;",
		variant: "outlined",
		label: "Sigma"
	};

	if (/*sigma*/ ctx[2] !== void 0) {
		textfield0_props.value = /*sigma*/ ctx[2];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[17].call(null, value);
	}

	let textfield1_props = {
		type: "number",
		style: "width:7em",
		variant: "outlined",
		label: "Scale"
	};

	if (/*scale*/ ctx[3] !== void 0) {
		textfield1_props.value = /*scale*/ ctx[3];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			button0.textContent = "Browse File";
			t1 = space();
			create_component(textfield0.$$.fragment);
			t2 = space();
			create_component(textfield1.$$.fragment);
			t3 = space();
			button1 = element("button");
			button1.textContent = "Replot";
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$13, 37, 8, 1577);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$13, 40, 8, 1927);
			attr_dev(div, "class", "align");
			add_location(div, file$13, 35, 4, 1530);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(div, t1);
			mount_component(textfield0, div, null);
			append_dev(div, t2);
			mount_component(textfield1, div, null);
			append_dev(div, t3);
			append_dev(div, button1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[15], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[18], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty & /*sigma*/ 4) {
				updating_value = true;
				textfield0_changes.value = /*sigma*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*scale*/ 8) {
				updating_value_1 = true;
				textfield1_changes.value = /*scale*/ ctx[3];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield0);
			destroy_component(textfield1);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$n.name,
		type: "if",
		source: "(34:0) {#if $toggleRow}",
		ctx
	});

	return block;
}

function create_fragment$1a(ctx) {
	let quickbrowser;
	let updating_active;
	let updating_currentLocation;
	let updating_fileChecked;
	let t;
	let if_block_anchor;
	let current;

	function quickbrowser_active_binding(value) {
		/*quickbrowser_active_binding*/ ctx[11].call(null, value);
	}

	function quickbrowser_currentLocation_binding(value) {
		/*quickbrowser_currentLocation_binding*/ ctx[12].call(null, value);
	}

	function quickbrowser_fileChecked_binding(value) {
		/*quickbrowser_fileChecked_binding*/ ctx[13].call(null, value);
	}

	let quickbrowser_props = { title: "Theory files" };

	if (/*showTheoryFiles*/ ctx[4] !== void 0) {
		quickbrowser_props.active = /*showTheoryFiles*/ ctx[4];
	}

	if (/*theoryLocation*/ ctx[0] !== void 0) {
		quickbrowser_props.currentLocation = /*theoryLocation*/ ctx[0];
	}

	if (/*theoryfilesChecked*/ ctx[1] !== void 0) {
		quickbrowser_props.fileChecked = /*theoryfilesChecked*/ ctx[1];
	}

	quickbrowser = new QuickBrowser({
			props: quickbrowser_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(quickbrowser, "active", quickbrowser_active_binding));
	binding_callbacks.push(() => bind(quickbrowser, "currentLocation", quickbrowser_currentLocation_binding));
	binding_callbacks.push(() => bind(quickbrowser, "fileChecked", quickbrowser_fileChecked_binding));
	quickbrowser.$on("submit", /*submit_handler*/ ctx[14]);
	let if_block = /*$toggleRow*/ ctx[5] && create_if_block$n(ctx);

	const block = {
		c: function create() {
			create_component(quickbrowser.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(quickbrowser, target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const quickbrowser_changes = {};

			if (!updating_active && dirty & /*showTheoryFiles*/ 16) {
				updating_active = true;
				quickbrowser_changes.active = /*showTheoryFiles*/ ctx[4];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_currentLocation && dirty & /*theoryLocation*/ 1) {
				updating_currentLocation = true;
				quickbrowser_changes.currentLocation = /*theoryLocation*/ ctx[0];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty & /*theoryfilesChecked*/ 2) {
				updating_fileChecked = true;
				quickbrowser_changes.fileChecked = /*theoryfilesChecked*/ ctx[1];
				add_flush_callback(() => updating_fileChecked = false);
			}

			quickbrowser.$set(quickbrowser_changes);

			if (/*$toggleRow*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$toggleRow*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$n(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(quickbrowser.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(quickbrowser.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(quickbrowser, detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props, $$invalidate) {
	let $toggleRow;
	validate_store(toggleRow, "toggleRow");
	component_subscribe($$self, toggleRow, $$value => $$invalidate(5, $toggleRow = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TheoryRow", slots, []);

	let { theoryLocation } = $$props,
		{ currentLocation } = $$props,
		{ show_theoryplot } = $$props,
		{ normMethod } = $$props,
		{ preModal } = $$props;

	let sigma = 20, scale = 1, theoryfiles = [];
	let showTheoryFiles = false, theoryfilesChecked = [];

	function plotData({ e = null, tkplot = "run" } = {}) {
		let pyfile = "theory.py", args;
		if (theoryfiles.length < 1) return window.createToast("No files selected", "danger");
		args = [...theoryfiles, normMethod, sigma, scale, currentLocation, tkplot];

		computePy_func({ e, pyfile, args }).then(dataFromPython => {
			theory_func({ dataFromPython, normMethod });
			window.createToast("Graph Plotted", "success");
			($$invalidate(7, show_theoryplot = true), $$invalidate(4, showTheoryFiles = false));
		}).catch(err => {
			$$invalidate(8, preModal.modalContent = err, preModal);
			$$invalidate(8, preModal.open = true, preModal);
		});
	}

	const writable_props = [
		"theoryLocation",
		"currentLocation",
		"show_theoryplot",
		"normMethod",
		"preModal"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TheoryRow> was created with unknown prop '${key}'`);
	});

	function quickbrowser_active_binding(value) {
		showTheoryFiles = value;
		$$invalidate(4, showTheoryFiles);
	}

	function quickbrowser_currentLocation_binding(value) {
		theoryLocation = value;
		$$invalidate(0, theoryLocation);
	}

	function quickbrowser_fileChecked_binding(value) {
		theoryfilesChecked = value;
		$$invalidate(1, theoryfilesChecked);
	}

	const submit_handler = e => {
		plotData({ e: e.detail.event });
		localStorage["theoryLocation"] = theoryLocation;
	};

	const click_handler = () => {
		$$invalidate(4, showTheoryFiles = !showTheoryFiles);
	};

	function textfield0_value_binding(value) {
		sigma = value;
		$$invalidate(2, sigma);
	}

	function textfield1_value_binding(value) {
		scale = value;
		$$invalidate(3, scale);
	}

	const click_handler_1 = e => plotData({ e });

	$$self.$$set = $$props => {
		if ("theoryLocation" in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
		if ("currentLocation" in $$props) $$invalidate(9, currentLocation = $$props.currentLocation);
		if ("show_theoryplot" in $$props) $$invalidate(7, show_theoryplot = $$props.show_theoryplot);
		if ("normMethod" in $$props) $$invalidate(10, normMethod = $$props.normMethod);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
	};

	$$self.$capture_state = () => ({
		toggleRow,
		Textfield,
		QuickBrowser,
		fade,
		theory_func,
		theoryLocation,
		currentLocation,
		show_theoryplot,
		normMethod,
		preModal,
		sigma,
		scale,
		theoryfiles,
		showTheoryFiles,
		theoryfilesChecked,
		plotData,
		$toggleRow
	});

	$$self.$inject_state = $$props => {
		if ("theoryLocation" in $$props) $$invalidate(0, theoryLocation = $$props.theoryLocation);
		if ("currentLocation" in $$props) $$invalidate(9, currentLocation = $$props.currentLocation);
		if ("show_theoryplot" in $$props) $$invalidate(7, show_theoryplot = $$props.show_theoryplot);
		if ("normMethod" in $$props) $$invalidate(10, normMethod = $$props.normMethod);
		if ("preModal" in $$props) $$invalidate(8, preModal = $$props.preModal);
		if ("sigma" in $$props) $$invalidate(2, sigma = $$props.sigma);
		if ("scale" in $$props) $$invalidate(3, scale = $$props.scale);
		if ("theoryfiles" in $$props) theoryfiles = $$props.theoryfiles;
		if ("showTheoryFiles" in $$props) $$invalidate(4, showTheoryFiles = $$props.showTheoryFiles);
		if ("theoryfilesChecked" in $$props) $$invalidate(1, theoryfilesChecked = $$props.theoryfilesChecked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*theoryLocation, theoryfilesChecked*/ 3) {
			 if (fs.existsSync(theoryLocation)) {
				theoryfiles = theoryfilesChecked.map(file => path.resolve(theoryLocation, file));
			}
		}
	};

	return [
		theoryLocation,
		theoryfilesChecked,
		sigma,
		scale,
		showTheoryFiles,
		$toggleRow,
		plotData,
		show_theoryplot,
		preModal,
		currentLocation,
		normMethod,
		quickbrowser_active_binding,
		quickbrowser_currentLocation_binding,
		quickbrowser_fileChecked_binding,
		submit_handler,
		click_handler,
		textfield0_value_binding,
		textfield1_value_binding,
		click_handler_1
	];
}

class TheoryRow extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
			theoryLocation: 0,
			currentLocation: 9,
			show_theoryplot: 7,
			normMethod: 10,
			preModal: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TheoryRow",
			options,
			id: create_fragment$1a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*theoryLocation*/ ctx[0] === undefined && !("theoryLocation" in props)) {
			console.warn("<TheoryRow> was created without expected prop 'theoryLocation'");
		}

		if (/*currentLocation*/ ctx[9] === undefined && !("currentLocation" in props)) {
			console.warn("<TheoryRow> was created without expected prop 'currentLocation'");
		}

		if (/*show_theoryplot*/ ctx[7] === undefined && !("show_theoryplot" in props)) {
			console.warn("<TheoryRow> was created without expected prop 'show_theoryplot'");
		}

		if (/*normMethod*/ ctx[10] === undefined && !("normMethod" in props)) {
			console.warn("<TheoryRow> was created without expected prop 'normMethod'");
		}

		if (/*preModal*/ ctx[8] === undefined && !("preModal" in props)) {
			console.warn("<TheoryRow> was created without expected prop 'preModal'");
		}
	}

	get theoryLocation() {
		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theoryLocation(value) {
		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentLocation() {
		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_theoryplot() {
		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_theoryplot(value) {
		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get normMethod() {
		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set normMethod(value) {
		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<TheoryRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<TheoryRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Table.svelte generated by Svelte v3.31.2 */

const { console: console_1$7 } = globals;
const file$14 = "src\\components\\Table.svelte";

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i].key;
	child_ctx[7] = list[i].id;
	child_ctx[19] = list;
	child_ctx[20] = i;
	return child_ctx;
}

function get_each_context_2$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (52:4) {#if addextraOption}
function create_if_block_2$5(ctx) {
	let div;
	let icon;
	let current;

	icon = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_2$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*addRow*/ ctx[10]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon.$$.fragment);
			attr_dev(div, "class", "icon-holder svelte-1kqr05j");
			add_location(div, file$14, 52, 8, 1103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 8388608) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(52:4) {#if addextraOption}",
		ctx
	});

	return block;
}

// (54:12) <Icon class="material-icons"  on:click="{addRow}">
function create_default_slot_2$c(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("add");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$c.name,
		type: "slot",
		source: "(54:12) <Icon class=\\\"material-icons\\\"  on:click=\\\"{addRow}\\\">",
		ctx
	});

	return block;
}

// (75:32) {#if sortOption}
function create_if_block_1$9(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$d] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(75:32) {#if sortOption}",
		ctx
	});

	return block;
}

// (76:36) <Icon class="material-icons" >
function create_default_slot_1$d(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_downward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$d.name,
		type: "slot",
		source: "(76:36) <Icon class=\\\"material-icons\\\" >",
		ctx
	});

	return block;
}

// (70:20) {#each head as item, index }
function create_each_block_2$3(ctx) {
	let th;
	let div;
	let t0;
	let t1_value = /*item*/ ctx[21] + "";
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block = /*sortOption*/ ctx[4] && create_if_block_1$9(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[11](/*index*/ ctx[17]);
	}

	const block = {
		c: function create() {
			th = element("th");
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			attr_dev(div, "class", "tableIcon svelte-1kqr05j");
			add_location(div, file$14, 73, 28, 1788);
			set_style(th, "cursor", "pointer");
			attr_dev(th, "class", "mdc-data-table__header-cell svelte-1kqr05j");
			attr_dev(th, "role", "columnheader");
			attr_dev(th, "scope", "col");
			add_location(th, file$14, 71, 24, 1658);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, div);
			if (if_block) if_block.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(th, t2);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*sortOption*/ ctx[4]) {
				if (if_block) {
					if (dirty & /*sortOption*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*head*/ 2) && t1_value !== (t1_value = /*item*/ ctx[21] + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$3.name,
		type: "each",
		source: "(70:20) {#each head as item, index }",
		ctx
	});

	return block;
}

// (94:24) {#each keyIDSets as {key, id}
function create_each_block_1$3(key_1, ctx) {
	let td;
	let t_value = /*row*/ ctx[15][/*key*/ ctx[18]] + "";
	let t;
	let td_id_value;
	let mounted;
	let dispose;

	function td_input_handler() {
		/*td_input_handler*/ ctx[12].call(td, /*key*/ ctx[18], /*each_value*/ ctx[16], /*index*/ ctx[17]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			td = element("td");
			t = text(t_value);
			attr_dev(td, "class", "mdc-data-table__cell  mdc-data-table__cell--numeric svelte-1kqr05j");
			attr_dev(td, "contenteditable", "true");
			attr_dev(td, "id", td_id_value = "" + (/*row*/ ctx[15].id + "-" + /*key*/ ctx[18]));
			if (/*row*/ ctx[15][/*key*/ ctx[18]] === void 0) add_render_callback(td_input_handler);
			add_location(td, file$14, 94, 28, 2654);
			this.first = td;
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, t);

			if (/*row*/ ctx[15][/*key*/ ctx[18]] !== void 0) {
				td.innerHTML = /*row*/ ctx[15][/*key*/ ctx[18]];
			}

			if (!mounted) {
				dispose = listen_dev(td, "input", td_input_handler);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*rows*/ 1 && t_value !== (t_value = /*row*/ ctx[15][/*key*/ ctx[18]] + "")) set_data_dev(t, t_value);

			if (dirty & /*rows*/ 1 && td_id_value !== (td_id_value = "" + (/*row*/ ctx[15].id + "-" + /*key*/ ctx[18]))) {
				attr_dev(td, "id", td_id_value);
			}

			if (dirty & /*rows, keyIDSets*/ 257 && /*row*/ ctx[15][/*key*/ ctx[18]] !== td.innerHTML) {
				td.innerHTML = /*row*/ ctx[15][/*key*/ ctx[18]];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$3.name,
		type: "each",
		source: "(94:24) {#each keyIDSets as {key, id}",
		ctx
	});

	return block;
}

// (99:24) {#if closeOption}
function create_if_block$o(ctx) {
	let td;
	let icon;
	let current;

	icon = new Icon({
			props: {
				id: /*row*/ ctx[15].id,
				class: "material-icons",
				$$slots: { default: [create_default_slot$q] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*click_handler_1*/ ctx[13]);

	const block = {
		c: function create() {
			td = element("td");
			create_component(icon.$$.fragment);
			attr_dev(td, "class", "mdc-data-table__cell svelte-1kqr05j");
			set_style(td, "background", "#f14668");
			set_style(td, "cursor", "pointer");
			set_style(td, "width", "2em");
			add_location(td, file$14, 100, 28, 2914);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(icon, td, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*rows*/ 1) icon_changes.id = /*row*/ ctx[15].id;

			if (dirty & /*$$scope*/ 8388608) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$o.name,
		type: "if",
		source: "(99:24) {#if closeOption}",
		ctx
	});

	return block;
}

// (102:32) <Icon id="{row.id}" class="material-icons" on:click="{(e)=> {rows = window._.filter(rows, (tb)=>tb.id != e.target.id)}}">
function create_default_slot$q(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$q.name,
		type: "slot",
		source: "(102:32) <Icon id=\\\"{row.id}\\\" class=\\\"material-icons\\\" on:click=\\\"{(e)=> {rows = window._.filter(rows, (tb)=>tb.id != e.target.id)}}\\\">",
		ctx
	});

	return block;
}

// (90:16) {#each rows as row, index (row.id)}
function create_each_block$9(key_1, ctx) {
	let tr;
	let td;
	let t0_value = /*index*/ ctx[17] + "";
	let t0;
	let t1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3;
	let tr_transition;
	let current;
	let each_value_1 = /*keyIDSets*/ ctx[8];
	validate_each_argument(each_value_1);
	const get_key = ctx => /*id*/ ctx[7];
	validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
	}

	let if_block = /*closeOption*/ ctx[5] && create_if_block$o(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			tr = element("tr");
			td = element("td");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block) if_block.c();
			t3 = space();
			attr_dev(td, "class", "mdc-data-table__cell svelte-1kqr05j");
			set_style(td, "width", "2em");
			add_location(td, file$14, 91, 24, 2495);
			attr_dev(tr, "class", "mdc-data-table__row svelte-1kqr05j");
			set_style(tr, "background-color", "#fafafa");
			add_location(tr, file$14, 90, 20, 2384);
			this.first = tr;
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, t0);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);
			if (if_block) if_block.m(tr, null);
			append_dev(tr, t3);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*rows*/ 1) && t0_value !== (t0_value = /*index*/ ctx[17] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*rows, keyIDSets*/ 257) {
				each_value_1 = /*keyIDSets*/ ctx[8];
				validate_each_argument(each_value_1);
				validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, destroy_block, create_each_block_1$3, t2, get_each_context_1$3);
			}

			if (/*closeOption*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*closeOption*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$o(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(tr, t3);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (!tr_transition) tr_transition = create_bidirectional_transition(tr, scale, {}, true);
				tr_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			if (!tr_transition) tr_transition = create_bidirectional_transition(tr, scale, {}, false);
			tr_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block) if_block.d();
			if (detaching && tr_transition) tr_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$9.name,
		type: "each",
		source: "(90:16) {#each rows as row, index (row.id)}",
		ctx
	});

	return block;
}

function create_fragment$1b(ctx) {
	let div1;
	let t0;
	let div0;
	let table;
	let thead;
	let tr;
	let th;
	let t2;
	let t3;
	let tbody;
	let each_blocks = [];
	let each1_lookup = new Map();
	let div0_transition;
	let current;
	let if_block = /*addextraOption*/ ctx[6] && create_if_block_2$5(ctx);
	let each_value_2 = /*head*/ ctx[1];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	let each_value = /*rows*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*row*/ ctx[15].id;
	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$9(ctx, each_value, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			th.textContent = "#";
			t2 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(th, "class", "mdc-data-table__header-cell svelte-1kqr05j");
			set_style(th, "width", "2em");
			attr_dev(th, "role", "columnheader");
			attr_dev(th, "scope", "col");
			add_location(th, file$14, 66, 20, 1478);
			attr_dev(tr, "class", "mdc-data-table__header-row svelte-1kqr05j");
			add_location(tr, file$14, 64, 16, 1415);
			attr_dev(thead, "class", "svelte-1kqr05j");
			add_location(thead, file$14, 62, 12, 1388);
			attr_dev(tbody, "class", "mdc-data-table__content svelte-1kqr05j");
			add_location(tbody, file$14, 87, 12, 2252);
			attr_dev(table, "class", "mdc-data-table__table svelte-1kqr05j");
			attr_dev(table, "aria-label", /*label*/ ctx[3]);
			attr_dev(table, "id", /*id*/ ctx[7]);
			add_location(table, file$14, 61, 8, 1313);
			attr_dev(div0, "class", "mdc-data-table tableContainer svelte-1kqr05j");
			add_location(div0, file$14, 60, 4, 1244);
			attr_dev(div1, "class", " svelte-1kqr05j");
			add_location(div1, file$14, 49, 0, 1051);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(tr, t2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(table, t3);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*addextraOption*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*addextraOption*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*sortTable, keys, head, sortOption*/ 534) {
				each_value_2 = /*head*/ ctx[1];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_2$3(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(tr, null);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*rows, window, closeOption, keyIDSets*/ 289) {
				each_value = /*rows*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, tbody, outro_and_destroy_block, create_each_block$9, null, get_each_context$9);
				check_outros();
			}

			if (!current || dirty & /*label*/ 8) {
				attr_dev(table, "aria-label", /*label*/ ctx[3]);
			}

			if (!current || dirty & /*id*/ 128) {
				attr_dev(table, "id", /*id*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, true);
				div0_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, false);
			div0_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks_1, detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching && div0_transition) div0_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Table", slots, []);

	let { head } = $$props,
		{ rows } = $$props,
		{ keys } = $$props,
		{ id = window.getID() } = $$props,
		{ label = "table" } = $$props,
		{ sortOption = false } = $$props,
		{ closeOption = true } = $$props,
		{ addextraOption = true } = $$props;

	const keyIDSets = keys.map(key => {
		return { key, id: window.getID() };
	});

	const sortTable = type => {
		if (sortOption) {
			$$invalidate(0, rows = _.orderBy(rows, [type], ["asc"]));
		}
	};

	let emptyRow = {};
	keys.forEach(key => emptyRow[key] = "");

	const addRow = async () => {
		const id = window.getID();
		$$invalidate(0, rows = [...rows, { ...emptyRow, id }]);
		await tick();
		const focusTargetID = `${id}-${keys[0]}`;
		document.getElementById(focusTargetID).focus();
	};

	const writable_props = [
		"head",
		"rows",
		"keys",
		"id",
		"label",
		"sortOption",
		"closeOption",
		"addextraOption"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<Table> was created with unknown prop '${key}'`);
	});

	const click_handler = index => sortTable(keys[index]);

	function td_input_handler(key, each_value, index) {
		each_value[index][key] = this.innerHTML;
		$$invalidate(0, rows);
		$$invalidate(8, keyIDSets);
	}

	const click_handler_1 = e => {
		$$invalidate(0, rows = window._.filter(rows, tb => tb.id != e.target.id));
	};

	$$self.$$set = $$props => {
		if ("head" in $$props) $$invalidate(1, head = $$props.head);
		if ("rows" in $$props) $$invalidate(0, rows = $$props.rows);
		if ("keys" in $$props) $$invalidate(2, keys = $$props.keys);
		if ("id" in $$props) $$invalidate(7, id = $$props.id);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("sortOption" in $$props) $$invalidate(4, sortOption = $$props.sortOption);
		if ("closeOption" in $$props) $$invalidate(5, closeOption = $$props.closeOption);
		if ("addextraOption" in $$props) $$invalidate(6, addextraOption = $$props.addextraOption);
	};

	$$self.$capture_state = () => ({
		fade,
		scale,
		Icon,
		tick,
		head,
		rows,
		keys,
		id,
		label,
		sortOption,
		closeOption,
		addextraOption,
		keyIDSets,
		sortTable,
		emptyRow,
		addRow
	});

	$$self.$inject_state = $$props => {
		if ("head" in $$props) $$invalidate(1, head = $$props.head);
		if ("rows" in $$props) $$invalidate(0, rows = $$props.rows);
		if ("keys" in $$props) $$invalidate(2, keys = $$props.keys);
		if ("id" in $$props) $$invalidate(7, id = $$props.id);
		if ("label" in $$props) $$invalidate(3, label = $$props.label);
		if ("sortOption" in $$props) $$invalidate(4, sortOption = $$props.sortOption);
		if ("closeOption" in $$props) $$invalidate(5, closeOption = $$props.closeOption);
		if ("addextraOption" in $$props) $$invalidate(6, addextraOption = $$props.addextraOption);
		if ("emptyRow" in $$props) emptyRow = $$props.emptyRow;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*rows*/ 1) {
			 console.log("Row: ", rows);
		}
	};

	return [
		rows,
		head,
		keys,
		label,
		sortOption,
		closeOption,
		addextraOption,
		id,
		keyIDSets,
		sortTable,
		addRow,
		click_handler,
		td_input_handler,
		click_handler_1
	];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
			head: 1,
			rows: 0,
			keys: 2,
			id: 7,
			label: 3,
			sortOption: 4,
			closeOption: 5,
			addextraOption: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment$1b.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*head*/ ctx[1] === undefined && !("head" in props)) {
			console_1$7.warn("<Table> was created without expected prop 'head'");
		}

		if (/*rows*/ ctx[0] === undefined && !("rows" in props)) {
			console_1$7.warn("<Table> was created without expected prop 'rows'");
		}

		if (/*keys*/ ctx[2] === undefined && !("keys" in props)) {
			console_1$7.warn("<Table> was created without expected prop 'keys'");
		}
	}

	get head() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set head(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keys() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keys(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortOption() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortOption(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOption() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOption(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addextraOption() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addextraOption(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function get_details_func({dataFromPython}={}) {
    
    const info = dataFromPython.files.map(data=>{
        let {filename, trap, res, b0, range} = data;
        let [min, max] = range;
        return {filename, min, max, trap, b0, res, precursor:"", ie:"", temp:"", id:getID()}

    });
    filedetails.set(info);
    
}

/* src\Pages\normline\widgets\preprocessing\GetFileInfoTable.svelte generated by Svelte v3.31.2 */

const file$15 = "src\\Pages\\normline\\widgets\\preprocessing\\GetFileInfoTable.svelte";

// (47:4) {#if toggleFileDetailsTable}
function create_if_block$p(ctx) {
	let table;
	let updating_rows;
	let current;

	function table_rows_binding(value) {
		/*table_rows_binding*/ ctx[9].call(null, value);
	}

	let table_props = {
		head: [
			"Filename",
			"min(cm-1)",
			"max(cm-1)",
			"Trap(s)",
			"B0(ms)",
			"Res.(V)",
			"IE(eV)",
			"Temp(K)",
			"Precursor"
		],
		keys: ["filename", "min", "max", "trap", "b0", "res", "ie", "temp", "precursor"],
		id: "felix_filedetails_table",
		closeOption: false,
		sortOption: true
	};

	if (/*$filedetails*/ ctx[1] !== void 0) {
		table_props.rows = /*$filedetails*/ ctx[1];
	}

	table = new Table({ props: table_props, $$inline: true });
	binding_callbacks.push(() => bind(table, "rows", table_rows_binding));

	const block = {
		c: function create() {
			create_component(table.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(table, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const table_changes = {};

			if (!updating_rows && dirty & /*$filedetails*/ 2) {
				updating_rows = true;
				table_changes.rows = /*$filedetails*/ ctx[1];
				add_flush_callback(() => updating_rows = false);
			}

			table.$set(table_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(table, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$p.name,
		type: "if",
		source: "(47:4) {#if toggleFileDetailsTable}",
		ctx
	});

	return block;
}

function create_fragment$1c(ctx) {
	let div1;
	let div0;
	let button0;
	let t1;
	let customiconswitch;
	let updating_toggler;
	let t2;
	let button1;
	let t4;
	let button2;
	let t6;
	let current;
	let mounted;
	let dispose;

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[7].call(null, value);
	}

	let customiconswitch_props = {
		icons: ["arrow_drop_down", "arrow_drop_up"]
	};

	if (/*toggleFileDetailsTable*/ ctx[0] !== void 0) {
		customiconswitch_props.toggler = /*toggleFileDetailsTable*/ ctx[0];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));
	let if_block = /*toggleFileDetailsTable*/ ctx[0] && create_if_block$p(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Get details";
			t1 = space();
			create_component(customiconswitch.$$.fragment);
			t2 = space();
			button1 = element("button");
			button1.textContent = "Save";
			t4 = space();
			button2 = element("button");
			button2.textContent = "Load";
			t6 = space();
			if (if_block) if_block.c();
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$15, 37, 8, 1331);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$15, 40, 8, 1544);
			attr_dev(button2, "class", "button is-link");
			add_location(button2, file$15, 41, 8, 1665);
			set_style(div0, "display", "flex");
			add_location(div0, file$15, 35, 4, 1292);
			attr_dev(div1, "class", "align");
			add_location(div1, file$15, 34, 0, 1266);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, button0);
			append_dev(div0, t1);
			mount_component(customiconswitch, div0, null);
			append_dev(div0, t2);
			append_dev(div0, button1);
			append_dev(div0, t4);
			append_dev(div0, button2);
			append_dev(div1, t6);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[8], false, false, false),
					listen_dev(button2, "click", /*loadfiledetails*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty & /*toggleFileDetailsTable*/ 1) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*toggleFileDetailsTable*/ ctx[0];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);

			if (/*toggleFileDetailsTable*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*toggleFileDetailsTable*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$p(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customiconswitch.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(customiconswitch.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(customiconswitch);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1c($$self, $$props, $$invalidate) {
	let $opoMode;
	let $filedetails;
	validate_store(opoMode, "opoMode");
	component_subscribe($$self, opoMode, $$value => $$invalidate(11, $opoMode = $$value));
	validate_store(filedetails, "filedetails");
	component_subscribe($$self, filedetails, $$value => $$invalidate(1, $filedetails = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GetFileInfoTable", slots, []);
	let { felixfiles } = $$props, { normMethod } = $$props;
	let toggleFileDetailsTable = false, preModal = {};

	function plotData({ e = null } = {}) {
		let pyfile = "getfile_details.py", args;
		if (felixfiles.length < 1) return window.createToast("No files selected", "danger");

		args = [
			JSON.stringify({
				files: $opoMode ? opofiles : felixfiles,
				normMethod
			})
		];

		computePy_func({ e, pyfile, args }).then(dataFromPython => {
			get_details_func({ dataFromPython });
			$$invalidate(0, toggleFileDetailsTable = true);
		}).catch(err => {
			preModal.modalContent = err;
			preModal.open = true;
		});
	}

	function loadfiledetails() {
		const loadedfile = loadfile({ name: "filedetails" });
		set_store_value(filedetails, $filedetails = _.uniqBy([...loadedfile, ...$filedetails], "filename"), $filedetails);
	}

	const writable_props = ["felixfiles", "normMethod"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GetFileInfoTable> was created with unknown prop '${key}'`);
	});

	const click_handler = e => plotData({ e });

	function customiconswitch_toggler_binding(value) {
		toggleFileDetailsTable = value;
		$$invalidate(0, toggleFileDetailsTable);
	}

	const click_handler_1 = () => savefile({ file: $filedetails, name: "filedetails" });

	function table_rows_binding(value) {
		$filedetails = value;
		filedetails.set($filedetails);
	}

	$$self.$$set = $$props => {
		if ("felixfiles" in $$props) $$invalidate(4, felixfiles = $$props.felixfiles);
		if ("normMethod" in $$props) $$invalidate(5, normMethod = $$props.normMethod);
	};

	$$self.$capture_state = () => ({
		filedetails,
		opoMode,
		CustomIconSwitch,
		Table,
		savefile,
		loadfile,
		get_details_func,
		felixfiles,
		normMethod,
		toggleFileDetailsTable,
		preModal,
		plotData,
		loadfiledetails,
		$opoMode,
		$filedetails
	});

	$$self.$inject_state = $$props => {
		if ("felixfiles" in $$props) $$invalidate(4, felixfiles = $$props.felixfiles);
		if ("normMethod" in $$props) $$invalidate(5, normMethod = $$props.normMethod);
		if ("toggleFileDetailsTable" in $$props) $$invalidate(0, toggleFileDetailsTable = $$props.toggleFileDetailsTable);
		if ("preModal" in $$props) preModal = $$props.preModal;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		toggleFileDetailsTable,
		$filedetails,
		plotData,
		loadfiledetails,
		felixfiles,
		normMethod,
		click_handler,
		customiconswitch_toggler_binding,
		click_handler_1,
		table_rows_binding
	];
}

class GetFileInfoTable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { felixfiles: 4, normMethod: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GetFileInfoTable",
			options,
			id: create_fragment$1c.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*felixfiles*/ ctx[4] === undefined && !("felixfiles" in props)) {
			console.warn("<GetFileInfoTable> was created without expected prop 'felixfiles'");
		}

		if (/*normMethod*/ ctx[5] === undefined && !("normMethod" in props)) {
			console.warn("<GetFileInfoTable> was created without expected prop 'normMethod'");
		}
	}

	get felixfiles() {
		throw new Error("<GetFileInfoTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set felixfiles(value) {
		throw new Error("<GetFileInfoTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get normMethod() {
		throw new Error("<GetFileInfoTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set normMethod(value) {
		throw new Error("<GetFileInfoTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CustomSwitch.svelte generated by Svelte v3.31.2 */
const file$16 = "src\\components\\CustomSwitch.svelte";

// (11:4) <span slot="label">
function create_label_slot$5(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*label*/ ctx[2]);
			attr_dev(span, "slot", "label");
			add_location(span, file$16, 10, 4, 244);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot$5.name,
		type: "slot",
		source: "(11:4) <span slot=\\\"label\\\">",
		ctx
	});

	return block;
}

// (9:0) <FormField {style}>
function create_default_slot$r(ctx) {
	let switch_1;
	let updating_checked;
	let t;
	let current;

	function switch_1_checked_binding(value) {
		/*switch_1_checked_binding*/ ctx[3].call(null, value);
	}

	let switch_1_props = {};

	if (/*selected*/ ctx[0] !== void 0) {
		switch_1_props.checked = /*selected*/ ctx[0];
	}

	switch_1 = new Switch({ props: switch_1_props, $$inline: true });
	binding_callbacks.push(() => bind(switch_1, "checked", switch_1_checked_binding));
	switch_1.$on("change", /*change_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(switch_1.$$.fragment);
			t = space();
		},
		m: function mount(target, anchor) {
			mount_component(switch_1, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_1_changes = {};

			if (!updating_checked && dirty & /*selected*/ 1) {
				updating_checked = true;
				switch_1_changes.checked = /*selected*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			switch_1.$set(switch_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(switch_1, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$r.name,
		type: "slot",
		source: "(9:0) <FormField {style}>",
		ctx
	});

	return block;
}

function create_fragment$1d(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				style: /*style*/ ctx[1],
				$$slots: {
					default: [create_default_slot$r],
					label: [create_label_slot$5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const formfield_changes = {};
			if (dirty & /*style*/ 2) formfield_changes.style = /*style*/ ctx[1];

			if (dirty & /*$$scope, label, selected*/ 37) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CustomSwitch", slots, []);

	let { selected = false } = $$props,
		{ style = "" } = $$props,
		{ label = "" } = $$props;

	const writable_props = ["selected", "style", "label"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CustomSwitch> was created with unknown prop '${key}'`);
	});

	function switch_1_checked_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
	};

	$$self.$capture_state = () => ({
		Switch,
		FormField,
		selected,
		style,
		label
	});

	$$self.$inject_state = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selected, style, label, switch_1_checked_binding, change_handler];
}

class CustomSwitch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, { selected: 0, style: 1, label: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CustomSwitch",
			options,
			id: create_fragment$1d.name
		});
	}

	get selected() {
		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<CustomSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<CustomSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\widgets\postprocessing\WriteFunctionContents.svelte generated by Svelte v3.31.2 */
const file$17 = "src\\Pages\\normline\\widgets\\postprocessing\\WriteFunctionContents.svelte";

function create_fragment$1e(ctx) {
	let div;
	let customselect;
	let updating_picked;
	let t0;
	let textfield;
	let updating_value;
	let t1;
	let customswitch0;
	let updating_selected;
	let t2;
	let customswitch1;
	let updating_selected_1;
	let t3;
	let customswitch2;
	let updating_selected_2;
	let t4;
	let button0;
	let t6;
	let button1;
	let current;
	let mounted;
	let dispose;

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[7].call(null, value);
	}

	let customselect_props = {
		label: "Output filename",
		options: /*output_namelists*/ ctx[3]
	};

	if (/*$felixOutputName*/ ctx[4] !== void 0) {
		customselect_props.picked = /*$felixOutputName*/ ctx[4];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[8].call(null, value);
	}

	let textfield_props = {
		style: "width:7em; margin:0 0.5em;",
		label: "writeFileName"
	};

	if (/*writeFileName*/ ctx[0] !== void 0) {
		textfield_props.value = /*writeFileName*/ ctx[0];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	function customswitch0_selected_binding(value) {
		/*customswitch0_selected_binding*/ ctx[9].call(null, value);
	}

	let customswitch0_props = { style: "margin: 0 1em;", label: "Write" };

	if (/*writeFile*/ ctx[1] !== void 0) {
		customswitch0_props.selected = /*writeFile*/ ctx[1];
	}

	customswitch0 = new CustomSwitch({
			props: customswitch0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch0, "selected", customswitch0_selected_binding));

	function customswitch1_selected_binding(value) {
		/*customswitch1_selected_binding*/ ctx[10].call(null, value);
	}

	let customswitch1_props = {
		style: "margin: 0 1em;",
		label: "Overwrite"
	};

	if (/*overwrite_expfit*/ ctx[2] !== void 0) {
		customswitch1_props.selected = /*overwrite_expfit*/ ctx[2];
	}

	customswitch1 = new CustomSwitch({
			props: customswitch1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch1, "selected", customswitch1_selected_binding));

	function customswitch2_selected_binding(value) {
		/*customswitch2_selected_binding*/ ctx[11].call(null, value);
	}

	let customswitch2_props = {
		style: "margin: 0 1em;",
		label: "Collect"
	};

	if (/*$collectData*/ ctx[5] !== void 0) {
		customswitch2_props.selected = /*$collectData*/ ctx[5];
	}

	customswitch2 = new CustomSwitch({
			props: customswitch2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch2, "selected", customswitch2_selected_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(customselect.$$.fragment);
			t0 = space();
			create_component(textfield.$$.fragment);
			t1 = space();
			create_component(customswitch0.$$.fragment);
			t2 = space();
			create_component(customswitch1.$$.fragment);
			t3 = space();
			create_component(customswitch2.$$.fragment);
			t4 = space();
			button0 = element("button");
			button0.textContent = "Add files";
			t6 = space();
			button1 = element("button");
			button1.textContent = "Remove files";
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$17, 20, 4, 995);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$17, 21, 4, 1087);
			attr_dev(div, "class", "align");
			add_location(div, file$17, 13, 0, 494);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(customselect, div, null);
			append_dev(div, t0);
			mount_component(textfield, div, null);
			append_dev(div, t1);
			mount_component(customswitch0, div, null);
			append_dev(div, t2);
			mount_component(customswitch1, div, null);
			append_dev(div, t3);
			mount_component(customswitch2, div, null);
			append_dev(div, t4);
			append_dev(div, button0);
			append_dev(div, t6);
			append_dev(div, button1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[12], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const customselect_changes = {};
			if (dirty & /*output_namelists*/ 8) customselect_changes.options = /*output_namelists*/ ctx[3];

			if (!updating_picked && dirty & /*$felixOutputName*/ 16) {
				updating_picked = true;
				customselect_changes.picked = /*$felixOutputName*/ ctx[4];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield_changes = {};

			if (!updating_value && dirty & /*writeFileName*/ 1) {
				updating_value = true;
				textfield_changes.value = /*writeFileName*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
			const customswitch0_changes = {};

			if (!updating_selected && dirty & /*writeFile*/ 2) {
				updating_selected = true;
				customswitch0_changes.selected = /*writeFile*/ ctx[1];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch0.$set(customswitch0_changes);
			const customswitch1_changes = {};

			if (!updating_selected_1 && dirty & /*overwrite_expfit*/ 4) {
				updating_selected_1 = true;
				customswitch1_changes.selected = /*overwrite_expfit*/ ctx[2];
				add_flush_callback(() => updating_selected_1 = false);
			}

			customswitch1.$set(customswitch1_changes);
			const customswitch2_changes = {};

			if (!updating_selected_2 && dirty & /*$collectData*/ 32) {
				updating_selected_2 = true;
				customswitch2_changes.selected = /*$collectData*/ ctx[5];
				add_flush_callback(() => updating_selected_2 = false);
			}

			customswitch2.$set(customswitch2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(customswitch0.$$.fragment, local);
			transition_in(customswitch1.$$.fragment, local);
			transition_in(customswitch2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(customswitch0.$$.fragment, local);
			transition_out(customswitch1.$$.fragment, local);
			transition_out(customswitch2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(customselect);
			destroy_component(textfield);
			destroy_component(customswitch0);
			destroy_component(customswitch1);
			destroy_component(customswitch2);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1e($$self, $$props, $$invalidate) {
	let $felixOutputName;
	let $collectData;
	validate_store(felixOutputName, "felixOutputName");
	component_subscribe($$self, felixOutputName, $$value => $$invalidate(4, $felixOutputName = $$value));
	validate_store(collectData, "collectData");
	component_subscribe($$self, collectData, $$value => $$invalidate(5, $collectData = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("WriteFunctionContents", slots, []);

	let { output_namelists } = $$props,
		{ writeFileName } = $$props,
		{ writeFile } = $$props,
		{ overwrite_expfit } = $$props;

	const dispatch = createEventDispatcher();
	const writable_props = ["output_namelists", "writeFileName", "writeFile", "overwrite_expfit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WriteFunctionContents> was created with unknown prop '${key}'`);
	});

	function customselect_picked_binding(value) {
		$felixOutputName = value;
		felixOutputName.set($felixOutputName);
	}

	function textfield_value_binding(value) {
		writeFileName = value;
		$$invalidate(0, writeFileName);
	}

	function customswitch0_selected_binding(value) {
		writeFile = value;
		$$invalidate(1, writeFile);
	}

	function customswitch1_selected_binding(value) {
		overwrite_expfit = value;
		$$invalidate(2, overwrite_expfit);
	}

	function customswitch2_selected_binding(value) {
		$collectData = value;
		collectData.set($collectData);
	}

	const click_handler = () => dispatch("addfile");
	const click_handler_1 = () => dispatch("removefile");

	$$self.$$set = $$props => {
		if ("output_namelists" in $$props) $$invalidate(3, output_namelists = $$props.output_namelists);
		if ("writeFileName" in $$props) $$invalidate(0, writeFileName = $$props.writeFileName);
		if ("writeFile" in $$props) $$invalidate(1, writeFile = $$props.writeFile);
		if ("overwrite_expfit" in $$props) $$invalidate(2, overwrite_expfit = $$props.overwrite_expfit);
	};

	$$self.$capture_state = () => ({
		felixOutputName,
		collectData,
		Textfield,
		CustomSelect,
		CustomSwitch,
		createEventDispatcher,
		output_namelists,
		writeFileName,
		writeFile,
		overwrite_expfit,
		dispatch,
		$felixOutputName,
		$collectData
	});

	$$self.$inject_state = $$props => {
		if ("output_namelists" in $$props) $$invalidate(3, output_namelists = $$props.output_namelists);
		if ("writeFileName" in $$props) $$invalidate(0, writeFileName = $$props.writeFileName);
		if ("writeFile" in $$props) $$invalidate(1, writeFile = $$props.writeFile);
		if ("overwrite_expfit" in $$props) $$invalidate(2, overwrite_expfit = $$props.overwrite_expfit);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		writeFileName,
		writeFile,
		overwrite_expfit,
		output_namelists,
		$felixOutputName,
		$collectData,
		dispatch,
		customselect_picked_binding,
		textfield_value_binding,
		customswitch0_selected_binding,
		customswitch1_selected_binding,
		customswitch2_selected_binding,
		click_handler,
		click_handler_1
	];
}

class WriteFunctionContents extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
			output_namelists: 3,
			writeFileName: 0,
			writeFile: 1,
			overwrite_expfit: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WriteFunctionContents",
			options,
			id: create_fragment$1e.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*output_namelists*/ ctx[3] === undefined && !("output_namelists" in props)) {
			console.warn("<WriteFunctionContents> was created without expected prop 'output_namelists'");
		}

		if (/*writeFileName*/ ctx[0] === undefined && !("writeFileName" in props)) {
			console.warn("<WriteFunctionContents> was created without expected prop 'writeFileName'");
		}

		if (/*writeFile*/ ctx[1] === undefined && !("writeFile" in props)) {
			console.warn("<WriteFunctionContents> was created without expected prop 'writeFile'");
		}

		if (/*overwrite_expfit*/ ctx[2] === undefined && !("overwrite_expfit" in props)) {
			console.warn("<WriteFunctionContents> was created without expected prop 'overwrite_expfit'");
		}
	}

	get output_namelists() {
		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set output_namelists(value) {
		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get writeFileName() {
		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set writeFileName(value) {
		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get writeFile() {
		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set writeFile(value) {
		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get overwrite_expfit() {
		throw new Error("<WriteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set overwrite_expfit(value) {
		throw new Error("<WriteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\normline\modals\AdjustInitialGuess.svelte generated by Svelte v3.31.2 */

const { console: console_1$8 } = globals;
const file$18 = "src\\Pages\\normline\\modals\\AdjustInitialGuess.svelte";

// (24:0) {#if active}
function create_if_block$q(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[5].call(null, value);
	}

	let modal_props = {
		title: "Adjust initial guess",
		$$slots: {
			default: [create_default_slot$s],
			footerbtn: [create_footerbtn_slot$3],
			content: [create_content_slot$4]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, $felixPeakTable*/ 66) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$q.name,
		type: "if",
		source: "(24:0) {#if active}",
		ctx
	});

	return block;
}

// (27:8) <div slot="content" >
function create_content_slot$4(ctx) {
	let div;
	let table;
	let updating_rows;
	let current;

	function table_rows_binding(value) {
		/*table_rows_binding*/ ctx[3].call(null, value);
	}

	let table_props = {
		head: ["Frequency", "Amplitude", "Sigma"],
		keys: ["freq", "amp", "sig"],
		sortOption: true
	};

	if (/*$felixPeakTable*/ ctx[1] !== void 0) {
		table_props.rows = /*$felixPeakTable*/ ctx[1];
	}

	table = new Table({ props: table_props, $$inline: true });
	binding_callbacks.push(() => bind(table, "rows", table_rows_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(table.$$.fragment);
			attr_dev(div, "slot", "content");
			add_location(div, file$18, 26, 8, 639);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(table, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const table_changes = {};

			if (!updating_rows && dirty & /*$felixPeakTable*/ 2) {
				updating_rows = true;
				table_changes.rows = /*$felixPeakTable*/ ctx[1];
				add_flush_callback(() => updating_rows = false);
			}

			table.$set(table_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(table);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$4.name,
		type: "slot",
		source: "(27:8) <div slot=\\\"content\\\" >",
		ctx
	});

	return block;
}

// (32:8) <button slot="footerbtn" class="button is-link" on:click="{()=>dispatch('save')}" >
function create_footerbtn_slot$3(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "Save";
			attr_dev(button, "slot", "footerbtn");
			attr_dev(button, "class", "button is-link");
			add_location(button, file$18, 31, 8, 831);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot$3.name,
		type: "slot",
		source: "(32:8) <button slot=\\\"footerbtn\\\" class=\\\"button is-link\\\" on:click=\\\"{()=>dispatch('save')}\\\" >",
		ctx
	});

	return block;
}

// (26:4) <Modal bind:active title="Adjust initial guess" >
function create_default_slot$s(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$s.name,
		type: "slot",
		source: "(26:4) <Modal bind:active title=\\\"Adjust initial guess\\\" >",
		ctx
	});

	return block;
}

function create_fragment$1f(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[0] && create_if_block$q(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$q(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1f($$self, $$props, $$invalidate) {
	let $felixPeakTable;
	validate_store(felixPeakTable, "felixPeakTable");
	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(1, $felixPeakTable = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AdjustInitialGuess", slots, []);
	let { active = false } = $$props;
	const dispatch = createEventDispatcher();
	const writable_props = ["active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<AdjustInitialGuess> was created with unknown prop '${key}'`);
	});

	function table_rows_binding(value) {
		$felixPeakTable = value;
		felixPeakTable.set($felixPeakTable);
	}

	const click_handler = () => dispatch("save");

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		felixPeakTable,
		fade,
		createEventDispatcher,
		Modal,
		Icon,
		Table,
		active,
		dispatch,
		$felixPeakTable
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$felixPeakTable*/ 2) {
			 console.log(`peakTable:`, $felixPeakTable);
		}
	};

	return [
		active,
		$felixPeakTable,
		dispatch,
		table_rows_binding,
		click_handler,
		modal_active_binding
	];
}

class AdjustInitialGuess extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { active: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AdjustInitialGuess",
			options,
			id: create_fragment$1f.name
		});
	}

	get active() {
		throw new Error("<AdjustInitialGuess>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<AdjustInitialGuess>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function NGauss_fit_func({dataFromPython}={}) {

    Plotly.addTraces(get_store_value(graphDiv), dataFromPython["fitted_data"]);
    fittedTraceCount.update(n=>n+1);

    const output_name = get_store_value(felixOutputName);
    const color = output_name === "averaged" ? "#836ac05c" : "#fafafa";

    // dataTable

    let newTable = dataFromPython["fitted_parameter"].map((data)=>{
        let {freq, amp, fwhm, sig} = data;
        return {name: output_name, id:getID(), freq:freq, amp:amp, fwhm:fwhm, sig:sig, color:color}
    
    });

    dataTable.set(_.uniqBy(newTable, "freq"));

    // dataTable_avg
    if(output_name === "averaged") {
        let newTable =dataFromPython["fitted_parameter"].map((data, index)=>{
            let {freq, amp, fwhm, sig} = data;

            return {name: `Line #${index}`, id:getID(), freq:freq, amp:amp, fwhm:fwhm, sig:sig, color:color}

        });
        dataTable_avg.set(_.uniqBy(newTable, "freq"));
        avgfittedLineCount.set(get_store_value(dataTable_avg).length);
    }
}

function find_peaks_func({dataFromPython}={}){

    const annotations = dataFromPython[2]["annotations"];

    felixPlotAnnotations.set(annotations);

    const color = annotations["arrowcolor"];
    felixAnnotationColor.set(color);
    Plotly.relayout(get_store_value(graphDiv), { annotations  });

    const [peakX, peakY] = [dataFromPython[0]["data"].x, dataFromPython[0]["data"].y];
    for (let index = 0; index < peakX.length; index++) {
        let [freq, amp, sig] = [peakX[index], peakY[index], get_store_value(Ngauss_sigma)];

        felixPeakTable.update(table => [...table, {freq, amp, sig, id:getID()}]);

    }
    console.log(`Found peaks:\nX: ${peakX}\nY: ${peakY}`);
    console.log("Peaks found");
}

function exp_fit_func({dataFromPython}={}) {

    Plotly.addTraces(get_store_value(graphDiv), dataFromPython["fit"]);
    fittedTraceCount.update(n=>n+1);

    expfittedLines.update(lines=>[...lines, ...dataFromPython["line"]]);
    Plotly.relayout(get_store_value(graphDiv), { shapes: get_store_value(expfittedLines) });
    
    let annotations = dataFromPython["annotations"];
    
    felixPlotAnnotations.update(annotate => [...annotate, annotations]);

    Plotly.relayout(get_store_value(graphDiv), { annotations: get_store_value(felixPlotAnnotations) });
    
    let [freq, amp, fwhm, sig] = dataFromPython["table"].split(", ");
    
    let color = "#fafafa";

    const output_name = get_store_value(felixOutputName);
    if (output_name === "averaged") {
        color = "#836ac05c";
        dataTable_avg.update(table=>[...table, {name: `Line #${get_store_value(avgfittedLineCount)}`, id:getID(), freq, amp, fwhm, sig, color}]);
        dataTable_avg.update(table=>_.uniqBy(table, "freq"));
        avgfittedLineCount.update(n=>n+1);

    } else {
        if (get_store_value(collectData)) {
            console.log("Collecting lines");
            expfittedLinesCollectedData.update(data=>[...data, dataFromPython["for_weighted_error"]]);
        }
    }
    let newTable = {name: output_name, id:getID(), freq, amp, fwhm, sig, color};
    dataTable.update(table=>_.uniqBy([...table, newTable], "freq"));

    console.log("Line fitted");

}

function get_err_func({dataFromPython}={}) {

    let {freq, amp, fwhm, sig } = dataFromPython;
    let data1 = {name: "unweighted_mean", id:getID(), freq:freq.mean, amp:amp.mean, fwhm:fwhm.mean, sig:sig.mean, color:"#f14668"};

    let data2 = {name: "weighted_mean", id:getID(), freq:freq.wmean, amp:amp.wmean, fwhm:fwhm.wmean, sig:sig.wmean, color:"#2098d1"};

    dataTable.update(table => [...table, data1, data2]);
    dataTable_avg.update(table => [...table, data1, data2]);

    console.log("Weighted fit.");

}

/* src\Pages\normline\widgets\postprocessing\ExecuteFunctionContents.svelte generated by Svelte v3.31.2 */

const { console: console_1$9 } = globals;
const file$19 = "src\\Pages\\normline\\widgets\\postprocessing\\ExecuteFunctionContents.svelte";

// (224:0) {#if toggleFindPeaksRow}
function create_if_block$r(ctx) {
	let div2;
	let div0;
	let customswitch;
	let updating_selected;
	let t0;
	let textfield0;
	let updating_value;
	let t1;
	let textfield1;
	let updating_value_1;
	let t2;
	let textfield2;
	let updating_value_2;
	let t3;
	let textfield3;
	let updating_value_3;
	let t4;
	let button0;
	let t6;
	let div1;
	let icon;
	let t7;
	let button1;
	let t9;
	let textfield4;
	let updating_value_4;
	let t10;
	let button2;
	let t12;
	let button3;
	let t14;
	let button4;
	let div2_transition;
	let current;
	let mounted;
	let dispose;

	function customswitch_selected_binding(value) {
		/*customswitch_selected_binding*/ ctx[31].call(null, value);
	}

	let customswitch_props = {
		style: "margin: 0 1em;",
		label: "BoxSelected"
	};

	if (/*boxSelected_peakfinder*/ ctx[1] !== void 0) {
		customswitch_props.selected = /*boxSelected_peakfinder*/ ctx[1];
	}

	customswitch = new CustomSwitch({
			props: customswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch, "selected", customswitch_selected_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[32].call(null, value);
	}

	let textfield0_props = {
		type: "number",
		style,
		step: "0.5",
		label: "Prominance"
	};

	if (/*peak_prominence*/ ctx[5] !== void 0) {
		textfield0_props.value = /*peak_prominence*/ ctx[5];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[33].call(null, value);
	}

	let textfield1_props = {
		type: "number",
		style,
		step: "0.5",
		label: "Width"
	};

	if (/*peak_width*/ ctx[4] !== void 0) {
		textfield1_props.value = /*peak_width*/ ctx[4];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[34].call(null, value);
	}

	let textfield2_props = {
		type: "number",
		style,
		step: "0.1",
		label: "Height"
	};

	if (/*peak_height*/ ctx[3] !== void 0) {
		textfield2_props.value = /*peak_height*/ ctx[3];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[35].call(null, value);
	}

	let textfield3_props = { style: "width:9em", label: "Sigma" };

	if (/*$Ngauss_sigma*/ ctx[12] !== void 0) {
		textfield3_props.value = /*$Ngauss_sigma*/ ctx[12];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));

	icon = new Icon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot$t] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon.$on("click", /*click_handler_5*/ ctx[37]);

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[39].call(null, value);
	}

	let textfield4_props = {
		style: "" + (style + "; margin-bottom: 0.5em; margin-left: 1em; margin-right: 1em;"),
		label: "savefile"
	};

	if (/*savePeakfilename*/ ctx[7] !== void 0) {
		textfield4_props.value = /*savePeakfilename*/ ctx[7];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			create_component(customswitch.$$.fragment);
			t0 = space();
			create_component(textfield0.$$.fragment);
			t1 = space();
			create_component(textfield1.$$.fragment);
			t2 = space();
			create_component(textfield2.$$.fragment);
			t3 = space();
			create_component(textfield3.$$.fragment);
			t4 = space();
			button0 = element("button");
			button0.textContent = "Get Peaks";
			t6 = space();
			div1 = element("div");
			create_component(icon.$$.fragment);
			t7 = space();
			button1 = element("button");
			button1.textContent = "Fit";
			t9 = space();
			create_component(textfield4.$$.fragment);
			t10 = space();
			button2 = element("button");
			button2.textContent = "Save peaks";
			t12 = space();
			button3 = element("button");
			button3.textContent = "Load peaks";
			t14 = space();
			button4 = element("button");
			button4.textContent = "Clear";
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$19, 234, 12, 10230);
			attr_dev(div0, "class", "align");
			set_style(div0, "margin", "1em 0");
			add_location(div0, file$19, 226, 8, 9662);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$19, 239, 12, 10503);
			attr_dev(button2, "class", "button is-link");
			add_location(button2, file$19, 241, 12, 10766);
			attr_dev(button3, "class", "button is-link");
			add_location(button3, file$19, 242, 12, 10903);
			attr_dev(button4, "class", "button is-danger");
			add_location(button4, file$19, 244, 12, 10996);
			attr_dev(div1, "class", "align");
			add_location(div1, file$19, 237, 8, 10372);
			attr_dev(div2, "class", "align");
			add_location(div2, file$19, 225, 4, 9617);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(customswitch, div0, null);
			append_dev(div0, t0);
			mount_component(textfield0, div0, null);
			append_dev(div0, t1);
			mount_component(textfield1, div0, null);
			append_dev(div0, t2);
			mount_component(textfield2, div0, null);
			append_dev(div0, t3);
			mount_component(textfield3, div0, null);
			append_dev(div0, t4);
			append_dev(div0, button0);
			append_dev(div2, t6);
			append_dev(div2, div1);
			mount_component(icon, div1, null);
			append_dev(div1, t7);
			append_dev(div1, button1);
			append_dev(div1, t9);
			mount_component(textfield4, div1, null);
			append_dev(div1, t10);
			append_dev(div1, button2);
			append_dev(div1, t12);
			append_dev(div1, button3);
			append_dev(div1, t14);
			append_dev(div1, button4);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler_4*/ ctx[36], false, false, false),
					listen_dev(button1, "click", /*click_handler_6*/ ctx[38], false, false, false),
					listen_dev(button2, "click", /*click_handler_7*/ ctx[40], false, false, false),
					listen_dev(button3, "click", /*loadpeakTable*/ ctx[15], false, false, false),
					listen_dev(button4, "click", /*click_handler_8*/ ctx[41], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const customswitch_changes = {};

			if (!updating_selected && dirty[0] & /*boxSelected_peakfinder*/ 2) {
				updating_selected = true;
				customswitch_changes.selected = /*boxSelected_peakfinder*/ ctx[1];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch.$set(customswitch_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*peak_prominence*/ 32) {
				updating_value = true;
				textfield0_changes.value = /*peak_prominence*/ ctx[5];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*peak_width*/ 16) {
				updating_value_1 = true;
				textfield1_changes.value = /*peak_width*/ ctx[4];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*peak_height*/ 8) {
				updating_value_2 = true;
				textfield2_changes.value = /*peak_height*/ ctx[3];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*$Ngauss_sigma*/ 4096) {
				updating_value_3 = true;
				textfield3_changes.value = /*$Ngauss_sigma*/ ctx[12];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const icon_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty[0] & /*savePeakfilename*/ 128) {
				updating_value_4 = true;
				textfield4_changes.value = /*savePeakfilename*/ ctx[7];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customswitch.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(customswitch.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(customswitch);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(icon);
			destroy_component(textfield4);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$r.name,
		type: "if",
		source: "(224:0) {#if toggleFindPeaksRow}",
		ctx
	});

	return block;
}

// (239:12) <Icon class="material-icons" on:click="{()=> modalActivate = true}">
function create_default_slot$t(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("settings");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$t.name,
		type: "slot",
		source: "(239:12) <Icon class=\\\"material-icons\\\" on:click=\\\"{()=> modalActivate = true}\\\">",
		ctx
	});

	return block;
}

function create_fragment$1g(ctx) {
	let adjustinitialguess;
	let updating_active;
	let t0;
	let div;
	let button0;
	let t2;
	let button1;
	let t4;
	let button2;
	let t6;
	let button3;
	let t8;
	let button4;
	let t10;
	let button5;
	let t12;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	function adjustinitialguess_active_binding(value) {
		/*adjustinitialguess_active_binding*/ ctx[26].call(null, value);
	}

	let adjustinitialguess_props = {};

	if (/*modalActivate*/ ctx[8] !== void 0) {
		adjustinitialguess_props.active = /*modalActivate*/ ctx[8];
	}

	adjustinitialguess = new AdjustInitialGuess({
			props: adjustinitialguess_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(adjustinitialguess, "active", adjustinitialguess_active_binding));
	adjustinitialguess.$on("save", /*adjustPeak*/ ctx[16]);
	let if_block = /*toggleFindPeaksRow*/ ctx[6] && create_if_block$r(ctx);

	const block = {
		c: function create() {
			create_component(adjustinitialguess.$$.fragment);
			t0 = space();
			div = element("div");
			button0 = element("button");
			button0.textContent = "Exp Fit.";
			t2 = space();
			button1 = element("button");
			button1.textContent = "Fit NGauss.";
			t4 = space();
			button2 = element("button");
			button2.textContent = "Clear Last";
			t6 = space();
			button3 = element("button");
			button3.textContent = "Clear All";
			t8 = space();
			button4 = element("button");
			button4.textContent = "Weighted Mean";
			t10 = space();
			button5 = element("button");
			button5.textContent = "Reset";
			t12 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(button0, "class", "button is-link");
			add_location(button0, file$19, 212, 4, 8879);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$19, 213, 4, 8987);
			attr_dev(button2, "class", "button is-warning");
			add_location(button2, file$19, 214, 4, 9102);
			attr_dev(button3, "class", "button is-danger");
			add_location(button3, file$19, 215, 4, 9186);
			attr_dev(button4, "class", "button is-link");
			add_location(button4, file$19, 216, 4, 9267);
			attr_dev(button5, "class", "button is-warning");
			add_location(button5, file$19, 217, 4, 9380);
			attr_dev(div, "class", "align");
			add_location(div, file$19, 211, 0, 8854);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(adjustinitialguess, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(div, t2);
			append_dev(div, button1);
			append_dev(div, t4);
			append_dev(div, button2);
			append_dev(div, t6);
			append_dev(div, button3);
			append_dev(div, t8);
			append_dev(div, button4);
			append_dev(div, t10);
			append_dev(div, button5);
			insert_dev(target, t12, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[27], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[28], false, false, false),
					listen_dev(button2, "click", /*clearLastPeak*/ ctx[14], false, false, false),
					listen_dev(button3, "click", /*clearAllPeak*/ ctx[13], false, false, false),
					listen_dev(button4, "click", /*click_handler_2*/ ctx[29], false, false, false),
					listen_dev(button5, "click", /*click_handler_3*/ ctx[30], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const adjustinitialguess_changes = {};

			if (!updating_active && dirty[0] & /*modalActivate*/ 256) {
				updating_active = true;
				adjustinitialguess_changes.active = /*modalActivate*/ ctx[8];
				add_flush_callback(() => updating_active = false);
			}

			adjustinitialguess.$set(adjustinitialguess_changes);

			if (/*toggleFindPeaksRow*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*toggleFindPeaksRow*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$r(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(adjustinitialguess.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(adjustinitialguess.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(adjustinitialguess, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t12);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const style = "width:7em; height:3.5em; margin-right:0.5em";

function instance$1g($$self, $$props, $$invalidate) {
	let $fittedTraceCount;
	let $felixPlotAnnotations;
	let $felixIndex;
	let $expfittedLines;
	let $expfittedLinesCollectedData;
	let $graphDiv;
	let $felixOutputName;
	let $felixopoLocation;
	let $dataTable;
	let $felixPeakTable;
	let $felixAnnotationColor;
	let $Ngauss_sigma;
	validate_store(fittedTraceCount, "fittedTraceCount");
	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(42, $fittedTraceCount = $$value));
	validate_store(felixPlotAnnotations, "felixPlotAnnotations");
	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(9, $felixPlotAnnotations = $$value));
	validate_store(felixIndex, "felixIndex");
	component_subscribe($$self, felixIndex, $$value => $$invalidate(43, $felixIndex = $$value));
	validate_store(expfittedLines, "expfittedLines");
	component_subscribe($$self, expfittedLines, $$value => $$invalidate(44, $expfittedLines = $$value));
	validate_store(expfittedLinesCollectedData, "expfittedLinesCollectedData");
	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(10, $expfittedLinesCollectedData = $$value));
	validate_store(graphDiv, "graphDiv");
	component_subscribe($$self, graphDiv, $$value => $$invalidate(11, $graphDiv = $$value));
	validate_store(felixOutputName, "felixOutputName");
	component_subscribe($$self, felixOutputName, $$value => $$invalidate(45, $felixOutputName = $$value));
	validate_store(felixopoLocation, "felixopoLocation");
	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(46, $felixopoLocation = $$value));
	validate_store(dataTable, "dataTable");
	component_subscribe($$self, dataTable, $$value => $$invalidate(47, $dataTable = $$value));
	validate_store(felixPeakTable, "felixPeakTable");
	component_subscribe($$self, felixPeakTable, $$value => $$invalidate(0, $felixPeakTable = $$value));
	validate_store(felixAnnotationColor, "felixAnnotationColor");
	component_subscribe($$self, felixAnnotationColor, $$value => $$invalidate(48, $felixAnnotationColor = $$value));
	validate_store(Ngauss_sigma, "Ngauss_sigma");
	component_subscribe($$self, Ngauss_sigma, $$value => $$invalidate(12, $Ngauss_sigma = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ExecuteFunctionContents", slots, []);

	let { addedFileScale } = $$props,
		{ addedFileCol } = $$props,
		{ normMethod } = $$props,
		{ writeFileName } = $$props,
		{ writeFile } = $$props,
		{ overwrite_expfit } = $$props,
		{ fullfiles } = $$props,
		{ preModal } = $$props;

	let boxSelected_peakfinder = false, NGauss_fit_args = {};
	let peak_height = 1, peak_width = 3, peak_prominence = 0;

	let toggleFindPeaksRow = false,
		savePeakfilename = "peakTable",
		modalActivate = false;

	const clearAllPeak = () => {
		if ($fittedTraceCount === 0) {
			return window.createToast("No fitted lines found", "danger");
		}

		console.log("Removing all found peak values");
		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = set_store_value(felixIndex, $felixIndex = set_store_value(expfittedLines, $expfittedLines = set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), $expfittedLines), $felixIndex), $felixPlotAnnotations);
		Plotly.relayout($graphDiv, { annotations: [], shapes: [] });

		for (let i = 0; i < $fittedTraceCount; i++) {
			Plotly.deleteTraces($graphDiv, [-1]);
		}

		set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount);
	};

	const clearLastPeak = () => {
		if ($fittedTraceCount === 0) {
			return window.createToast("No fitted lines found", "danger");
		}

		plotData({
			filetype: "general",
			general: {
				args: [$felixOutputName, $felixopoLocation, normMethod],
				pyfile: "delete_fileLines.py"
			}
		});

		set_store_value(dataTable, $dataTable = _.dropRight($dataTable, 1), $dataTable);
		set_store_value(expfittedLines, $expfittedLines = _.dropRight($expfittedLines, 2), $expfittedLines);
		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = _.dropRight($felixPlotAnnotations, 1), $felixPlotAnnotations);
		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = _.dropRight($expfittedLinesCollectedData, 1), $expfittedLinesCollectedData);

		Plotly.relayout($graphDiv, {
			annotations: $felixPlotAnnotations,
			shapes: $expfittedLines
		});

		Plotly.deleteTraces($graphDiv, [-1]);
		console.log("Last fitted peak removed");
		set_store_value(fittedTraceCount, $fittedTraceCount--, $fittedTraceCount);
	};

	function loadpeakTable() {
		const loadedfile = loadfile({ name: savePeakfilename });
		set_store_value(felixPeakTable, $felixPeakTable = _.uniqBy([...loadedfile, ...$felixPeakTable], "freq"), $felixPeakTable);
		adjustPeak();
	}

	function adjustPeak({ closeMainModal = true } = {}) {
		set_store_value(felixPeakTable, $felixPeakTable = _.filter($felixPeakTable, tb => tb.sig != 0), $felixPeakTable);
		set_store_value(felixPeakTable, $felixPeakTable = _.sortBy($felixPeakTable, [o => o["freq"]]), $felixPeakTable);

		let temp_annotate = {
			xref: "x",
			y: "y",
			"showarrow": true,
			"arrowhead": 2,
			"ax": -25,
			"ay": -40,
			font: { color: $felixAnnotationColor },
			arrowcolor: $felixAnnotationColor
		};

		set_store_value(
			felixPlotAnnotations,
			$felixPlotAnnotations = $felixPeakTable.map(f => {
				const { freq, amp } = f;
				const x = parseFloat(freq);
				const y = parseFloat(amp);

				let _annotate = {
					x,
					y,
					text: `(${x.toFixed(2)}, ${y.toFixed(2)})`
				};

				return { ...temp_annotate, ..._annotate };
			}),
			$felixPlotAnnotations
		);

		if (closeMainModal) {
			($$invalidate(8, modalActivate = false), window.createToast("Initial guess adjusted for full spectrum fitting"));
		}

		Plotly.relayout($graphDiv, { annotations: $felixPlotAnnotations });
	}

	

	function plotData({ e = null, filetype = "exp_fit", general = {} } = {}) {
		if (filetype == "general") {
			const { pyfile, args } = general;

			computePy_func({ pyfile, args, general: true }).catch(err => {
				$$invalidate(18, preModal.modalContent = err, preModal);
				$$invalidate(18, preModal.open = true, preModal);
			});

			return;
		}

		let pyfile = "", args;
		let expfit_args = [], find_peaks_args = {};

		switch (filetype) {
			case "exp_fit":
				if ($felixIndex.length < 2) {
					return window.createToast("Range not found!!. Select a range using Box-select", "danger");
				}
				expfit_args = {
					addedFileScale,
					addedFileCol,
					output_name: $felixOutputName,
					overwrite_expfit,
					writeFile,
					writeFileName,
					normMethod,
					index: $felixIndex,
					fullfiles,
					location: $felixopoLocation
				};
				(pyfile = "exp_gauss_fit.py", args = [JSON.stringify(expfit_args)]);
				computePy_func({ e, pyfile, args }).then(dataFromPython => {
					exp_fit_func({ dataFromPython });
					window.createToast("Line fitted with gaussian function", "success");
				}).catch(err => {
					$$invalidate(18, preModal.modalContent = err, preModal);
					$$invalidate(18, preModal.open = true, preModal);
				});
				break;
			case "NGauss_fit":
				if (boxSelected_peakfinder) {
					if ($felixIndex.length < 2) {
						return window.createToast("Box selection is turned ON so please select a wn. range to fit", "danger");
					}

					$$invalidate(2, NGauss_fit_args.index = $felixIndex, NGauss_fit_args);
				} else {
					delete NGauss_fit_args.index;
				}
				if ($felixPeakTable.length === 0) {
					return window.createToast("No arguments initialised yet.", "danger");
				}
				$$invalidate(2, NGauss_fit_args.fitNGauss_arguments = {}, NGauss_fit_args);
				set_store_value(felixPeakTable, $felixPeakTable = _.sortBy($felixPeakTable, [o => o["freq"]]), $felixPeakTable);
				$felixPeakTable.forEach((f, index) => {
					$$invalidate(2, NGauss_fit_args.fitNGauss_arguments[`cen${index}`] = f.freq, NGauss_fit_args);
					$$invalidate(2, NGauss_fit_args.fitNGauss_arguments[`A${index}`] = f.amp, NGauss_fit_args);
					$$invalidate(2, NGauss_fit_args.fitNGauss_arguments[`sigma${index}`] = f.sig, NGauss_fit_args);
				});
				$$invalidate(2, NGauss_fit_args = {
					...NGauss_fit_args,
					location: $felixopoLocation,
					addedFileScale,
					addedFileCol,
					overwrite_expfit,
					writeFile,
					writeFileName,
					output_name: $felixOutputName,
					fullfiles,
					normMethod
				});
				(pyfile = "multiGauss.py", args = [JSON.stringify(NGauss_fit_args)]);
				computePy_func({ e, pyfile, args }).then(dataFromPython => {
					NGauss_fit_func({ dataFromPython });
					console.log("Line fitted");
					window.createToast(`Line fitted with ${dataFromPython["fitted_parameter"].length} gaussian function`, "success");
				}).catch(err => {
					$$invalidate(18, preModal.modalContent = err, preModal);
					$$invalidate(18, preModal.open = true, preModal);
				});
				break;
			case "find_peaks":
				set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable);
				if ($felixIndex.length < 2 && boxSelected_peakfinder) {
					return window.createToast("Box selection is turned ON so please select a wn. range to fit", "danger");
				}
				let selectedIndex = boxSelected_peakfinder ? $felixIndex : [0, 0];
				find_peaks_args = {
					addedFileScale,
					addedFileCol,
					output_name: $felixOutputName,
					normMethod,
					peak_prominence,
					peak_width,
					peak_height,
					selectedIndex,
					fullfiles,
					location: $felixopoLocation
				};
				(pyfile = "fit_all.py", args = [JSON.stringify(find_peaks_args)]);
				computePy_func({ e, pyfile, args }).then(dataFromPython => {
					find_peaks_func({ dataFromPython });
					console.log(`felixPeakTable:`, $felixPeakTable);
					window.createToast("Peaks found", "success");
				}).catch(err => {
					$$invalidate(18, preModal.modalContent = err, preModal);
					$$invalidate(18, preModal.open = true, preModal);
				});
				break;
			case "get_err":
				if ($expfittedLinesCollectedData.length < 2) return window.createToast("Not sufficient lines collected!", "danger");
				(pyfile = "weighted_error.py", args = $expfittedLinesCollectedData);
				computePy_func({ e, pyfile, args }).then(dataFromPython => {
					get_err_func({ dataFromPython });
					window.createToast("Weighted fit. done", "success");
				}).catch(err => {
					$$invalidate(18, preModal.modalContent = err, preModal);
					$$invalidate(18, preModal.open = true, preModal);
				});
				break;
		}
	}

	const writable_props = [
		"addedFileScale",
		"addedFileCol",
		"normMethod",
		"writeFileName",
		"writeFile",
		"overwrite_expfit",
		"fullfiles",
		"preModal"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<ExecuteFunctionContents> was created with unknown prop '${key}'`);
	});

	function adjustinitialguess_active_binding(value) {
		modalActivate = value;
		$$invalidate(8, modalActivate);
	}

	const click_handler = e => plotData({ e, filetype: "exp_fit" });
	const click_handler_1 = () => $$invalidate(6, toggleFindPeaksRow = !toggleFindPeaksRow);
	const click_handler_2 = e => plotData({ e, filetype: "get_err" });

	const click_handler_3 = () => {
		set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData);
		window.createToast("Line collection restted", "warning");
	};

	function customswitch_selected_binding(value) {
		boxSelected_peakfinder = value;
		$$invalidate(1, boxSelected_peakfinder);
	}

	function textfield0_value_binding(value) {
		peak_prominence = value;
		$$invalidate(5, peak_prominence);
	}

	function textfield1_value_binding(value) {
		peak_width = value;
		$$invalidate(4, peak_width);
	}

	function textfield2_value_binding(value) {
		peak_height = value;
		$$invalidate(3, peak_height);
	}

	function textfield3_value_binding(value) {
		$Ngauss_sigma = value;
		Ngauss_sigma.set($Ngauss_sigma);
	}

	const click_handler_4 = e => plotData({ e, filetype: "find_peaks" });
	const click_handler_5 = () => $$invalidate(8, modalActivate = true);
	const click_handler_6 = e => plotData({ e, filetype: "NGauss_fit" });

	function textfield4_value_binding(value) {
		savePeakfilename = value;
		$$invalidate(7, savePeakfilename);
	}

	const click_handler_7 = () => savefile({
		file: $felixPeakTable,
		name: savePeakfilename
	});

	const click_handler_8 = () => {
		set_store_value(felixPlotAnnotations, $felixPlotAnnotations = [], $felixPlotAnnotations);
		set_store_value(felixPeakTable, $felixPeakTable = [], $felixPeakTable);
		$$invalidate(2, NGauss_fit_args = {});
		window.Plotly.relayout($graphDiv, { annotations: [] });
		window.createToast("Cleared", "warning");
	};

	$$self.$$set = $$props => {
		if ("addedFileScale" in $$props) $$invalidate(19, addedFileScale = $$props.addedFileScale);
		if ("addedFileCol" in $$props) $$invalidate(20, addedFileCol = $$props.addedFileCol);
		if ("normMethod" in $$props) $$invalidate(21, normMethod = $$props.normMethod);
		if ("writeFileName" in $$props) $$invalidate(22, writeFileName = $$props.writeFileName);
		if ("writeFile" in $$props) $$invalidate(23, writeFile = $$props.writeFile);
		if ("overwrite_expfit" in $$props) $$invalidate(24, overwrite_expfit = $$props.overwrite_expfit);
		if ("fullfiles" in $$props) $$invalidate(25, fullfiles = $$props.fullfiles);
		if ("preModal" in $$props) $$invalidate(18, preModal = $$props.preModal);
	};

	$$self.$capture_state = () => ({
		fittedTraceCount,
		felixPlotAnnotations,
		felixIndex,
		expfittedLines,
		expfittedLinesCollectedData,
		graphDiv,
		dataTable,
		Ngauss_sigma,
		felixOutputName,
		felixPeakTable,
		felixopoLocation,
		felixAnnotationColor,
		Textfield,
		CustomSwitch,
		Icon,
		AdjustInitialGuess,
		savefile,
		loadfile,
		fade,
		NGauss_fit_func,
		find_peaks_func,
		exp_fit_func,
		get_err_func,
		addedFileScale,
		addedFileCol,
		normMethod,
		writeFileName,
		writeFile,
		overwrite_expfit,
		fullfiles,
		preModal,
		boxSelected_peakfinder,
		NGauss_fit_args,
		peak_height,
		peak_width,
		peak_prominence,
		toggleFindPeaksRow,
		savePeakfilename,
		modalActivate,
		style,
		clearAllPeak,
		clearLastPeak,
		loadpeakTable,
		adjustPeak,
		plotData,
		$fittedTraceCount,
		$felixPlotAnnotations,
		$felixIndex,
		$expfittedLines,
		$expfittedLinesCollectedData,
		$graphDiv,
		$felixOutputName,
		$felixopoLocation,
		$dataTable,
		$felixPeakTable,
		$felixAnnotationColor,
		$Ngauss_sigma
	});

	$$self.$inject_state = $$props => {
		if ("addedFileScale" in $$props) $$invalidate(19, addedFileScale = $$props.addedFileScale);
		if ("addedFileCol" in $$props) $$invalidate(20, addedFileCol = $$props.addedFileCol);
		if ("normMethod" in $$props) $$invalidate(21, normMethod = $$props.normMethod);
		if ("writeFileName" in $$props) $$invalidate(22, writeFileName = $$props.writeFileName);
		if ("writeFile" in $$props) $$invalidate(23, writeFile = $$props.writeFile);
		if ("overwrite_expfit" in $$props) $$invalidate(24, overwrite_expfit = $$props.overwrite_expfit);
		if ("fullfiles" in $$props) $$invalidate(25, fullfiles = $$props.fullfiles);
		if ("preModal" in $$props) $$invalidate(18, preModal = $$props.preModal);
		if ("boxSelected_peakfinder" in $$props) $$invalidate(1, boxSelected_peakfinder = $$props.boxSelected_peakfinder);
		if ("NGauss_fit_args" in $$props) $$invalidate(2, NGauss_fit_args = $$props.NGauss_fit_args);
		if ("peak_height" in $$props) $$invalidate(3, peak_height = $$props.peak_height);
		if ("peak_width" in $$props) $$invalidate(4, peak_width = $$props.peak_width);
		if ("peak_prominence" in $$props) $$invalidate(5, peak_prominence = $$props.peak_prominence);
		if ("toggleFindPeaksRow" in $$props) $$invalidate(6, toggleFindPeaksRow = $$props.toggleFindPeaksRow);
		if ("savePeakfilename" in $$props) $$invalidate(7, savePeakfilename = $$props.savePeakfilename);
		if ("modalActivate" in $$props) $$invalidate(8, modalActivate = $$props.modalActivate);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$felixPeakTable*/ 1) {
			 set_store_value(
				felixPeakTable,
				$felixPeakTable = $felixPeakTable.map(f => {
					let { freq, amp, sig, id } = f;
					freq = parseFloat(freq);
					amp = parseFloat(amp);
					sig = parseFloat(sig);
					return { freq, amp, sig, id };
				}),
				$felixPeakTable
			);
		}
	};

	return [
		$felixPeakTable,
		boxSelected_peakfinder,
		NGauss_fit_args,
		peak_height,
		peak_width,
		peak_prominence,
		toggleFindPeaksRow,
		savePeakfilename,
		modalActivate,
		$felixPlotAnnotations,
		$expfittedLinesCollectedData,
		$graphDiv,
		$Ngauss_sigma,
		clearAllPeak,
		clearLastPeak,
		loadpeakTable,
		adjustPeak,
		plotData,
		preModal,
		addedFileScale,
		addedFileCol,
		normMethod,
		writeFileName,
		writeFile,
		overwrite_expfit,
		fullfiles,
		adjustinitialguess_active_binding,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		customswitch_selected_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		textfield2_value_binding,
		textfield3_value_binding,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		textfield4_value_binding,
		click_handler_7,
		click_handler_8
	];
}

class ExecuteFunctionContents extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1g,
			create_fragment$1g,
			safe_not_equal,
			{
				addedFileScale: 19,
				addedFileCol: 20,
				normMethod: 21,
				writeFileName: 22,
				writeFile: 23,
				overwrite_expfit: 24,
				fullfiles: 25,
				preModal: 18
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExecuteFunctionContents",
			options,
			id: create_fragment$1g.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*addedFileScale*/ ctx[19] === undefined && !("addedFileScale" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'addedFileScale'");
		}

		if (/*addedFileCol*/ ctx[20] === undefined && !("addedFileCol" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'addedFileCol'");
		}

		if (/*normMethod*/ ctx[21] === undefined && !("normMethod" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'normMethod'");
		}

		if (/*writeFileName*/ ctx[22] === undefined && !("writeFileName" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'writeFileName'");
		}

		if (/*writeFile*/ ctx[23] === undefined && !("writeFile" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'writeFile'");
		}

		if (/*overwrite_expfit*/ ctx[24] === undefined && !("overwrite_expfit" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'overwrite_expfit'");
		}

		if (/*fullfiles*/ ctx[25] === undefined && !("fullfiles" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'fullfiles'");
		}

		if (/*preModal*/ ctx[18] === undefined && !("preModal" in props)) {
			console_1$9.warn("<ExecuteFunctionContents> was created without expected prop 'preModal'");
		}
	}

	get addedFileScale() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedFileScale(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addedFileCol() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addedFileCol(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get normMethod() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set normMethod(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get writeFileName() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set writeFileName(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get writeFile() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set writeFile(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get overwrite_expfit() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set overwrite_expfit(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullfiles() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullfiles(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preModal() {
		throw new Error("<ExecuteFunctionContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preModal(value) {
		throw new Error("<ExecuteFunctionContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function init_tour_normline({filetype="felix"}={}) {
        
    const intro = introJs();
    intro.setOptions({

        steps: [

            {
                element: document.getElementById(`${filetype}_filebrowser_btn`),
                intro: "Browse file location folder"
            },
            {
                element: document.getElementById(`${filetype}_filebrowser`),
                intro: "Select file(s) here", position:"right"
            },
            {
                element: document.getElementById('create_baseline_btn'),
                intro: "Create/ajusting baseline"
            },
            {
                element: document.getElementById('felix_plotting_btn'),
                intro: "After creating baseline -> Plot the graph (NOTE: .pow file should be already present in DATA folder)"
            },

        ], showProgress: true, showBullets:false
      
    });

    console.log("Starting introduction tour");
    intro.start();

    intro.onbeforeexit(function() {
        console.log("introduction tour exited");

        // return false; // returning false means don't exit the intro
    
    });

    intro.onbeforechange(function(targetElement) {
        console.log("before new step",targetElement);
    });

    intro.onafterchange(function(targetElement) {
        console.log("after new step",targetElement);
    });

    intro.oncomplete(function() {
        console.log("introduction tour completed");
    });
}

/* src\Pages\Normline.svelte generated by Svelte v3.31.2 */

const { console: console_1$a } = globals;
const file$1a = "src\\Pages\\Normline.svelte";

// (180:4) <div class="buttonSlot" slot="buttonContainer">
function create_buttonContainer_slot(ctx) {
	let div0;
	let initfunctionrow;
	let updating_preModal;
	let updating_graphPlotted;
	let updating_show_theoryplot;
	let t0;
	let oporow;
	let updating_OPOLocation;
	let updating_OPOfilesChecked;
	let updating_opofiles;
	let updating_preModal_1;
	let updating_graphPlotted_1;
	let t1;
	let theoryrow;
	let updating_theoryLocation;
	let updating_show_theoryplot_1;
	let updating_preModal_2;
	let t2;
	let div1;
	let customradio;
	let updating_selected;
	let current;

	function initfunctionrow_preModal_binding(value) {
		/*initfunctionrow_preModal_binding*/ ctx[45].call(null, value);
	}

	function initfunctionrow_graphPlotted_binding(value) {
		/*initfunctionrow_graphPlotted_binding*/ ctx[46].call(null, value);
	}

	function initfunctionrow_show_theoryplot_binding(value) {
		/*initfunctionrow_show_theoryplot_binding*/ ctx[47].call(null, value);
	}

	let initfunctionrow_props = {
		removeExtraFile: /*removeExtraFile*/ ctx[27],
		felixPlotCheckboxes: /*felixPlotCheckboxes*/ ctx[10],
		opofiles: /*opofiles*/ ctx[5],
		felixfiles: /*felixfiles*/ ctx[8],
		normMethod: /*$normMethod*/ ctx[25],
		theoryLocation: /*theoryLocation*/ ctx[2]
	};

	if (/*preModal*/ ctx[23] !== void 0) {
		initfunctionrow_props.preModal = /*preModal*/ ctx[23];
	}

	if (/*graphPlotted*/ ctx[13] !== void 0) {
		initfunctionrow_props.graphPlotted = /*graphPlotted*/ ctx[13];
	}

	if (/*show_theoryplot*/ ctx[12] !== void 0) {
		initfunctionrow_props.show_theoryplot = /*show_theoryplot*/ ctx[12];
	}

	initfunctionrow = new InitFunctionRow({
			props: initfunctionrow_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(initfunctionrow, "preModal", initfunctionrow_preModal_binding));
	binding_callbacks.push(() => bind(initfunctionrow, "graphPlotted", initfunctionrow_graphPlotted_binding));
	binding_callbacks.push(() => bind(initfunctionrow, "show_theoryplot", initfunctionrow_show_theoryplot_binding));

	function oporow_OPOLocation_binding(value) {
		/*oporow_OPOLocation_binding*/ ctx[48].call(null, value);
	}

	function oporow_OPOfilesChecked_binding(value) {
		/*oporow_OPOfilesChecked_binding*/ ctx[49].call(null, value);
	}

	function oporow_opofiles_binding(value) {
		/*oporow_opofiles_binding*/ ctx[50].call(null, value);
	}

	function oporow_preModal_binding(value) {
		/*oporow_preModal_binding*/ ctx[51].call(null, value);
	}

	function oporow_graphPlotted_binding(value) {
		/*oporow_graphPlotted_binding*/ ctx[52].call(null, value);
	}

	let oporow_props = {
		removeExtraFile: /*removeExtraFile*/ ctx[27]
	};

	if (/*OPOLocation*/ ctx[4] !== void 0) {
		oporow_props.OPOLocation = /*OPOLocation*/ ctx[4];
	}

	if (/*OPOfilesChecked*/ ctx[3] !== void 0) {
		oporow_props.OPOfilesChecked = /*OPOfilesChecked*/ ctx[3];
	}

	if (/*opofiles*/ ctx[5] !== void 0) {
		oporow_props.opofiles = /*opofiles*/ ctx[5];
	}

	if (/*preModal*/ ctx[23] !== void 0) {
		oporow_props.preModal = /*preModal*/ ctx[23];
	}

	if (/*graphPlotted*/ ctx[13] !== void 0) {
		oporow_props.graphPlotted = /*graphPlotted*/ ctx[13];
	}

	oporow = new OPORow({ props: oporow_props, $$inline: true });
	binding_callbacks.push(() => bind(oporow, "OPOLocation", oporow_OPOLocation_binding));
	binding_callbacks.push(() => bind(oporow, "OPOfilesChecked", oporow_OPOfilesChecked_binding));
	binding_callbacks.push(() => bind(oporow, "opofiles", oporow_opofiles_binding));
	binding_callbacks.push(() => bind(oporow, "preModal", oporow_preModal_binding));
	binding_callbacks.push(() => bind(oporow, "graphPlotted", oporow_graphPlotted_binding));

	function theoryrow_theoryLocation_binding(value) {
		/*theoryrow_theoryLocation_binding*/ ctx[53].call(null, value);
	}

	function theoryrow_show_theoryplot_binding(value) {
		/*theoryrow_show_theoryplot_binding*/ ctx[54].call(null, value);
	}

	function theoryrow_preModal_binding(value) {
		/*theoryrow_preModal_binding*/ ctx[55].call(null, value);
	}

	let theoryrow_props = {
		normMethod: /*$normMethod*/ ctx[25],
		currentLocation: /*currentLocation*/ ctx[1]
	};

	if (/*theoryLocation*/ ctx[2] !== void 0) {
		theoryrow_props.theoryLocation = /*theoryLocation*/ ctx[2];
	}

	if (/*show_theoryplot*/ ctx[12] !== void 0) {
		theoryrow_props.show_theoryplot = /*show_theoryplot*/ ctx[12];
	}

	if (/*preModal*/ ctx[23] !== void 0) {
		theoryrow_props.preModal = /*preModal*/ ctx[23];
	}

	theoryrow = new TheoryRow({ props: theoryrow_props, $$inline: true });
	binding_callbacks.push(() => bind(theoryrow, "theoryLocation", theoryrow_theoryLocation_binding));
	binding_callbacks.push(() => bind(theoryrow, "show_theoryplot", theoryrow_show_theoryplot_binding));
	binding_callbacks.push(() => bind(theoryrow, "preModal", theoryrow_preModal_binding));

	function customradio_selected_binding(value) {
		/*customradio_selected_binding*/ ctx[56].call(null, value);
	}

	let customradio_props = {
		options: ["Log", "Relative", "IntensityPerPhoton"]
	};

	if (/*$normMethod*/ ctx[25] !== void 0) {
		customradio_props.selected = /*$normMethod*/ ctx[25];
	}

	customradio = new CustomRadio({ props: customradio_props, $$inline: true });
	binding_callbacks.push(() => bind(customradio, "selected", customradio_selected_binding));
	customradio.$on("change", /*replot*/ ctx[26]);

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(initfunctionrow.$$.fragment);
			t0 = space();
			create_component(oporow.$$.fragment);
			t1 = space();
			create_component(theoryrow.$$.fragment);
			t2 = space();
			div1 = element("div");
			create_component(customradio.$$.fragment);
			set_style(div1, "display", "flex");
			add_location(div1, file$1a, 185, 8, 7439);
			attr_dev(div0, "class", "buttonSlot");
			attr_dev(div0, "slot", "buttonContainer");
			add_location(div0, file$1a, 179, 4, 6949);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(initfunctionrow, div0, null);
			append_dev(div0, t0);
			mount_component(oporow, div0, null);
			append_dev(div0, t1);
			mount_component(theoryrow, div0, null);
			append_dev(div0, t2);
			append_dev(div0, div1);
			mount_component(customradio, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const initfunctionrow_changes = {};
			if (dirty[0] & /*felixPlotCheckboxes*/ 1024) initfunctionrow_changes.felixPlotCheckboxes = /*felixPlotCheckboxes*/ ctx[10];
			if (dirty[0] & /*opofiles*/ 32) initfunctionrow_changes.opofiles = /*opofiles*/ ctx[5];
			if (dirty[0] & /*felixfiles*/ 256) initfunctionrow_changes.felixfiles = /*felixfiles*/ ctx[8];
			if (dirty[0] & /*$normMethod*/ 33554432) initfunctionrow_changes.normMethod = /*$normMethod*/ ctx[25];
			if (dirty[0] & /*theoryLocation*/ 4) initfunctionrow_changes.theoryLocation = /*theoryLocation*/ ctx[2];

			if (!updating_preModal && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal = true;
				initfunctionrow_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal = false);
			}

			if (!updating_graphPlotted && dirty[0] & /*graphPlotted*/ 8192) {
				updating_graphPlotted = true;
				initfunctionrow_changes.graphPlotted = /*graphPlotted*/ ctx[13];
				add_flush_callback(() => updating_graphPlotted = false);
			}

			if (!updating_show_theoryplot && dirty[0] & /*show_theoryplot*/ 4096) {
				updating_show_theoryplot = true;
				initfunctionrow_changes.show_theoryplot = /*show_theoryplot*/ ctx[12];
				add_flush_callback(() => updating_show_theoryplot = false);
			}

			initfunctionrow.$set(initfunctionrow_changes);
			const oporow_changes = {};

			if (!updating_OPOLocation && dirty[0] & /*OPOLocation*/ 16) {
				updating_OPOLocation = true;
				oporow_changes.OPOLocation = /*OPOLocation*/ ctx[4];
				add_flush_callback(() => updating_OPOLocation = false);
			}

			if (!updating_OPOfilesChecked && dirty[0] & /*OPOfilesChecked*/ 8) {
				updating_OPOfilesChecked = true;
				oporow_changes.OPOfilesChecked = /*OPOfilesChecked*/ ctx[3];
				add_flush_callback(() => updating_OPOfilesChecked = false);
			}

			if (!updating_opofiles && dirty[0] & /*opofiles*/ 32) {
				updating_opofiles = true;
				oporow_changes.opofiles = /*opofiles*/ ctx[5];
				add_flush_callback(() => updating_opofiles = false);
			}

			if (!updating_preModal_1 && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal_1 = true;
				oporow_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal_1 = false);
			}

			if (!updating_graphPlotted_1 && dirty[0] & /*graphPlotted*/ 8192) {
				updating_graphPlotted_1 = true;
				oporow_changes.graphPlotted = /*graphPlotted*/ ctx[13];
				add_flush_callback(() => updating_graphPlotted_1 = false);
			}

			oporow.$set(oporow_changes);
			const theoryrow_changes = {};
			if (dirty[0] & /*$normMethod*/ 33554432) theoryrow_changes.normMethod = /*$normMethod*/ ctx[25];
			if (dirty[0] & /*currentLocation*/ 2) theoryrow_changes.currentLocation = /*currentLocation*/ ctx[1];

			if (!updating_theoryLocation && dirty[0] & /*theoryLocation*/ 4) {
				updating_theoryLocation = true;
				theoryrow_changes.theoryLocation = /*theoryLocation*/ ctx[2];
				add_flush_callback(() => updating_theoryLocation = false);
			}

			if (!updating_show_theoryplot_1 && dirty[0] & /*show_theoryplot*/ 4096) {
				updating_show_theoryplot_1 = true;
				theoryrow_changes.show_theoryplot = /*show_theoryplot*/ ctx[12];
				add_flush_callback(() => updating_show_theoryplot_1 = false);
			}

			if (!updating_preModal_2 && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal_2 = true;
				theoryrow_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal_2 = false);
			}

			theoryrow.$set(theoryrow_changes);
			const customradio_changes = {};

			if (!updating_selected && dirty[0] & /*$normMethod*/ 33554432) {
				updating_selected = true;
				customradio_changes.selected = /*$normMethod*/ ctx[25];
				add_flush_callback(() => updating_selected = false);
			}

			customradio.$set(customradio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(initfunctionrow.$$.fragment, local);
			transition_in(oporow.$$.fragment, local);
			transition_in(theoryrow.$$.fragment, local);
			transition_in(customradio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(initfunctionrow.$$.fragment, local);
			transition_out(oporow.$$.fragment, local);
			transition_out(theoryrow.$$.fragment, local);
			transition_out(customradio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(initfunctionrow);
			destroy_component(oporow);
			destroy_component(theoryrow);
			destroy_component(customradio);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttonContainer_slot.name,
		type: "slot",
		source: "(180:4) <div class=\\\"buttonSlot\\\" slot=\\\"buttonContainer\\\">",
		ctx
	});

	return block;
}

// (214:8) {#if graphPlotted}
function create_if_block$s(ctx) {
	let div;
	let writefunctioncontents;
	let updating_writeFileName;
	let updating_writeFile;
	let updating_overwrite_expfit;
	let t0;
	let executefunctioncontents;
	let updating_preModal;
	let t1;
	let frequencytable;
	let updating_keepTable;
	let t2;
	let reportlayout;
	let updating_currentLocation;
	let div_transition;
	let current;

	function writefunctioncontents_writeFileName_binding(value) {
		/*writefunctioncontents_writeFileName_binding*/ ctx[57].call(null, value);
	}

	function writefunctioncontents_writeFile_binding(value) {
		/*writefunctioncontents_writeFile_binding*/ ctx[58].call(null, value);
	}

	function writefunctioncontents_overwrite_expfit_binding(value) {
		/*writefunctioncontents_overwrite_expfit_binding*/ ctx[59].call(null, value);
	}

	let writefunctioncontents_props = {
		output_namelists: /*output_namelists*/ ctx[24]
	};

	if (/*writeFileName*/ ctx[16] !== void 0) {
		writefunctioncontents_props.writeFileName = /*writeFileName*/ ctx[16];
	}

	if (/*writeFile*/ ctx[15] !== void 0) {
		writefunctioncontents_props.writeFile = /*writeFile*/ ctx[15];
	}

	if (/*overwrite_expfit*/ ctx[14] !== void 0) {
		writefunctioncontents_props.overwrite_expfit = /*overwrite_expfit*/ ctx[14];
	}

	writefunctioncontents = new WriteFunctionContents({
			props: writefunctioncontents_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(writefunctioncontents, "writeFileName", writefunctioncontents_writeFileName_binding));
	binding_callbacks.push(() => bind(writefunctioncontents, "writeFile", writefunctioncontents_writeFile_binding));
	binding_callbacks.push(() => bind(writefunctioncontents, "overwrite_expfit", writefunctioncontents_overwrite_expfit_binding));
	writefunctioncontents.$on("addfile", /*addfile_handler*/ ctx[60]);
	writefunctioncontents.$on("removefile", /*removeExtraFile*/ ctx[27]);

	function executefunctioncontents_preModal_binding(value) {
		/*executefunctioncontents_preModal_binding*/ ctx[61].call(null, value);
	}

	let executefunctioncontents_props = {
		addedFileScale: /*addedFileScale*/ ctx[21],
		addedFileCol: /*addedFileCol*/ ctx[19],
		normMethod: /*$normMethod*/ ctx[25],
		writeFileName: /*writeFileName*/ ctx[16],
		writeFile: /*writeFile*/ ctx[15],
		overwrite_expfit: /*overwrite_expfit*/ ctx[14],
		fullfiles: /*fullfiles*/ ctx[22]
	};

	if (/*preModal*/ ctx[23] !== void 0) {
		executefunctioncontents_props.preModal = /*preModal*/ ctx[23];
	}

	executefunctioncontents = new ExecuteFunctionContents({
			props: executefunctioncontents_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(executefunctioncontents, "preModal", executefunctioncontents_preModal_binding));

	function frequencytable_keepTable_binding(value) {
		/*frequencytable_keepTable_binding*/ ctx[62].call(null, value);
	}

	let frequencytable_props = {};

	if (/*keepTable*/ ctx[17] !== void 0) {
		frequencytable_props.keepTable = /*keepTable*/ ctx[17];
	}

	frequencytable = new FrequencyTable({
			props: frequencytable_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(frequencytable, "keepTable", frequencytable_keepTable_binding));

	function reportlayout_currentLocation_binding(value) {
		/*reportlayout_currentLocation_binding*/ ctx[63].call(null, value);
	}

	let reportlayout_props = {
		id: `${filetype}_report`,
		includePlotsInReport: /*includePlotsInReport*/ ctx[29],
		includeTablesInReports: /*includeTablesInReports*/ ctx[30]
	};

	if (/*currentLocation*/ ctx[1] !== void 0) {
		reportlayout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	reportlayout = new ReportLayout({
			props: reportlayout_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(reportlayout, "currentLocation", reportlayout_currentLocation_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(writefunctioncontents.$$.fragment);
			t0 = space();
			create_component(executefunctioncontents.$$.fragment);
			t1 = space();
			create_component(frequencytable.$$.fragment);
			t2 = space();
			create_component(reportlayout.$$.fragment);
			attr_dev(div, "class", "svelte-1soq9o5");
			add_location(div, file$1a, 215, 12, 8440);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(writefunctioncontents, div, null);
			append_dev(div, t0);
			mount_component(executefunctioncontents, div, null);
			append_dev(div, t1);
			mount_component(frequencytable, div, null);
			append_dev(div, t2);
			mount_component(reportlayout, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const writefunctioncontents_changes = {};
			if (dirty[0] & /*output_namelists*/ 16777216) writefunctioncontents_changes.output_namelists = /*output_namelists*/ ctx[24];

			if (!updating_writeFileName && dirty[0] & /*writeFileName*/ 65536) {
				updating_writeFileName = true;
				writefunctioncontents_changes.writeFileName = /*writeFileName*/ ctx[16];
				add_flush_callback(() => updating_writeFileName = false);
			}

			if (!updating_writeFile && dirty[0] & /*writeFile*/ 32768) {
				updating_writeFile = true;
				writefunctioncontents_changes.writeFile = /*writeFile*/ ctx[15];
				add_flush_callback(() => updating_writeFile = false);
			}

			if (!updating_overwrite_expfit && dirty[0] & /*overwrite_expfit*/ 16384) {
				updating_overwrite_expfit = true;
				writefunctioncontents_changes.overwrite_expfit = /*overwrite_expfit*/ ctx[14];
				add_flush_callback(() => updating_overwrite_expfit = false);
			}

			writefunctioncontents.$set(writefunctioncontents_changes);
			const executefunctioncontents_changes = {};
			if (dirty[0] & /*addedFileScale*/ 2097152) executefunctioncontents_changes.addedFileScale = /*addedFileScale*/ ctx[21];
			if (dirty[0] & /*addedFileCol*/ 524288) executefunctioncontents_changes.addedFileCol = /*addedFileCol*/ ctx[19];
			if (dirty[0] & /*$normMethod*/ 33554432) executefunctioncontents_changes.normMethod = /*$normMethod*/ ctx[25];
			if (dirty[0] & /*writeFileName*/ 65536) executefunctioncontents_changes.writeFileName = /*writeFileName*/ ctx[16];
			if (dirty[0] & /*writeFile*/ 32768) executefunctioncontents_changes.writeFile = /*writeFile*/ ctx[15];
			if (dirty[0] & /*overwrite_expfit*/ 16384) executefunctioncontents_changes.overwrite_expfit = /*overwrite_expfit*/ ctx[14];
			if (dirty[0] & /*fullfiles*/ 4194304) executefunctioncontents_changes.fullfiles = /*fullfiles*/ ctx[22];

			if (!updating_preModal && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal = true;
				executefunctioncontents_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal = false);
			}

			executefunctioncontents.$set(executefunctioncontents_changes);
			const frequencytable_changes = {};

			if (!updating_keepTable && dirty[0] & /*keepTable*/ 131072) {
				updating_keepTable = true;
				frequencytable_changes.keepTable = /*keepTable*/ ctx[17];
				add_flush_callback(() => updating_keepTable = false);
			}

			frequencytable.$set(frequencytable_changes);
			const reportlayout_changes = {};

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				reportlayout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			reportlayout.$set(reportlayout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(writefunctioncontents.$$.fragment, local);
			transition_in(executefunctioncontents.$$.fragment, local);
			transition_in(frequencytable.$$.fragment, local);
			transition_in(reportlayout.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(writefunctioncontents.$$.fragment, local);
			transition_out(executefunctioncontents.$$.fragment, local);
			transition_out(frequencytable.$$.fragment, local);
			transition_out(reportlayout.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(writefunctioncontents);
			destroy_component(executefunctioncontents);
			destroy_component(frequencytable);
			destroy_component(reportlayout);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$s.name,
		type: "if",
		source: "(214:8) {#if graphPlotted}",
		ctx
	});

	return block;
}

// (194:4) <div class="plotSlot" slot="plotContainer">
function create_plotContainer_slot(ctx) {
	let div0;
	let getfileinfotable;
	let t0;
	let div8;
	let div1;
	let t1;
	let div2;
	let t2;
	let div3;
	let t3;
	let div4;
	let t4;
	let div5;
	let t5;
	let div6;
	let t6;
	let div7;
	let t7;
	let current;

	getfileinfotable = new GetFileInfoTable({
			props: {
				felixfiles: /*felixfiles*/ ctx[8],
				normMethod: /*$normMethod*/ ctx[25]
			},
			$$inline: true
		});

	let if_block = /*graphPlotted*/ ctx[13] && create_if_block$s(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(getfileinfotable.$$.fragment);
			t0 = space();
			div8 = element("div");
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			t2 = space();
			div3 = element("div");
			t3 = space();
			div4 = element("div");
			t4 = space();
			div5 = element("div");
			t5 = space();
			div6 = element("div");
			t6 = space();
			div7 = element("div");
			t7 = space();
			if (if_block) if_block.c();
			attr_dev(div1, "class", "animated fadeIn svelte-1soq9o5");
			attr_dev(div1, "id", "exp-theory-plot");
			toggle_class(div1, "hide", !/*show_theoryplot*/ ctx[12]);
			add_location(div1, file$1a, 201, 12, 7899);
			attr_dev(div2, "id", "bplot");
			attr_dev(div2, "class", "svelte-1soq9o5");
			add_location(div2, file$1a, 202, 12, 7999);
			attr_dev(div3, "id", "saPlot");
			attr_dev(div3, "class", "svelte-1soq9o5");
			add_location(div3, file$1a, 203, 12, 8035);
			attr_dev(div4, "id", "avgplot");
			attr_dev(div4, "class", "svelte-1soq9o5");
			add_location(div4, file$1a, 204, 12, 8072);
			attr_dev(div5, "class", "animated fadeIn svelte-1soq9o5");
			attr_dev(div5, "id", "opoplot");
			toggle_class(div5, "hide", !/*$opoMode*/ ctx[9]);
			add_location(div5, file$1a, 206, 12, 8116);
			attr_dev(div6, "class", "animated fadeIn svelte-1soq9o5");
			attr_dev(div6, "id", "opoSA");
			toggle_class(div6, "hide", !/*$opoMode*/ ctx[9]);
			add_location(div6, file$1a, 208, 12, 8207);
			attr_dev(div7, "class", "animated fadeIn svelte-1soq9o5");
			attr_dev(div7, "id", "opoRelPlot");
			toggle_class(div7, "hide", !/*$opoMode*/ ctx[9]);
			add_location(div7, file$1a, 209, 12, 8290);
			attr_dev(div8, "class", "felixPlot svelte-1soq9o5");
			add_location(div8, file$1a, 200, 8, 7862);
			attr_dev(div0, "class", "plotSlot svelte-1soq9o5");
			attr_dev(div0, "slot", "plotContainer");
			add_location(div0, file$1a, 193, 4, 7647);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(getfileinfotable, div0, null);
			append_dev(div0, t0);
			append_dev(div0, div8);
			append_dev(div8, div1);
			append_dev(div8, t1);
			append_dev(div8, div2);
			append_dev(div8, t2);
			append_dev(div8, div3);
			append_dev(div8, t3);
			append_dev(div8, div4);
			append_dev(div8, t4);
			append_dev(div8, div5);
			append_dev(div8, t5);
			append_dev(div8, div6);
			append_dev(div8, t6);
			append_dev(div8, div7);
			append_dev(div0, t7);
			if (if_block) if_block.m(div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const getfileinfotable_changes = {};
			if (dirty[0] & /*felixfiles*/ 256) getfileinfotable_changes.felixfiles = /*felixfiles*/ ctx[8];
			if (dirty[0] & /*$normMethod*/ 33554432) getfileinfotable_changes.normMethod = /*$normMethod*/ ctx[25];
			getfileinfotable.$set(getfileinfotable_changes);

			if (dirty[0] & /*show_theoryplot*/ 4096) {
				toggle_class(div1, "hide", !/*show_theoryplot*/ ctx[12]);
			}

			if (dirty[0] & /*$opoMode*/ 512) {
				toggle_class(div5, "hide", !/*$opoMode*/ ctx[9]);
			}

			if (dirty[0] & /*$opoMode*/ 512) {
				toggle_class(div6, "hide", !/*$opoMode*/ ctx[9]);
			}

			if (dirty[0] & /*$opoMode*/ 512) {
				toggle_class(div7, "hide", !/*$opoMode*/ ctx[9]);
			}

			if (/*graphPlotted*/ ctx[13]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*graphPlotted*/ 8192) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$s(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(getfileinfotable.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(getfileinfotable.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(getfileinfotable);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_plotContainer_slot.name,
		type: "slot",
		source: "(194:4) <div class=\\\"plotSlot\\\" slot=\\\"plotContainer\\\">",
		ctx
	});

	return block;
}

// (178:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked bind:toggleBrowser on:tour={init_tour}>
function create_default_slot$u(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$u.name,
		type: "slot",
		source: "(178:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked bind:toggleBrowser on:tour={init_tour}>",
		ctx
	});

	return block;
}

function create_fragment$1h(ctx) {
	let addfilestoplot;
	let updating_extrafileAdded;
	let updating_active;
	let updating_addedFileCol;
	let updating_addedFileScale;
	let updating_addedfiles;
	let updating_addedFile;
	let updating_preModal;
	let t;
	let layout;
	let updating_preModal_1;
	let updating_currentLocation;
	let updating_fileChecked;
	let updating_toggleBrowser;
	let current;

	function addfilestoplot_extrafileAdded_binding(value) {
		/*addfilestoplot_extrafileAdded_binding*/ ctx[38].call(null, value);
	}

	function addfilestoplot_active_binding(value) {
		/*addfilestoplot_active_binding*/ ctx[39].call(null, value);
	}

	function addfilestoplot_addedFileCol_binding(value) {
		/*addfilestoplot_addedFileCol_binding*/ ctx[40].call(null, value);
	}

	function addfilestoplot_addedFileScale_binding(value) {
		/*addfilestoplot_addedFileScale_binding*/ ctx[41].call(null, value);
	}

	function addfilestoplot_addedfiles_binding(value) {
		/*addfilestoplot_addedfiles_binding*/ ctx[42].call(null, value);
	}

	function addfilestoplot_addedFile_binding(value) {
		/*addfilestoplot_addedFile_binding*/ ctx[43].call(null, value);
	}

	function addfilestoplot_preModal_binding(value) {
		/*addfilestoplot_preModal_binding*/ ctx[44].call(null, value);
	}

	let addfilestoplot_props = { fileChecked: /*fileChecked*/ ctx[0] };

	if (/*extrafileAdded*/ ctx[7] !== void 0) {
		addfilestoplot_props.extrafileAdded = /*extrafileAdded*/ ctx[7];
	}

	if (/*addFileModal*/ ctx[18] !== void 0) {
		addfilestoplot_props.active = /*addFileModal*/ ctx[18];
	}

	if (/*addedFileCol*/ ctx[19] !== void 0) {
		addfilestoplot_props.addedFileCol = /*addedFileCol*/ ctx[19];
	}

	if (/*addedFileScale*/ ctx[21] !== void 0) {
		addfilestoplot_props.addedFileScale = /*addedFileScale*/ ctx[21];
	}

	if (/*addedfiles*/ ctx[6] !== void 0) {
		addfilestoplot_props.addedfiles = /*addedfiles*/ ctx[6];
	}

	if (/*addedFile*/ ctx[20] !== void 0) {
		addfilestoplot_props.addedFile = /*addedFile*/ ctx[20];
	}

	if (/*preModal*/ ctx[23] !== void 0) {
		addfilestoplot_props.preModal = /*preModal*/ ctx[23];
	}

	addfilestoplot = new AddFilesToPlot({
			props: addfilestoplot_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(addfilestoplot, "extrafileAdded", addfilestoplot_extrafileAdded_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "active", addfilestoplot_active_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "addedFileCol", addfilestoplot_addedFileCol_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "addedFileScale", addfilestoplot_addedFileScale_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "addedfiles", addfilestoplot_addedfiles_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "addedFile", addfilestoplot_addedFile_binding));
	binding_callbacks.push(() => bind(addfilestoplot, "preModal", addfilestoplot_preModal_binding));

	function layout_preModal_binding(value) {
		/*layout_preModal_binding*/ ctx[64].call(null, value);
	}

	function layout_currentLocation_binding(value) {
		/*layout_currentLocation_binding*/ ctx[65].call(null, value);
	}

	function layout_fileChecked_binding(value) {
		/*layout_fileChecked_binding*/ ctx[66].call(null, value);
	}

	function layout_toggleBrowser_binding(value) {
		/*layout_toggleBrowser_binding*/ ctx[67].call(null, value);
	}

	let layout_props = {
		filetype,
		id,
		$$slots: {
			default: [create_default_slot$u],
			plotContainer: [create_plotContainer_slot],
			buttonContainer: [create_buttonContainer_slot]
		},
		$$scope: { ctx }
	};

	if (/*preModal*/ ctx[23] !== void 0) {
		layout_props.preModal = /*preModal*/ ctx[23];
	}

	if (/*currentLocation*/ ctx[1] !== void 0) {
		layout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	if (/*fileChecked*/ ctx[0] !== void 0) {
		layout_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	if (/*toggleBrowser*/ ctx[11] !== void 0) {
		layout_props.toggleBrowser = /*toggleBrowser*/ ctx[11];
	}

	layout = new Layout({ props: layout_props, $$inline: true });
	binding_callbacks.push(() => bind(layout, "preModal", layout_preModal_binding));
	binding_callbacks.push(() => bind(layout, "currentLocation", layout_currentLocation_binding));
	binding_callbacks.push(() => bind(layout, "fileChecked", layout_fileChecked_binding));
	binding_callbacks.push(() => bind(layout, "toggleBrowser", layout_toggleBrowser_binding));
	layout.$on("tour", /*init_tour*/ ctx[28]);

	const block = {
		c: function create() {
			create_component(addfilestoplot.$$.fragment);
			t = space();
			create_component(layout.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(addfilestoplot, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(layout, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const addfilestoplot_changes = {};
			if (dirty[0] & /*fileChecked*/ 1) addfilestoplot_changes.fileChecked = /*fileChecked*/ ctx[0];

			if (!updating_extrafileAdded && dirty[0] & /*extrafileAdded*/ 128) {
				updating_extrafileAdded = true;
				addfilestoplot_changes.extrafileAdded = /*extrafileAdded*/ ctx[7];
				add_flush_callback(() => updating_extrafileAdded = false);
			}

			if (!updating_active && dirty[0] & /*addFileModal*/ 262144) {
				updating_active = true;
				addfilestoplot_changes.active = /*addFileModal*/ ctx[18];
				add_flush_callback(() => updating_active = false);
			}

			if (!updating_addedFileCol && dirty[0] & /*addedFileCol*/ 524288) {
				updating_addedFileCol = true;
				addfilestoplot_changes.addedFileCol = /*addedFileCol*/ ctx[19];
				add_flush_callback(() => updating_addedFileCol = false);
			}

			if (!updating_addedFileScale && dirty[0] & /*addedFileScale*/ 2097152) {
				updating_addedFileScale = true;
				addfilestoplot_changes.addedFileScale = /*addedFileScale*/ ctx[21];
				add_flush_callback(() => updating_addedFileScale = false);
			}

			if (!updating_addedfiles && dirty[0] & /*addedfiles*/ 64) {
				updating_addedfiles = true;
				addfilestoplot_changes.addedfiles = /*addedfiles*/ ctx[6];
				add_flush_callback(() => updating_addedfiles = false);
			}

			if (!updating_addedFile && dirty[0] & /*addedFile*/ 1048576) {
				updating_addedFile = true;
				addfilestoplot_changes.addedFile = /*addedFile*/ ctx[20];
				add_flush_callback(() => updating_addedFile = false);
			}

			if (!updating_preModal && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal = true;
				addfilestoplot_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal = false);
			}

			addfilestoplot.$set(addfilestoplot_changes);
			const layout_changes = {};

			if (dirty[0] & /*currentLocation, keepTable, addedFileScale, addedFileCol, $normMethod, writeFileName, writeFile, overwrite_expfit, fullfiles, preModal, output_namelists, addFileModal, graphPlotted, $opoMode, show_theoryplot, felixfiles, theoryLocation, OPOLocation, OPOfilesChecked, opofiles, felixPlotCheckboxes*/ 66058046 | dirty[2] & /*$$scope*/ 4096) {
				layout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_preModal_1 && dirty[0] & /*preModal*/ 8388608) {
				updating_preModal_1 = true;
				layout_changes.preModal = /*preModal*/ ctx[23];
				add_flush_callback(() => updating_preModal_1 = false);
			}

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			if (!updating_toggleBrowser && dirty[0] & /*toggleBrowser*/ 2048) {
				updating_toggleBrowser = true;
				layout_changes.toggleBrowser = /*toggleBrowser*/ ctx[11];
				add_flush_callback(() => updating_toggleBrowser = false);
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(addfilestoplot.$$.fragment, local);
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(addfilestoplot.$$.fragment, local);
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(addfilestoplot, detaching);
			if (detaching) detach_dev(t);
			destroy_component(layout, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const filetype = "felix", id = "Normline";

function instance$1h($$self, $$props, $$invalidate) {
	let felixfiles;
	let plottedFiles;
	let output_namelists;
	let datlocation;
	let datfiles;
	let calcfiles;
	let felixPlotCheckboxes;
	let $fittedTraceCount;
	let $opoMode;
	let $normMethodDatas;
	let $normMethod;
	let $graphDiv;
	let $expfittedLines;
	let $felixPlotAnnotations;
	let $expfittedLinesCollectedData;
	let $felixopoLocation;
	let $Ngauss_sigma;
	validate_store(fittedTraceCount, "fittedTraceCount");
	component_subscribe($$self, fittedTraceCount, $$value => $$invalidate(31, $fittedTraceCount = $$value));
	validate_store(opoMode, "opoMode");
	component_subscribe($$self, opoMode, $$value => $$invalidate(9, $opoMode = $$value));
	validate_store(normMethodDatas, "normMethodDatas");
	component_subscribe($$self, normMethodDatas, $$value => $$invalidate(68, $normMethodDatas = $$value));
	validate_store(normMethod, "normMethod");
	component_subscribe($$self, normMethod, $$value => $$invalidate(25, $normMethod = $$value));
	validate_store(graphDiv, "graphDiv");
	component_subscribe($$self, graphDiv, $$value => $$invalidate(33, $graphDiv = $$value));
	validate_store(expfittedLines, "expfittedLines");
	component_subscribe($$self, expfittedLines, $$value => $$invalidate(69, $expfittedLines = $$value));
	validate_store(felixPlotAnnotations, "felixPlotAnnotations");
	component_subscribe($$self, felixPlotAnnotations, $$value => $$invalidate(70, $felixPlotAnnotations = $$value));
	validate_store(expfittedLinesCollectedData, "expfittedLinesCollectedData");
	component_subscribe($$self, expfittedLinesCollectedData, $$value => $$invalidate(71, $expfittedLinesCollectedData = $$value));
	validate_store(felixopoLocation, "felixopoLocation");
	component_subscribe($$self, felixopoLocation, $$value => $$invalidate(34, $felixopoLocation = $$value));
	validate_store(Ngauss_sigma, "Ngauss_sigma");
	component_subscribe($$self, Ngauss_sigma, $$value => $$invalidate(72, $Ngauss_sigma = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Normline", slots, []);
	let fileChecked = [], toggleBrowser = false;
	let currentLocation = localStorage[`${filetype}_location`] || "";

	///////////////////////////////////////////////////////////////////////
	// Theory file
	let show_theoryplot = false;

	let theoryLocation = localStorage["theoryLocation"] || currentLocation;

	///////////////////////////////////////////////////////////////////////
	let openShell = false;

	// let felix_normMethod = "Relative";
	let graphPlotted = false, overwrite_expfit = false, writeFile = false;

	let OPOfilesChecked = [];
	let writeFileName = "";
	let keepTable = true;

	//////// OPO Plot ///////////
	window.getID = () => Math.random().toString(32).substring(2);

	const replot = () => {
		if (graphPlotted) {
			let { data, layout } = $normMethodDatas[$normMethod];

			try {
				Plotly.react($graphDiv, data, layout, { editable: true });
				(set_store_value(expfittedLines, $expfittedLines = set_store_value(felixPlotAnnotations, $felixPlotAnnotations = set_store_value(expfittedLinesCollectedData, $expfittedLinesCollectedData = [], $expfittedLinesCollectedData), $felixPlotAnnotations), $expfittedLines), set_store_value(fittedTraceCount, $fittedTraceCount = 0, $fittedTraceCount));
			} catch(err) {
				
			}
		}
	};

	// OPO
	let OPOLocation = localStorage["opoLocation"] || currentLocation;

	let opofiles = [];

	let addFileModal = false,
		addedFileCol = "0, 1",
		addedFile = {},
		addedFileScale = 1,
		addedfiles = [],
		extrafileAdded = 0;

	function removeExtraFile() {
		for (let i = 0; i < extrafileAdded; i++) {
			try {
				Plotly.deleteTraces($graphDiv, [-1]);
				($$invalidate(7, extrafileAdded = 0), $$invalidate(6, addedfiles = []));
			} catch(err) {
				console.log("The plot is empty");
			}
		}
	} // window.createToast("Files removed", "warning")

	let fullfiles = [];

	const init_tour = async () => {
		if (!toggleBrowser) {
			$$invalidate(11, toggleBrowser = true);
			await sleep(600);
		} // Filebrowser toggling and its animation time to appear

		await tick(); // For all the reactive components to render
		init_tour_normline({ filetype });
	};

	const includePlotsInReport = [
		{
			id: "bplot",
			include: true,
			label: "Baseline"
		},
		{
			id: "saPlot",
			include: false,
			label: "SA-Pow"
		},
		{
			id: "avgplot",
			include: false,
			label: "Normalised Spectrum"
		},
		{
			id: "exp-theory-plot",
			include: false,
			label: "Exp-Theory plot"
		},
		{
			id: "opoplot",
			include: false,
			label: "OPO: Baseline"
		},
		{
			id: "opoSA",
			include: false,
			label: "OPO: SA-pow"
		},
		{
			id: "opoRelPlot",
			include: false,
			label: "OPO: Normalised Spectrum"
		}
	];

	const includeTablesInReports = [
		{
			id: "felixTable",
			include: true,
			label: "Freq. table"
		},
		{
			id: "felix_filedetails_table",
			include: false,
			label: "File info table"
		}
	];

	let preModal = {};

	onMount(() => {
		console.log("Normline mounted");
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<Normline> was created with unknown prop '${key}'`);
	});

	function addfilestoplot_extrafileAdded_binding(value) {
		extrafileAdded = value;
		$$invalidate(7, extrafileAdded);
	}

	function addfilestoplot_active_binding(value) {
		addFileModal = value;
		$$invalidate(18, addFileModal);
	}

	function addfilestoplot_addedFileCol_binding(value) {
		addedFileCol = value;
		$$invalidate(19, addedFileCol);
	}

	function addfilestoplot_addedFileScale_binding(value) {
		addedFileScale = value;
		$$invalidate(21, addedFileScale);
	}

	function addfilestoplot_addedfiles_binding(value) {
		addedfiles = value;
		$$invalidate(6, addedfiles);
	}

	function addfilestoplot_addedFile_binding(value) {
		addedFile = value;
		$$invalidate(20, addedFile);
	}

	function addfilestoplot_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function initfunctionrow_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function initfunctionrow_graphPlotted_binding(value) {
		graphPlotted = value;
		$$invalidate(13, graphPlotted);
	}

	function initfunctionrow_show_theoryplot_binding(value) {
		show_theoryplot = value;
		$$invalidate(12, show_theoryplot);
	}

	function oporow_OPOLocation_binding(value) {
		OPOLocation = value;
		$$invalidate(4, OPOLocation);
	}

	function oporow_OPOfilesChecked_binding(value) {
		OPOfilesChecked = value;
		$$invalidate(3, OPOfilesChecked);
	}

	function oporow_opofiles_binding(value) {
		opofiles = value;
		$$invalidate(5, opofiles);
	}

	function oporow_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function oporow_graphPlotted_binding(value) {
		graphPlotted = value;
		$$invalidate(13, graphPlotted);
	}

	function theoryrow_theoryLocation_binding(value) {
		theoryLocation = value;
		$$invalidate(2, theoryLocation);
	}

	function theoryrow_show_theoryplot_binding(value) {
		show_theoryplot = value;
		$$invalidate(12, show_theoryplot);
	}

	function theoryrow_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function customradio_selected_binding(value) {
		$normMethod = value;
		normMethod.set($normMethod);
	}

	function writefunctioncontents_writeFileName_binding(value) {
		writeFileName = value;
		$$invalidate(16, writeFileName);
	}

	function writefunctioncontents_writeFile_binding(value) {
		writeFile = value;
		$$invalidate(15, writeFile);
	}

	function writefunctioncontents_overwrite_expfit_binding(value) {
		overwrite_expfit = value;
		$$invalidate(14, overwrite_expfit);
	}

	const addfile_handler = () => {
		$$invalidate(18, addFileModal = true);
	};

	function executefunctioncontents_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function frequencytable_keepTable_binding(value) {
		keepTable = value;
		$$invalidate(17, keepTable);
	}

	function reportlayout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_preModal_binding(value) {
		preModal = value;
		$$invalidate(23, preModal);
	}

	function layout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	function layout_toggleBrowser_binding(value) {
		toggleBrowser = value;
		$$invalidate(11, toggleBrowser);
	}

	$$self.$capture_state = () => ({
		opoMode,
		normMethodDatas,
		Ngauss_sigma,
		felixopoLocation,
		felixPlotAnnotations,
		expfittedLines,
		expfittedLinesCollectedData,
		fittedTraceCount,
		graphDiv,
		normMethod,
		Layout,
		fade,
		CustomRadio,
		ReportLayout,
		onMount,
		tick,
		AddFilesToPlot,
		FrequencyTable,
		InitFunctionRow,
		OPORow,
		TheoryRow,
		GetFileInfoTable,
		WriteFunctionContents,
		ExecuteFunctionContents,
		init_tour_normline,
		filetype,
		id,
		fileChecked,
		toggleBrowser,
		currentLocation,
		show_theoryplot,
		theoryLocation,
		openShell,
		graphPlotted,
		overwrite_expfit,
		writeFile,
		OPOfilesChecked,
		writeFileName,
		keepTable,
		replot,
		OPOLocation,
		opofiles,
		addFileModal,
		addedFileCol,
		addedFile,
		addedFileScale,
		addedfiles,
		extrafileAdded,
		removeExtraFile,
		fullfiles,
		init_tour,
		includePlotsInReport,
		includeTablesInReports,
		preModal,
		felixfiles,
		$fittedTraceCount,
		plottedFiles,
		$opoMode,
		output_namelists,
		$normMethodDatas,
		$normMethod,
		$graphDiv,
		$expfittedLines,
		$felixPlotAnnotations,
		$expfittedLinesCollectedData,
		$felixopoLocation,
		$Ngauss_sigma,
		calcfiles,
		felixPlotCheckboxes,
		datlocation,
		datfiles
	});

	$$self.$inject_state = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("toggleBrowser" in $$props) $$invalidate(11, toggleBrowser = $$props.toggleBrowser);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("show_theoryplot" in $$props) $$invalidate(12, show_theoryplot = $$props.show_theoryplot);
		if ("theoryLocation" in $$props) $$invalidate(2, theoryLocation = $$props.theoryLocation);
		if ("openShell" in $$props) $$invalidate(73, openShell = $$props.openShell);
		if ("graphPlotted" in $$props) $$invalidate(13, graphPlotted = $$props.graphPlotted);
		if ("overwrite_expfit" in $$props) $$invalidate(14, overwrite_expfit = $$props.overwrite_expfit);
		if ("writeFile" in $$props) $$invalidate(15, writeFile = $$props.writeFile);
		if ("OPOfilesChecked" in $$props) $$invalidate(3, OPOfilesChecked = $$props.OPOfilesChecked);
		if ("writeFileName" in $$props) $$invalidate(16, writeFileName = $$props.writeFileName);
		if ("keepTable" in $$props) $$invalidate(17, keepTable = $$props.keepTable);
		if ("OPOLocation" in $$props) $$invalidate(4, OPOLocation = $$props.OPOLocation);
		if ("opofiles" in $$props) $$invalidate(5, opofiles = $$props.opofiles);
		if ("addFileModal" in $$props) $$invalidate(18, addFileModal = $$props.addFileModal);
		if ("addedFileCol" in $$props) $$invalidate(19, addedFileCol = $$props.addedFileCol);
		if ("addedFile" in $$props) $$invalidate(20, addedFile = $$props.addedFile);
		if ("addedFileScale" in $$props) $$invalidate(21, addedFileScale = $$props.addedFileScale);
		if ("addedfiles" in $$props) $$invalidate(6, addedfiles = $$props.addedfiles);
		if ("extrafileAdded" in $$props) $$invalidate(7, extrafileAdded = $$props.extrafileAdded);
		if ("fullfiles" in $$props) $$invalidate(22, fullfiles = $$props.fullfiles);
		if ("preModal" in $$props) $$invalidate(23, preModal = $$props.preModal);
		if ("felixfiles" in $$props) $$invalidate(8, felixfiles = $$props.felixfiles);
		if ("plottedFiles" in $$props) $$invalidate(32, plottedFiles = $$props.plottedFiles);
		if ("output_namelists" in $$props) $$invalidate(24, output_namelists = $$props.output_namelists);
		if ("calcfiles" in $$props) $$invalidate(35, calcfiles = $$props.calcfiles);
		if ("felixPlotCheckboxes" in $$props) $$invalidate(10, felixPlotCheckboxes = $$props.felixPlotCheckboxes);
		if ("datlocation" in $$props) $$invalidate(36, datlocation = $$props.datlocation);
		if ("datfiles" in $$props) $$invalidate(37, datfiles = $$props.datfiles);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*fileChecked, currentLocation*/ 3) {
			 $$invalidate(8, felixfiles = fileChecked.map(file => path.resolve(currentLocation, file)));
		}

		if ($$self.$$.dirty[0] & /*currentLocation*/ 2) {
			 console.log(`${filetype} currentlocation: \n${currentLocation}`);
		}

		if ($$self.$$.dirty[1] & /*$fittedTraceCount*/ 1) {
			 console.log("Trace length: ", $fittedTraceCount);
		}

		if ($$self.$$.dirty[0] & /*$opoMode, OPOfilesChecked, fileChecked*/ 521) {
			 $$invalidate(32, plottedFiles = $opoMode
			? OPOfilesChecked.map(file => file.split(".")[0]) || []
			: fileChecked.map(file => file.split(".")[0]) || []);
		}

		if ($$self.$$.dirty[0] & /*addedfiles*/ 64 | $$self.$$.dirty[1] & /*plottedFiles*/ 2) {
			 $$invalidate(24, output_namelists = [
				"averaged",
				...plottedFiles,
				...addedfiles.map(file => path.basename(file)).map(file => file.split(".")[0])
			]);
		}

		if ($$self.$$.dirty[0] & /*$opoMode, OPOLocation, currentLocation*/ 530) {
			// $: $normMethod = $opoMode ? "Log" : felix_normMethod
			 set_store_value(felixopoLocation, $felixopoLocation = $opoMode ? OPOLocation : currentLocation, $felixopoLocation);
		}

		if ($$self.$$.dirty[0] & /*$opoMode*/ 512) {
			 $opoMode
			? window.createToast("OPO MODE", "warning")
			: window.createToast("FELIX MODE");
		}

		if ($$self.$$.dirty[0] & /*$opoMode*/ 512) {
			 set_store_value(Ngauss_sigma, $Ngauss_sigma = $opoMode ? 2 : 5, $Ngauss_sigma);
		}

		if ($$self.$$.dirty[0] & /*extrafileAdded*/ 128) {
			 console.log(`Extrafile added: ${extrafileAdded}`);
		}

		if ($$self.$$.dirty[0] & /*$opoMode, opofiles, addedfiles, currentLocation, felixfiles*/ 866) {
			 $opoMode
			? $$invalidate(22, fullfiles = [
					...opofiles,
					...addedfiles,
					path.resolve(currentLocation, "averaged.felix")
				])
			: $$invalidate(22, fullfiles = [
					...felixfiles,
					...addedfiles,
					path.resolve(currentLocation, "averaged.felix")
				]);
		}

		if ($$self.$$.dirty[0] & /*theoryLocation*/ 4) {
			 $$invalidate(35, calcfiles = fs.existsSync(theoryLocation)
			? fs.readdirSync(theoryLocation).map(f => f = { name: f, id: getID() })
			: [{ name: "", id: getID() }]);
		}

		if ($$self.$$.dirty[1] & /*$felixopoLocation*/ 8) {
			 $$invalidate(36, datlocation = path.resolve($felixopoLocation, "../EXPORT"));
		}

		if ($$self.$$.dirty[1] & /*datlocation*/ 32) {
			 $$invalidate(37, datfiles = fs.existsSync(datlocation)
			? fs.readdirSync(datlocation).filter(f => f.endsWith(".dat")).map(f => f = { name: f, id: getID() })
			: [{ name: "", id: getID() }]);
		}

		if ($$self.$$.dirty[1] & /*datfiles, calcfiles*/ 80) {
			 $$invalidate(10, felixPlotCheckboxes = [
				{
					label: "DAT file",
					options: datfiles,
					selected: [],
					style: "width:100%;",
					id: getID()
				},
				{
					label: "Fundamentals",
					options: calcfiles,
					selected: [],
					style: "width:25%; margin-left:1em;",
					id: getID()
				},
				{
					label: "Overtones",
					options: calcfiles,
					selected: [],
					style: "width:25%; margin-left:1em;",
					id: getID()
				},
				{
					label: "Combinations",
					options: calcfiles,
					selected: [],
					style: "width:25%; margin-left:1em;",
					id: getID()
				}
			]);
		}

		if ($$self.$$.dirty[0] & /*theoryLocation, felixPlotCheckboxes*/ 1028 | $$self.$$.dirty[1] & /*calcfiles*/ 16) {
			 console.log(theoryLocation, calcfiles, felixPlotCheckboxes);
		}

		if ($$self.$$.dirty[0] & /*$opoMode*/ 512) {
			 console.log(`$opoMode: ${$opoMode}`);
		}

		if ($$self.$$.dirty[1] & /*$graphDiv*/ 4) {
			 console.log(`graphDiv: ${$graphDiv}`);
		}
	};

	 console.log("Open Shell: ", filetype, openShell);

	return [
		fileChecked,
		currentLocation,
		theoryLocation,
		OPOfilesChecked,
		OPOLocation,
		opofiles,
		addedfiles,
		extrafileAdded,
		felixfiles,
		$opoMode,
		felixPlotCheckboxes,
		toggleBrowser,
		show_theoryplot,
		graphPlotted,
		overwrite_expfit,
		writeFile,
		writeFileName,
		keepTable,
		addFileModal,
		addedFileCol,
		addedFile,
		addedFileScale,
		fullfiles,
		preModal,
		output_namelists,
		$normMethod,
		replot,
		removeExtraFile,
		init_tour,
		includePlotsInReport,
		includeTablesInReports,
		$fittedTraceCount,
		plottedFiles,
		$graphDiv,
		$felixopoLocation,
		calcfiles,
		datlocation,
		datfiles,
		addfilestoplot_extrafileAdded_binding,
		addfilestoplot_active_binding,
		addfilestoplot_addedFileCol_binding,
		addfilestoplot_addedFileScale_binding,
		addfilestoplot_addedfiles_binding,
		addfilestoplot_addedFile_binding,
		addfilestoplot_preModal_binding,
		initfunctionrow_preModal_binding,
		initfunctionrow_graphPlotted_binding,
		initfunctionrow_show_theoryplot_binding,
		oporow_OPOLocation_binding,
		oporow_OPOfilesChecked_binding,
		oporow_opofiles_binding,
		oporow_preModal_binding,
		oporow_graphPlotted_binding,
		theoryrow_theoryLocation_binding,
		theoryrow_show_theoryplot_binding,
		theoryrow_preModal_binding,
		customradio_selected_binding,
		writefunctioncontents_writeFileName_binding,
		writefunctioncontents_writeFile_binding,
		writefunctioncontents_overwrite_expfit_binding,
		addfile_handler,
		executefunctioncontents_preModal_binding,
		frequencytable_keepTable_binding,
		reportlayout_currentLocation_binding,
		layout_preModal_binding,
		layout_currentLocation_binding,
		layout_fileChecked_binding,
		layout_toggleBrowser_binding
	];
}

class Normline extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {}, [-1, -1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Normline",
			options,
			id: create_fragment$1h.name
		});
	}
}

/* src\components\GetLabviewSettings.svelte generated by Svelte v3.31.2 */

const { console: console_1$b } = globals;
const file$1b = "src\\components\\GetLabviewSettings.svelte";

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_2$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_3$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_4$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

// (85:0) {#if active}
function create_if_block$t(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[14].call(null, value);
	}

	let modal_props = {
		title: "Labview Settings",
		$$slots: { content: [create_content_slot$5] },
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, variableValues, settingsLoaded, fullfileslist, selected_file*/ 8388638) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$t.name,
		type: "if",
		source: "(85:0) {#if active}",
		ctx
	});

	return block;
}

// (93:12) {#if settingsLoaded}
function create_if_block_1$a(ctx) {
	let div10;
	let div0;
	let each_blocks_4 = [];
	let each0_lookup = new Map();
	let t0;
	let div1;
	let textfield0;
	let t1;
	let textfield1;
	let t2;
	let div2;
	let each_blocks_3 = [];
	let each1_lookup = new Map();
	let t3;
	let div3;
	let textfield2;
	let t4;
	let div4;
	let each_blocks_2 = [];
	let each2_lookup = new Map();
	let t5;
	let div5;
	let textfield3;
	let t6;
	let div6;
	let each_blocks_1 = [];
	let each3_lookup = new Map();
	let t7;
	let div7;
	let textfield4;
	let t8;
	let div8;
	let each_blocks = [];
	let each4_lookup = new Map();
	let t9;
	let div9;
	let textfield5;
	let t10;
	let textfield6;
	let t11;
	let textfield7;
	let current;
	let each_value_4 = /*settingsVariable*/ ctx[5].b0;
	validate_each_argument(each_value_4);
	const get_key = ctx => /*item*/ ctx[16];
	validate_each_keys(ctx, each_value_4, get_each_context_4$1, get_key);

	for (let i = 0; i < each_value_4.length; i += 1) {
		let child_ctx = get_each_context_4$1(ctx, each_value_4, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_4[i] = create_each_block_4$1(key, child_ctx));
	}

	textfield0 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].q1float],
				label: "Quad 1 float"
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bq0],
				label: "bq0"
			},
			$$inline: true
		});

	let each_value_3 = /*settingsVariable*/ ctx[5].bqLenses;
	validate_each_argument(each_value_3);
	const get_key_1 = ctx => /*item*/ ctx[16];
	validate_each_keys(ctx, each_value_3, get_each_context_3$3, get_key_1);

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3$3(ctx, each_value_3, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_3[i] = create_each_block_3$3(key, child_ctx));
	}

	textfield2 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bq5],
				label: "bq5"
			},
			$$inline: true
		});

	let each_value_2 = /*settingsVariable*/ ctx[5].benderLenses;
	validate_each_argument(each_value_2);
	const get_key_2 = ctx => /*item*/ ctx[16];
	validate_each_keys(ctx, each_value_2, get_each_context_2$4, get_key_2);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$4(ctx, each_value_2, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks_2[i] = create_each_block_2$4(key, child_ctx));
	}

	textfield3 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bl4],
				label: "bl4"
			},
			$$inline: true
		});

	let each_value_1 = /*settingsVariable*/ ctx[5].se;
	validate_each_argument(each_value_1);
	const get_key_3 = ctx => /*item*/ ctx[16];
	validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key_3);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
		let key = get_key_3(child_ctx);
		each3_lookup.set(key, each_blocks_1[i] = create_each_block_1$4(key, child_ctx));
	}

	textfield4 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].trapfloat],
				label: "trapfloat"
			},
			$$inline: true
		});

	let each_value = /*settingsVariable*/ ctx[5].sa;
	validate_each_argument(each_value);
	const get_key_4 = ctx => /*item*/ ctx[16];
	validate_each_keys(ctx, each_value, get_each_context$a, get_key_4);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$a(ctx, each_value, i);
		let key = get_key_4(child_ctx);
		each4_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
	}

	textfield5 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bl5],
				label: "bl5"
			},
			$$inline: true
		});

	textfield6 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].res],
				label: "Resolution"
			},
			$$inline: true
		});

	textfield7 = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].q2float],
				label: "Quad 2 float"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div10 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			t0 = space();
			div1 = element("div");
			create_component(textfield0.$$.fragment);
			t1 = space();
			create_component(textfield1.$$.fragment);
			t2 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t3 = space();
			div3 = element("div");
			create_component(textfield2.$$.fragment);
			t4 = space();
			div4 = element("div");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t5 = space();
			div5 = element("div");
			create_component(textfield3.$$.fragment);
			t6 = space();
			div6 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t7 = space();
			div7 = element("div");
			create_component(textfield4.$$.fragment);
			t8 = space();
			div8 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t9 = space();
			div9 = element("div");
			create_component(textfield5.$$.fragment);
			t10 = space();
			create_component(textfield6.$$.fragment);
			t11 = space();
			create_component(textfield7.$$.fragment);
			attr_dev(div0, "class", "b0 col svelte-1w4z4ma");
			add_location(div0, file$1b, 94, 20, 3048);
			attr_dev(div1, "class", "row svelte-1w4z4ma");
			add_location(div1, file$1b, 103, 20, 3428);
			attr_dev(div2, "class", "bqLenses col svelte-1w4z4ma");
			add_location(div2, file$1b, 107, 20, 3716);
			attr_dev(div3, "class", "row svelte-1w4z4ma");
			add_location(div3, file$1b, 113, 20, 4031);
			attr_dev(div4, "class", "benderLenses col svelte-1w4z4ma");
			add_location(div4, file$1b, 114, 20, 4154);
			attr_dev(div5, "class", "row svelte-1w4z4ma");
			add_location(div5, file$1b, 122, 20, 4489);
			attr_dev(div6, "class", "se row svelte-1w4z4ma");
			add_location(div6, file$1b, 125, 20, 4660);
			attr_dev(div7, "class", "row svelte-1w4z4ma");
			add_location(div7, file$1b, 133, 20, 4990);
			attr_dev(div8, "class", "sa row svelte-1w4z4ma");
			add_location(div8, file$1b, 135, 20, 5127);
			attr_dev(div9, "class", "row svelte-1w4z4ma");
			add_location(div9, file$1b, 142, 20, 5415);
			attr_dev(div10, "class", "container svelte-1w4z4ma");
			add_location(div10, file$1b, 93, 16, 3003);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div10, anchor);
			append_dev(div10, div0);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].m(div0, null);
			}

			append_dev(div10, t0);
			append_dev(div10, div1);
			mount_component(textfield0, div1, null);
			append_dev(div1, t1);
			mount_component(textfield1, div1, null);
			append_dev(div10, t2);
			append_dev(div10, div2);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(div2, null);
			}

			append_dev(div10, t3);
			append_dev(div10, div3);
			mount_component(textfield2, div3, null);
			append_dev(div10, t4);
			append_dev(div10, div4);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div4, null);
			}

			append_dev(div10, t5);
			append_dev(div10, div5);
			mount_component(textfield3, div5, null);
			append_dev(div10, t6);
			append_dev(div10, div6);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div6, null);
			}

			append_dev(div10, t7);
			append_dev(div10, div7);
			mount_component(textfield4, div7, null);
			append_dev(div10, t8);
			append_dev(div10, div8);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div8, null);
			}

			append_dev(div10, t9);
			append_dev(div10, div9);
			mount_component(textfield5, div9, null);
			append_dev(div9, t10);
			mount_component(textfield6, div9, null);
			append_dev(div9, t11);
			mount_component(textfield7, div9, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*style, variableValues, settingsVariable, labelRowB0*/ 100) {
				each_value_4 = /*settingsVariable*/ ctx[5].b0;
				validate_each_argument(each_value_4);
				group_outros();
				validate_each_keys(ctx, each_value_4, get_each_context_4$1, get_key);
				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key, 1, ctx, each_value_4, each0_lookup, div0, outro_and_destroy_block, create_each_block_4$1, null, get_each_context_4$1);
				check_outros();
			}

			const textfield0_changes = {};
			if (dirty & /*variableValues*/ 4) textfield0_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].q1float];
			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty & /*variableValues*/ 4) textfield1_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bq0];
			textfield1.$set(textfield1_changes);

			if (dirty & /*style, variableValues, settingsVariable, bqlensLabel*/ 548) {
				each_value_3 = /*settingsVariable*/ ctx[5].bqLenses;
				validate_each_argument(each_value_3);
				group_outros();
				validate_each_keys(ctx, each_value_3, get_each_context_3$3, get_key_1);
				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_1, 1, ctx, each_value_3, each1_lookup, div2, outro_and_destroy_block, create_each_block_3$3, null, get_each_context_3$3);
				check_outros();
			}

			const textfield2_changes = {};
			if (dirty & /*variableValues*/ 4) textfield2_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bq5];
			textfield2.$set(textfield2_changes);

			if (dirty & /*style, variableValues, settingsVariable, benderLabel*/ 1060) {
				each_value_2 = /*settingsVariable*/ ctx[5].benderLenses;
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2$4, get_key_2);
				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_2, 1, ctx, each_value_2, each2_lookup, div4, outro_and_destroy_block, create_each_block_2$4, null, get_each_context_2$4);
				check_outros();
			}

			const textfield3_changes = {};
			if (dirty & /*variableValues*/ 4) textfield3_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bl4];
			textfield3.$set(textfield3_changes);

			if (dirty & /*style, variableValues, settingsVariable, labelRowSE*/ 164) {
				each_value_1 = /*settingsVariable*/ ctx[5].se;
				validate_each_argument(each_value_1);
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key_3);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_3, 1, ctx, each_value_1, each3_lookup, div6, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
				check_outros();
			}

			const textfield4_changes = {};
			if (dirty & /*variableValues*/ 4) textfield4_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].trapfloat];
			textfield4.$set(textfield4_changes);

			if (dirty & /*style, variableValues, settingsVariable, labelRowSA*/ 292) {
				each_value = /*settingsVariable*/ ctx[5].sa;
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$a, get_key_4);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_4, 1, ctx, each_value, each4_lookup, div8, outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
				check_outros();
			}

			const textfield5_changes = {};
			if (dirty & /*variableValues*/ 4) textfield5_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].bl5];
			textfield5.$set(textfield5_changes);
			const textfield6_changes = {};
			if (dirty & /*variableValues*/ 4) textfield6_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].res];
			textfield6.$set(textfield6_changes);
			const textfield7_changes = {};
			if (dirty & /*variableValues*/ 4) textfield7_changes.value = /*variableValues*/ ctx[2][/*settingsVariable*/ ctx[5].q2float];
			textfield7.$set(textfield7_changes);
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks_4[i]);
			}

			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			transition_in(textfield2.$$.fragment, local);

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			transition_in(textfield3.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(textfield4.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(textfield5.$$.fragment, local);
			transition_in(textfield6.$$.fragment, local);
			transition_in(textfield7.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks_4.length; i += 1) {
				transition_out(each_blocks_4[i]);
			}

			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			transition_out(textfield2.$$.fragment, local);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			transition_out(textfield3.$$.fragment, local);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(textfield4.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(textfield5.$$.fragment, local);
			transition_out(textfield6.$$.fragment, local);
			transition_out(textfield7.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div10);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].d();
			}

			destroy_component(textfield0);
			destroy_component(textfield1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].d();
			}

			destroy_component(textfield2);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d();
			}

			destroy_component(textfield3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			destroy_component(textfield4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(textfield5);
			destroy_component(textfield6);
			destroy_component(textfield7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(93:12) {#if settingsLoaded}",
		ctx
	});

	return block;
}

// (97:24) {#each settingsVariable.b0 as item, index (item)}
function create_each_block_4$1(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*item*/ ctx[16]],
				label: /*labelRowB0*/ ctx[6][/*index*/ ctx[18]]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[16]];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4$1.name,
		type: "each",
		source: "(97:24) {#each settingsVariable.b0 as item, index (item)}",
		ctx
	});

	return block;
}

// (109:24) {#each settingsVariable.bqLenses as item, index (item)}
function create_each_block_3$3(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*item*/ ctx[16]],
				label: /*bqlensLabel*/ ctx[9][/*index*/ ctx[18]]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[16]];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$3.name,
		type: "each",
		source: "(109:24) {#each settingsVariable.bqLenses as item, index (item)}",
		ctx
	});

	return block;
}

// (117:24) {#each settingsVariable.benderLenses as item, index (item)}
function create_each_block_2$4(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*item*/ ctx[16]],
				label: /*benderLabel*/ ctx[10][/*index*/ ctx[18]]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[16]];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$4.name,
		type: "each",
		source: "(117:24) {#each settingsVariable.benderLenses as item, index (item)}",
		ctx
	});

	return block;
}

// (128:24) {#each settingsVariable.se as item, index (item)}
function create_each_block_1$4(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*item*/ ctx[16]],
				label: /*labelRowSE*/ ctx[7][/*index*/ ctx[18]]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[16]];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$4.name,
		type: "each",
		source: "(128:24) {#each settingsVariable.se as item, index (item)}",
		ctx
	});

	return block;
}

// (138:24) {#each settingsVariable.sa as item, index (item)}
function create_each_block$a(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: style$1,
				value: /*variableValues*/ ctx[2][/*item*/ ctx[16]],
				label: /*labelRowSA*/ ctx[8][/*index*/ ctx[18]]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty & /*variableValues*/ 4) textfield_changes.value = /*variableValues*/ ctx[2][/*item*/ ctx[16]];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$a.name,
		type: "each",
		source: "(138:24) {#each settingsVariable.sa as item, index (item)}",
		ctx
	});

	return block;
}

// (88:8) <div slot="content" transition:fade >
function create_content_slot$5(ctx) {
	let div;
	let customselect;
	let updating_picked;
	let t;
	let div_transition;
	let current;

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[13].call(null, value);
	}

	let customselect_props = {
		style: "width:12em; height:3.5em; margin-right:0.5em",
		label: "Filename",
		options: ["", .../*fullfileslist*/ ctx[1]]
	};

	if (/*selected_file*/ ctx[4] !== void 0) {
		customselect_props.picked = /*selected_file*/ ctx[4];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));
	let if_block = /*settingsLoaded*/ ctx[3] && create_if_block_1$a(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(customselect.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr_dev(div, "slot", "content");
			add_location(div, file$1b, 87, 8, 2748);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(customselect, div, null);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const customselect_changes = {};
			if (dirty & /*fullfileslist*/ 2) customselect_changes.options = ["", .../*fullfileslist*/ ctx[1]];

			if (!updating_picked && dirty & /*selected_file*/ 16) {
				updating_picked = true;
				customselect_changes.picked = /*selected_file*/ ctx[4];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);

			if (/*settingsLoaded*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*settingsLoaded*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customselect.$$.fragment, local);
			transition_in(if_block);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(customselect.$$.fragment, local);
			transition_out(if_block);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(customselect);
			if (if_block) if_block.d();
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$5.name,
		type: "slot",
		source: "(88:8) <div slot=\\\"content\\\" transition:fade >",
		ctx
	});

	return block;
}

function create_fragment$1i(ctx) {
	let button;
	let t1;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*active*/ ctx[0] && create_if_block$t(ctx);

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "GetLabviewSettings";
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(button, "class", "button is-link");
			add_location(button, file$1b, 83, 0, 2581);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*active*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$t(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const style$1 = "width:7em; height:3.5em; margin-right:0.5em";

function instance$1i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GetLabviewSettings", slots, []);
	let { currentLocation } = $$props, { fullfileslist } = $$props;
	let { active = false } = $$props;

	// console.log(filename, location)
	const settingsVariable = {
		b0: ["m03_ao09_bl0", "m03_ao09_high", "m03_ao09_width"],
		bq0: "m03_ao01_bq0",
		bq5: "m03_ao03_bq5",
		q1float: "m03_ao15_qd1_float",
		q2float: "m04_ao09_qd2_float",
		res: "m03_ao13_reso",
		bqLenses: ["m03_ao08_bq1", "m03_ao07_bq2", "m03_ao06_bq3", "m03_ao05_bq4"],
		benderLenses: ["m04_ao01_b_in", "m04_ao00_b_outer", "m04_ao02_b_inner"],
		se: [
			"m04_ao03_se_trap_in",
			"m04_ao03_se_delay",
			"m04_ao03_se_high",
			"m04_ao03_se_width"
		],
		sa: [
			"m04_ao04_sa_trap_out",
			"m04_ao04_sa_delay",
			"m04_ao04_sa_high",
			"m04_ao04_sa_width"
		],
		trapfloat: "m04_ao05_trap_float",
		bl4: "m04_ao07_bl4",
		bl5: "m04_ao08_bl5"
	};

	let fileContents = "";
	let variableValues = {};
	let settingsLoaded = false;

	afterUpdate(() => {
		const fullFilename = path.join(currentLocation, selected_file);
		console.log(fullFilename);
		$$invalidate(3, settingsLoaded = false);

		if (fs.existsSync(fullFilename) && selected_file) {
			fileContents = fs.readFileSync(fullFilename).toString();

			for (const line of fileContents.split("\n")) {
				if (line.trim().length > 0 && line.startsWith("# Sect01 Ion Source")) {
					let tempLine = line.split(" ");
					$$invalidate(2, variableValues[tempLine[7]] = parseFloat(tempLine[9]), variableValues);
				}
			}

			$$invalidate(3, settingsLoaded = true);
		}
	});

	const labelRowB0 = ["B0 Low", "B0 high", "B0 Width"];
	const labelRowSE = ["Trap-in", "SE delay", "SE high", "SE Width"];
	const labelRowSA = ["Trap-out", "Trap time (ms)", "SA high", "SA Width"];
	const bqlensLabel = ["bq1", "bq2", "bq3", "bq4"];
	const benderLabel = ["Bender in", "Bender outer", "Bender inner"];
	let selected_file = "";
	const writable_props = ["currentLocation", "fullfileslist", "active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<GetLabviewSettings> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, active = true);
	};

	function customselect_picked_binding(value) {
		selected_file = value;
		$$invalidate(4, selected_file);
	}

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	$$self.$$set = $$props => {
		if ("currentLocation" in $$props) $$invalidate(11, currentLocation = $$props.currentLocation);
		if ("fullfileslist" in $$props) $$invalidate(1, fullfileslist = $$props.fullfileslist);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		Modal,
		fade,
		afterUpdate,
		Textfield,
		CustomSelect,
		currentLocation,
		fullfileslist,
		active,
		settingsVariable,
		style: style$1,
		fileContents,
		variableValues,
		settingsLoaded,
		labelRowB0,
		labelRowSE,
		labelRowSA,
		bqlensLabel,
		benderLabel,
		selected_file
	});

	$$self.$inject_state = $$props => {
		if ("currentLocation" in $$props) $$invalidate(11, currentLocation = $$props.currentLocation);
		if ("fullfileslist" in $$props) $$invalidate(1, fullfileslist = $$props.fullfileslist);
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("fileContents" in $$props) fileContents = $$props.fileContents;
		if ("variableValues" in $$props) $$invalidate(2, variableValues = $$props.variableValues);
		if ("settingsLoaded" in $$props) $$invalidate(3, settingsLoaded = $$props.settingsLoaded);
		if ("selected_file" in $$props) $$invalidate(4, selected_file = $$props.selected_file);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		active,
		fullfileslist,
		variableValues,
		settingsLoaded,
		selected_file,
		settingsVariable,
		labelRowB0,
		labelRowSE,
		labelRowSA,
		bqlensLabel,
		benderLabel,
		currentLocation,
		click_handler,
		customselect_picked_binding,
		modal_active_binding
	];
}

class GetLabviewSettings extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
			currentLocation: 11,
			fullfileslist: 1,
			active: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GetLabviewSettings",
			options,
			id: create_fragment$1i.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*currentLocation*/ ctx[11] === undefined && !("currentLocation" in props)) {
			console_1$b.warn("<GetLabviewSettings> was created without expected prop 'currentLocation'");
		}

		if (/*fullfileslist*/ ctx[1] === undefined && !("fullfileslist" in props)) {
			console_1$b.warn("<GetLabviewSettings> was created without expected prop 'fullfileslist'");
		}
	}

	get currentLocation() {
		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentLocation(value) {
		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullfileslist() {
		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullfileslist(value) {
		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<GetLabviewSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<GetLabviewSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\Masspec.svelte generated by Svelte v3.31.2 */
const file$1c = "src\\Pages\\Masspec.svelte";

// (129:4) <div class="masspec_buttonContainer" slot="buttonContainer">
function create_buttonContainer_slot$1(ctx) {
	let div0;
	let div1;
	let button0;
	let t1;
	let button1;
	let t3;
	let button2;
	let t5;
	let getlabviewsettings;
	let t6;
	let button3;
	let t8;
	let customiconswitch;
	let updating_toggler;
	let t9;
	let customswitch;
	let updating_selected;
	let t10;
	let div2;
	let customselect;
	let updating_picked;
	let t11;
	let textfield0;
	let updating_value;
	let t12;
	let textfield1;
	let updating_value_1;
	let t13;
	let textfield2;
	let updating_value_2;
	let t14;
	let button4;
	let t16;
	let button5;
	let t18;
	let div3;
	let textfield3;
	let updating_value_3;
	let t19;
	let textfield4;
	let updating_value_4;
	let current;
	let mounted;
	let dispose;

	getlabviewsettings = new GetLabviewSettings({
			props: {
				currentLocation: /*currentLocation*/ ctx[1],
				fullfileslist: /*fullfileslist*/ ctx[15]
			},
			$$inline: true
		});

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[24].call(null, value);
	}

	let customiconswitch_props = {
		style: "padding:0;",
		icons: ["settings_ethernet", "code"]
	};

	if (/*openShell*/ ctx[4] !== void 0) {
		customiconswitch_props.toggler = /*openShell*/ ctx[4];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));

	function customswitch_selected_binding(value) {
		/*customswitch_selected_binding*/ ctx[25].call(null, value);
	}

	let customswitch_props = { style: "margin: 0 1em;", label: "Log" };

	if (/*logScale*/ ctx[13] !== void 0) {
		customswitch_props.selected = /*logScale*/ ctx[13];
	}

	customswitch = new CustomSwitch({
			props: customswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch, "selected", customswitch_selected_binding));
	customswitch.$on("change", /*linearlogCheck*/ ctx[18]);

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[26].call(null, value);
	}

	let customselect_props = {
		style: "width:12em; height:3.5em; margin-right:0.5em",
		label: "Filename",
		options: ["", .../*fileChecked*/ ctx[0]]
	};

	if (/*selected_file*/ ctx[7] !== void 0) {
		customselect_props.picked = /*selected_file*/ ctx[7];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[27].call(null, value);
	}

	let textfield0_props = {
		type: "number",
		style: style$2,
		label: "Prominance"
	};

	if (/*peak_prominance*/ ctx[8] !== void 0) {
		textfield0_props.value = /*peak_prominance*/ ctx[8];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));
	textfield0.$on("change", /*change_handler*/ ctx[28]);

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[29].call(null, value);
	}

	let textfield1_props = { type: "number", style: style$2, label: "Width" };

	if (/*peak_width*/ ctx[9] !== void 0) {
		textfield1_props.value = /*peak_width*/ ctx[9];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));
	textfield1.$on("change", /*change_handler_1*/ ctx[30]);

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[31].call(null, value);
	}

	let textfield2_props = { type: "number", style: style$2, label: "Height" };

	if (/*peak_height*/ ctx[10] !== void 0) {
		textfield2_props.value = /*peak_height*/ ctx[10];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));
	textfield2.$on("change", /*change_handler_2*/ ctx[32]);

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[35].call(null, value);
	}

	let textfield3_props = { style2, label: "Molecule Name" };

	if (/*nist_molecule*/ ctx[2] !== void 0) {
		textfield3_props.value = /*nist_molecule*/ ctx[2];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));
	textfield3.$on("change", /*change_handler_3*/ ctx[36]);

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[37].call(null, value);
	}

	let textfield4_props = { style2, label: "Molecule Formula" };

	if (/*nist_formula*/ ctx[3] !== void 0) {
		textfield4_props.value = /*nist_formula*/ ctx[3];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));
	textfield4.$on("change", /*set_nist_url*/ ctx[16]);

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			button0 = element("button");
			button0.textContent = "Masspec Plot";
			t1 = space();
			button1 = element("button");
			button1.textContent = "Find Peaks";
			t3 = space();
			button2 = element("button");
			button2.textContent = "NIST Webbook";
			t5 = space();
			create_component(getlabviewsettings.$$.fragment);
			t6 = space();
			button3 = element("button");
			button3.textContent = "Open in Matplotlib";
			t8 = space();
			create_component(customiconswitch.$$.fragment);
			t9 = space();
			create_component(customswitch.$$.fragment);
			t10 = space();
			div2 = element("div");
			create_component(customselect.$$.fragment);
			t11 = space();
			create_component(textfield0.$$.fragment);
			t12 = space();
			create_component(textfield1.$$.fragment);
			t13 = space();
			create_component(textfield2.$$.fragment);
			t14 = space();
			button4 = element("button");
			button4.textContent = "Get Peaks";
			t16 = space();
			button5 = element("button");
			button5.textContent = "Clear";
			t18 = space();
			div3 = element("div");
			create_component(textfield3.$$.fragment);
			t19 = space();
			create_component(textfield4.$$.fragment);
			attr_dev(button0, "class", "button is-link svelte-10o0u8m");
			add_location(button0, file$1c, 131, 12, 5214);
			attr_dev(button1, "class", "button is-link svelte-10o0u8m");
			add_location(button1, file$1c, 132, 12, 5314);
			attr_dev(button2, "class", "button is-link svelte-10o0u8m");
			add_location(button2, file$1c, 133, 12, 5422);
			attr_dev(button3, "class", "button is-link svelte-10o0u8m");
			add_location(button3, file$1c, 135, 12, 5601);
			attr_dev(div1, "class", "content align buttonRow svelte-10o0u8m");
			add_location(div1, file$1c, 130, 8, 5163);
			attr_dev(button4, "class", "button is-link svelte-10o0u8m");
			add_location(button4, file$1c, 145, 12, 6662);
			attr_dev(button5, "class", "button is-danger svelte-10o0u8m");
			add_location(button5, file$1c, 146, 12, 6782);
			attr_dev(div2, "class", "animated fadeIn hide buttonRow svelte-10o0u8m");
			toggle_class(div2, "active", /*toggleRow1*/ ctx[6]);
			add_location(div2, file$1c, 140, 8, 5972);
			attr_dev(div3, "class", "animated fadeIn hide buttonRow svelte-10o0u8m");
			toggle_class(div3, "active", /*toggleRow2*/ ctx[11]);
			add_location(div3, file$1c, 149, 8, 6927);
			attr_dev(div0, "class", "masspec_buttonContainer svelte-10o0u8m");
			attr_dev(div0, "slot", "buttonContainer");
			add_location(div0, file$1c, 128, 4, 5091);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div1, button0);
			append_dev(div1, t1);
			append_dev(div1, button1);
			append_dev(div1, t3);
			append_dev(div1, button2);
			append_dev(div1, t5);
			mount_component(getlabviewsettings, div1, null);
			append_dev(div1, t6);
			append_dev(div1, button3);
			append_dev(div1, t8);
			mount_component(customiconswitch, div1, null);
			append_dev(div1, t9);
			mount_component(customswitch, div1, null);
			append_dev(div0, t10);
			append_dev(div0, div2);
			mount_component(customselect, div2, null);
			append_dev(div2, t11);
			mount_component(textfield0, div2, null);
			append_dev(div2, t12);
			mount_component(textfield1, div2, null);
			append_dev(div2, t13);
			mount_component(textfield2, div2, null);
			append_dev(div2, t14);
			append_dev(div2, button4);
			append_dev(div2, t16);
			append_dev(div2, button5);
			append_dev(div0, t18);
			append_dev(div0, div3);
			mount_component(textfield3, div3, null);
			append_dev(div3, t19);
			mount_component(textfield4, div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[20], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[21], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[22], false, false, false),
					listen_dev(button3, "click", /*click_handler_3*/ ctx[23], false, false, false),
					listen_dev(button4, "click", /*click_handler_4*/ ctx[33], false, false, false),
					listen_dev(button5, "click", /*click_handler_5*/ ctx[34], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const getlabviewsettings_changes = {};
			if (dirty[0] & /*currentLocation*/ 2) getlabviewsettings_changes.currentLocation = /*currentLocation*/ ctx[1];
			if (dirty[0] & /*fullfileslist*/ 32768) getlabviewsettings_changes.fullfileslist = /*fullfileslist*/ ctx[15];
			getlabviewsettings.$set(getlabviewsettings_changes);
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty[0] & /*openShell*/ 16) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*openShell*/ ctx[4];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);
			const customswitch_changes = {};

			if (!updating_selected && dirty[0] & /*logScale*/ 8192) {
				updating_selected = true;
				customswitch_changes.selected = /*logScale*/ ctx[13];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch.$set(customswitch_changes);
			const customselect_changes = {};
			if (dirty[0] & /*fileChecked*/ 1) customselect_changes.options = ["", .../*fileChecked*/ ctx[0]];

			if (!updating_picked && dirty[0] & /*selected_file*/ 128) {
				updating_picked = true;
				customselect_changes.picked = /*selected_file*/ ctx[7];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*peak_prominance*/ 256) {
				updating_value = true;
				textfield0_changes.value = /*peak_prominance*/ ctx[8];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*peak_width*/ 512) {
				updating_value_1 = true;
				textfield1_changes.value = /*peak_width*/ ctx[9];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*peak_height*/ 1024) {
				updating_value_2 = true;
				textfield2_changes.value = /*peak_height*/ ctx[10];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);

			if (dirty[0] & /*toggleRow1*/ 64) {
				toggle_class(div2, "active", /*toggleRow1*/ ctx[6]);
			}

			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*nist_molecule*/ 4) {
				updating_value_3 = true;
				textfield3_changes.value = /*nist_molecule*/ ctx[2];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty[0] & /*nist_formula*/ 8) {
				updating_value_4 = true;
				textfield4_changes.value = /*nist_formula*/ ctx[3];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);

			if (dirty[0] & /*toggleRow2*/ 2048) {
				toggle_class(div3, "active", /*toggleRow2*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(getlabviewsettings.$$.fragment, local);
			transition_in(customiconswitch.$$.fragment, local);
			transition_in(customswitch.$$.fragment, local);
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(getlabviewsettings.$$.fragment, local);
			transition_out(customiconswitch.$$.fragment, local);
			transition_out(customswitch.$$.fragment, local);
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(getlabviewsettings);
			destroy_component(customiconswitch);
			destroy_component(customswitch);
			destroy_component(customselect);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(textfield4);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttonContainer_slot$1.name,
		type: "slot",
		source: "(129:4) <div class=\\\"masspec_buttonContainer\\\" slot=\\\"buttonContainer\\\">",
		ctx
	});

	return block;
}

// (161:8) {#if graphPlotted}
function create_if_block$u(ctx) {
	let div;
	let reportlayout;
	let updating_currentLocation;
	let current;

	function reportlayout_currentLocation_binding(value) {
		/*reportlayout_currentLocation_binding*/ ctx[38].call(null, value);
	}

	let reportlayout_props = {
		id: `${filetype$1}_report`,
		includePlotsInReport: /*includePlotsInReport*/ ctx[19]
	};

	if (/*currentLocation*/ ctx[1] !== void 0) {
		reportlayout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	reportlayout = new ReportLayout({
			props: reportlayout_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(reportlayout, "currentLocation", reportlayout_currentLocation_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(reportlayout.$$.fragment);
			attr_dev(div, "class", "animated fadeIn svelte-10o0u8m");
			set_style(div, "flex-direction", "column ");
			add_location(div, file$1c, 161, 12, 7412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(reportlayout, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const reportlayout_changes = {};

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				reportlayout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			reportlayout.$set(reportlayout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(reportlayout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(reportlayout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(reportlayout);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$u.name,
		type: "if",
		source: "(161:8) {#if graphPlotted}",
		ctx
	});

	return block;
}

// (169:16) <Icon on:click="{()=>window.nist_webview.goToIndex(0)}" class="material-icons hvr-glow">
function create_default_slot_4$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("home");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$6.name,
		type: "slot",
		source: "(169:16) <Icon on:click=\\\"{()=>window.nist_webview.goToIndex(0)}\\\" class=\\\"material-icons hvr-glow\\\">",
		ctx
	});

	return block;
}

// (171:16) <Icon on:click="{()=>window.nist_webview.reload()}" class="material-icons hvr-glow">
function create_default_slot_3$8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("refresh");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$8.name,
		type: "slot",
		source: "(171:16) <Icon on:click=\\\"{()=>window.nist_webview.reload()}\\\" class=\\\"material-icons hvr-glow\\\">",
		ctx
	});

	return block;
}

// (172:16) <Icon on:click="{()=>{if(window.nist_webview.canGoBack()) {window.nist_webview.goBack()}}}" class="material-icons hvr-glow">
function create_default_slot_2$d(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_left");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$d.name,
		type: "slot",
		source: "(172:16) <Icon on:click=\\\"{()=>{if(window.nist_webview.canGoBack()) {window.nist_webview.goBack()}}}\\\" class=\\\"material-icons hvr-glow\\\">",
		ctx
	});

	return block;
}

// (173:16) <Icon on:click="{()=>{if(window.nist_webview.canGoForward()) {window.nist_webview.goForward()}}}" class="material-icons hvr-glow">
function create_default_slot_1$e(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_right");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$e.name,
		type: "slot",
		source: "(173:16) <Icon on:click=\\\"{()=>{if(window.nist_webview.canGoForward()) {window.nist_webview.goForward()}}}\\\" class=\\\"material-icons hvr-glow\\\">",
		ctx
	});

	return block;
}

// (157:4) <div style="margin-right: 1em;" slot="plotContainer">
function create_plotContainer_slot$1(ctx) {
	let div0;
	let div1;
	let t0;
	let t1;
	let div4;
	let div2;
	let icon0;
	let t2;
	let icon1;
	let t3;
	let icon2;
	let t4;
	let icon3;
	let t5;
	let div3;
	let webview;
	let webview_src_value;
	let current;
	let if_block = /*graphPlotted*/ ctx[5] && create_if_block$u(ctx);

	icon0 = new Icon({
			props: {
				class: "material-icons hvr-glow",
				$$slots: { default: [create_default_slot_4$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon0.$on("click", /*click_handler_6*/ ctx[39]);

	icon1 = new Icon({
			props: {
				class: "material-icons hvr-glow",
				$$slots: { default: [create_default_slot_3$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon1.$on("click", /*click_handler_7*/ ctx[40]);

	icon2 = new Icon({
			props: {
				class: "material-icons hvr-glow",
				$$slots: { default: [create_default_slot_2$d] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon2.$on("click", /*click_handler_8*/ ctx[41]);

	icon3 = new Icon({
			props: {
				class: "material-icons hvr-glow",
				$$slots: { default: [create_default_slot_1$e] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon3.$on("click", /*click_handler_9*/ ctx[42]);

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div4 = element("div");
			div2 = element("div");
			create_component(icon0.$$.fragment);
			t2 = space();
			create_component(icon1.$$.fragment);
			t3 = space();
			create_component(icon2.$$.fragment);
			t4 = space();
			create_component(icon3.$$.fragment);
			t5 = space();
			div3 = element("div");
			webview = element("webview");
			attr_dev(div1, "id", "mplot");
			attr_dev(div1, "class", "svelte-10o0u8m");
			add_location(div1, file$1c, 158, 8, 7339);
			set_style(div2, "margin", "1em");
			attr_dev(div2, "class", "svelte-10o0u8m");
			add_location(div2, file$1c, 167, 12, 7777);
			if (webview.src !== (webview_src_value = /*nist_url*/ ctx[12])) attr_dev(webview, "src", webview_src_value);
			attr_dev(webview, "id", "nist_webview");
			set_style(webview, "height", "50vh");
			set_style(webview, "padding-bottom", "3em");
			attr_dev(webview, "class", "svelte-10o0u8m");
			add_location(webview, file$1c, 175, 16, 8428);
			attr_dev(div3, "class", " svelte-10o0u8m");
			add_location(div3, file$1c, 174, 12, 8396);
			attr_dev(div4, "class", "hide animated fadeIn svelte-10o0u8m");
			set_style(div4, "margin-top", "1em");
			set_style(div4, "display", "none");
			set_style(div4, "flex-direction", "column");
			toggle_class(div4, "active", /*toggleRow2*/ ctx[11]);
			add_location(div4, file$1c, 166, 8, 7641);
			set_style(div0, "margin-right", "1em");
			attr_dev(div0, "slot", "plotContainer");
			attr_dev(div0, "class", "svelte-10o0u8m");
			add_location(div0, file$1c, 156, 4, 7274);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div0, t0);
			if (if_block) if_block.m(div0, null);
			append_dev(div0, t1);
			append_dev(div0, div4);
			append_dev(div4, div2);
			mount_component(icon0, div2, null);
			append_dev(div2, t2);
			mount_component(icon1, div2, null);
			append_dev(div2, t3);
			mount_component(icon2, div2, null);
			append_dev(div2, t4);
			mount_component(icon3, div2, null);
			append_dev(div4, t5);
			append_dev(div4, div3);
			append_dev(div3, webview);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*graphPlotted*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*graphPlotted*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$u(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const icon0_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				icon0_changes.$$scope = { dirty, ctx };
			}

			icon0.$set(icon0_changes);
			const icon1_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				icon1_changes.$$scope = { dirty, ctx };
			}

			icon1.$set(icon1_changes);
			const icon2_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				icon2_changes.$$scope = { dirty, ctx };
			}

			icon2.$set(icon2_changes);
			const icon3_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				icon3_changes.$$scope = { dirty, ctx };
			}

			icon3.$set(icon3_changes);

			if (!current || dirty[0] & /*nist_url*/ 4096 && webview.src !== (webview_src_value = /*nist_url*/ ctx[12])) {
				attr_dev(webview, "src", webview_src_value);
			}

			if (dirty[0] & /*toggleRow2*/ 2048) {
				toggle_class(div4, "active", /*toggleRow2*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(icon2.$$.fragment, local);
			transition_in(icon3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			transition_out(icon3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (if_block) if_block.d();
			destroy_component(icon0);
			destroy_component(icon1);
			destroy_component(icon2);
			destroy_component(icon3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_plotContainer_slot$1.name,
		type: "slot",
		source: "(157:4) <div style=\\\"margin-right: 1em;\\\" slot=\\\"plotContainer\\\">",
		ctx
	});

	return block;
}

// (128:0) <Layout bind:preModal {filetype} bind:fullfileslist {id} bind:currentLocation bind:fileChecked >
function create_default_slot$v(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$v.name,
		type: "slot",
		source: "(128:0) <Layout bind:preModal {filetype} bind:fullfileslist {id} bind:currentLocation bind:fileChecked >",
		ctx
	});

	return block;
}

function create_fragment$1j(ctx) {
	let layout;
	let updating_preModal;
	let updating_fullfileslist;
	let updating_currentLocation;
	let updating_fileChecked;
	let current;

	function layout_preModal_binding(value) {
		/*layout_preModal_binding*/ ctx[43].call(null, value);
	}

	function layout_fullfileslist_binding(value) {
		/*layout_fullfileslist_binding*/ ctx[44].call(null, value);
	}

	function layout_currentLocation_binding(value) {
		/*layout_currentLocation_binding*/ ctx[45].call(null, value);
	}

	function layout_fileChecked_binding(value) {
		/*layout_fileChecked_binding*/ ctx[46].call(null, value);
	}

	let layout_props = {
		filetype: filetype$1,
		id: id$1,
		$$slots: {
			default: [create_default_slot$v],
			plotContainer: [create_plotContainer_slot$1],
			buttonContainer: [create_buttonContainer_slot$1]
		},
		$$scope: { ctx }
	};

	if (/*preModal*/ ctx[14] !== void 0) {
		layout_props.preModal = /*preModal*/ ctx[14];
	}

	if (/*fullfileslist*/ ctx[15] !== void 0) {
		layout_props.fullfileslist = /*fullfileslist*/ ctx[15];
	}

	if (/*currentLocation*/ ctx[1] !== void 0) {
		layout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	if (/*fileChecked*/ ctx[0] !== void 0) {
		layout_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	layout = new Layout({ props: layout_props, $$inline: true });
	binding_callbacks.push(() => bind(layout, "preModal", layout_preModal_binding));
	binding_callbacks.push(() => bind(layout, "fullfileslist", layout_fullfileslist_binding));
	binding_callbacks.push(() => bind(layout, "currentLocation", layout_currentLocation_binding));
	binding_callbacks.push(() => bind(layout, "fileChecked", layout_fileChecked_binding));

	const block = {
		c: function create() {
			create_component(layout.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const layout_changes = {};

			if (dirty[0] & /*toggleRow2, nist_url, currentLocation, graphPlotted, nist_formula, nist_molecule, toggleRow1, peak_height, peak_width, peak_prominance, fileChecked, selected_file, logScale, openShell, fullfileslist*/ 49151 | dirty[1] & /*$$scope*/ 1048576) {
				layout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_preModal && dirty[0] & /*preModal*/ 16384) {
				updating_preModal = true;
				layout_changes.preModal = /*preModal*/ ctx[14];
				add_flush_callback(() => updating_preModal = false);
			}

			if (!updating_fullfileslist && dirty[0] & /*fullfileslist*/ 32768) {
				updating_fullfileslist = true;
				layout_changes.fullfileslist = /*fullfileslist*/ ctx[15];
				add_flush_callback(() => updating_fullfileslist = false);
			}

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(layout, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const filetype$1 = "mass", id$1 = "Masspec";
const style$2 = "width:7em; height:3.5em; margin-right:0.5em";
const style2 = "width:12em; height:3em; margin-right:0.5em";

function instance$1j($$self, $$props, $$invalidate) {
	let massfiles;
	let nist_molecule_name;
	let nist_molecule_formula;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Masspec", slots, []);
	let fileChecked = [];
	let currentLocation = localStorage[`${filetype$1}_location`] || "";

	// $: if(currentLocation !== "") {OPOcalibFiles = fs.readdirSync(OPOLocation).filter(file=> file.endsWith(".calibOPO"))}
	let openShell = false, graphPlotted = false;

	// Find peaks
	let toggleRow1 = false;

	let selected_file = "", peak_prominance = 3, peak_width = 2, peak_height = 40;

	// NIST 
	let toggleRow2 = false,
		nist_molecule = localStorage["nist_molecule"] || "",
		nist_formula = localStorage["nist_formula"] || "";

	let nist_url = localStorage["nist_url"] || "https://webbook.nist.gov/cgi/cbook.cgi?Name=&Units=SI&Mask=200#Mass-Spec";

	const set_nist_url = (format = "") => {
		let fmt;

		format == "by_name"
		? fmt = nist_molecule_name
		: fmt = nist_molecule_formula;

		$$invalidate(12, nist_url = `https://webbook.nist.gov/cgi/cbook.cgi?${fmt}&Units=SI&Mask=200#Mass-Spec`);
		localStorage["nist_url"] = nist_url;
		localStorage["nist_formula"] = nist_formula;
		localStorage["nist_molecule"] = nist_molecule;
	};

	// Linear log
	let logScale = true;

	// Functions
	function plotData({ e = null, filetype = "mass" } = {}) {
		if (!fs.existsSync(currentLocation)) {
			return window.createToast("Location not defined", "danger");
		}

		if (fileChecked.length < 1) {
			return window.createToast("No files selected", "danger");
		}

		if (filetype === "find_peaks") {
			if (selected_file === "") return window.createToast("No files selected", "danger");
		}

		// console.log("Running")
		let pyfileInfo = {
			mass: {
				pyfile: "mass.py",
				args: [...massfiles, "run"]
			},
			general: {
				pyfile: "mass.py",
				args: [...massfiles, "plot"]
			},
			find_peaks: {
				pyfile: "find_peaks_masspec.py",
				args: [
					path.resolve(currentLocation, selected_file),
					peak_prominance,
					peak_width,
					peak_height
				]
			}
		};

		let { pyfile, args } = pyfileInfo[filetype];

		if (filetype == "general") {
			return computePy_func({
				e,
				pyfile,
				args,
				general: true,
				openShell
			}).catch(err => {
				$$invalidate(14, preModal.modalContent = err, preModal);
				$$invalidate(14, preModal.open = true, preModal);
			});
		}

		if (filetype == "mass") {
			$$invalidate(5, graphPlotted = false);
		}

		return computePy_func({ e, pyfile, args }).then(dataFromPython => {
			if (filetype == "mass") {
				plot("Mass spectrum", "Mass [u]", "Counts", dataFromPython, "mplot", "mass");
			} else if (filetype == "find_peaks") {
				Plotly.relayout("mplot", { yaxis: { title: "Counts", type: "" } });
				Plotly.relayout("mplot", { annotations: [] });

				Plotly.relayout("mplot", {
					annotations: dataFromPython["annotations"]
				});

				Plotly.relayout("mplot", { yaxis: { title: "Counts", type: "log" } });
			}

			window.createToast("Graph plotted", "success");
			$$invalidate(5, graphPlotted = true);
		}).catch(err => {
			$$invalidate(14, preModal.modalContent = err, preModal);
			$$invalidate(14, preModal.open = true, preModal);
		});
	}

	// Linearlog check
	const linearlogCheck = () => {
		let layout = {
			yaxis: {
				title: "Counts",
				type: logScale ? "log" : null
			}
		};

		if (graphPlotted) Plotly.relayout("mplot", layout);
	};

	let includePlotsInReport = [
		{
			id: "mplot",
			include: true,
			label: "Mass Spectrum"
		}
	];

	let preModal = {}, openSettings = false;
	let fullfileslist = [];
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Masspec> was created with unknown prop '${key}'`);
	});

	const click_handler = e => plotData({ e });

	const click_handler_1 = () => {
		$$invalidate(6, toggleRow1 = !toggleRow1);
	};

	const click_handler_2 = () => {
		$$invalidate(11, toggleRow2 = !toggleRow2);
	};

	const click_handler_3 = e => plotData({ e, filetype: "general" });

	function customiconswitch_toggler_binding(value) {
		openShell = value;
		$$invalidate(4, openShell);
	}

	function customswitch_selected_binding(value) {
		logScale = value;
		$$invalidate(13, logScale);
	}

	function customselect_picked_binding(value) {
		selected_file = value;
		$$invalidate(7, selected_file);
	}

	function textfield0_value_binding(value) {
		peak_prominance = value;
		$$invalidate(8, peak_prominance);
	}

	const change_handler = e => plotData({ e, filetype: "find_peaks" });

	function textfield1_value_binding(value) {
		peak_width = value;
		$$invalidate(9, peak_width);
	}

	const change_handler_1 = e => plotData({ e, filetype: "find_peaks" });

	function textfield2_value_binding(value) {
		peak_height = value;
		$$invalidate(10, peak_height);
	}

	const change_handler_2 = e => plotData({ e, filetype: "find_peaks" });
	const click_handler_4 = e => plotData({ e, filetype: "find_peaks" });
	const click_handler_5 = () => window.Plotly.relayout("mplot", { annotations: [] });

	function textfield3_value_binding(value) {
		nist_molecule = value;
		$$invalidate(2, nist_molecule);
	}

	const change_handler_3 = () => set_nist_url("by_name");

	function textfield4_value_binding(value) {
		nist_formula = value;
		$$invalidate(3, nist_formula);
	}

	function reportlayout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	const click_handler_6 = () => window.nist_webview.goToIndex(0);
	const click_handler_7 = () => window.nist_webview.reload();

	const click_handler_8 = () => {
		if (window.nist_webview.canGoBack()) {
			window.nist_webview.goBack();
		}
	};

	const click_handler_9 = () => {
		if (window.nist_webview.canGoForward()) {
			window.nist_webview.goForward();
		}
	};

	function layout_preModal_binding(value) {
		preModal = value;
		$$invalidate(14, preModal);
	}

	function layout_fullfileslist_binding(value) {
		fullfileslist = value;
		$$invalidate(15, fullfileslist);
	}

	function layout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	$$self.$capture_state = () => ({
		Layout,
		CustomIconSwitch,
		CustomSelect,
		CustomSwitch,
		ReportLayout,
		Textfield,
		plot,
		Icon,
		GetLabviewSettings,
		filetype: filetype$1,
		id: id$1,
		fileChecked,
		currentLocation,
		openShell,
		graphPlotted,
		toggleRow1,
		selected_file,
		peak_prominance,
		peak_width,
		peak_height,
		style: style$2,
		toggleRow2,
		nist_molecule,
		nist_formula,
		style2,
		nist_url,
		set_nist_url,
		logScale,
		plotData,
		linearlogCheck,
		includePlotsInReport,
		preModal,
		openSettings,
		fullfileslist,
		massfiles,
		nist_molecule_name,
		nist_molecule_formula
	});

	$$self.$inject_state = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("openShell" in $$props) $$invalidate(4, openShell = $$props.openShell);
		if ("graphPlotted" in $$props) $$invalidate(5, graphPlotted = $$props.graphPlotted);
		if ("toggleRow1" in $$props) $$invalidate(6, toggleRow1 = $$props.toggleRow1);
		if ("selected_file" in $$props) $$invalidate(7, selected_file = $$props.selected_file);
		if ("peak_prominance" in $$props) $$invalidate(8, peak_prominance = $$props.peak_prominance);
		if ("peak_width" in $$props) $$invalidate(9, peak_width = $$props.peak_width);
		if ("peak_height" in $$props) $$invalidate(10, peak_height = $$props.peak_height);
		if ("toggleRow2" in $$props) $$invalidate(11, toggleRow2 = $$props.toggleRow2);
		if ("nist_molecule" in $$props) $$invalidate(2, nist_molecule = $$props.nist_molecule);
		if ("nist_formula" in $$props) $$invalidate(3, nist_formula = $$props.nist_formula);
		if ("nist_url" in $$props) $$invalidate(12, nist_url = $$props.nist_url);
		if ("logScale" in $$props) $$invalidate(13, logScale = $$props.logScale);
		if ("includePlotsInReport" in $$props) $$invalidate(19, includePlotsInReport = $$props.includePlotsInReport);
		if ("preModal" in $$props) $$invalidate(14, preModal = $$props.preModal);
		if ("openSettings" in $$props) openSettings = $$props.openSettings;
		if ("fullfileslist" in $$props) $$invalidate(15, fullfileslist = $$props.fullfileslist);
		if ("massfiles" in $$props) massfiles = $$props.massfiles;
		if ("nist_molecule_name" in $$props) nist_molecule_name = $$props.nist_molecule_name;
		if ("nist_molecule_formula" in $$props) nist_molecule_formula = $$props.nist_molecule_formula;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentLocation, fileChecked*/ 3) {
			 massfiles = fs.existsSync(currentLocation)
			? fileChecked.map(file => path.resolve(currentLocation, file))
			: [];
		}

		if ($$self.$$.dirty[0] & /*nist_molecule*/ 4) {
			 nist_molecule_name = `Name=${nist_molecule}`;
		}

		if ($$self.$$.dirty[0] & /*nist_formula*/ 8) {
			 nist_molecule_formula = `Formula=${nist_formula}`;
		}
	};

	return [
		fileChecked,
		currentLocation,
		nist_molecule,
		nist_formula,
		openShell,
		graphPlotted,
		toggleRow1,
		selected_file,
		peak_prominance,
		peak_width,
		peak_height,
		toggleRow2,
		nist_url,
		logScale,
		preModal,
		fullfileslist,
		set_nist_url,
		plotData,
		linearlogCheck,
		includePlotsInReport,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		customiconswitch_toggler_binding,
		customswitch_selected_binding,
		customselect_picked_binding,
		textfield0_value_binding,
		change_handler,
		textfield1_value_binding,
		change_handler_1,
		textfield2_value_binding,
		change_handler_2,
		click_handler_4,
		click_handler_5,
		textfield3_value_binding,
		change_handler_3,
		textfield4_value_binding,
		reportlayout_currentLocation_binding,
		click_handler_6,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		layout_preModal_binding,
		layout_fullfileslist_binding,
		layout_currentLocation_binding,
		layout_fileChecked_binding
	];
}

class Masspec extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Masspec",
			options,
			id: create_fragment$1j.name
		});
	}
}

/* src\Pages\Timescan.svelte generated by Svelte v3.31.2 */

const { console: console_1$c } = globals;
const file$1d = "src\\Pages\\Timescan.svelte";

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	return child_ctx;
}

// (111:4) <div class="timescan_buttonContainer" slot="buttonContainer">
function create_buttonContainer_slot$2(ctx) {
	let div0;
	let div1;
	let button0;
	let t1;
	let button1;
	let t3;
	let button2;
	let t5;
	let customiconswitch;
	let updating_toggler;
	let t6;
	let customswitch;
	let updating_selected;
	let t7;
	let div2;
	let customselect0;
	let updating_picked;
	let t8;
	let customselect1;
	let updating_picked_1;
	let t9;
	let textfield0;
	let updating_value;
	let t10;
	let textfield1;
	let updating_value_1;
	let t11;
	let textfield2;
	let updating_value_2;
	let t12;
	let textfield3;
	let updating_value_3;
	let t13;
	let button3;
	let current;
	let mounted;
	let dispose;

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[22].call(null, value);
	}

	let customiconswitch_props = {
		style: "padding:0;",
		icons: ["settings_ethernet", "code"]
	};

	if (/*openShell*/ ctx[4] !== void 0) {
		customiconswitch_props.toggler = /*openShell*/ ctx[4];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));

	function customswitch_selected_binding(value) {
		/*customswitch_selected_binding*/ ctx[23].call(null, value);
	}

	let customswitch_props = { style: "margin: 0 1em;", label: "Log" };

	if (/*logScale*/ ctx[12] !== void 0) {
		customswitch_props.selected = /*logScale*/ ctx[12];
	}

	customswitch = new CustomSwitch({
			props: customswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch, "selected", customswitch_selected_binding));
	customswitch.$on("change", /*linearlogCheck*/ ctx[18]);

	function customselect0_picked_binding(value) {
		/*customselect0_picked_binding*/ ctx[24].call(null, value);
	}

	let customselect0_props = {
		style: "width:12em; height:3.5em; margin-right:0.5em",
		label: "ResOn",
		options: /*fullfiles*/ ctx[10]
	};

	if (/*resON_Files*/ ctx[2] !== void 0) {
		customselect0_props.picked = /*resON_Files*/ ctx[2];
	}

	customselect0 = new CustomSelect({
			props: customselect0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect0, "picked", customselect0_picked_binding));

	function customselect1_picked_binding(value) {
		/*customselect1_picked_binding*/ ctx[25].call(null, value);
	}

	let customselect1_props = {
		style: "width:12em; height:3.5em; margin-right:0.5em",
		label: "ResOFF",
		options: /*fullfiles*/ ctx[10]
	};

	if (/*resOFF_Files*/ ctx[3] !== void 0) {
		customselect1_props.picked = /*resOFF_Files*/ ctx[3];
	}

	customselect1 = new CustomSelect({
			props: customselect1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect1, "picked", customselect1_picked_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[26].call(null, value);
	}

	let textfield0_props = {
		style: "width:9em; height:3.5em; margin-right:0.5em",
		label: "Power (ON, OFF) [mJ]"
	};

	if (/*power*/ ctx[9] !== void 0) {
		textfield0_props.value = /*power*/ ctx[9];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[27].call(null, value);
	}

	let textfield1_props = {
		type: "number",
		style: /*style*/ ctx[16],
		label: "FELIX Hz"
	};

	if (/*nshots*/ ctx[8] !== void 0) {
		textfield1_props.value = /*nshots*/ ctx[8];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[28].call(null, value);
	}

	let textfield2_props = {
		type: "number",
		style: /*style*/ ctx[16],
		label: "Mass Index"
	};

	if (/*massIndex*/ ctx[6] !== void 0) {
		textfield2_props.value = /*massIndex*/ ctx[6];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[29].call(null, value);
	}

	let textfield3_props = {
		type: "number",
		style: /*style*/ ctx[16],
		label: "Time Index"
	};

	if (/*timestartIndex*/ ctx[7] !== void 0) {
		textfield3_props.value = /*timestartIndex*/ ctx[7];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			button0 = element("button");
			button0.textContent = "Timescan Plot";
			t1 = space();
			button1 = element("button");
			button1.textContent = "Depletion Plot";
			t3 = space();
			button2 = element("button");
			button2.textContent = "Open in Matplotlib";
			t5 = space();
			create_component(customiconswitch.$$.fragment);
			t6 = space();
			create_component(customswitch.$$.fragment);
			t7 = space();
			div2 = element("div");
			create_component(customselect0.$$.fragment);
			t8 = space();
			create_component(customselect1.$$.fragment);
			t9 = space();
			create_component(textfield0.$$.fragment);
			t10 = space();
			create_component(textfield1.$$.fragment);
			t11 = space();
			create_component(textfield2.$$.fragment);
			t12 = space();
			create_component(textfield3.$$.fragment);
			t13 = space();
			button3 = element("button");
			button3.textContent = "Submit";
			attr_dev(button0, "class", "button is-link svelte-5dy3s0");
			add_location(button0, file$1d, 113, 12, 4132);
			attr_dev(button1, "class", "button is-link svelte-5dy3s0");
			add_location(button1, file$1d, 114, 12, 4233);
			attr_dev(button2, "class", "button is-link svelte-5dy3s0");
			add_location(button2, file$1d, 115, 12, 4343);
			attr_dev(div1, "class", "content align buttonRow svelte-5dy3s0");
			add_location(div1, file$1d, 112, 8, 4081);
			attr_dev(button3, "class", "button is-link svelte-5dy3s0");
			add_location(button3, file$1d, 127, 12, 5497);
			attr_dev(div2, "class", "animated fadeIn hide buttonRow svelte-5dy3s0");
			toggle_class(div2, "active", /*toggleRow*/ ctx[11]);
			add_location(div2, file$1d, 120, 8, 4726);
			attr_dev(div0, "class", "timescan_buttonContainer svelte-5dy3s0");
			attr_dev(div0, "slot", "buttonContainer");
			add_location(div0, file$1d, 110, 4, 4008);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div1, button0);
			append_dev(div1, t1);
			append_dev(div1, button1);
			append_dev(div1, t3);
			append_dev(div1, button2);
			append_dev(div1, t5);
			mount_component(customiconswitch, div1, null);
			append_dev(div1, t6);
			mount_component(customswitch, div1, null);
			append_dev(div0, t7);
			append_dev(div0, div2);
			mount_component(customselect0, div2, null);
			append_dev(div2, t8);
			mount_component(customselect1, div2, null);
			append_dev(div2, t9);
			mount_component(textfield0, div2, null);
			append_dev(div2, t10);
			mount_component(textfield1, div2, null);
			append_dev(div2, t11);
			mount_component(textfield2, div2, null);
			append_dev(div2, t12);
			mount_component(textfield3, div2, null);
			append_dev(div2, t13);
			append_dev(div2, button3);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[19], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[20], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[21], false, false, false),
					listen_dev(button3, "click", /*click_handler_3*/ ctx[30], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty[0] & /*openShell*/ 16) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*openShell*/ ctx[4];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);
			const customswitch_changes = {};

			if (!updating_selected && dirty[0] & /*logScale*/ 4096) {
				updating_selected = true;
				customswitch_changes.selected = /*logScale*/ ctx[12];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch.$set(customswitch_changes);
			const customselect0_changes = {};
			if (dirty[0] & /*fullfiles*/ 1024) customselect0_changes.options = /*fullfiles*/ ctx[10];

			if (!updating_picked && dirty[0] & /*resON_Files*/ 4) {
				updating_picked = true;
				customselect0_changes.picked = /*resON_Files*/ ctx[2];
				add_flush_callback(() => updating_picked = false);
			}

			customselect0.$set(customselect0_changes);
			const customselect1_changes = {};
			if (dirty[0] & /*fullfiles*/ 1024) customselect1_changes.options = /*fullfiles*/ ctx[10];

			if (!updating_picked_1 && dirty[0] & /*resOFF_Files*/ 8) {
				updating_picked_1 = true;
				customselect1_changes.picked = /*resOFF_Files*/ ctx[3];
				add_flush_callback(() => updating_picked_1 = false);
			}

			customselect1.$set(customselect1_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*power*/ 512) {
				updating_value = true;
				textfield0_changes.value = /*power*/ ctx[9];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*nshots*/ 256) {
				updating_value_1 = true;
				textfield1_changes.value = /*nshots*/ ctx[8];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*massIndex*/ 64) {
				updating_value_2 = true;
				textfield2_changes.value = /*massIndex*/ ctx[6];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*timestartIndex*/ 128) {
				updating_value_3 = true;
				textfield3_changes.value = /*timestartIndex*/ ctx[7];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);

			if (dirty[0] & /*toggleRow*/ 2048) {
				toggle_class(div2, "active", /*toggleRow*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customiconswitch.$$.fragment, local);
			transition_in(customswitch.$$.fragment, local);
			transition_in(customselect0.$$.fragment, local);
			transition_in(customselect1.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customiconswitch.$$.fragment, local);
			transition_out(customswitch.$$.fragment, local);
			transition_out(customselect0.$$.fragment, local);
			transition_out(customselect1.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(customiconswitch);
			destroy_component(customswitch);
			destroy_component(customselect0);
			destroy_component(customselect1);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttonContainer_slot$2.name,
		type: "slot",
		source: "(111:4) <div class=\\\"timescan_buttonContainer\\\" slot=\\\"buttonContainer\\\">",
		ctx
	});

	return block;
}

// (135:12) {#each fileChecked as scanfile}
function create_each_block$b(ctx) {
	let div;
	let div_id_value;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", div_id_value = "" + (/*scanfile*/ ctx[36] + "_tplot"));
			set_style(div, "padding-bottom", "1em");
			attr_dev(div, "class", "svelte-5dy3s0");
			add_location(div, file$1d, 135, 16, 5786);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*fileChecked*/ 1 && div_id_value !== (div_id_value = "" + (/*scanfile*/ ctx[36] + "_tplot"))) {
				attr_dev(div, "id", div_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$b.name,
		type: "each",
		source: "(135:12) {#each fileChecked as scanfile}",
		ctx
	});

	return block;
}

// (140:8) {#if graphPlotted}
function create_if_block$v(ctx) {
	let div;
	let reportlayout;
	let updating_currentLocation;
	let current;

	function reportlayout_currentLocation_binding(value) {
		/*reportlayout_currentLocation_binding*/ ctx[31].call(null, value);
	}

	let reportlayout_props = {
		id: `${filetype$2}_report`,
		includePlotsInReport: /*includePlotsInReport*/ ctx[14]
	};

	if (/*currentLocation*/ ctx[1] !== void 0) {
		reportlayout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	reportlayout = new ReportLayout({
			props: reportlayout_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(reportlayout, "currentLocation", reportlayout_currentLocation_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(reportlayout.$$.fragment);
			attr_dev(div, "class", "animated fadeIn svelte-5dy3s0");
			set_style(div, "flex-direction", "column ");
			add_location(div, file$1d, 141, 12, 5925);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(reportlayout, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const reportlayout_changes = {};
			if (dirty[0] & /*includePlotsInReport*/ 16384) reportlayout_changes.includePlotsInReport = /*includePlotsInReport*/ ctx[14];

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				reportlayout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			reportlayout.$set(reportlayout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(reportlayout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(reportlayout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(reportlayout);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$v.name,
		type: "if",
		source: "(140:8) {#if graphPlotted}",
		ctx
	});

	return block;
}

// (133:4) <div style="margin-right: 1em;" slot="plotContainer">
function create_plotContainer_slot$2(ctx) {
	let div0;
	let div1;
	let t;
	let current;
	let each_value = /*fileChecked*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	}

	let if_block = /*graphPlotted*/ ctx[5] && create_if_block$v(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			attr_dev(div1, "id", "tplotContainer");
			attr_dev(div1, "class", "svelte-5dy3s0");
			add_location(div1, file$1d, 133, 8, 5698);
			set_style(div0, "margin-right", "1em");
			attr_dev(div0, "slot", "plotContainer");
			attr_dev(div0, "class", "svelte-5dy3s0");
			add_location(div0, file$1d, 132, 4, 5635);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div0, t);
			if (if_block) if_block.m(div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*fileChecked*/ 1) {
				each_value = /*fileChecked*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$b(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$b(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*graphPlotted*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*graphPlotted*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$v(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_plotContainer_slot$2.name,
		type: "slot",
		source: "(133:4) <div style=\\\"margin-right: 1em;\\\" slot=\\\"plotContainer\\\">",
		ctx
	});

	return block;
}

// (109:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked on:chdir={dir_changed}>
function create_default_slot$w(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$w.name,
		type: "slot",
		source: "(109:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked on:chdir={dir_changed}>",
		ctx
	});

	return block;
}

function create_fragment$1k(ctx) {
	let layout;
	let updating_preModal;
	let updating_currentLocation;
	let updating_fileChecked;
	let current;

	function layout_preModal_binding(value) {
		/*layout_preModal_binding*/ ctx[32].call(null, value);
	}

	function layout_currentLocation_binding(value) {
		/*layout_currentLocation_binding*/ ctx[33].call(null, value);
	}

	function layout_fileChecked_binding(value) {
		/*layout_fileChecked_binding*/ ctx[34].call(null, value);
	}

	let layout_props = {
		filetype: filetype$2,
		id: id$2,
		$$slots: {
			default: [create_default_slot$w],
			plotContainer: [create_plotContainer_slot$2],
			buttonContainer: [create_buttonContainer_slot$2]
		},
		$$scope: { ctx }
	};

	if (/*preModal*/ ctx[13] !== void 0) {
		layout_props.preModal = /*preModal*/ ctx[13];
	}

	if (/*currentLocation*/ ctx[1] !== void 0) {
		layout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	if (/*fileChecked*/ ctx[0] !== void 0) {
		layout_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	layout = new Layout({ props: layout_props, $$inline: true });
	binding_callbacks.push(() => bind(layout, "preModal", layout_preModal_binding));
	binding_callbacks.push(() => bind(layout, "currentLocation", layout_currentLocation_binding));
	binding_callbacks.push(() => bind(layout, "fileChecked", layout_fileChecked_binding));
	layout.$on("chdir", /*dir_changed*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(layout.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const layout_changes = {};

			if (dirty[0] & /*includePlotsInReport, currentLocation, graphPlotted, fileChecked, toggleRow, timestartIndex, massIndex, nshots, power, fullfiles, resOFF_Files, resON_Files, logScale, openShell*/ 24575 | dirty[1] & /*$$scope*/ 256) {
				layout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_preModal && dirty[0] & /*preModal*/ 8192) {
				updating_preModal = true;
				layout_changes.preModal = /*preModal*/ ctx[13];
				add_flush_callback(() => updating_preModal = false);
			}

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(layout, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const filetype$2 = "scan", id$2 = "Timescan";

function instance$1k($$self, $$props, $$invalidate) {
	let scanfiles;
	let includePlotsInReport;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Timescan", slots, []);
	let fileChecked = [];
	let currentLocation = localStorage[`${filetype$2}_location`] || "";
	let openShell = false, graphPlotted = false;

	let massIndex = 0,
		timestartIndex = 1,
		nshots = 10,
		power = "21, 21",
		resON_Files = "",
		resOFF_Files = "";

	let fullfiles = [];

	function dir_changed() {
		// console.log("Directory changed/refreshed", event)
		if (fs.existsSync(currentLocation)) {
			$$invalidate(10, fullfiles = [
				"",
				...fs.readdirSync(currentLocation).filter(file => file.endsWith(".scan"))
			]);
		}
	}

	// Depletion Row
	let toggleRow = false;

	let style = "width:7em; height:3.5em; margin-right:0.5em";

	// Linear log
	let logScale = false;

	function plotData({ e = null, filetype = "scan", tkplot = "run" } = {}) {
		if (fileChecked.length === 0 && filetype === "scan") {
			return window.createToast("No files selected", "danger");
		}

		if (filetype === "general") {
			if (resOFF_Files === "" || resON_Files === "") {
				return window.createToast("No files selected", "danger");
			}
		}

		let pyfileInfo = {
			scan: {
				pyfile: "timescan.py",
				args: [...scanfiles, tkplot]
			},
			general: {
				pyfile: "depletionscan.py",
				args: [
					currentLocation,
					resON_Files,
					resOFF_Files,
					...power.split(",").map(pow => parseFloat(pow)),
					nshots,
					massIndex,
					timestartIndex
				]
			}
		};

		let { pyfile, args } = pyfileInfo[filetype];

		// if (tkplot == "plot") {filetype = "general"}
		if (filetype == "scan") {
			$$invalidate(5, graphPlotted = false);
		}

		if (filetype == "general") {
			return computePy_func({
				e,
				pyfile,
				args,
				general: true,
				openShell
			}).catch(err => {
				$$invalidate(13, preModal.modalContent = err, preModal);
				$$invalidate(13, preModal.open = true, preModal);
			});
		}

		return computePy_func({ e, pyfile, args }).then(dataFromPython => {
			if (filetype == "scan") {
				fileChecked.forEach(file => {
					plot(`Timescan Plot: ${file}`, "Time (in ms)", "Counts", dataFromPython[file], `${file}_tplot`);
				});
			}

			window.createToast("Graph plotted", "success");
			$$invalidate(5, graphPlotted = true);
		}).catch(err => {
			$$invalidate(13, preModal.modalContent = err, preModal);
			$$invalidate(13, preModal.open = true, preModal);
		});
	}

	// Linearlog check
	const linearlogCheck = () => {
		let layout = {
			yaxis: {
				title: "Counts",
				type: logScale ? "log" : null
			}
		};

		if (graphPlotted) {
			fileChecked.forEach(file => {
				let tplot = file + "_tplot";
				Plotly.relayout(tplot, layout);
			});
		}
	};

	let preModal = {};
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Timescan> was created with unknown prop '${key}'`);
	});

	const click_handler = e => plotData({ e });

	const click_handler_1 = () => {
		$$invalidate(11, toggleRow = !toggleRow);
	};

	const click_handler_2 = e => plotData({ e, filetype: "scan", tkplot: "plot" });

	function customiconswitch_toggler_binding(value) {
		openShell = value;
		$$invalidate(4, openShell);
	}

	function customswitch_selected_binding(value) {
		logScale = value;
		$$invalidate(12, logScale);
	}

	function customselect0_picked_binding(value) {
		resON_Files = value;
		$$invalidate(2, resON_Files);
	}

	function customselect1_picked_binding(value) {
		resOFF_Files = value;
		$$invalidate(3, resOFF_Files);
	}

	function textfield0_value_binding(value) {
		power = value;
		$$invalidate(9, power);
	}

	function textfield1_value_binding(value) {
		nshots = value;
		$$invalidate(8, nshots);
	}

	function textfield2_value_binding(value) {
		massIndex = value;
		$$invalidate(6, massIndex);
	}

	function textfield3_value_binding(value) {
		timestartIndex = value;
		$$invalidate(7, timestartIndex);
	}

	const click_handler_3 = e => plotData({ e, filetype: "general" });

	function reportlayout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_preModal_binding(value) {
		preModal = value;
		$$invalidate(13, preModal);
	}

	function layout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	$$self.$capture_state = () => ({
		Layout,
		CustomIconSwitch,
		CustomSelect,
		CustomSwitch,
		ReportLayout,
		Textfield,
		plot,
		filetype: filetype$2,
		id: id$2,
		fileChecked,
		currentLocation,
		openShell,
		graphPlotted,
		massIndex,
		timestartIndex,
		nshots,
		power,
		resON_Files,
		resOFF_Files,
		fullfiles,
		dir_changed,
		toggleRow,
		style,
		logScale,
		plotData,
		linearlogCheck,
		preModal,
		scanfiles,
		includePlotsInReport
	});

	$$self.$inject_state = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("openShell" in $$props) $$invalidate(4, openShell = $$props.openShell);
		if ("graphPlotted" in $$props) $$invalidate(5, graphPlotted = $$props.graphPlotted);
		if ("massIndex" in $$props) $$invalidate(6, massIndex = $$props.massIndex);
		if ("timestartIndex" in $$props) $$invalidate(7, timestartIndex = $$props.timestartIndex);
		if ("nshots" in $$props) $$invalidate(8, nshots = $$props.nshots);
		if ("power" in $$props) $$invalidate(9, power = $$props.power);
		if ("resON_Files" in $$props) $$invalidate(2, resON_Files = $$props.resON_Files);
		if ("resOFF_Files" in $$props) $$invalidate(3, resOFF_Files = $$props.resOFF_Files);
		if ("fullfiles" in $$props) $$invalidate(10, fullfiles = $$props.fullfiles);
		if ("toggleRow" in $$props) $$invalidate(11, toggleRow = $$props.toggleRow);
		if ("style" in $$props) $$invalidate(16, style = $$props.style);
		if ("logScale" in $$props) $$invalidate(12, logScale = $$props.logScale);
		if ("preModal" in $$props) $$invalidate(13, preModal = $$props.preModal);
		if ("scanfiles" in $$props) scanfiles = $$props.scanfiles;
		if ("includePlotsInReport" in $$props) $$invalidate(14, includePlotsInReport = $$props.includePlotsInReport);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*fileChecked, currentLocation*/ 3) {
			 scanfiles = fileChecked.map(file => path.resolve(currentLocation, file));
		}

		if ($$self.$$.dirty[0] & /*resON_Files, resOFF_Files*/ 12) {
			 console.log(`ResOn: ${resON_Files}\nResOff: ${resOFF_Files}`);
		}

		if ($$self.$$.dirty[0] & /*fileChecked*/ 1) {
			 $$invalidate(14, includePlotsInReport = fileChecked.map(file => file = {
				id: `${file}_tplot`,
				include: false,
				label: file
			}));
		}
	};

	return [
		fileChecked,
		currentLocation,
		resON_Files,
		resOFF_Files,
		openShell,
		graphPlotted,
		massIndex,
		timestartIndex,
		nshots,
		power,
		fullfiles,
		toggleRow,
		logScale,
		preModal,
		includePlotsInReport,
		dir_changed,
		style,
		plotData,
		linearlogCheck,
		click_handler,
		click_handler_1,
		click_handler_2,
		customiconswitch_toggler_binding,
		customswitch_selected_binding,
		customselect0_picked_binding,
		customselect1_picked_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		textfield2_value_binding,
		textfield3_value_binding,
		click_handler_3,
		reportlayout_currentLocation_binding,
		layout_preModal_binding,
		layout_currentLocation_binding,
		layout_fileChecked_binding
	];
}

class Timescan extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Timescan",
			options,
			id: create_fragment$1k.name
		});
	}
}

/* src\Pages\thz\ROSAA.svelte generated by Svelte v3.31.2 */

const { console: console_1$d } = globals;
const file$1e = "src\\Pages\\thz\\ROSAA.svelte";

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[56] = list;
	child_ctx[57] = i;
	return child_ctx;
}

function get_each_context_1$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	return child_ctx;
}

function get_each_context_2$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	return child_ctx;
}

function get_each_context_3$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[63] = list;
	child_ctx[64] = i;
	return child_ctx;
}

function get_each_context_4$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[65] = list;
	child_ctx[66] = i;
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[67] = list;
	child_ctx[68] = i;
	return child_ctx;
}

function get_each_context_6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[69] = list;
	child_ctx[70] = i;
	return child_ctx;
}

function get_each_context_7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[53] = list[i].label;
	child_ctx[54] = list[i].value;
	child_ctx[55] = list[i].id;
	child_ctx[71] = list;
	child_ctx[72] = i;
	return child_ctx;
}

// (211:8) {:else}
function create_else_block$b(ctx) {
	let div0;
	let button;
	let t1;
	let textfield0;
	let updating_value;
	let t2;
	let textfield1;
	let updating_value_1;
	let t3;
	let div1;
	let customcheckbox0;
	let updating_selected;
	let t4;
	let div2;
	let customcheckbox1;
	let updating_selected_1;
	let t5;
	let customcheckbox2;
	let updating_selected_2;
	let t6;
	let customcheckbox3;
	let updating_selected_3;
	let t7;
	let div3;
	let t8;
	let t9;
	let t10;
	let t11;
	let div4;
	let customselect;
	let updating_picked;
	let t12;
	let textfield2;
	let updating_value_2;
	let t13;
	let div5;
	let t15;
	let each_blocks_5 = [];
	let each0_lookup = new Map();
	let t16;
	let div6;
	let t18;
	let each_blocks_4 = [];
	let each1_lookup = new Map();
	let t19;
	let textfield3;
	let updating_value_3;
	let t20;
	let div7;
	let t22;
	let each_blocks_3 = [];
	let each2_lookup = new Map();
	let t23;
	let div8;
	let t25;
	let each_blocks_2 = [];
	let each3_lookup = new Map();
	let t26;
	let div11;
	let div9;
	let t28;
	let div10;
	let each_blocks_1 = [];
	let each4_lookup = new Map();
	let t29;
	let t30;
	let div14;
	let div12;
	let t32;
	let div13;
	let each_blocks = [];
	let each5_lookup = new Map();
	let current;
	let mounted;
	let dispose;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[31].call(null, value);
	}

	let textfield0_props = { label: "Current location" };

	if (/*currentLocation*/ ctx[15] !== void 0) {
		textfield0_props.value = /*currentLocation*/ ctx[15];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[32].call(null, value);
	}

	let textfield1_props = { label: "filename" };

	if (/*filename*/ ctx[16] !== void 0) {
		textfield1_props.value = /*filename*/ ctx[16];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function customcheckbox0_selected_binding(value) {
		/*customcheckbox0_selected_binding*/ ctx[33].call(null, value);
	}

	let customcheckbox0_props = { label: "writefile" };

	if (/*writefile*/ ctx[17] !== void 0) {
		customcheckbox0_props.selected = /*writefile*/ ctx[17];
	}

	customcheckbox0 = new CustomCheckbox({
			props: customcheckbox0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox0, "selected", customcheckbox0_selected_binding));

	function customcheckbox1_selected_binding(value) {
		/*customcheckbox1_selected_binding*/ ctx[34].call(null, value);
	}

	let customcheckbox1_props = { label: "includeCollision" };

	if (/*includeCollision*/ ctx[18] !== void 0) {
		customcheckbox1_props.selected = /*includeCollision*/ ctx[18];
	}

	customcheckbox1 = new CustomCheckbox({
			props: customcheckbox1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox1, "selected", customcheckbox1_selected_binding));

	function customcheckbox2_selected_binding(value) {
		/*customcheckbox2_selected_binding*/ ctx[35].call(null, value);
	}

	let customcheckbox2_props = { label: "includeAttachmentRate" };

	if (/*includeAttachmentRate*/ ctx[20] !== void 0) {
		customcheckbox2_props.selected = /*includeAttachmentRate*/ ctx[20];
	}

	customcheckbox2 = new CustomCheckbox({
			props: customcheckbox2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox2, "selected", customcheckbox2_selected_binding));

	function customcheckbox3_selected_binding(value) {
		/*customcheckbox3_selected_binding*/ ctx[36].call(null, value);
	}

	let customcheckbox3_props = { label: "includeSpontaneousEmission" };

	if (/*includeSpontaneousEmission*/ ctx[19] !== void 0) {
		customcheckbox3_props.selected = /*includeSpontaneousEmission*/ ctx[19];
	}

	customcheckbox3 = new CustomCheckbox({
			props: customcheckbox3_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customcheckbox3, "selected", customcheckbox3_selected_binding));

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[37].call(null, value);
	}

	let customselect_props = { options: /*variablesList*/ ctx[29] };

	if (/*variable*/ ctx[21] !== void 0) {
		customselect_props.picked = /*variable*/ ctx[21];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[38].call(null, value);
	}

	let textfield2_props = { label: "Range (min, max, totalsteps)" };

	if (/*variableRange*/ ctx[22] !== void 0) {
		textfield2_props.value = /*variableRange*/ ctx[22];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));
	let each_value_7 = /*mainParameters*/ ctx[6];
	validate_each_argument(each_value_7);
	const get_key = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_7, get_each_context_7, get_key);

	for (let i = 0; i < each_value_7.length; i += 1) {
		let child_ctx = get_each_context_7(ctx, each_value_7, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_5[i] = create_each_block_7(key, child_ctx));
	}

	let each_value_6 = /*simulationParameters*/ ctx[7];
	validate_each_argument(each_value_6);
	const get_key_1 = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_6, get_each_context_6, get_key_1);

	for (let i = 0; i < each_value_6.length; i += 1) {
		let child_ctx = get_each_context_6(ctx, each_value_6, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_4[i] = create_each_block_6(key, child_ctx));
	}

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[41].call(null, value);
	}

	let textfield3_props = { style: style$3, label: "numberOfLevel (J levels)" };

	if (/*numberOfLevels*/ ctx[2] !== void 0) {
		textfield3_props.value = /*numberOfLevels*/ ctx[2];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));
	let each_value_5 = /*dopplerLineshape*/ ctx[8];
	validate_each_argument(each_value_5);
	const get_key_2 = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_5, get_each_context_5, get_key_2);

	for (let i = 0; i < each_value_5.length; i += 1) {
		let child_ctx = get_each_context_5(ctx, each_value_5, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks_3[i] = create_each_block_5(key, child_ctx));
	}

	let each_value_4 = /*powerBroadening*/ ctx[9];
	validate_each_argument(each_value_4);
	const get_key_3 = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key_3);

	for (let i = 0; i < each_value_4.length; i += 1) {
		let child_ctx = get_each_context_4$2(ctx, each_value_4, i);
		let key = get_key_3(child_ctx);
		each3_lookup.set(key, each_blocks_2[i] = create_each_block_4$2(key, child_ctx));
	}

	let each_value_3 = /*einsteinCoefficient*/ ctx[10];
	validate_each_argument(each_value_3);
	const get_key_4 = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_3, get_each_context_3$4, get_key_4);

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3$4(ctx, each_value_3, i);
		let key = get_key_4(child_ctx);
		each4_lookup.set(key, each_blocks_1[i] = create_each_block_3$4(key, child_ctx));
	}

	let if_block = /*includeCollision*/ ctx[18] && create_if_block_1$b(ctx);
	let each_value = /*rateCoefficients*/ ctx[12];
	validate_each_argument(each_value);
	const get_key_5 = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value, get_each_context$c, get_key_5);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$c(ctx, each_value, i);
		let key = get_key_5(child_ctx);
		each5_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
	}

	const block = {
		c: function create() {
			div0 = element("div");
			button = element("button");
			button.textContent = "Browse";
			t1 = space();
			create_component(textfield0.$$.fragment);
			t2 = space();
			create_component(textfield1.$$.fragment);
			t3 = space();
			div1 = element("div");
			create_component(customcheckbox0.$$.fragment);
			t4 = space();
			div2 = element("div");
			create_component(customcheckbox1.$$.fragment);
			t5 = space();
			create_component(customcheckbox2.$$.fragment);
			t6 = space();
			create_component(customcheckbox3.$$.fragment);
			t7 = space();
			div3 = element("div");
			t8 = text("Simulate signal(%) as a function of \"");
			t9 = text(/*variable*/ ctx[21]);
			t10 = text("\"");
			t11 = space();
			div4 = element("div");
			create_component(customselect.$$.fragment);
			t12 = space();
			create_component(textfield2.$$.fragment);
			t13 = space();
			div5 = element("div");
			div5.textContent = "Main Parameters";
			t15 = space();

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].c();
			}

			t16 = space();
			div6 = element("div");
			div6.textContent = "Simulation parameters";
			t18 = space();

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			t19 = space();
			create_component(textfield3.$$.fragment);
			t20 = space();
			div7 = element("div");
			div7.textContent = "Doppler lineshape";
			t22 = space();

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t23 = space();
			div8 = element("div");
			div8.textContent = "Lorrentz lineshape";
			t25 = space();

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t26 = space();
			div11 = element("div");
			div9 = element("div");
			div9.textContent = "Einstein Co-efficients";
			t28 = space();
			div10 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t29 = space();
			if (if_block) if_block.c();
			t30 = space();
			div14 = element("div");
			div12 = element("div");
			div12.textContent = "He attachment (K3) and diisociation (kCID) constants";
			t32 = space();
			div13 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(button, "class", "button is-link svelte-1eiecyv");
			attr_dev(button, "id", "thz_modal_filebrowser_btn");
			add_location(button, file$1e, 213, 16, 6666);
			attr_dev(div0, "class", "locationColumn svelte-1eiecyv");
			add_location(div0, file$1e, 212, 12, 6620);
			attr_dev(div1, "class", "writefileCheck svelte-1eiecyv");
			add_location(div1, file$1e, 219, 12, 6961);
			attr_dev(div2, "class", "writefileCheck svelte-1eiecyv");
			add_location(div2, file$1e, 223, 12, 7105);
			attr_dev(div3, "class", "subtitle svelte-1eiecyv");
			add_location(div3, file$1e, 230, 12, 7483);
			attr_dev(div4, "class", "variableColumn svelte-1eiecyv");
			add_location(div4, file$1e, 231, 12, 7573);
			attr_dev(div5, "class", "subtitle svelte-1eiecyv");
			add_location(div5, file$1e, 238, 12, 7817);
			attr_dev(div6, "class", "subtitle svelte-1eiecyv");
			add_location(div6, file$1e, 245, 12, 8020);
			attr_dev(div7, "class", "subtitle svelte-1eiecyv");
			add_location(div7, file$1e, 252, 12, 8328);
			attr_dev(div8, "class", "subtitle svelte-1eiecyv");
			add_location(div8, file$1e, 257, 12, 8531);
			attr_dev(div9, "class", "subtitle svelte-1eiecyv");
			add_location(div9, file$1e, 263, 16, 8794);
			attr_dev(div10, "class", "rates__mainContainer svelte-1eiecyv");
			add_location(div10, file$1e, 264, 16, 8862);
			attr_dev(div11, "class", "rates__div einsteinRate__div svelte-1eiecyv");
			add_location(div11, file$1e, 262, 12, 8734);
			attr_dev(div12, "class", "subtitle svelte-1eiecyv");
			add_location(div12, file$1e, 295, 16, 10177);
			attr_dev(div13, "class", "rates__mainContainer svelte-1eiecyv");
			add_location(div13, file$1e, 296, 16, 10275);
			attr_dev(div14, "class", "rates__div attachmentDissociationRate__div svelte-1eiecyv");
			add_location(div14, file$1e, 294, 12, 10103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, button);
			append_dev(div0, t1);
			mount_component(textfield0, div0, null);
			append_dev(div0, t2);
			mount_component(textfield1, div0, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, div1, anchor);
			mount_component(customcheckbox0, div1, null);
			insert_dev(target, t4, anchor);
			insert_dev(target, div2, anchor);
			mount_component(customcheckbox1, div2, null);
			append_dev(div2, t5);
			mount_component(customcheckbox2, div2, null);
			append_dev(div2, t6);
			mount_component(customcheckbox3, div2, null);
			insert_dev(target, t7, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, t8);
			append_dev(div3, t9);
			append_dev(div3, t10);
			insert_dev(target, t11, anchor);
			insert_dev(target, div4, anchor);
			mount_component(customselect, div4, null);
			append_dev(div4, t12);
			mount_component(textfield2, div4, null);
			insert_dev(target, t13, anchor);
			insert_dev(target, div5, anchor);
			insert_dev(target, t15, anchor);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].m(target, anchor);
			}

			insert_dev(target, t16, anchor);
			insert_dev(target, div6, anchor);
			insert_dev(target, t18, anchor);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].m(target, anchor);
			}

			insert_dev(target, t19, anchor);
			mount_component(textfield3, target, anchor);
			insert_dev(target, t20, anchor);
			insert_dev(target, div7, anchor);
			insert_dev(target, t22, anchor);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(target, anchor);
			}

			insert_dev(target, t23, anchor);
			insert_dev(target, div8, anchor);
			insert_dev(target, t25, anchor);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(target, anchor);
			}

			insert_dev(target, t26, anchor);
			insert_dev(target, div11, anchor);
			append_dev(div11, div9);
			append_dev(div11, t28);
			append_dev(div11, div10);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div10, null);
			}

			insert_dev(target, t29, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t30, anchor);
			insert_dev(target, div14, anchor);
			append_dev(div14, div12);
			append_dev(div14, t32);
			append_dev(div14, div13);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div13, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*browse_folder*/ ctx[28], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*currentLocation*/ 32768) {
				updating_value = true;
				textfield0_changes.value = /*currentLocation*/ ctx[15];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*filename*/ 65536) {
				updating_value_1 = true;
				textfield1_changes.value = /*filename*/ ctx[16];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const customcheckbox0_changes = {};

			if (!updating_selected && dirty[0] & /*writefile*/ 131072) {
				updating_selected = true;
				customcheckbox0_changes.selected = /*writefile*/ ctx[17];
				add_flush_callback(() => updating_selected = false);
			}

			customcheckbox0.$set(customcheckbox0_changes);
			const customcheckbox1_changes = {};

			if (!updating_selected_1 && dirty[0] & /*includeCollision*/ 262144) {
				updating_selected_1 = true;
				customcheckbox1_changes.selected = /*includeCollision*/ ctx[18];
				add_flush_callback(() => updating_selected_1 = false);
			}

			customcheckbox1.$set(customcheckbox1_changes);
			const customcheckbox2_changes = {};

			if (!updating_selected_2 && dirty[0] & /*includeAttachmentRate*/ 1048576) {
				updating_selected_2 = true;
				customcheckbox2_changes.selected = /*includeAttachmentRate*/ ctx[20];
				add_flush_callback(() => updating_selected_2 = false);
			}

			customcheckbox2.$set(customcheckbox2_changes);
			const customcheckbox3_changes = {};

			if (!updating_selected_3 && dirty[0] & /*includeSpontaneousEmission*/ 524288) {
				updating_selected_3 = true;
				customcheckbox3_changes.selected = /*includeSpontaneousEmission*/ ctx[19];
				add_flush_callback(() => updating_selected_3 = false);
			}

			customcheckbox3.$set(customcheckbox3_changes);
			if (!current || dirty[0] & /*variable*/ 2097152) set_data_dev(t9, /*variable*/ ctx[21]);
			const customselect_changes = {};

			if (!updating_picked && dirty[0] & /*variable*/ 2097152) {
				updating_picked = true;
				customselect_changes.picked = /*variable*/ ctx[21];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*variableRange*/ 4194304) {
				updating_value_2 = true;
				textfield2_changes.value = /*variableRange*/ ctx[22];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);

			if (dirty[0] & /*mainParameters*/ 64) {
				each_value_7 = /*mainParameters*/ ctx[6];
				validate_each_argument(each_value_7);
				group_outros();
				validate_each_keys(ctx, each_value_7, get_each_context_7, get_key);
				each_blocks_5 = update_keyed_each(each_blocks_5, dirty, get_key, 1, ctx, each_value_7, each0_lookup, t16.parentNode, outro_and_destroy_block, create_each_block_7, t16, get_each_context_7);
				check_outros();
			}

			if (dirty[0] & /*simulationParameters*/ 128) {
				each_value_6 = /*simulationParameters*/ ctx[7];
				validate_each_argument(each_value_6);
				group_outros();
				validate_each_keys(ctx, each_value_6, get_each_context_6, get_key_1);
				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key_1, 1, ctx, each_value_6, each1_lookup, t19.parentNode, outro_and_destroy_block, create_each_block_6, t19, get_each_context_6);
				check_outros();
			}

			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*numberOfLevels*/ 4) {
				updating_value_3 = true;
				textfield3_changes.value = /*numberOfLevels*/ ctx[2];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);

			if (dirty[0] & /*dopplerLineshape*/ 256) {
				each_value_5 = /*dopplerLineshape*/ ctx[8];
				validate_each_argument(each_value_5);
				group_outros();
				validate_each_keys(ctx, each_value_5, get_each_context_5, get_key_2);
				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_2, 1, ctx, each_value_5, each2_lookup, t23.parentNode, outro_and_destroy_block, create_each_block_5, t23, get_each_context_5);
				check_outros();
			}

			if (dirty[0] & /*powerBroadening*/ 512) {
				each_value_4 = /*powerBroadening*/ ctx[9];
				validate_each_argument(each_value_4);
				group_outros();
				validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key_3);
				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_3, 1, ctx, each_value_4, each3_lookup, t26.parentNode, outro_and_destroy_block, create_each_block_4$2, t26, get_each_context_4$2);
				check_outros();
			}

			if (dirty[0] & /*einsteinCoefficient*/ 1024) {
				each_value_3 = /*einsteinCoefficient*/ ctx[10];
				validate_each_argument(each_value_3);
				group_outros();
				validate_each_keys(ctx, each_value_3, get_each_context_3$4, get_key_4);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_4, 1, ctx, each_value_3, each4_lookup, div10, outro_and_destroy_block, create_each_block_3$4, null, get_each_context_3$4);
				check_outros();
			}

			if (/*includeCollision*/ ctx[18]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*includeCollision*/ 262144) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t30.parentNode, t30);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*rateCoefficients*/ 4096) {
				each_value = /*rateCoefficients*/ ctx[12];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$c, get_key_5);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_5, 1, ctx, each_value, each5_lookup, div13, outro_and_destroy_block, create_each_block$c, null, get_each_context$c);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(customcheckbox0.$$.fragment, local);
			transition_in(customcheckbox1.$$.fragment, local);
			transition_in(customcheckbox2.$$.fragment, local);
			transition_in(customcheckbox3.$$.fragment, local);
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);

			for (let i = 0; i < each_value_7.length; i += 1) {
				transition_in(each_blocks_5[i]);
			}

			for (let i = 0; i < each_value_6.length; i += 1) {
				transition_in(each_blocks_4[i]);
			}

			transition_in(textfield3.$$.fragment, local);

			for (let i = 0; i < each_value_5.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(customcheckbox0.$$.fragment, local);
			transition_out(customcheckbox1.$$.fragment, local);
			transition_out(customcheckbox2.$$.fragment, local);
			transition_out(customcheckbox3.$$.fragment, local);
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				transition_out(each_blocks_5[i]);
			}

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				transition_out(each_blocks_4[i]);
			}

			transition_out(textfield3.$$.fragment, local);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(if_block);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(textfield0);
			destroy_component(textfield1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div1);
			destroy_component(customcheckbox0);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div2);
			destroy_component(customcheckbox1);
			destroy_component(customcheckbox2);
			destroy_component(customcheckbox3);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(div3);
			if (detaching) detach_dev(t11);
			if (detaching) detach_dev(div4);
			destroy_component(customselect);
			destroy_component(textfield2);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(div5);
			if (detaching) detach_dev(t15);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].d(detaching);
			}

			if (detaching) detach_dev(t16);
			if (detaching) detach_dev(div6);
			if (detaching) detach_dev(t18);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].d(detaching);
			}

			if (detaching) detach_dev(t19);
			destroy_component(textfield3, detaching);
			if (detaching) detach_dev(t20);
			if (detaching) detach_dev(div7);
			if (detaching) detach_dev(t22);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].d(detaching);
			}

			if (detaching) detach_dev(t23);
			if (detaching) detach_dev(div8);
			if (detaching) detach_dev(t25);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d(detaching);
			}

			if (detaching) detach_dev(t26);
			if (detaching) detach_dev(div11);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			if (detaching) detach_dev(t29);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t30);
			if (detaching) detach_dev(div14);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$b.name,
		type: "else",
		source: "(211:8) {:else}",
		ctx
	});

	return block;
}

// (209:8) {#if reportToggle}
function create_if_block$w(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*statusReport*/ ctx[3]);
			attr_dev(div, "class", "content");
			attr_dev(div, "style", "white-space: pre-wrap; user");
			add_location(div, file$1e, 209, 12, 6510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*statusReport*/ 8) set_data_dev(t, /*statusReport*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$w.name,
		type: "if",
		source: "(209:8) {#if reportToggle}",
		ctx
	});

	return block;
}

// (241:12) {#each mainParameters as {label, value, id}
function create_each_block_7(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[39].call(null, value, /*value*/ ctx[54], /*each_value_7*/ ctx[71], /*each_index_6*/ ctx[72]);
	}

	let textfield_props = { style: style$3, label: /*label*/ ctx[53] };

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*mainParameters*/ 64) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*mainParameters*/ 64) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_7.name,
		type: "each",
		source: "(241:12) {#each mainParameters as {label, value, id}",
		ctx
	});

	return block;
}

// (247:12) {#each simulationParameters as {label, value, id}
function create_each_block_6(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_1(value) {
		/*textfield_value_binding_1*/ ctx[40].call(null, value, /*value*/ ctx[54], /*each_value_6*/ ctx[69], /*each_index_5*/ ctx[70]);
	}

	let textfield_props = { style: style$3, label: /*label*/ ctx[53] };

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*simulationParameters*/ 128) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*simulationParameters*/ 128) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_6.name,
		type: "each",
		source: "(247:12) {#each simulationParameters as {label, value, id}",
		ctx
	});

	return block;
}

// (254:12) {#each dopplerLineshape as {label, value, id}
function create_each_block_5(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_2(value) {
		/*textfield_value_binding_2*/ ctx[42].call(null, value, /*value*/ ctx[54], /*each_value_5*/ ctx[67], /*each_index_4*/ ctx[68]);
	}

	let textfield_props = { style: style$3, label: /*label*/ ctx[53] };

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_2));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*dopplerLineshape*/ 256) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*dopplerLineshape*/ 256) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5.name,
		type: "each",
		source: "(254:12) {#each dopplerLineshape as {label, value, id}",
		ctx
	});

	return block;
}

// (259:12) {#each powerBroadening as {label, value, id}
function create_each_block_4$2(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_3(value) {
		/*textfield_value_binding_3*/ ctx[43].call(null, value, /*value*/ ctx[54], /*each_value_4*/ ctx[65], /*each_index_3*/ ctx[66]);
	}

	let textfield_props = { style: style$3, label: /*label*/ ctx[53] };

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_3));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*powerBroadening*/ 512) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*powerBroadening*/ 512) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4$2.name,
		type: "each",
		source: "(259:12) {#each powerBroadening as {label, value, id}",
		ctx
	});

	return block;
}

// (266:20) {#each einsteinCoefficient as {label, value, id}
function create_each_block_3$4(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_4(value) {
		/*textfield_value_binding_4*/ ctx[44].call(null, value, /*value*/ ctx[54], /*each_value_3*/ ctx[63], /*each_index_2*/ ctx[64]);
	}

	let textfield_props = {
		style: "width:12em;",
		label: /*label*/ ctx[53]
	};

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_4));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*einsteinCoefficient*/ 1024) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*einsteinCoefficient*/ 1024) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$4.name,
		type: "each",
		source: "(266:20) {#each einsteinCoefficient as {label, value, id}",
		ctx
	});

	return block;
}

// (273:12) {#if includeCollision}
function create_if_block_1$b(ctx) {
	let div2;
	let div0;
	let t1;
	let customselect;
	let updating_picked;
	let t2;
	let div1;
	let textfield;
	let updating_value;
	let t3;
	let current;

	function customselect_picked_binding_1(value) {
		/*customselect_picked_binding_1*/ ctx[45].call(null, value);
	}

	let customselect_props = {
		style: "width: 12em;",
		options: ["deexcitation", "excitation"]
	};

	if (/*collisionalRateType*/ ctx[1] !== void 0) {
		customselect_props.picked = /*collisionalRateType*/ ctx[1];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding_1));

	function textfield_value_binding_5(value) {
		/*textfield_value_binding_5*/ ctx[46].call(null, value);
	}

	let textfield_props = {
		style: "width:12em;",
		label: "trapTemp(K)"
	};

	if (/*trapTemp*/ ctx[11] !== void 0) {
		textfield_props.value = /*trapTemp*/ ctx[11];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_5));
	let each_value_1 = /*collisionalCoefficient*/ ctx[4];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			div0.textContent = "Collisional rate constants";
			t1 = space();
			create_component(customselect.$$.fragment);
			t2 = space();
			div1 = element("div");
			create_component(textfield.$$.fragment);
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", "subtitle svelte-1eiecyv");
			add_location(div0, file$1e, 276, 20, 9250);
			attr_dev(div1, "class", "rates__mainContainer svelte-1eiecyv");
			add_location(div1, file$1e, 278, 20, 9460);
			attr_dev(div2, "class", "rates__div collisionalRate__div svelte-1eiecyv");
			add_location(div2, file$1e, 274, 16, 9181);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t1);
			mount_component(customselect, div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			mount_component(textfield, div1, null);
			append_dev(div1, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const customselect_changes = {};

			if (!updating_picked && dirty[0] & /*collisionalRateType*/ 2) {
				updating_picked = true;
				customselect_changes.picked = /*collisionalRateType*/ ctx[1];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield_changes = {};

			if (!updating_value && dirty[0] & /*trapTemp*/ 2048) {
				updating_value = true;
				textfield_changes.value = /*trapTemp*/ ctx[11];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (dirty[0] & /*collisionalCoefficient*/ 16) {
				each_value_1 = /*collisionalCoefficient*/ ctx[4];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(customselect);
			destroy_component(textfield);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$b.name,
		type: "if",
		source: "(273:12) {#if includeCollision}",
		ctx
	});

	return block;
}

// (283:32) {#each rateConstant as {label, value, id}
function create_each_block_2$5(key_1, ctx) {
	let first;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				style: "width:12em;",
				value: /*value*/ ctx[54],
				label: /*label*/ ctx[53],
				id: /*label*/ ctx[53]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*collisionalCoefficient*/ 16) textfield_changes.value = /*value*/ ctx[54];
			if (dirty[0] & /*collisionalCoefficient*/ 16) textfield_changes.label = /*label*/ ctx[53];
			if (dirty[0] & /*collisionalCoefficient*/ 16) textfield_changes.id = /*label*/ ctx[53];
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$5.name,
		type: "each",
		source: "(283:32) {#each rateConstant as {label, value, id}",
		ctx
	});

	return block;
}

// (281:24) {#each collisionalCoefficient as rateConstant}
function create_each_block_1$5(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let current;
	let each_value_2 = /*rateConstant*/ ctx[58];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*id*/ ctx[55];
	validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$5(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$5(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(div, "class", "");
			add_location(div, file$1e, 281, 28, 9696);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*collisionalCoefficient*/ 16) {
				each_value_2 = /*rateConstant*/ ctx[58];
				validate_each_argument(each_value_2);
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, div, outro_and_destroy_block, create_each_block_2$5, t, get_each_context_2$5);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$5.name,
		type: "each",
		source: "(281:24) {#each collisionalCoefficient as rateConstant}",
		ctx
	});

	return block;
}

// (298:20) {#each rateCoefficients as {label, value, id}
function create_each_block$c(key_1, ctx) {
	let first;
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding_6(value) {
		/*textfield_value_binding_6*/ ctx[47].call(null, value, /*value*/ ctx[54], /*each_value*/ ctx[56], /*each_index*/ ctx[57]);
	}

	let textfield_props = { label: /*label*/ ctx[53] };

	if (/*value*/ ctx[54] !== void 0) {
		textfield_props.value = /*value*/ ctx[54];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_6));

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(textfield.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield_changes = {};
			if (dirty[0] & /*rateCoefficients*/ 4096) textfield_changes.label = /*label*/ ctx[53];

			if (!updating_value && dirty[0] & /*rateCoefficients*/ 4096) {
				updating_value = true;
				textfield_changes.value = /*value*/ ctx[54];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$c.name,
		type: "each",
		source: "(298:20) {#each rateCoefficients as {label, value, id}",
		ctx
	});

	return block;
}

// (207:4) <div class="ROSAA__modal" slot="content">
function create_content_slot$6(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$w, create_else_block$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*reportToggle*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "ROSAA__modal svelte-1eiecyv");
			attr_dev(div, "slot", "content");
			add_location(div, file$1e, 206, 4, 6425);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$6.name,
		type: "slot",
		source: "(207:4) <div class=\\\"ROSAA__modal\\\" slot=\\\"content\\\">",
		ctx
	});

	return block;
}

// (307:4) <div class="align" slot="footerbtn">
function create_footerbtn_slot$4(ctx) {
	let div;
	let button0;
	let t1;
	let button1;
	let t2;
	let t3;
	let button2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			button0.textContent = "Stop";
			t1 = space();
			button1 = element("button");
			t2 = text(/*buttonName*/ ctx[23]);
			t3 = space();
			button2 = element("button");
			button2.textContent = "Submit";
			attr_dev(button0, "class", "button is-danger");
			add_location(button0, file$1e, 308, 8, 10596);
			attr_dev(button1, "class", "button is-link");
			add_location(button1, file$1e, 310, 8, 10740);
			attr_dev(button2, "class", "button is-link");
			toggle_class(button2, "is-loading", /*running*/ ctx[14]);
			add_location(button2, file$1e, 311, 8, 10853);
			attr_dev(div, "class", "align");
			attr_dev(div, "slot", "footerbtn");
			add_location(div, file$1e, 306, 4, 10548);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(div, t1);
			append_dev(div, button1);
			append_dev(button1, t2);
			append_dev(div, t3);
			append_dev(div, button2);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[48], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[49], false, false, false),
					listen_dev(button2, "click", /*simulation*/ ctx[27], false, false, false),
					listen_dev(button2, "pyEvent", /*pyEventHandle*/ ctx[24], false, false, false),
					listen_dev(button2, "pyEventClosed", /*pyEventClosedHandle*/ ctx[26], false, false, false),
					listen_dev(button2, "pyEventData", /*pyEventDataReceivedHandle*/ ctx[25], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*buttonName*/ 8388608) set_data_dev(t2, /*buttonName*/ ctx[23]);

			if (dirty[0] & /*running*/ 16384) {
				toggle_class(button2, "is-loading", /*running*/ ctx[14]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot$4.name,
		type: "slot",
		source: "(307:4) <div class=\\\"align\\\" slot=\\\"footerbtn\\\">",
		ctx
	});

	return block;
}

// (205:0) <Modal bind:active title="ROSAA modal" >
function create_default_slot$x(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$x.name,
		type: "slot",
		source: "(205:0) <Modal bind:active title=\\\"ROSAA modal\\\" >",
		ctx
	});

	return block;
}

function create_fragment$1l(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[50].call(null, value);
	}

	let modal_props = {
		title: "ROSAA modal",
		$$slots: {
			default: [create_default_slot$x],
			footerbtn: [create_footerbtn_slot$4],
			content: [create_content_slot$6]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[0] !== void 0) {
		modal_props.active = /*active*/ ctx[0];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};

			if (dirty[0] & /*running, reportToggle, buttonName, py, statusReport, rateCoefficients, collisionalCoefficient, trapTemp, collisionalRateType, includeCollision, einsteinCoefficient, powerBroadening, dopplerLineshape, numberOfLevels, simulationParameters, mainParameters, variableRange, variable, includeSpontaneousEmission, includeAttachmentRate, writefile, filename, currentLocation*/ 16777214 | dirty[2] & /*$$scope*/ 2048) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty[0] & /*active*/ 1) {
				updating_active = true;
				modal_changes.active = /*active*/ ctx[0];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const style$3 = "width:12em; margin-bottom:1em;";

function instance$1l($$self, $$props, $$invalidate) {
	let deexcitation;
	let collisionalCoefficient;
	let reportToggle;
	let buttonName;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ROSAA", slots, []);
	let { active = false } = $$props;
	const dispatch = createEventDispatcher();

	let mainParameters = [
		{
			label: "molecule",
			value: "CD",
			id: window.getID()
		},
		{
			label: "tagging partner",
			value: "He",
			id: window.getID()
		},
		{
			label: "freq",
			value: "453_521_850_000",
			id: window.getID()
		},
		{
			label: "trap_area",
			value: "5e-5",
			id: window.getID()
		},
		{
			label: "Energy",
			value: "0, 15.127861, 45.373851",
			id: window.getID()
		}
	];

	let simulationParameters = [
		{
			label: "totalIonCounts",
			value: 1000,
			id: window.getID()
		},
		{
			label: "Simulation time(ms)",
			value: 600,
			id: window.getID()
		},
		{
			label: "Total steps",
			value: 1000,
			id: window.getID()
		},
		{
			label: "excitedTo",
			value: 1,
			id: window.getID()
		},
		{
			label: "excitedFrom",
			value: 0,
			id: window.getID()
		}
	];

	let dopplerLineshape = [
		{
			label: "IonMass(amu)",
			value: 14,
			id: window.getID()
		},
		{
			label: "IonTemperature(K)",
			value: 12,
			id: window.getID()
		}
	];

	let powerBroadening = [
		{
			label: "cp",
			value: "4.9e7",
			id: window.getID()
		},
		{
			label: "dipoleMoment(D)",
			value: 0,
			id: window.getID()
		},
		{
			label: "power(W)",
			value: "2e-5",
			id: window.getID()
		}
	];

	let einsteinCoefficient = [
		{
			label: "A_10",
			value: "6.24e-4",
			id: window.getID()
		}
	];

	let trapTemp = 5.7;

	let rateCoefficients = [
		{
			label: "branching-ratio",
			value: 0.5,
			id: window.getID()
		},
		{
			label: "a",
			value: 0.5,
			id: window.getID()
		},
		{
			label: "He density(cm3)",
			value: "2e14",
			id: window.getID()
		},
		{
			label: "k3",
			value: "9.6e-31, 2.9e-30",
			id: window.getID()
		},
		{
			label: "kCID",
			value: "6.7e-16, 1.9e-15",
			id: window.getID()
		}
	];

	let collisionalRateType = "deexcitation";
	let totalJLevel = 3;
	let numberOfLevels = 3;
	let py, running = false;

	const pyEventHandle = e => {
		$$invalidate(3, statusReport = "");
		const events = e.detail;
		$$invalidate(13, py = events.py);
	};

	let statusReport = "";

	const pyEventDataReceivedHandle = e => {
		let dataReceived = e.detail.dataReceived;
		$$invalidate(3, statusReport += `${dataReceived}\n`);
	};

	const pyEventClosedHandle = e => {
		$$invalidate(14, running = false);
		window.createToast("Terminated", "danger");
		$$invalidate(3, statusReport += "\n######## TERMINATED ########");
	};

	const simulation = e => {
		const collisionalRates = window._.flatten(collisionalCoefficient);
		const collisional_rates = {};
		collisionalRates.forEach(f => collisional_rates[f.label] = parseFloat(document.querySelector(`#${f.label} input`).value));
		const main_parameters = {};
		mainParameters.forEach(f => main_parameters[f.label] = f.value);
		const simulation_parameters = {};
		simulationParameters.forEach(f => simulation_parameters[f.label] = f.value);
		const lineshape_conditions = {};
		dopplerLineshape.forEach(f => lineshape_conditions[f.label] = f.value);
		const power_broadening = {};
		powerBroadening.forEach(f => power_broadening[f.label] = f.value);
		const einstein_coefficient = {};
		einsteinCoefficient.forEach(f => einstein_coefficient[f.label] = f.value);
		const rate_coefficients = {};
		rateCoefficients.forEach(f => rate_coefficients[f.label] = f.value);

		const conditions = {
			trapTemp,
			variable,
			variableRange,
			numberOfLevels,
			includeCollision,
			includeAttachmentRate,
			includeSpontaneousEmission,
			writefile,
			filename,
			currentLocation,
			deexcitation,
			collisional_rates,
			main_parameters,
			simulation_parameters,
			einstein_coefficient,
			power_broadening,
			lineshape_conditions,
			rate_coefficients
		};

		dispatch("submit", { e, conditions });
		$$invalidate(14, running = true);
	};

	let currentLocation = localStorage["thz_modal_location"] || localStorage["thz_location"] || "";
	let filename = `ROSAA_modal_${mainParameters[0].value}_${mainParameters[1].value}`;

	function browse_folder() {
		browse({ dir: true }).then(result => {
			if (!result.canceled) {
				$$invalidate(15, currentLocation = localStorage["thz_modal_location"] = result.filePaths[0]);
			}
		});
	}

	let writefile = true,
		includeCollision = true,
		includeSpontaneousEmission = true,
		includeAttachmentRate = true;

	let variable = "time", variableRange = "1e12, 1e16, 10";
	const variablesList = ["time", "He density(cm3)", "Power(W)"];
	const writable_props = ["active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<ROSAA> was created with unknown prop '${key}'`);
	});

	function textfield0_value_binding(value) {
		currentLocation = value;
		$$invalidate(15, currentLocation);
	}

	function textfield1_value_binding(value) {
		filename = value;
		$$invalidate(16, filename);
	}

	function customcheckbox0_selected_binding(value) {
		writefile = value;
		$$invalidate(17, writefile);
	}

	function customcheckbox1_selected_binding(value) {
		includeCollision = value;
		$$invalidate(18, includeCollision);
	}

	function customcheckbox2_selected_binding(value) {
		includeAttachmentRate = value;
		$$invalidate(20, includeAttachmentRate);
	}

	function customcheckbox3_selected_binding(value) {
		includeSpontaneousEmission = value;
		$$invalidate(19, includeSpontaneousEmission);
	}

	function customselect_picked_binding(value) {
		variable = value;
		$$invalidate(21, variable);
	}

	function textfield2_value_binding(value) {
		variableRange = value;
		$$invalidate(22, variableRange);
	}

	function textfield_value_binding(value$1, value, each_value_7, each_index_6) {
		each_value_7[each_index_6].value = value$1;
		$$invalidate(6, mainParameters);
	}

	function textfield_value_binding_1(value$1, value, each_value_6, each_index_5) {
		each_value_6[each_index_5].value = value$1;
		$$invalidate(7, simulationParameters);
	}

	function textfield3_value_binding(value) {
		numberOfLevels = value;
		$$invalidate(2, numberOfLevels);
	}

	function textfield_value_binding_2(value$1, value, each_value_5, each_index_4) {
		each_value_5[each_index_4].value = value$1;
		$$invalidate(8, dopplerLineshape);
	}

	function textfield_value_binding_3(value$1, value, each_value_4, each_index_3) {
		each_value_4[each_index_3].value = value$1;
		$$invalidate(9, powerBroadening);
	}

	function textfield_value_binding_4(value$1, value, each_value_3, each_index_2) {
		each_value_3[each_index_2].value = value$1;
		$$invalidate(10, einsteinCoefficient);
	}

	function customselect_picked_binding_1(value) {
		collisionalRateType = value;
		$$invalidate(1, collisionalRateType);
	}

	function textfield_value_binding_5(value) {
		trapTemp = value;
		$$invalidate(11, trapTemp);
	}

	function textfield_value_binding_6(value$1, value, each_value, each_index) {
		each_value[each_index].value = value$1;
		$$invalidate(12, rateCoefficients);
	}

	const click_handler = () => {
		py && running
		? py.kill()
		: console.log("pyEvent is not available");
	};

	const click_handler_1 = e => {
		$$invalidate(5, reportToggle = !reportToggle);
	};

	function modal_active_binding(value) {
		active = value;
		$$invalidate(0, active);
	}

	$$self.$$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		browse,
		Textfield,
		Modal,
		CustomCheckbox,
		CustomSelect,
		active,
		dispatch,
		mainParameters,
		simulationParameters,
		dopplerLineshape,
		powerBroadening,
		einsteinCoefficient,
		trapTemp,
		rateCoefficients,
		collisionalRateType,
		totalJLevel,
		numberOfLevels,
		py,
		running,
		pyEventHandle,
		statusReport,
		pyEventDataReceivedHandle,
		pyEventClosedHandle,
		simulation,
		style: style$3,
		currentLocation,
		filename,
		browse_folder,
		writefile,
		includeCollision,
		includeSpontaneousEmission,
		includeAttachmentRate,
		variable,
		variableRange,
		variablesList,
		deexcitation,
		collisionalCoefficient,
		reportToggle,
		buttonName
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
		if ("mainParameters" in $$props) $$invalidate(6, mainParameters = $$props.mainParameters);
		if ("simulationParameters" in $$props) $$invalidate(7, simulationParameters = $$props.simulationParameters);
		if ("dopplerLineshape" in $$props) $$invalidate(8, dopplerLineshape = $$props.dopplerLineshape);
		if ("powerBroadening" in $$props) $$invalidate(9, powerBroadening = $$props.powerBroadening);
		if ("einsteinCoefficient" in $$props) $$invalidate(10, einsteinCoefficient = $$props.einsteinCoefficient);
		if ("trapTemp" in $$props) $$invalidate(11, trapTemp = $$props.trapTemp);
		if ("rateCoefficients" in $$props) $$invalidate(12, rateCoefficients = $$props.rateCoefficients);
		if ("collisionalRateType" in $$props) $$invalidate(1, collisionalRateType = $$props.collisionalRateType);
		if ("totalJLevel" in $$props) totalJLevel = $$props.totalJLevel;
		if ("numberOfLevels" in $$props) $$invalidate(2, numberOfLevels = $$props.numberOfLevels);
		if ("py" in $$props) $$invalidate(13, py = $$props.py);
		if ("running" in $$props) $$invalidate(14, running = $$props.running);
		if ("statusReport" in $$props) $$invalidate(3, statusReport = $$props.statusReport);
		if ("currentLocation" in $$props) $$invalidate(15, currentLocation = $$props.currentLocation);
		if ("filename" in $$props) $$invalidate(16, filename = $$props.filename);
		if ("writefile" in $$props) $$invalidate(17, writefile = $$props.writefile);
		if ("includeCollision" in $$props) $$invalidate(18, includeCollision = $$props.includeCollision);
		if ("includeSpontaneousEmission" in $$props) $$invalidate(19, includeSpontaneousEmission = $$props.includeSpontaneousEmission);
		if ("includeAttachmentRate" in $$props) $$invalidate(20, includeAttachmentRate = $$props.includeAttachmentRate);
		if ("variable" in $$props) $$invalidate(21, variable = $$props.variable);
		if ("variableRange" in $$props) $$invalidate(22, variableRange = $$props.variableRange);
		if ("deexcitation" in $$props) $$invalidate(30, deexcitation = $$props.deexcitation);
		if ("collisionalCoefficient" in $$props) $$invalidate(4, collisionalCoefficient = $$props.collisionalCoefficient);
		if ("reportToggle" in $$props) $$invalidate(5, reportToggle = $$props.reportToggle);
		if ("buttonName" in $$props) $$invalidate(23, buttonName = $$props.buttonName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*collisionalRateType*/ 2) {
			 $$invalidate(30, deexcitation = collisionalRateType === "deexcitation");
		}

		if ($$self.$$.dirty[0] & /*numberOfLevels, deexcitation*/ 1073741828) {
			 $$invalidate(4, collisionalCoefficient = _.range(1, numberOfLevels).map(j => _.range(j).map(jj => deexcitation
			? {
					label: `q_${j}${jj}`,
					value: 0,
					id: window.getID()
				}
			: {
					label: `q_${jj}${j}`,
					value: 0,
					id: window.getID()
				})));
		}

		if ($$self.$$.dirty[0] & /*collisionalCoefficient*/ 16) {
			 console.log(collisionalCoefficient);
		}

		if ($$self.$$.dirty[0] & /*reportToggle*/ 32) {
			 $$invalidate(23, buttonName = reportToggle ? "Go Back" : "Status report");
		}

		if ($$self.$$.dirty[0] & /*statusReport*/ 8) {
			 console.log(statusReport);
		}
	};

	 $$invalidate(5, reportToggle = false);

	return [
		active,
		collisionalRateType,
		numberOfLevels,
		statusReport,
		collisionalCoefficient,
		reportToggle,
		mainParameters,
		simulationParameters,
		dopplerLineshape,
		powerBroadening,
		einsteinCoefficient,
		trapTemp,
		rateCoefficients,
		py,
		running,
		currentLocation,
		filename,
		writefile,
		includeCollision,
		includeSpontaneousEmission,
		includeAttachmentRate,
		variable,
		variableRange,
		buttonName,
		pyEventHandle,
		pyEventDataReceivedHandle,
		pyEventClosedHandle,
		simulation,
		browse_folder,
		variablesList,
		deexcitation,
		textfield0_value_binding,
		textfield1_value_binding,
		customcheckbox0_selected_binding,
		customcheckbox1_selected_binding,
		customcheckbox2_selected_binding,
		customcheckbox3_selected_binding,
		customselect_picked_binding,
		textfield2_value_binding,
		textfield_value_binding,
		textfield_value_binding_1,
		textfield3_value_binding,
		textfield_value_binding_2,
		textfield_value_binding_3,
		textfield_value_binding_4,
		customselect_picked_binding_1,
		textfield_value_binding_5,
		textfield_value_binding_6,
		click_handler,
		click_handler_1,
		modal_active_binding
	];
}

class ROSAA extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, { active: 0 }, [-1, -1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ROSAA",
			options,
			id: create_fragment$1l.name
		});
	}

	get active() {
		throw new Error("<ROSAA>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<ROSAA>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\THz.svelte generated by Svelte v3.31.2 */
const file$1f = "src\\Pages\\THz.svelte";

// (104:4) <div class="thz_buttonContainer" slot="buttonContainer">
function create_buttonContainer_slot$3(ctx) {
	let div0;
	let div2;
	let button0;
	let t0;
	let button0_class_value;
	let t1;
	let button1;
	let t2;
	let button1_class_value;
	let t3;
	let customswitch0;
	let updating_selected;
	let t4;
	let button2;
	let t5;
	let button2_class_value;
	let t6;
	let button3;
	let t7;
	let button3_class_value;
	let t8;
	let customiconswitch;
	let updating_toggler;
	let t9;
	let button4;
	let t10;
	let button4_class_value;
	let t11;
	let textfield0;
	let updating_value;
	let t12;
	let textfield1;
	let updating_value_1;
	let t13;
	let div1;
	let customselect;
	let updating_picked;
	let t14;
	let customswitch1;
	let updating_selected_1;
	let t15;
	let div3;
	let textfield2;
	let updating_value_2;
	let t16;
	let textfield3;
	let updating_value_3;
	let t17;
	let textfield4;
	let updating_value_4;
	let t18;
	let textfield5;
	let updating_value_5;
	let t19;
	let textfield6;
	let updating_value_6;
	let t20;
	let button5;
	let t21;
	let button5_class_value;
	let t22;
	let button6;
	let t23;
	let button6_class_value;
	let current;
	let mounted;
	let dispose;

	function customswitch0_selected_binding(value) {
		/*customswitch0_selected_binding*/ ctx[25].call(null, value);
	}

	let customswitch0_props = { label: "Bin", style: "margin:0 1em;" };

	if (/*binData*/ ctx[14] !== void 0) {
		customswitch0_props.selected = /*binData*/ ctx[14];
	}

	customswitch0 = new CustomSwitch({
			props: customswitch0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch0, "selected", customswitch0_selected_binding));

	function customiconswitch_toggler_binding(value) {
		/*customiconswitch_toggler_binding*/ ctx[28].call(null, value);
	}

	let customiconswitch_props = {
		style: "padding:0;",
		icons: ["settings_ethernet", "code"]
	};

	if (/*openShell*/ ctx[2] !== void 0) {
		customiconswitch_props.toggler = /*openShell*/ ctx[2];
	}

	customiconswitch = new CustomIconSwitch({
			props: customiconswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customiconswitch, "toggler", customiconswitch_toggler_binding));

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[30].call(null, value);
	}

	let textfield0_props = {
		type: "number",
		style: "width:4em; height:3.5em; margin-right:0.5em",
		label: "Delta"
	};

	if (/*delta*/ ctx[4] !== void 0) {
		textfield0_props.value = /*delta*/ ctx[4];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[31].call(null, value);
	}

	let textfield1_props = {
		type: "number",
		style: "width:4em; height:3.5em; margin-right:0.5em",
		label: "Gamma"
	};

	if (/*gamma*/ ctx[5] !== void 0) {
		textfield1_props.value = /*gamma*/ ctx[5];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[32].call(null, value);
	}

	let customselect_props = {
		options: /*plotStyle*/ ctx[17],
		label: "Plot Style"
	};

	if (/*plotStyleSelected*/ ctx[12] !== void 0) {
		customselect_props.picked = /*plotStyleSelected*/ ctx[12];
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function customswitch1_selected_binding(value) {
		/*customswitch1_selected_binding*/ ctx[33].call(null, value);
	}

	let customswitch1_props = { label: "Fill area" };

	if (/*plotFill*/ ctx[13] !== void 0) {
		customswitch1_props.selected = /*plotFill*/ ctx[13];
	}

	customswitch1 = new CustomSwitch({
			props: customswitch1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch1, "selected", customswitch1_selected_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[34].call(null, value);
	}

	let textfield2_props = { type: "number", style: style$4, label: "B0 (MHz)" };

	if (/*B0*/ ctx[6] !== void 0) {
		textfield2_props.value = /*B0*/ ctx[6];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[35].call(null, value);
	}

	let textfield3_props = { type: "number", style: style$4, label: "D0 (MHz)" };

	if (/*D0*/ ctx[7] !== void 0) {
		textfield3_props.value = /*D0*/ ctx[7];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[36].call(null, value);
	}

	let textfield4_props = { type: "number", style: style$4, label: "H0 (MHz)" };

	if (/*H0*/ ctx[8] !== void 0) {
		textfield4_props.value = /*H0*/ ctx[8];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));

	function textfield5_value_binding(value) {
		/*textfield5_value_binding*/ ctx[37].call(null, value);
	}

	let textfield5_props = { type: "number", style: style$4, label: "Temp." };

	if (/*temp*/ ctx[9] !== void 0) {
		textfield5_props.value = /*temp*/ ctx[9];
	}

	textfield5 = new Textfield({ props: textfield5_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield5, "value", textfield5_value_binding));

	function textfield6_value_binding(value) {
		/*textfield6_value_binding*/ ctx[38].call(null, value);
	}

	let textfield6_props = { type: "number", style: style$4, label: "Total J" };

	if (/*totalJ*/ ctx[10] !== void 0) {
		textfield6_props.value = /*totalJ*/ ctx[10];
	}

	textfield6 = new Textfield({ props: textfield6_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield6, "value", textfield6_value_binding));

	const block = {
		c: function create() {
			div0 = element("div");
			div2 = element("div");
			button0 = element("button");
			t0 = text("ROSAA");
			t1 = space();
			button1 = element("button");
			t2 = text("Plot");
			t3 = space();
			create_component(customswitch0.$$.fragment);
			t4 = space();
			button2 = element("button");
			t5 = text("Fit");
			t6 = space();
			button3 = element("button");
			t7 = text("Open in Matplotlib");
			t8 = space();
			create_component(customiconswitch.$$.fragment);
			t9 = space();
			button4 = element("button");
			t10 = text("Boltzman");
			t11 = space();
			create_component(textfield0.$$.fragment);
			t12 = space();
			create_component(textfield1.$$.fragment);
			t13 = space();
			div1 = element("div");
			create_component(customselect.$$.fragment);
			t14 = space();
			create_component(customswitch1.$$.fragment);
			t15 = space();
			div3 = element("div");
			create_component(textfield2.$$.fragment);
			t16 = space();
			create_component(textfield3.$$.fragment);
			t17 = space();
			create_component(textfield4.$$.fragment);
			t18 = space();
			create_component(textfield5.$$.fragment);
			t19 = space();
			create_component(textfield6.$$.fragment);
			t20 = space();
			button5 = element("button");
			t21 = text("Submit");
			t22 = space();
			button6 = element("button");
			t23 = text("Open in Matplotlib");
			attr_dev(button0, "class", button0_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button0, file$1f, 106, 12, 4287);
			attr_dev(button1, "class", button1_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button1, file$1f, 108, 12, 4387);
			attr_dev(button2, "class", button2_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button2, file$1f, 111, 12, 4581);
			attr_dev(button3, "class", button3_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button3, file$1f, 112, 12, 4670);
			attr_dev(button4, "class", button4_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button4, file$1f, 114, 12, 4902);
			attr_dev(div1, "class", "animated fadeIn svelte-1d0ouw7");
			toggle_class(div1, "hide", !/*graphPlotted*/ ctx[3]);
			add_location(div1, file$1f, 118, 12, 5256);
			attr_dev(div2, "class", "content align buttonRow svelte-1d0ouw7");
			add_location(div2, file$1f, 105, 8, 4236);
			attr_dev(button5, "class", button5_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button5, file$1f, 132, 12, 6064);
			attr_dev(button6, "class", button6_class_value = "" + (null_to_empty(btnClass) + " svelte-1d0ouw7"));
			add_location(button6, file$1f, 133, 12, 6175);
			attr_dev(div3, "class", "animated fadeIn buttonRow svelte-1d0ouw7");
			toggle_class(div3, "hide", !/*toggleRow*/ ctx[11]);
			add_location(div3, file$1f, 126, 8, 5572);
			attr_dev(div0, "class", "thz_buttonContainer svelte-1d0ouw7");
			attr_dev(div0, "slot", "buttonContainer");
			add_location(div0, file$1f, 103, 4, 4168);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div2);
			append_dev(div2, button0);
			append_dev(button0, t0);
			append_dev(div2, t1);
			append_dev(div2, button1);
			append_dev(button1, t2);
			append_dev(div2, t3);
			mount_component(customswitch0, div2, null);
			append_dev(div2, t4);
			append_dev(div2, button2);
			append_dev(button2, t5);
			append_dev(div2, t6);
			append_dev(div2, button3);
			append_dev(button3, t7);
			append_dev(div2, t8);
			mount_component(customiconswitch, div2, null);
			append_dev(div2, t9);
			append_dev(div2, button4);
			append_dev(button4, t10);
			append_dev(div2, t11);
			mount_component(textfield0, div2, null);
			append_dev(div2, t12);
			mount_component(textfield1, div2, null);
			append_dev(div2, t13);
			append_dev(div2, div1);
			mount_component(customselect, div1, null);
			append_dev(div1, t14);
			mount_component(customswitch1, div1, null);
			append_dev(div0, t15);
			append_dev(div0, div3);
			mount_component(textfield2, div3, null);
			append_dev(div3, t16);
			mount_component(textfield3, div3, null);
			append_dev(div3, t17);
			mount_component(textfield4, div3, null);
			append_dev(div3, t18);
			mount_component(textfield5, div3, null);
			append_dev(div3, t19);
			mount_component(textfield6, div3, null);
			append_dev(div3, t20);
			append_dev(div3, button5);
			append_dev(button5, t21);
			append_dev(div3, t22);
			append_dev(div3, button6);
			append_dev(button6, t23);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[23], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[24], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[26], false, false, false),
					listen_dev(button3, "click", /*click_handler_3*/ ctx[27], false, false, false),
					listen_dev(button4, "click", /*click_handler_4*/ ctx[29], false, false, false),
					listen_dev(div1, "change", /*changePlotStyle*/ ctx[18], false, false, false),
					listen_dev(button5, "click", /*click_handler_5*/ ctx[39], false, false, false),
					listen_dev(button6, "click", /*click_handler_6*/ ctx[40], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const customswitch0_changes = {};

			if (!updating_selected && dirty[0] & /*binData*/ 16384) {
				updating_selected = true;
				customswitch0_changes.selected = /*binData*/ ctx[14];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch0.$set(customswitch0_changes);
			const customiconswitch_changes = {};

			if (!updating_toggler && dirty[0] & /*openShell*/ 4) {
				updating_toggler = true;
				customiconswitch_changes.toggler = /*openShell*/ ctx[2];
				add_flush_callback(() => updating_toggler = false);
			}

			customiconswitch.$set(customiconswitch_changes);
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*delta*/ 16) {
				updating_value = true;
				textfield0_changes.value = /*delta*/ ctx[4];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*gamma*/ 32) {
				updating_value_1 = true;
				textfield1_changes.value = /*gamma*/ ctx[5];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const customselect_changes = {};

			if (!updating_picked && dirty[0] & /*plotStyleSelected*/ 4096) {
				updating_picked = true;
				customselect_changes.picked = /*plotStyleSelected*/ ctx[12];
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const customswitch1_changes = {};

			if (!updating_selected_1 && dirty[0] & /*plotFill*/ 8192) {
				updating_selected_1 = true;
				customswitch1_changes.selected = /*plotFill*/ ctx[13];
				add_flush_callback(() => updating_selected_1 = false);
			}

			customswitch1.$set(customswitch1_changes);

			if (dirty[0] & /*graphPlotted*/ 8) {
				toggle_class(div1, "hide", !/*graphPlotted*/ ctx[3]);
			}

			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*B0*/ 64) {
				updating_value_2 = true;
				textfield2_changes.value = /*B0*/ ctx[6];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*D0*/ 128) {
				updating_value_3 = true;
				textfield3_changes.value = /*D0*/ ctx[7];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty[0] & /*H0*/ 256) {
				updating_value_4 = true;
				textfield4_changes.value = /*H0*/ ctx[8];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);
			const textfield5_changes = {};

			if (!updating_value_5 && dirty[0] & /*temp*/ 512) {
				updating_value_5 = true;
				textfield5_changes.value = /*temp*/ ctx[9];
				add_flush_callback(() => updating_value_5 = false);
			}

			textfield5.$set(textfield5_changes);
			const textfield6_changes = {};

			if (!updating_value_6 && dirty[0] & /*totalJ*/ 1024) {
				updating_value_6 = true;
				textfield6_changes.value = /*totalJ*/ ctx[10];
				add_flush_callback(() => updating_value_6 = false);
			}

			textfield6.$set(textfield6_changes);

			if (dirty[0] & /*toggleRow*/ 2048) {
				toggle_class(div3, "hide", !/*toggleRow*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(customswitch0.$$.fragment, local);
			transition_in(customiconswitch.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(customselect.$$.fragment, local);
			transition_in(customswitch1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);
			transition_in(textfield5.$$.fragment, local);
			transition_in(textfield6.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(customswitch0.$$.fragment, local);
			transition_out(customiconswitch.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(customselect.$$.fragment, local);
			transition_out(customswitch1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			transition_out(textfield5.$$.fragment, local);
			transition_out(textfield6.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(customswitch0);
			destroy_component(customiconswitch);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(customselect);
			destroy_component(customswitch1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(textfield4);
			destroy_component(textfield5);
			destroy_component(textfield6);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttonContainer_slot$3.name,
		type: "slot",
		source: "(104:4) <div class=\\\"thz_buttonContainer\\\" slot=\\\"buttonContainer\\\">",
		ctx
	});

	return block;
}

// (149:8) {#if graphPlotted}
function create_if_block$x(ctx) {
	let div;
	let reportlayout;
	let updating_currentLocation;
	let current;

	function reportlayout_currentLocation_binding(value) {
		/*reportlayout_currentLocation_binding*/ ctx[41].call(null, value);
	}

	let reportlayout_props = {
		id: `${filetype$3}_report`,
		includePlotsInReport: /*includePlotsInReport*/ ctx[20]
	};

	if (/*currentLocation*/ ctx[1] !== void 0) {
		reportlayout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	reportlayout = new ReportLayout({
			props: reportlayout_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(reportlayout, "currentLocation", reportlayout_currentLocation_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(reportlayout.$$.fragment);
			attr_dev(div, "class", "animated fadeIn svelte-1d0ouw7");
			set_style(div, "flex-direction", "column ");
			add_location(div, file$1f, 149, 12, 6695);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(reportlayout, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const reportlayout_changes = {};

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				reportlayout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			reportlayout.$set(reportlayout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(reportlayout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(reportlayout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(reportlayout);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$x.name,
		type: "if",
		source: "(149:8) {#if graphPlotted}",
		ctx
	});

	return block;
}

// (139:4) <div style="margin-right: 1em;" slot="plotContainer">
function create_plotContainer_slot$3(ctx) {
	let div0;
	let div1;
	let t0;
	let div2;
	let t1;
	let div3;
	let t2;
	let current;
	let if_block = /*graphPlotted*/ ctx[3] && create_if_block$x(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			t0 = space();
			div2 = element("div");
			t1 = space();
			div3 = element("div");
			t2 = space();
			if (if_block) if_block.c();
			attr_dev(div1, "id", "resOnOffPlot");
			set_style(div1, "margin-bottom", "1em");
			attr_dev(div1, "class", "svelte-1d0ouw7");
			add_location(div1, file$1f, 142, 8, 6436);
			attr_dev(div2, "id", "thzPlot");
			set_style(div2, "margin-bottom", "1em");
			attr_dev(div2, "class", "svelte-1d0ouw7");
			add_location(div2, file$1f, 143, 8, 6503);
			attr_dev(div3, "id", "boltzman_plot");
			set_style(div3, "margin-bottom", "1em");
			attr_dev(div3, "class", "svelte-1d0ouw7");
			add_location(div3, file$1f, 144, 8, 6565);
			set_style(div0, "margin-right", "1em");
			attr_dev(div0, "slot", "plotContainer");
			attr_dev(div0, "class", "svelte-1d0ouw7");
			add_location(div0, file$1f, 138, 4, 6337);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div0, t0);
			append_dev(div0, div2);
			append_dev(div0, t1);
			append_dev(div0, div3);
			append_dev(div0, t2);
			if (if_block) if_block.m(div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*graphPlotted*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*graphPlotted*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$x(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_plotContainer_slot$3.name,
		type: "slot",
		source: "(139:4) <div style=\\\"margin-right: 1em;\\\" slot=\\\"plotContainer\\\">",
		ctx
	});

	return block;
}

// (102:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked>
function create_default_slot$y(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$y.name,
		type: "slot",
		source: "(102:0) <Layout bind:preModal {filetype} {id} bind:currentLocation bind:fileChecked>",
		ctx
	});

	return block;
}

function create_fragment$1m(ctx) {
	let rosaa;
	let updating_active;
	let t;
	let layout;
	let updating_preModal;
	let updating_currentLocation;
	let updating_fileChecked;
	let current;

	function rosaa_active_binding(value) {
		/*rosaa_active_binding*/ ctx[21].call(null, value);
	}

	let rosaa_props = {};

	if (/*ROSAA_modal_active*/ ctx[16] !== void 0) {
		rosaa_props.active = /*ROSAA_modal_active*/ ctx[16];
	}

	rosaa = new ROSAA({ props: rosaa_props, $$inline: true });
	binding_callbacks.push(() => bind(rosaa, "active", rosaa_active_binding));
	rosaa.$on("submit", /*submit_handler*/ ctx[22]);

	function layout_preModal_binding(value) {
		/*layout_preModal_binding*/ ctx[42].call(null, value);
	}

	function layout_currentLocation_binding(value) {
		/*layout_currentLocation_binding*/ ctx[43].call(null, value);
	}

	function layout_fileChecked_binding(value) {
		/*layout_fileChecked_binding*/ ctx[44].call(null, value);
	}

	let layout_props = {
		filetype: filetype$3,
		id: id$3,
		$$slots: {
			default: [create_default_slot$y],
			plotContainer: [create_plotContainer_slot$3],
			buttonContainer: [create_buttonContainer_slot$3]
		},
		$$scope: { ctx }
	};

	if (/*preModal*/ ctx[15] !== void 0) {
		layout_props.preModal = /*preModal*/ ctx[15];
	}

	if (/*currentLocation*/ ctx[1] !== void 0) {
		layout_props.currentLocation = /*currentLocation*/ ctx[1];
	}

	if (/*fileChecked*/ ctx[0] !== void 0) {
		layout_props.fileChecked = /*fileChecked*/ ctx[0];
	}

	layout = new Layout({ props: layout_props, $$inline: true });
	binding_callbacks.push(() => bind(layout, "preModal", layout_preModal_binding));
	binding_callbacks.push(() => bind(layout, "currentLocation", layout_currentLocation_binding));
	binding_callbacks.push(() => bind(layout, "fileChecked", layout_fileChecked_binding));

	const block = {
		c: function create() {
			create_component(rosaa.$$.fragment);
			t = space();
			create_component(layout.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(rosaa, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(layout, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const rosaa_changes = {};

			if (!updating_active && dirty[0] & /*ROSAA_modal_active*/ 65536) {
				updating_active = true;
				rosaa_changes.active = /*ROSAA_modal_active*/ ctx[16];
				add_flush_callback(() => updating_active = false);
			}

			rosaa.$set(rosaa_changes);
			const layout_changes = {};

			if (dirty[0] & /*currentLocation, graphPlotted, toggleRow, totalJ, temp, H0, D0, B0, plotFill, plotStyleSelected, gamma, delta, openShell, binData, ROSAA_modal_active*/ 98302 | dirty[1] & /*$$scope*/ 32768) {
				layout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_preModal && dirty[0] & /*preModal*/ 32768) {
				updating_preModal = true;
				layout_changes.preModal = /*preModal*/ ctx[15];
				add_flush_callback(() => updating_preModal = false);
			}

			if (!updating_currentLocation && dirty[0] & /*currentLocation*/ 2) {
				updating_currentLocation = true;
				layout_changes.currentLocation = /*currentLocation*/ ctx[1];
				add_flush_callback(() => updating_currentLocation = false);
			}

			if (!updating_fileChecked && dirty[0] & /*fileChecked*/ 1) {
				updating_fileChecked = true;
				layout_changes.fileChecked = /*fileChecked*/ ctx[0];
				add_flush_callback(() => updating_fileChecked = false);
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(rosaa.$$.fragment, local);
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(rosaa.$$.fragment, local);
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(rosaa, detaching);
			if (detaching) detach_dev(t);
			destroy_component(layout, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const filetype$3 = "thz", id$3 = "THz";
const style$4 = "width:7em; height:3.5em; margin-right:0.5em";
const btnClass = "button is-link";

function instance$1m($$self, $$props, $$invalidate) {
	let thzfiles;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("THz", slots, []);
	let fileChecked = [];
	let currentLocation = localStorage[`${filetype$3}_location`] || "";
	let openShell = false, graphPlotted = false;
	let delta = 10, gamma = 0;
	let B0 = 0, D0 = 0, H0 = 0, temp = 300, totalJ = 20;

	// Depletion Row
	let toggleRow = false;

	const plotStyle = ["", "lines", "markers", "lines+markers"];
	let plotStyleSelected = plotStyle[3], plotFill = true;
	let binData = false;

	const changePlotStyle = () => {
		Plotly.restyle("thzPlot", {
			mode: plotStyleSelected,
			fill: plotFill ? "tozeroy" : ""
		});
	};

	function plotData(
		{ e = null, filetype = "thz", tkplot = "run", justPlot = false, general = {} } = {}
	) {
		if (fileChecked.length === 0 && filetype === "thz") {
			return window.createToast("No files selected", "danger");
		}

		let pyfileInfo = {
			general,
			thz: {
				pyfile: "thz_scan.py",
				args: [...thzfiles, binData, delta, tkplot, gamma, justPlot]
			},
			boltzman: {
				pyfile: "boltzman.py",
				args: [currentLocation, B0, D0, H0, temp, totalJ, tkplot]
			}
		};

		let { pyfile, args } = pyfileInfo[filetype];

		if (tkplot == "plot") {
			filetype = "general";
		}

		if (filetype == "general") {
			return computePy_func({
				e,
				pyfile,
				args,
				general: true,
				openShell
			}).catch(err => {
				$$invalidate(15, preModal.modalContent = err, preModal);
				$$invalidate(15, preModal.open = true, preModal);
			});
		}

		computePy_func({ e, pyfile, args }).then(dataFromPython => {
			if (filetype == "thz") {
				plot(`THz Scan: Depletion (%)`, "Frequency (GHz)", "Depletion (%)", dataFromPython["thz"], "thzPlot");
				plot(`THz Scan`, "Frequency (GHz)", "Counts", dataFromPython["resOnOff_Counts"], "resOnOffPlot");

				if (!justPlot) {
					let lines = [];

					for (let x in dataFromPython["shapes"]) {
						lines.push(dataFromPython["shapes"][x]);
					}

					let layout_update = { shapes: lines };
					Plotly.relayout("thzPlot", layout_update);
				}
			} else if (filetype == "boltzman") {
				plot(`Boltzman Distribution`, "Rotational levels (J)", "Probability (%)", dataFromPython, "boltzman_plot");
			}

			window.createToast("Graph plotted", "success");
			$$invalidate(3, graphPlotted = true);
		}).catch(err => {
			$$invalidate(15, preModal.modalContent = err, preModal);
			$$invalidate(15, preModal.open = true, preModal);
		});
	}

	let includePlotsInReport = [
		{
			id: "resOnOffPlot",
			include: false,
			label: "THz Res-ON/OFF"
		},
		{
			id: "thzPlot",
			include: true,
			label: "Normalised THz Spectrum"
		},
		{
			id: "boltzman_plot",
			include: false,
			label: "Boltzman plot"
		}
	];

	let preModal = {};
	let ROSAA_modal_active = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<THz> was created with unknown prop '${key}'`);
	});

	function rosaa_active_binding(value) {
		ROSAA_modal_active = value;
		$$invalidate(16, ROSAA_modal_active);
	}

	const submit_handler = e => {
		plotData({
			e: e.detail.e,
			filetype: "general",
			general: {
				pyfile: "ROSAA.py",
				args: [JSON.stringify(e.detail.conditions)]
			}
		});
	};

	const click_handler = () => {
		$$invalidate(16, ROSAA_modal_active = true);
	};

	const click_handler_1 = e => {
		plotData({ e, justPlot: true });
	};

	function customswitch0_selected_binding(value) {
		binData = value;
		$$invalidate(14, binData);
	}

	const click_handler_2 = e => {
		plotData({ e });
	};

	const click_handler_3 = e => plotData({ e, tkplot: "plot" });

	function customiconswitch_toggler_binding(value) {
		openShell = value;
		$$invalidate(2, openShell);
	}

	const click_handler_4 = () => {
		$$invalidate(11, toggleRow = !toggleRow);
	};

	function textfield0_value_binding(value) {
		delta = value;
		$$invalidate(4, delta);
	}

	function textfield1_value_binding(value) {
		gamma = value;
		$$invalidate(5, gamma);
	}

	function customselect_picked_binding(value) {
		plotStyleSelected = value;
		$$invalidate(12, plotStyleSelected);
	}

	function customswitch1_selected_binding(value) {
		plotFill = value;
		$$invalidate(13, plotFill);
	}

	function textfield2_value_binding(value) {
		B0 = value;
		$$invalidate(6, B0);
	}

	function textfield3_value_binding(value) {
		D0 = value;
		$$invalidate(7, D0);
	}

	function textfield4_value_binding(value) {
		H0 = value;
		$$invalidate(8, H0);
	}

	function textfield5_value_binding(value) {
		temp = value;
		$$invalidate(9, temp);
	}

	function textfield6_value_binding(value) {
		totalJ = value;
		$$invalidate(10, totalJ);
	}

	const click_handler_5 = e => plotData({ e, filetype: "boltzman" });
	const click_handler_6 = e => plotData({ e, filetype: "boltzman", tkplot: "plot" });

	function reportlayout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_preModal_binding(value) {
		preModal = value;
		$$invalidate(15, preModal);
	}

	function layout_currentLocation_binding(value) {
		currentLocation = value;
		$$invalidate(1, currentLocation);
	}

	function layout_fileChecked_binding(value) {
		fileChecked = value;
		$$invalidate(0, fileChecked);
	}

	$$self.$capture_state = () => ({
		Layout,
		CustomIconSwitch,
		CustomSelect,
		CustomSwitch,
		ReportLayout,
		Textfield,
		plot,
		ROSAA,
		filetype: filetype$3,
		id: id$3,
		fileChecked,
		currentLocation,
		openShell,
		graphPlotted,
		delta,
		gamma,
		B0,
		D0,
		H0,
		temp,
		totalJ,
		toggleRow,
		style: style$4,
		btnClass,
		plotStyle,
		plotStyleSelected,
		plotFill,
		binData,
		changePlotStyle,
		plotData,
		includePlotsInReport,
		preModal,
		ROSAA_modal_active,
		thzfiles
	});

	$$self.$inject_state = $$props => {
		if ("fileChecked" in $$props) $$invalidate(0, fileChecked = $$props.fileChecked);
		if ("currentLocation" in $$props) $$invalidate(1, currentLocation = $$props.currentLocation);
		if ("openShell" in $$props) $$invalidate(2, openShell = $$props.openShell);
		if ("graphPlotted" in $$props) $$invalidate(3, graphPlotted = $$props.graphPlotted);
		if ("delta" in $$props) $$invalidate(4, delta = $$props.delta);
		if ("gamma" in $$props) $$invalidate(5, gamma = $$props.gamma);
		if ("B0" in $$props) $$invalidate(6, B0 = $$props.B0);
		if ("D0" in $$props) $$invalidate(7, D0 = $$props.D0);
		if ("H0" in $$props) $$invalidate(8, H0 = $$props.H0);
		if ("temp" in $$props) $$invalidate(9, temp = $$props.temp);
		if ("totalJ" in $$props) $$invalidate(10, totalJ = $$props.totalJ);
		if ("toggleRow" in $$props) $$invalidate(11, toggleRow = $$props.toggleRow);
		if ("plotStyleSelected" in $$props) $$invalidate(12, plotStyleSelected = $$props.plotStyleSelected);
		if ("plotFill" in $$props) $$invalidate(13, plotFill = $$props.plotFill);
		if ("binData" in $$props) $$invalidate(14, binData = $$props.binData);
		if ("includePlotsInReport" in $$props) $$invalidate(20, includePlotsInReport = $$props.includePlotsInReport);
		if ("preModal" in $$props) $$invalidate(15, preModal = $$props.preModal);
		if ("ROSAA_modal_active" in $$props) $$invalidate(16, ROSAA_modal_active = $$props.ROSAA_modal_active);
		if ("thzfiles" in $$props) thzfiles = $$props.thzfiles;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*fileChecked, currentLocation*/ 3) {
			 thzfiles = fileChecked.map(file => path.resolve(currentLocation, file));
		}
	};

	return [
		fileChecked,
		currentLocation,
		openShell,
		graphPlotted,
		delta,
		gamma,
		B0,
		D0,
		H0,
		temp,
		totalJ,
		toggleRow,
		plotStyleSelected,
		plotFill,
		binData,
		preModal,
		ROSAA_modal_active,
		plotStyle,
		changePlotStyle,
		plotData,
		includePlotsInReport,
		rosaa_active_binding,
		submit_handler,
		click_handler,
		click_handler_1,
		customswitch0_selected_binding,
		click_handler_2,
		click_handler_3,
		customiconswitch_toggler_binding,
		click_handler_4,
		textfield0_value_binding,
		textfield1_value_binding,
		customselect_picked_binding,
		customswitch1_selected_binding,
		textfield2_value_binding,
		textfield3_value_binding,
		textfield4_value_binding,
		textfield5_value_binding,
		textfield6_value_binding,
		click_handler_5,
		click_handler_6,
		reportlayout_currentLocation_binding,
		layout_preModal_binding,
		layout_currentLocation_binding,
		layout_fileChecked_binding
	];
}

class THz extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "THz",
			options,
			id: create_fragment$1m.name
		});
	}
}

/* src\components\Changelog.svelte generated by Svelte v3.31.2 */
const file$1g = "src\\components\\Changelog.svelte";

// (61:0) {#if $activateChangelog && $windowLoaded}
function create_if_block$y(ctx) {
	let modal;
	let updating_active;
	let current;

	function modal_active_binding(value) {
		/*modal_active_binding*/ ctx[8].call(null, value);
	}

	let modal_props = {
		title: /*changelogTitle*/ ctx[2],
		$$slots: {
			default: [create_default_slot$z],
			footerbtn: [create_footerbtn_slot$5],
			content: [create_content_slot$7]
		},
		$$scope: { ctx }
	};

	if (/*$activateChangelog*/ ctx[3] !== void 0) {
		modal_props.active = /*$activateChangelog*/ ctx[3];
	}

	modal = new Modal({ props: modal_props, $$inline: true });
	binding_callbacks.push(() => bind(modal, "active", modal_active_binding));

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modal_changes = {};
			if (dirty & /*changelogTitle*/ 4) modal_changes.title = /*changelogTitle*/ ctx[2];

			if (dirty & /*$$scope, $updating, $updateAvailable, changelogContent*/ 1059) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty & /*$activateChangelog*/ 8) {
				updating_active = true;
				modal_changes.active = /*$activateChangelog*/ ctx[3];
				add_flush_callback(() => updating_active = false);
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$y.name,
		type: "if",
		source: "(61:0) {#if $activateChangelog && $windowLoaded}",
		ctx
	});

	return block;
}

// (68:12) {:else}
function create_else_block$c(ctx) {
	let html_tag;
	let raw_value = window.marked(/*changelogContent*/ ctx[1]) + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*changelogContent*/ 2 && raw_value !== (raw_value = window.marked(/*changelogContent*/ ctx[1]) + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$c.name,
		type: "else",
		source: "(68:12) {:else}",
		ctx
	});

	return block;
}

// (65:12) {#if $updateAvailable && window.changelogNewContent}
function create_if_block_2$6(ctx) {
	let html_tag;
	let raw_value = window.marked(window.changelogNewContent) + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(65:12) {#if $updateAvailable && window.changelogNewContent}",
		ctx
	});

	return block;
}

// (64:8) <div slot="content" transition:fade style="user-select:text;">
function create_content_slot$7(ctx) {
	let div;
	let div_transition;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*$updateAvailable*/ ctx[0] && window.changelogNewContent) return create_if_block_2$6;
		return create_else_block$c;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "slot", "content");
			set_style(div, "user-select", "text");
			add_location(div, file$1g, 63, 8, 1470);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$7.name,
		type: "slot",
		source: "(64:8) <div slot=\\\"content\\\" transition:fade style=\\\"user-select:text;\\\">",
		ctx
	});

	return block;
}

// (75:12) {#if $updateAvailable}
function create_if_block_1$c(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "Update Now";
			attr_dev(button, "class", "button is-warning");
			toggle_class(button, "is-loading", /*$updating*/ ctx[5]);
			add_location(button, file$1g, 75, 16, 1878);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*updateNow*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$updating*/ 32) {
				toggle_class(button, "is-loading", /*$updating*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$c.name,
		type: "if",
		source: "(75:12) {#if $updateAvailable}",
		ctx
	});

	return block;
}

// (74:8) <div slot="footerbtn">
function create_footerbtn_slot$5(ctx) {
	let div;
	let if_block = /*$updateAvailable*/ ctx[0] && create_if_block_1$c(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			attr_dev(div, "slot", "footerbtn");
			add_location(div, file$1g, 73, 8, 1802);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (/*$updateAvailable*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$c(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footerbtn_slot$5.name,
		type: "slot",
		source: "(74:8) <div slot=\\\"footerbtn\\\">",
		ctx
	});

	return block;
}

// (63:4) <Modal title={changelogTitle} bind:active={$activateChangelog}>
function create_default_slot$z(ctx) {
	let t;

	const block = {
		c: function create() {
			t = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$z.name,
		type: "slot",
		source: "(63:4) <Modal title={changelogTitle} bind:active={$activateChangelog}>",
		ctx
	});

	return block;
}

function create_fragment$1n(ctx) {
	let html_tag;

	let raw_value = `<style>

ul {padding-left: 1em;}

li {list-style: disc;}

h1 {
    color: #fafafa;
    font-size: 2rem;
    font-weight: 600;
    line-height: 1.125;
}

h2 {

    color: #fafafa;
    font-size: 1.25rem;
    font-weight: 400;
    line-height: 1.25;
}


h1, h2 {

    word-break: break-word;
    margin-bottom: 0.5em;
}


</style>` + "";

	let t;
	let if_block_anchor;
	let current;
	let if_block = /*$activateChangelog*/ ctx[3] && /*$windowLoaded*/ ctx[4] && create_if_block$y(ctx);

	const block = {
		c: function create() {
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			html_tag = new HtmlTag(t);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$activateChangelog*/ ctx[3] && /*$windowLoaded*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$activateChangelog, $windowLoaded*/ 24) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$y(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1n($$self, $$props, $$invalidate) {
	let $updateAvailable;
	let $activateChangelog;
	let $newVersion;
	let $windowLoaded;
	let $updating;
	validate_store(updateAvailable, "updateAvailable");
	component_subscribe($$self, updateAvailable, $$value => $$invalidate(0, $updateAvailable = $$value));
	validate_store(activateChangelog, "activateChangelog");
	component_subscribe($$self, activateChangelog, $$value => $$invalidate(3, $activateChangelog = $$value));
	validate_store(newVersion, "newVersion");
	component_subscribe($$self, newVersion, $$value => $$invalidate(7, $newVersion = $$value));
	validate_store(windowLoaded, "windowLoaded");
	component_subscribe($$self, windowLoaded, $$value => $$invalidate(4, $windowLoaded = $$value));
	validate_store(updating, "updating");
	component_subscribe($$self, updating, $$value => $$invalidate(5, $updating = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Changelog", slots, []);
	let changelogContent = fs.readFileSync(path.resolve(__dirname, "../CHANGELOG.md")).toString();

	beforeUpdate(() => {
		$$invalidate(1, changelogContent = fs.readFileSync(path.resolve(__dirname, "../CHANGELOG.md")).toString());
	});

	const updateEvent = new CustomEvent("update", { bubbles: false });

	const updateNow = e => {
		let target = document.getElementById("updateCheckBtn");
		target.dispatchEvent(updateEvent);
	};

	let changelogTitle = "FELion GUI Changelog";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Changelog> was created with unknown prop '${key}'`);
	});

	function modal_active_binding(value) {
		$activateChangelog = value;
		activateChangelog.set($activateChangelog);
	}

	$$self.$capture_state = () => ({
		windowLoaded,
		activateChangelog,
		updateAvailable,
		newVersion,
		updating,
		Modal,
		onMount,
		beforeUpdate,
		fade,
		changelogContent,
		updateEvent,
		updateNow,
		changelogTitle,
		$updateAvailable,
		$activateChangelog,
		$newVersion,
		$windowLoaded,
		$updating
	});

	$$self.$inject_state = $$props => {
		if ("changelogContent" in $$props) $$invalidate(1, changelogContent = $$props.changelogContent);
		if ("changelogTitle" in $$props) $$invalidate(2, changelogTitle = $$props.changelogTitle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$updateAvailable, $newVersion*/ 129) {
			 if ($updateAvailable) {
				set_store_value(activateChangelog, $activateChangelog = true, $activateChangelog);
				$$invalidate(2, changelogTitle = "New update available: " + $newVersion);
			} else {
				$$invalidate(2, changelogTitle = "FELion GUI Changelog");
			}
		}
	};

	return [
		$updateAvailable,
		changelogContent,
		changelogTitle,
		$activateChangelog,
		$windowLoaded,
		$updating,
		updateNow,
		$newVersion,
		modal_active_binding
	];
}

class Changelog extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Changelog",
			options,
			id: create_fragment$1n.name
		});
	}
}

var require$1 = function() {
  var fs = fs$4;
  if (process.versions['electron']) {
	  try {
	    originalFs = originalFs$1;
	    if (Object.keys(originalFs).length > 0) {
	      fs = originalFs;
      }
	  } catch (e) {}
  }
  return fs
};

var fileSystem = {
	require: require$1
};

var constants = {
    /* The local file header */
    LOCHDR           : 30, // LOC header size
    LOCSIG           : 0x04034b50, // "PK\003\004"
    LOCVER           : 4,	// version needed to extract
    LOCFLG           : 6, // general purpose bit flag
    LOCHOW           : 8, // compression method
    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)
    LOCCRC           : 14, // uncompressed file crc-32 value
    LOCSIZ           : 18, // compressed size
    LOCLEN           : 22, // uncompressed size
    LOCNAM           : 26, // filename length
    LOCEXT           : 28, // extra field length

    /* The Data descriptor */
    EXTSIG           : 0x08074b50, // "PK\007\008"
    EXTHDR           : 16, // EXT header size
    EXTCRC           : 4, // uncompressed file crc-32 value
    EXTSIZ           : 8, // compressed size
    EXTLEN           : 12, // uncompressed size

    /* The central directory file header */
    CENHDR           : 46, // CEN header size
    CENSIG           : 0x02014b50, // "PK\001\002"
    CENVEM           : 4, // version made by
    CENVER           : 6, // version needed to extract
    CENFLG           : 8, // encrypt, decrypt flags
    CENHOW           : 10, // compression method
    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)
    CENCRC           : 16, // uncompressed file crc-32 value
    CENSIZ           : 20, // compressed size
    CENLEN           : 24, // uncompressed size
    CENNAM           : 28, // filename length
    CENEXT           : 30, // extra field length
    CENCOM           : 32, // file comment length
    CENDSK           : 34, // volume number start
    CENATT           : 36, // internal file attributes
    CENATX           : 38, // external file attributes (host system dependent)
    CENOFF           : 42, // LOC header offset

    /* The entries in the end of central directory */
    ENDHDR           : 22, // END header size
    ENDSIG           : 0x06054b50, // "PK\005\006"
    ENDSUB           : 8, // number of entries on this disk
    ENDTOT           : 10, // total number of entries
    ENDSIZ           : 12, // central directory size in bytes
    ENDOFF           : 16, // offset of first CEN header
    ENDCOM           : 20, // zip file comment length

    END64HDR         : 20, // zip64 END header size
    END64SIG         : 0x07064b50, // zip64 Locator signature, "PK\006\007"
    END64START       : 4, // number of the disk with the start of the zip64
    END64OFF         : 8, // relative offset of the zip64 end of central directory
    END64NUMDISKS    : 16, // total number of disks

    ZIP64SIG         : 0x06064b50, // zip64 signature, "PK\006\006"
    ZIP64HDR         : 56, // zip64 record minimum size
    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
    ZIP64SIZE        : 4, // zip64 size of the central directory record
    ZIP64VEM         : 12, // zip64 version made by
    ZIP64VER         : 14, // zip64 version needed to extract
    ZIP64DSK         : 16, // zip64 number of this disk
    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory
    ZIP64SUB         : 24, // number of entries on this disk
    ZIP64TOT         : 32, // total number of entries
    ZIP64SIZB        : 40, // zip64 central directory size in bytes
    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number
    ZIP64EXTRA       : 56, // extensible data sector

    /* Compression methods */
    STORED           : 0, // no compression
    SHRUNK           : 1, // shrunk
    REDUCED1         : 2, // reduced with compression factor 1
    REDUCED2         : 3, // reduced with compression factor 2
    REDUCED3         : 4, // reduced with compression factor 3
    REDUCED4         : 5, // reduced with compression factor 4
    IMPLODED         : 6, // imploded
    // 7 reserved
    DEFLATED         : 8, // deflated
    ENHANCED_DEFLATED: 9, // enhanced deflated
    PKWARE           : 10,// PKWare DCL imploded
    // 11 reserved
    BZIP2            : 12, //  compressed using BZIP2
    // 13 reserved
    LZMA             : 14, // LZMA
    // 15-17 reserved
    IBM_TERSE        : 18, // compressed using IBM TERSE
    IBM_LZ77         : 19, //IBM LZ77 z

    /* General purpose bit flag */
    FLG_ENC          : 0,  // encripted file
    FLG_COMP1        : 1,  // compression option
    FLG_COMP2        : 2,  // compression option
    FLG_DESC         : 4,  // data descriptor
    FLG_ENH          : 8,  // enhanced deflation
    FLG_STR          : 16, // strong encryption
    FLG_LNG          : 1024, // language encoding
    FLG_MSK          : 4096, // mask header values

    /* Load type */
    FILE             : 0,
    BUFFER           : 1,
    NONE             : 2,

    /* 4.5 Extensible data fields */
    EF_ID            : 0,
    EF_SIZE          : 2,

    /* Header IDs */
    ID_ZIP64         : 0x0001,
    ID_AVINFO        : 0x0007,
    ID_PFS           : 0x0008,
    ID_OS2           : 0x0009,
    ID_NTFS          : 0x000a,
    ID_OPENVMS       : 0x000c,
    ID_UNIX          : 0x000d,
    ID_FORK          : 0x000e,
    ID_PATCH         : 0x000f,
    ID_X509_PKCS7    : 0x0014,
    ID_X509_CERTID_F : 0x0015,
    ID_X509_CERTID_C : 0x0016,
    ID_STRONGENC     : 0x0017,
    ID_RECORD_MGT    : 0x0018,
    ID_X509_PKCS7_RL : 0x0019,
    ID_IBM1          : 0x0065,
    ID_IBM2          : 0x0066,
    ID_POSZIP        : 0x4690,

    EF_ZIP64_OR_32   : 0xffffffff,
    EF_ZIP64_OR_16   : 0xffff,
    EF_ZIP64_SUNCOMP : 0,
    EF_ZIP64_SCOMP   : 8,
    EF_ZIP64_RHO     : 16,
    EF_ZIP64_DSN     : 24
};

var errors = {
    /* Header error messages */
    "INVALID_LOC" : "Invalid LOC header (bad signature)",
    "INVALID_CEN" : "Invalid CEN header (bad signature)",
    "INVALID_END" : "Invalid END header (bad signature)",

    /* ZipEntry error messages*/
    "NO_DATA" : "Nothing to decompress",
    "BAD_CRC" : "CRC32 checksum failed",
    "FILE_IN_THE_WAY" : "There is a file in the way: %s",
    "UNKNOWN_METHOD" : "Invalid/unsupported compression method",

    /* Inflater error messages */
    "AVAIL_DATA" : "inflate::Available inflate data did not terminate",
    "INVALID_DISTANCE" : "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    "TO_MANY_CODES" : "inflate::Dynamic block code description: too many length or distance codes",
    "INVALID_REPEAT_LEN" : "inflate::Dynamic block code description: repeat more than specified lengths",
    "INVALID_REPEAT_FIRST" : "inflate::Dynamic block code description: repeat lengths with no first length",
    "INCOMPLETE_CODES" : "inflate::Dynamic block code description: code lengths codes incomplete",
    "INVALID_DYN_DISTANCE": "inflate::Dynamic block code description: invalid distance code lengths",
    "INVALID_CODES_LEN": "inflate::Dynamic block code description: invalid literal/length code lengths",
    "INVALID_STORE_BLOCK" : "inflate::Stored block length did not match one's complement",
    "INVALID_BLOCK_TYPE" : "inflate::Invalid block type (type == 3)",

    /* ADM-ZIP error messages */
    "CANT_EXTRACT_FILE" : "Could not extract the file",
    "CANT_OVERRIDE" : "Target file already exists",
    "NO_ZIP" : "No zip file was loaded",
    "NO_ENTRY" : "Entry doesn't exist",
    "DIRECTORY_CONTENT_ERROR" : "A directory cannot have content",
    "FILE_NOT_FOUND" : "File not found: %s",
    "NOT_IMPLEMENTED" : "Not implemented",
    "INVALID_FILENAME" : "Invalid filename",
    "INVALID_FORMAT" : "Invalid or unsupported zip format. No END header found"
};

var fs$1 = fileSystem.require();

fs$1.existsSync = fs$1.existsSync || path$2.existsSync;

var utils = (function() {

    var crcTable = [],
        Constants = constants,
        Errors = errors,

        PATH_SEPARATOR = path$2.sep;


    function mkdirSync(/*String*/path) {
        var resolvedPath = path.split(PATH_SEPARATOR)[0];
        path.split(PATH_SEPARATOR).forEach(function(name) {
            if (!name || name.substr(-1,1) === ":") return;
            resolvedPath += PATH_SEPARATOR + name;
            var stat;
            try {
                stat = fs$1.statSync(resolvedPath);
            } catch (e) {
                fs$1.mkdirSync(resolvedPath);
            }
            if (stat && stat.isFile())
                throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
        });
    }

    function findSync(/*String*/dir, /*RegExp*/pattern, /*Boolean*/recoursive) {
        if (typeof pattern === 'boolean') {
            recoursive = pattern;
            pattern = undefined;
        }
        var files = [];
        fs$1.readdirSync(dir).forEach(function(file) {
            var path = path$2.join(dir, file);

            if (fs$1.statSync(path).isDirectory() && recoursive)
                files = files.concat(findSync(path, pattern, recoursive));

            if (!pattern || pattern.test(path)) {
                files.push(path$2.normalize(path) + (fs$1.statSync(path).isDirectory() ? PATH_SEPARATOR : ""));
            }

        });
        return files;
    }

    function readBigUInt64LE(/*Buffer*/buffer, /*int*/index) {
        var slice = Buffer.from(buffer.slice(index, index + 8));
        slice.swap64();

        return parseInt(`0x${ slice.toString('hex') }`);
    }

    return {
        makeDir : function(/*String*/path) {
            mkdirSync(path);
        },

        crc32 : function(buf) {
            if (typeof buf === 'string') {
                buf = Buffer.alloc(buf.length, buf);
            }
            var b = Buffer.alloc(4);
            if (!crcTable.length) {
                for (var n = 0; n < 256; n++) {
                    var c = n;
                    for (var k = 8; --k >= 0;)  //
                        if ((c & 1) !== 0)  { c = 0xedb88320 ^ (c >>> 1); } else { c = c >>> 1; }
                    if (c < 0) {
                        b.writeInt32LE(c, 0);
                        c = b.readUInt32LE(0);
                    }
                    crcTable[n] = c;
                }
            }
            var crc = 0, off = 0, len = buf.length, c1 = ~crc;
            while(--len >= 0) c1 = crcTable[(c1 ^ buf[off++]) & 0xff] ^ (c1 >>> 8);
            crc = ~c1;
            b.writeInt32LE(crc & 0xffffffff, 0);
            return b.readUInt32LE(0);
        },

        methodToString : function(/*Number*/method) {
            switch (method) {
                case Constants.STORED:
                    return 'STORED (' + method + ')';
                case Constants.DEFLATED:
                    return 'DEFLATED (' + method + ')';
                default:
                    return 'UNSUPPORTED (' + method + ')';
            }

        },

        writeFileTo : function(/*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr) {
            if (fs$1.existsSync(path)) {
                if (!overwrite)
                    return false; // cannot overwrite

                var stat = fs$1.statSync(path);
                if (stat.isDirectory()) {
                    return false;
                }
            }
            var folder = path$2.dirname(path);
            if (!fs$1.existsSync(folder)) {
                mkdirSync(folder);
            }

            var fd;
            try {
                fd = fs$1.openSync(path, 'w', 438); // 0666
            } catch(e) {
                fs$1.chmodSync(path, 438);
                fd = fs$1.openSync(path, 'w', 438);
            }
            if (fd) {
                try {
                    fs$1.writeSync(fd, content, 0, content.length, 0);
                }
                catch (e){
                    throw e;
                }
                finally {
                    fs$1.closeSync(fd);
                }
            }
            fs$1.chmodSync(path, attr || 438);
            return true;
        },

        writeFileToAsync : function(/*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr, /*Function*/callback) {
            if(typeof attr === 'function') {
                callback = attr;
                attr = undefined;
            }

            fs$1.exists(path, function(exists) {
                if(exists && !overwrite)
                    return callback(false);

                fs$1.stat(path, function(err, stat) {
                    if(exists &&stat.isDirectory()) {
                        return callback(false);
                    }

                    var folder = path$2.dirname(path);
                    fs$1.exists(folder, function(exists) {
                        if(!exists)
                            mkdirSync(folder);

                        fs$1.open(path, 'w', 438, function(err, fd) {
                            if(err) {
                                fs$1.chmod(path, 438, function() {
                                    fs$1.open(path, 'w', 438, function(err, fd) {
                                        fs$1.write(fd, content, 0, content.length, 0, function() {
                                            fs$1.close(fd, function() {
                                                fs$1.chmod(path, attr || 438, function() {
                                                    callback(true);
                                                });
                                            });
                                        });
                                    });
                                });
                            } else {
                                if(fd) {
                                    fs$1.write(fd, content, 0, content.length, 0, function() {
                                        fs$1.close(fd, function() {
                                            fs$1.chmod(path, attr || 438, function() {
                                                callback(true);
                                            });
                                        });
                                    });
                                } else {
                                    fs$1.chmod(path, attr || 438, function() {
                                        callback(true);
                                    });
                                }
                            }
                        });
                    });
                });
            });
        },

        findFiles : function(/*String*/path) {
            return findSync(path, true);
        },

        getAttributes : function(/*String*/path) {

        },

        setAttributes : function(/*String*/path) {

        },

        toBuffer : function(input) {
            if (Buffer.isBuffer(input)) {
                return input;
            } else {
                if (input.length === 0) {
                    return Buffer.alloc(0)
                }
                return Buffer.from(input, 'utf8');
            }
        },

        readBigUInt64LE,

        Constants : Constants,
        Errors : Errors
    }
})();

var fs$2 = fileSystem.require();
	
fs$2.existsSync = fs$2.existsSync || path$2.existsSync;

var fattr = function(/*String*/path) {

    var _path = path || "",
        _obj = newAttr(),
        _stat = null;

    function newAttr() {
        return {
            directory : false,
            readonly : false,
            hidden : false,
            executable : false,
            mtime : 0,
            atime : 0
        }
    }

    if (_path && fs$2.existsSync(_path)) {
        _stat = fs$2.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = !!(1 & parseInt ((_stat.mode & parseInt ("777", 8)).toString (8)[0]));
        _obj.readonly = !!(2 & parseInt ((_stat.mode & parseInt ("777", 8)).toString (8)[0]));
        _obj.hidden = path$2.basename(_path)[0] === ".";
    } else {
        console.warn("Invalid path: " + _path);
    }

    return {

        get directory () {
            return _obj.directory;
        },

        get readOnly () {
            return _obj.readonly;
        },

        get hidden () {
            return _obj.hidden;
        },

        get mtime () {
            return _obj.mtime;
        },

        get atime () {
           return _obj.atime;
        },


        get executable () {
            return _obj.executable;
        },

        decodeAttributes : function(val) {

        },

        encodeAttributes : function (val) {

        },

        toString : function() {
           return '{\n' +
               '\t"path" : "' + _path + ",\n" +
               '\t"isDirectory" : ' + _obj.directory + ",\n" +
               '\t"isReadOnly" : ' + _obj.readonly + ",\n" +
               '\t"isHidden" : ' + _obj.hidden + ",\n" +
               '\t"isExecutable" : ' + _obj.executable + ",\n" +
               '\t"mTime" : ' + _obj.mtime + "\n" +
               '\t"aTime" : ' + _obj.atime + "\n" +
           '}';
        }
    }

};

var util = utils;
var FileSystem = fileSystem;
var Constants = constants;
var Errors = errors;
var FileAttr = fattr;
util.FileSystem = FileSystem;
util.Constants = Constants;
util.Errors = Errors;
util.FileAttr = FileAttr;

var Constants$1 = util.Constants;

/* The central directory file header */
var entryHeader = function () {
    var _verMade = 0x0A,
        _version = 0x0A,
        _flags = 0,
        _method = 0,
        _time = 0,
        _crc = 0,
        _compressedSize = 0,
        _size = 0,
        _fnameLen = 0,
        _extraLen = 0,

        _comLen = 0,
        _diskStart = 0,
        _inattr = 0,
        _attr = 0,
        _offset = 0;

    var _dataHeader = {};

    function setTime(val) {
        val = new Date(val);
        _time = (val.getFullYear() - 1980 & 0x7f) << 25  // b09-16 years from 1980
            | (val.getMonth() + 1) << 21                 // b05-08 month
            | val.getDate() << 16                        // b00-04 hour

            // 2 bytes time
            | val.getHours() << 11    // b11-15 hour
            | val.getMinutes() << 5   // b05-10 minute
            | val.getSeconds() >> 1;  // b00-04 seconds divided by 2
    }

    setTime(+new Date());

    return {
        get made () { return _verMade; },
        set made (val) { _verMade = val; },

        get version () { return _version; },
        set version (val) { _version = val; },

        get flags () { return _flags },
        set flags (val) { _flags = val; },

        get method () { return _method; },
        set method (val) { _method = val; },

        get time () { return new Date(
            ((_time >> 25) & 0x7f) + 1980,
            ((_time >> 21) & 0x0f) - 1,
            (_time >> 16) & 0x1f,
            (_time >> 11) & 0x1f,
            (_time >> 5) & 0x3f,
            (_time & 0x1f) << 1
        );
        },
        set time (val) {
            setTime(val);
        },

        get crc () { return _crc; },
        set crc (val) { _crc = val; },

        get compressedSize () { return _compressedSize; },
        set compressedSize (val) { _compressedSize = val; },

        get size () { return _size; },
        set size (val) { _size = val; },

        get fileNameLength () { return _fnameLen; },
        set fileNameLength (val) { _fnameLen = val; },

        get extraLength () { return _extraLen },
        set extraLength (val) { _extraLen = val; },

        get commentLength () { return _comLen },
        set commentLength (val) { _comLen = val; },

        get diskNumStart () { return _diskStart },
        set diskNumStart (val) { _diskStart = val; },

        get inAttr () { return _inattr },
        set inAttr (val) { _inattr = val; },

        get attr () { return _attr },
        set attr (val) { _attr = val; },

        get offset () { return _offset },
        set offset (val) { _offset = val; },

        get encripted () { return (_flags & 1) === 1 },

        get entryHeaderSize () {
            return Constants$1.CENHDR + _fnameLen + _extraLen + _comLen;
        },

        get realDataOffset () {
            return _offset + Constants$1.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
        },

        get dataHeader () {
            return _dataHeader;
        },

        loadDataHeaderFromBinary : function(/*Buffer*/input) {
            var data = input.slice(_offset, _offset + Constants$1.LOCHDR);
            // 30 bytes and should start with "PK\003\004"
            if (data.readUInt32LE(0) !== Constants$1.LOCSIG) {
                throw new Error(util.Errors.INVALID_LOC);
            }
            _dataHeader = {
                // version needed to extract
                version : data.readUInt16LE(Constants$1.LOCVER),
                // general purpose bit flag
                flags : data.readUInt16LE(Constants$1.LOCFLG),
                // compression method
                method : data.readUInt16LE(Constants$1.LOCHOW),
                // modification time (2 bytes time, 2 bytes date)
                time : data.readUInt32LE(Constants$1.LOCTIM),
                // uncompressed file crc-32 value
                crc : data.readUInt32LE(Constants$1.LOCCRC),
                // compressed size
                compressedSize : data.readUInt32LE(Constants$1.LOCSIZ),
                // uncompressed size
                size : data.readUInt32LE(Constants$1.LOCLEN),
                // filename length
                fnameLen : data.readUInt16LE(Constants$1.LOCNAM),
                // extra field length
                extraLen : data.readUInt16LE(Constants$1.LOCEXT)
            };
        },

        loadFromBinary : function(/*Buffer*/data) {
            // data should be 46 bytes and start with "PK 01 02"
            if (data.length !== Constants$1.CENHDR || data.readUInt32LE(0) !== Constants$1.CENSIG) {
                throw new Error(util.Errors.INVALID_CEN);
            }
            // version made by
            _verMade = data.readUInt16LE(Constants$1.CENVEM);
            // version needed to extract
            _version = data.readUInt16LE(Constants$1.CENVER);
            // encrypt, decrypt flags
            _flags = data.readUInt16LE(Constants$1.CENFLG);
            // compression method
            _method = data.readUInt16LE(Constants$1.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            _time = data.readUInt32LE(Constants$1.CENTIM);
            // uncompressed file crc-32 value
            _crc = data.readUInt32LE(Constants$1.CENCRC);
            // compressed size
            _compressedSize = data.readUInt32LE(Constants$1.CENSIZ);
            // uncompressed size
            _size = data.readUInt32LE(Constants$1.CENLEN);
            // filename length
            _fnameLen = data.readUInt16LE(Constants$1.CENNAM);
            // extra field length
            _extraLen = data.readUInt16LE(Constants$1.CENEXT);
            // file comment length
            _comLen = data.readUInt16LE(Constants$1.CENCOM);
            // volume number start
            _diskStart = data.readUInt16LE(Constants$1.CENDSK);
            // internal file attributes
            _inattr = data.readUInt16LE(Constants$1.CENATT);
            // external file attributes
            _attr = data.readUInt32LE(Constants$1.CENATX);
            // LOC header offset
            _offset = data.readUInt32LE(Constants$1.CENOFF);
        },

        dataHeaderToBinary : function() {
            // LOC header size (30 bytes)
            var data = Buffer.alloc(Constants$1.LOCHDR);
            // "PK\003\004"
            data.writeUInt32LE(Constants$1.LOCSIG, 0);
            // version needed to extract
            data.writeUInt16LE(_version, Constants$1.LOCVER);
            // general purpose bit flag
            data.writeUInt16LE(_flags, Constants$1.LOCFLG);
            // compression method
            data.writeUInt16LE(_method, Constants$1.LOCHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants$1.LOCTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants$1.LOCCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants$1.LOCSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants$1.LOCLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants$1.LOCNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants$1.LOCEXT);
            return data;
        },

        entryHeaderToBinary : function() {
            // CEN header size (46 bytes)
            var data = Buffer.alloc(Constants$1.CENHDR + _fnameLen + _extraLen + _comLen);
            // "PK\001\002"
            data.writeUInt32LE(Constants$1.CENSIG, 0);
            // version made by
            data.writeUInt16LE(_verMade, Constants$1.CENVEM);
            // version needed to extract
            data.writeUInt16LE(_version, Constants$1.CENVER);
            // encrypt, decrypt flags
            data.writeUInt16LE(_flags, Constants$1.CENFLG);
            // compression method
            data.writeUInt16LE(_method, Constants$1.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants$1.CENTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants$1.CENCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants$1.CENSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants$1.CENLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants$1.CENNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants$1.CENEXT);
            // file comment length
            data.writeUInt16LE(_comLen, Constants$1.CENCOM);
            // volume number start
            data.writeUInt16LE(_diskStart, Constants$1.CENDSK);
            // internal file attributes
            data.writeUInt16LE(_inattr, Constants$1.CENATT);
            // external file attributes
            data.writeUInt32LE(_attr, Constants$1.CENATX);
            // LOC header offset
            data.writeUInt32LE(_offset, Constants$1.CENOFF);
            // fill all with
            data.fill(0x00, Constants$1.CENHDR);
            return data;
        },

        toString : function() {
            return '{\n' +
                '\t"made" : ' + _verMade + ",\n" +
                '\t"version" : ' + _version + ",\n" +
                '\t"flags" : ' + _flags + ",\n" +
                '\t"method" : ' + util.methodToString(_method) + ",\n" +
                '\t"time" : ' + this.time + ",\n" +
                '\t"crc" : 0x' + _crc.toString(16).toUpperCase() + ",\n" +
                '\t"compressedSize" : ' + _compressedSize + " bytes,\n" +
                '\t"size" : ' + _size + " bytes,\n" +
                '\t"fileNameLength" : ' + _fnameLen + ",\n" +
                '\t"extraLength" : ' + _extraLen + " bytes,\n" +
                '\t"commentLength" : ' + _comLen + " bytes,\n" +
                '\t"diskNumStart" : ' + _diskStart + ",\n" +
                '\t"inAttr" : ' + _inattr + ",\n" +
                '\t"attr" : ' + _attr + ",\n" +
                '\t"offset" : ' + _offset + ",\n" +
                '\t"entryHeaderSize" : ' + (Constants$1.CENHDR + _fnameLen + _extraLen + _comLen) + " bytes\n" +
                '}';
        }
    }
};

var Constants$2 = util.Constants;

/* The entries in the end of central directory */
var mainHeader = function () {
    var _volumeEntries = 0,
        _totalEntries = 0,
        _size = 0,
        _offset = 0,
        _commentLength = 0;

    return {
        get diskEntries () { return _volumeEntries },
        set diskEntries (/*Number*/val) { _volumeEntries = _totalEntries = val; },

        get totalEntries () { return _totalEntries },
        set totalEntries (/*Number*/val) { _totalEntries = _volumeEntries = val; },

        get size () { return _size },
        set size (/*Number*/val) { _size = val; },

        get offset () { return _offset },
        set offset (/*Number*/val) { _offset = val; },

        get commentLength () { return _commentLength },
        set commentLength (/*Number*/val) { _commentLength = val; },

        get mainHeaderSize () {
            return Constants$2.ENDHDR + _commentLength;
        },

        loadFromBinary : function(/*Buffer*/data) {
            // data should be 22 bytes and start with "PK 05 06"
            // or be 56+ bytes and start with "PK 06 06" for Zip64
            if ((data.length !== Constants$2.ENDHDR || data.readUInt32LE(0) !== Constants$2.ENDSIG) &&
                (data.length < Constants$2.ZIP64HDR || data.readUInt32LE(0) !== Constants$2.ZIP64SIG)) {

                throw new Error(util.Errors.INVALID_END);
            }

            if (data.readUInt32LE(0) === Constants$2.ENDSIG) {
                // number of entries on this volume
                _volumeEntries = data.readUInt16LE(Constants$2.ENDSUB);
                // total number of entries
                _totalEntries = data.readUInt16LE(Constants$2.ENDTOT);
                // central directory size in bytes
                _size = data.readUInt32LE(Constants$2.ENDSIZ);
                // offset of first CEN header
                _offset = data.readUInt32LE(Constants$2.ENDOFF);
                // zip file comment length
                _commentLength = data.readUInt16LE(Constants$2.ENDCOM);
            } else {
                // number of entries on this volume
                _volumeEntries = util.readBigUInt64LE(data, Constants$2.ZIP64SUB);
                // total number of entries
                _totalEntries = util.readBigUInt64LE(data, Constants$2.ZIP64TOT);
                // central directory size in bytes
                _size = util.readBigUInt64LE(data, Constants$2.ZIP64SIZ);
                // offset of first CEN header
                _offset = util.readBigUInt64LE(data, Constants$2.ZIP64OFF);

                _commentLength = 0;
            }

        },

        toBinary : function() {
           var b = Buffer.alloc(Constants$2.ENDHDR + _commentLength);
            // "PK 05 06" signature
            b.writeUInt32LE(Constants$2.ENDSIG, 0);
            b.writeUInt32LE(0, 4);
            // number of entries on this volume
            b.writeUInt16LE(_volumeEntries, Constants$2.ENDSUB);
            // total number of entries
            b.writeUInt16LE(_totalEntries, Constants$2.ENDTOT);
            // central directory size in bytes
            b.writeUInt32LE(_size, Constants$2.ENDSIZ);
            // offset of first CEN header
            b.writeUInt32LE(_offset, Constants$2.ENDOFF);
            // zip file comment length
            b.writeUInt16LE(_commentLength, Constants$2.ENDCOM);
            // fill comment memory with spaces so no garbage is left there
            b.fill(" ", Constants$2.ENDHDR);

            return b;
        },

        toString : function() {
            return '{\n' +
                '\t"diskEntries" : ' + _volumeEntries + ",\n" +
                '\t"totalEntries" : ' + _totalEntries + ",\n" +
                '\t"size" : ' + _size + " bytes,\n" +
                '\t"offset" : 0x' + _offset.toString(16).toUpperCase() + ",\n" +
                '\t"commentLength" : 0x' + _commentLength + "\n" +
            '}';
        }
    }
};

var EntryHeader = entryHeader;
var MainHeader = mainHeader;

var headers = {
	EntryHeader: EntryHeader,
	MainHeader: MainHeader
};

var deflater = function (/*Buffer*/inbuf) {

  var zlib$1 = zlib;
  
  var opts = {chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024};
  
  return {
    deflate: function () {
      return zlib$1.deflateRawSync(inbuf, opts);
    },

    deflateAsync: function (/*Function*/callback) {
      var tmp = zlib$1.createDeflateRaw(opts), parts = [], total = 0;
      tmp.on('data', function (data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on('end', function () {
        var buf = Buffer.alloc(total), written = 0;
        buf.fill(0);
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }
        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  }
};

var inflater = function (/*Buffer*/inbuf) {

  var zlib$1 = zlib;

  return {
    inflate: function () {
      return zlib$1.inflateRawSync(inbuf);
    },

    inflateAsync: function (/*Function*/callback) {
      var tmp = zlib$1.createInflateRaw(), parts = [], total = 0;
      tmp.on('data', function (data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on('end', function () {
        var buf = Buffer.alloc(total), written = 0;
        buf.fill(0);
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }
        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  }
};

var Deflater = deflater;
var Inflater = inflater;

var methods = {
	Deflater: Deflater,
	Inflater: Inflater
};

var Constants$3 = util.Constants;

var zipEntry = function (/*Buffer*/input) {

    var _entryHeader = new headers.EntryHeader(),
        _entryName = Buffer.alloc(0),
        _comment = Buffer.alloc(0),
        _isDirectory = false,
        uncompressedData = null,
        _extra = Buffer.alloc(0);

    function getCompressedDataFromZip() {
        if (!input || !Buffer.isBuffer(input)) {
            return Buffer.alloc(0);
        }
        _entryHeader.loadDataHeaderFromBinary(input);
        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)
    }

    function crc32OK(data) {
        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
        if ((_entryHeader.flags & 0x8) !== 0x8) {
           if (util.crc32(data) !== _entryHeader.dataHeader.crc) {
               return false;
           }
        }
        return true;
    }

    function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {
        if(typeof callback === 'undefined' && typeof async === 'string') {
            async=void 0;
        }
        if (_isDirectory) {
            if (async && callback) {
                callback(Buffer.alloc(0), util.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
            }
            return Buffer.alloc(0);
        }

        var compressedData = getCompressedDataFromZip();

        if (compressedData.length === 0) {
            // File is empty, nothing to decompress.
            if (async && callback) callback(compressedData);
            return compressedData;
        }

        var data = Buffer.alloc(_entryHeader.size);

        switch (_entryHeader.method) {
            case util.Constants.STORED:
                compressedData.copy(data);
                if (!crc32OK(data)) {
                    if (async && callback) callback(data, util.Errors.BAD_CRC);//si added error
                    throw new Error(util.Errors.BAD_CRC);
                } else {//si added otherwise did not seem to return data.
                    if (async && callback) callback(data);
                    return data;
                }
            case util.Constants.DEFLATED:
                var inflater = new methods.Inflater(compressedData);
                if (!async) {
                    var result = inflater.inflate(data);
                    result.copy(data, 0);
                    if (!crc32OK(data)) {
                        throw new Error(util.Errors.BAD_CRC + " " + _entryName.toString());
                    }
                    return data;
                } else {
                    inflater.inflateAsync(function(result) {
                        result.copy(data, 0);
                        if (!crc32OK(data)) {
                            if (callback) callback(data, util.Errors.BAD_CRC); //si added error
                        } else { //si added otherwise did not seem to return data.
                            if (callback) callback(data);
                        }
                    });
                }
                break;
            default:
                if (async && callback) callback(Buffer.alloc(0), util.Errors.UNKNOWN_METHOD);
                throw new Error(util.Errors.UNKNOWN_METHOD);
        }
    }

    function compress(/*Boolean*/async, /*Function*/callback) {
        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
            // no data set or the data wasn't changed to require recompression
            if (async && callback) callback(getCompressedDataFromZip());
            return getCompressedDataFromZip();
        }

        if (uncompressedData.length && !_isDirectory) {
            var compressedData;
            // Local file header
            switch (_entryHeader.method) {
                case util.Constants.STORED:
                    _entryHeader.compressedSize = _entryHeader.size;

                    compressedData = Buffer.alloc(uncompressedData.length);
                    uncompressedData.copy(compressedData);

                    if (async && callback) callback(compressedData);
                    return compressedData;
                default:
                case util.Constants.DEFLATED:

                    var deflater = new methods.Deflater(uncompressedData);
                    if (!async) {
                        var deflated = deflater.deflate();
                        _entryHeader.compressedSize = deflated.length;
                        return deflated;
                    } else {
                        deflater.deflateAsync(function(data) {
                            compressedData = Buffer.alloc(data.length);
                            _entryHeader.compressedSize = data.length;
                            data.copy(compressedData);
                            callback && callback(compressedData);
                        });
                    }
                    deflater = null;
                    break;
            }
        } else {
            if (async && callback) {
                callback(Buffer.alloc(0));
            } else {
                return Buffer.alloc(0);
            }
        }
    }

    function readUInt64LE(buffer, offset) {
        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
    }

    function parseExtra(data) {
        var offset = 0;
        var signature, size, part;
        while(offset<data.length) {
            signature = data.readUInt16LE(offset);
            offset += 2;
            size = data.readUInt16LE(offset);
            offset += 2;
            part = data.slice(offset, offset+size);
            offset += size;
            if(Constants$3.ID_ZIP64 === signature) {
                parseZip64ExtendedInformation(part);
            }
        }
    }

    //Override header field values with values from the ZIP64 extra field
    function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;

        if(data.length >= Constants$3.EF_ZIP64_SCOMP) {
            size = readUInt64LE(data, Constants$3.EF_ZIP64_SUNCOMP);
            if(_entryHeader.size === Constants$3.EF_ZIP64_OR_32) {
                _entryHeader.size = size;
            }
        }
        if(data.length >= Constants$3.EF_ZIP64_RHO) {
            compressedSize = readUInt64LE(data, Constants$3.EF_ZIP64_SCOMP);
            if(_entryHeader.compressedSize === Constants$3.EF_ZIP64_OR_32) {
                _entryHeader.compressedSize = compressedSize;
            }
        }
        if(data.length >= Constants$3.EF_ZIP64_DSN) {
            offset = readUInt64LE(data, Constants$3.EF_ZIP64_RHO);
            if(_entryHeader.offset === Constants$3.EF_ZIP64_OR_32) {
                _entryHeader.offset = offset;
            }
        }
        if(data.length >= Constants$3.EF_ZIP64_DSN+4) {
            diskNumStart = data.readUInt32LE(Constants$3.EF_ZIP64_DSN);
            if(_entryHeader.diskNumStart === Constants$3.EF_ZIP64_OR_16) {
                _entryHeader.diskNumStart = diskNumStart;
            }
        }
    }


    return {
        get entryName () { return _entryName.toString(); },
        get rawEntryName() { return _entryName; },
        set entryName (val) {
            _entryName = util.toBuffer(val);
            var lastChar = _entryName[_entryName.length - 1];
            _isDirectory = (lastChar === 47) || (lastChar === 92);
            _entryHeader.fileNameLength = _entryName.length;
        },

        get extra () { return _extra; },
        set extra (val) {
            _extra = val;
            _entryHeader.extraLength = val.length;
            parseExtra(val);
        },

        get comment () { return _comment.toString(); },
        set comment (val) {
            _comment = util.toBuffer(val);
            _entryHeader.commentLength = _comment.length;
        },

        get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop(); },
        get isDirectory () { return _isDirectory },

        getCompressedData : function() {
            return compress(false, null)
        },

        getCompressedDataAsync : function(/*Function*/callback) {
            compress(true, callback);
        },

        setData : function(value) {
            uncompressedData = util.toBuffer(value);
            if (!_isDirectory && uncompressedData.length) {
                _entryHeader.size = uncompressedData.length;
                _entryHeader.method = util.Constants.DEFLATED;
                _entryHeader.crc = util.crc32(value);
                _entryHeader.changed = true;
            } else { // folders and blank files should be stored
                _entryHeader.method = util.Constants.STORED;
            }
        },

        getData : function(pass) {
            if (_entryHeader.changed) {
				return uncompressedData;
			} else {
				return decompress(false, null);
            }
        },

        getDataAsync : function(/*Function*/callback, pass) {
			if (_entryHeader.changed) {
				callback(uncompressedData);
			} else {
				decompress(true, callback);
            }
        },

        set attr(attr) { _entryHeader.attr = attr; },
        get attr() { return _entryHeader.attr; },

        set header(/*Buffer*/data) {
            _entryHeader.loadFromBinary(data);
        },

        get header() {
            return _entryHeader;
        },

        packHeader : function() {
            var header = _entryHeader.entryHeaderToBinary();
            // add
            _entryName.copy(header, util.Constants.CENHDR);
            if (_entryHeader.extraLength) {
                _extra.copy(header, util.Constants.CENHDR + _entryName.length);
            }
            if (_entryHeader.commentLength) {
                _comment.copy(header, util.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);
            }
            return header;
        },

        toString : function() {
            return '{\n' +
                '\t"entryName" : "' + _entryName.toString() + "\",\n" +
                '\t"name" : "' + (_isDirectory ? _entryName.toString().replace(/\/$/, '').split("/").pop() : _entryName.toString().split("/").pop()) + "\",\n" +
                '\t"comment" : "' + _comment.toString() + "\",\n" +
                '\t"isDirectory" : ' + _isDirectory + ",\n" +
                '\t"header" : ' + _entryHeader.toString().replace(/\t/mg, "\t\t").replace(/}/mg, "\t}")  + ",\n" +
                '\t"compressedData" : <' + (input && input.length  + " bytes buffer" || "null") + ">\n" +
                '\t"data" : <' + (uncompressedData && uncompressedData.length  + " bytes buffer" || "null") + ">\n" +
                '}';
        }
    }
};

var zipFile = function (/*String|Buffer*/input, /*Number*/inputType) {
	var entryList = [],
		entryTable = {},
		_comment = Buffer.alloc(0),
		filename = "",
		fs = util.FileSystem.require(),
		inBuffer = null,
		mainHeader = new headers.MainHeader(),
		loadedEntries = false;

	if (inputType === util.Constants.FILE) {
		// is a filename
		filename = input;
		inBuffer = fs.readFileSync(filename);
		readMainHeader();
	} else if (inputType === util.Constants.BUFFER) {
		// is a memory buffer
		inBuffer = input;
		readMainHeader();
	} else {
		// none. is a new file
		loadedEntries = true;
	}

	function iterateEntries(callback) {
		const totalEntries = mainHeader.diskEntries; // total number of entries
		let index = mainHeader.offset; // offset of first CEN header

		for (let i = 0; i < totalEntries; i++) {
			let tmp = index;
			const entry = new zipEntry(inBuffer);

			entry.header = inBuffer.slice(tmp, tmp += util.Constants.CENHDR);
			entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);

			index += entry.header.entryHeaderSize;

			callback(entry);
		}
	}

	function readEntries() {
		loadedEntries = true;
		entryTable = {};
		entryList = new Array(mainHeader.diskEntries);  // total number of entries
		var index = mainHeader.offset;  // offset of first CEN header
		for (var i = 0; i < entryList.length; i++) {

			var tmp = index,
				entry = new zipEntry(inBuffer);
			entry.header = inBuffer.slice(tmp, tmp += util.Constants.CENHDR);

			entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);

			if (entry.header.extraLength) {
				entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
			}

			if (entry.header.commentLength)
				entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);

			index += entry.header.entryHeaderSize;

			entryList[i] = entry;
			entryTable[entry.entryName] = entry;
		}
	}

	function readMainHeader() {
		var i = inBuffer.length - util.Constants.ENDHDR, // END header size
			max = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length
			n = max,
			endStart = inBuffer.length,
			endOffset = -1, // Start offset of the END header
			commentEnd = 0;

		for (i; i >= n; i--) {
			if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'
			if (inBuffer.readUInt32LE(i) === util.Constants.ENDSIG) { // "PK\005\006"
				endOffset = i;
				commentEnd = i;
				endStart = i + util.Constants.ENDHDR;
				// We already found a regular signature, let's look just a bit further to check if there's any zip64 signature
				n = i - util.Constants.END64HDR;
				continue;
			}

			if (inBuffer.readUInt32LE(i) === util.Constants.END64SIG) {
				// Found a zip64 signature, let's continue reading the whole zip64 record
				n = max;
				continue;
			}

			if (inBuffer.readUInt32LE(i) == util.Constants.ZIP64SIG) {
				// Found the zip64 record, let's determine it's size
				endOffset = i;
				endStart = i + util.readBigUInt64LE(inBuffer, i + util.Constants.ZIP64SIZE) + util.Constants.ZIP64LEAD;
				break;
			}
		}

		if (!~endOffset)
			throw new Error(util.Errors.INVALID_FORMAT);

		mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
		if (mainHeader.commentLength) {
			_comment = inBuffer.slice(commentEnd + util.Constants.ENDHDR);
		}
		// readEntries();
	}

	return {
		/**
		 * Returns an array of ZipEntry objects existent in the current opened archive
		 * @return Array
		 */
		get entries() {
			if (!loadedEntries) {
				readEntries();
			}
			return entryList;
		},

		/**
		 * Archive comment
		 * @return {String}
		 */
		get comment() {
			return _comment.toString();
		},
		set comment(val) {
			mainHeader.commentLength = val.length;
			_comment = val;
		},

		getEntryCount: function() {
			if (!loadedEntries) {
				return mainHeader.diskEntries;
			}

			return entryList.length;
		},

		forEach: function(callback) {
			if (!loadedEntries) {
				iterateEntries(callback);
				return;
			}

			entryList.forEach(callback);
		},

		/**
		 * Returns a reference to the entry with the given name or null if entry is inexistent
		 *
		 * @param entryName
		 * @return ZipEntry
		 */
		getEntry: function (/*String*/entryName) {
			if (!loadedEntries) {
				readEntries();
			}
			return entryTable[entryName] || null;
		},

		/**
		 * Adds the given entry to the entry list
		 *
		 * @param entry
		 */
		setEntry: function (/*ZipEntry*/entry) {
			if (!loadedEntries) {
				readEntries();
			}
			entryList.push(entry);
			entryTable[entry.entryName] = entry;
			mainHeader.totalEntries = entryList.length;
		},

		/**
		 * Removes the entry with the given name from the entry list.
		 *
		 * If the entry is a directory, then all nested files and directories will be removed
		 * @param entryName
		 */
		deleteEntry: function (/*String*/entryName) {
			if (!loadedEntries) {
				readEntries();
			}
			var entry = entryTable[entryName];
			if (entry && entry.isDirectory) {
				var _self = this;
				this.getEntryChildren(entry).forEach(function (child) {
					if (child.entryName !== entryName) {
						_self.deleteEntry(child.entryName);
					}
				});
			}
			entryList.splice(entryList.indexOf(entry), 1);
			delete(entryTable[entryName]);
			mainHeader.totalEntries = entryList.length;
		},

		/**
		 *  Iterates and returns all nested files and directories of the given entry
		 *
		 * @param entry
		 * @return Array
		 */
		getEntryChildren: function (/*ZipEntry*/entry) {
			if (!loadedEntries) {
				readEntries();
			}
			if (entry.isDirectory) {
				var list = [],
					name = entry.entryName,
					len = name.length;

				entryList.forEach(function (zipEntry) {
					if (zipEntry.entryName.substr(0, len) === name) {
						list.push(zipEntry);
					}
				});
				return list;
			}
			return []
		},

		/**
		 * Returns the zip file
		 *
		 * @return Buffer
		 */
		compressToBuffer: function () {
			if (!loadedEntries) {
				readEntries();
			}
			if (entryList.length > 1) {
				entryList.sort(function (a, b) {
					var nameA = a.entryName.toLowerCase();
					var nameB = b.entryName.toLowerCase();
					if (nameA < nameB) {
						return -1
					}
					if (nameA > nameB) {
						return 1
					}
					return 0;
				});
			}

			var totalSize = 0,
				dataBlock = [],
				entryHeaders = [],
				dindex = 0;

			mainHeader.size = 0;
			mainHeader.offset = 0;

			entryList.forEach(function (entry) {
				// compress data and set local and entry header accordingly. Reason why is called first
				var compressedData = entry.getCompressedData();
				// data header
				entry.header.offset = dindex;
				var dataHeader = entry.header.dataHeaderToBinary();
				var entryNameLen = entry.rawEntryName.length;
				var extra = entry.extra.toString();
				var postHeader = Buffer.alloc(entryNameLen + extra.length);
				entry.rawEntryName.copy(postHeader, 0);
				postHeader.fill(extra, entryNameLen);

				var dataLength = dataHeader.length + postHeader.length + compressedData.length;

				dindex += dataLength;

				dataBlock.push(dataHeader);
				dataBlock.push(postHeader);
				dataBlock.push(compressedData);

				var entryHeader = entry.packHeader();
				entryHeaders.push(entryHeader);
				mainHeader.size += entryHeader.length;
				totalSize += (dataLength + entryHeader.length);
			});

			totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
			// point to end of data and beginning of central directory first record
			mainHeader.offset = dindex;

			dindex = 0;
			var outBuffer = Buffer.alloc(totalSize);
			dataBlock.forEach(function (content) {
				content.copy(outBuffer, dindex); // write data blocks
				dindex += content.length;
			});
			entryHeaders.forEach(function (content) {
				content.copy(outBuffer, dindex); // write central directory entries
				dindex += content.length;
			});

			var mh = mainHeader.toBinary();
			if (_comment) {
				Buffer.from(_comment).copy(mh, util.Constants.ENDHDR); // add zip file comment
			}

			mh.copy(outBuffer, dindex); // write main header

			return outBuffer
		},

		toAsyncBuffer: function (/*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {
			if (!loadedEntries) {
				readEntries();
			}
			if (entryList.length > 1) {
				entryList.sort(function (a, b) {
					var nameA = a.entryName.toLowerCase();
					var nameB = b.entryName.toLowerCase();
					if (nameA > nameB) {
						return -1
					}
					if (nameA < nameB) {
						return 1
					}
					return 0;
				});
			}

			var totalSize = 0,
				dataBlock = [],
				entryHeaders = [],
				dindex = 0;

			mainHeader.size = 0;
			mainHeader.offset = 0;

			var compress = function (entryList) {
				var self = arguments.callee;
				if (entryList.length) {
					var entry = entryList.pop();
					var name = entry.entryName + entry.extra.toString();
					if (onItemStart) onItemStart(name);
					entry.getCompressedDataAsync(function (compressedData) {
						if (onItemEnd) onItemEnd(name);

						entry.header.offset = dindex;
						// data header
						var dataHeader = entry.header.dataHeaderToBinary();
						var postHeader;
						try {
							postHeader = Buffer.alloc(name.length, name);  // using alloc will work on node  5.x+
						} catch(e){
							postHeader = new Buffer(name); // use deprecated method if alloc fails...
						}
						var dataLength = dataHeader.length + postHeader.length + compressedData.length;

						dindex += dataLength;

						dataBlock.push(dataHeader);
						dataBlock.push(postHeader);
						dataBlock.push(compressedData);

						var entryHeader = entry.packHeader();
						entryHeaders.push(entryHeader);
						mainHeader.size += entryHeader.length;
						totalSize += (dataLength + entryHeader.length);

						if (entryList.length) {
							self(entryList);
						} else {


							totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
							// point to end of data and beginning of central directory first record
							mainHeader.offset = dindex;

							dindex = 0;
							var outBuffer = Buffer.alloc(totalSize);
							dataBlock.forEach(function (content) {
								content.copy(outBuffer, dindex); // write data blocks
								dindex += content.length;
							});
							entryHeaders.forEach(function (content) {
								content.copy(outBuffer, dindex); // write central directory entries
								dindex += content.length;
							});

							var mh = mainHeader.toBinary();
							if (_comment) {
								_comment.copy(mh, util.Constants.ENDHDR); // add zip file comment
							}

							mh.copy(outBuffer, dindex); // write main header

							onSuccess(outBuffer);
						}
					});
				}
			};

			compress(entryList);
		}
	}
};

var fs$3 = util.FileSystem.require();

fs$3.existsSync = fs$3.existsSync || path$2.existsSync;



var isWin = /^win/.test(process.platform);


var admZip = function (/**String*/input) {
	var _zip = undefined,
		_filename = "";

	if (input && typeof input === "string") { // load zip file
		if (fs$3.existsSync(input)) {
			_filename = input;
			_zip = new zipFile(input, util.Constants.FILE);
		} else {
			throw new Error(util.Errors.INVALID_FILENAME);
		}
	} else if (input && Buffer.isBuffer(input)) { // load buffer
		_zip = new zipFile(input, util.Constants.BUFFER);
	} else { // create new zip file
		_zip = new zipFile(null, util.Constants.NONE);
	}

	function sanitize(prefix, name) {
		prefix = path$2.resolve(path$2.normalize(prefix));
		var parts = name.split('/');
		for (var i = 0, l = parts.length; i < l; i++) {
			var path = path$2.normalize(path$2.join(prefix, parts.slice(i, l).join(path$2.sep)));
			if (path.indexOf(prefix) === 0) {
				return path;
			}
		}
		return path$2.normalize(path$2.join(prefix, path$2.basename(name)));
	}

	function getEntry(/**Object*/entry) {
		if (entry && _zip) {
			var item;
			// If entry was given as a file name
			if (typeof entry === "string")
				item = _zip.getEntry(entry);
			// if entry was given as a ZipEntry object
			if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined")
				item = _zip.getEntry(entry.entryName);

			if (item) {
				return item;
			}
		}
		return null;
	}

	return {
		/**
		 * Extracts the given entry from the archive and returns the content as a Buffer object
		 * @param entry ZipEntry object or String with the full path of the entry
		 *
		 * @return Buffer or Null in case of error
		 */
		readFile: function (/**Object*/entry) {
			var item = getEntry(entry);
			return item && item.getData() || null;
		},

		/**
		 * Asynchronous readFile
		 * @param entry ZipEntry object or String with the full path of the entry
		 * @param callback
		 *
		 * @return Buffer or Null in case of error
		 */
		readFileAsync: function (/**Object*/entry, /**Function*/callback) {
			var item = getEntry(entry);
			if (item) {
				item.getDataAsync(callback);
			} else {
				callback(null, "getEntry failed for:" + entry);
			}
		},

		/**
		 * Extracts the given entry from the archive and returns the content as plain text in the given encoding
		 * @param entry ZipEntry object or String with the full path of the entry
		 * @param encoding Optional. If no encoding is specified utf8 is used
		 *
		 * @return String
		 */
		readAsText: function (/**Object*/entry, /**String=*/encoding) {
			var item = getEntry(entry);
			if (item) {
				var data = item.getData();
				if (data && data.length) {
					return data.toString(encoding || "utf8");
				}
			}
			return "";
		},

		/**
		 * Asynchronous readAsText
		 * @param entry ZipEntry object or String with the full path of the entry
		 * @param callback
		 * @param encoding Optional. If no encoding is specified utf8 is used
		 *
		 * @return String
		 */
		readAsTextAsync: function (/**Object*/entry, /**Function*/callback, /**String=*/encoding) {
			var item = getEntry(entry);
			if (item) {
				item.getDataAsync(function (data, err) {
					if (err) {
						callback(data, err);
						return;
					}

					if (data && data.length) {
						callback(data.toString(encoding || "utf8"));
					} else {
						callback("");
					}
				});
			} else {
				callback("");
			}
		},

		/**
		 * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
		 *
		 * @param entry
		 */
		deleteFile: function (/**Object*/entry) { // @TODO: test deleteFile
			var item = getEntry(entry);
			if (item) {
				_zip.deleteEntry(item.entryName);
			}
		},

		/**
		 * Adds a comment to the zip. The zip must be rewritten after adding the comment.
		 *
		 * @param comment
		 */
		addZipComment: function (/**String*/comment) { // @TODO: test addZipComment
			_zip.comment = comment;
		},

		/**
		 * Returns the zip comment
		 *
		 * @return String
		 */
		getZipComment: function () {
			return _zip.comment || '';
		},

		/**
		 * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
		 * The comment cannot exceed 65535 characters in length
		 *
		 * @param entry
		 * @param comment
		 */
		addZipEntryComment: function (/**Object*/entry, /**String*/comment) {
			var item = getEntry(entry);
			if (item) {
				item.comment = comment;
			}
		},

		/**
		 * Returns the comment of the specified entry
		 *
		 * @param entry
		 * @return String
		 */
		getZipEntryComment: function (/**Object*/entry) {
			var item = getEntry(entry);
			if (item) {
				return item.comment || '';
			}
			return ''
		},

		/**
		 * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
		 *
		 * @param entry
		 * @param content
		 */
		updateFile: function (/**Object*/entry, /**Buffer*/content) {
			var item = getEntry(entry);
			if (item) {
				item.setData(content);
			}
		},

		/**
		 * Adds a file from the disk to the archive
		 *
		 * @param localPath File to add to zip
		 * @param zipPath Optional path inside the zip
		 * @param zipName Optional name for the file
		 */
		addLocalFile: function (/**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {
			if (fs$3.existsSync(localPath)) {
				if (zipPath) {
					zipPath = zipPath.split("\\").join("/");
					if (zipPath.charAt(zipPath.length - 1) !== "/") {
						zipPath += "/";
					}
				} else {
					zipPath = "";
				}
				var p = localPath.split("\\").join("/").split("/").pop();

				if (zipName) {
					this.addFile(zipPath + zipName, fs$3.readFileSync(localPath), "", 0);
				} else {
					this.addFile(zipPath + p, fs$3.readFileSync(localPath), "", 0);
				}
			} else {
				throw new Error(util.Errors.FILE_NOT_FOUND.replace("%s", localPath));
			}
		},

		/**
		 * Adds a local directory and all its nested files and directories to the archive
		 *
		 * @param localPath
		 * @param zipPath optional path inside zip
		 * @param filter optional RegExp or Function if files match will
		 *               be included.
		 */
		addLocalFolder: function (/**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {
			if (filter === undefined) {
				filter = function () {
					return true;
				};
			} else if (filter instanceof RegExp) {
				filter = function (filter) {
					return function (filename) {
						return filter.test(filename);
					}
				}(filter);
			}

			if (zipPath) {
				zipPath = zipPath.split("\\").join("/");
				if (zipPath.charAt(zipPath.length - 1) !== "/") {
					zipPath += "/";
				}
			} else {
				zipPath = "";
			}
			// normalize the path first
			localPath = path$2.normalize(localPath);
			localPath = localPath.split("\\").join("/"); //windows fix
			if (localPath.charAt(localPath.length - 1) !== "/")
				localPath += "/";

			if (fs$3.existsSync(localPath)) {

				var items = util.findFiles(localPath),
					self = this;

				if (items.length) {
					items.forEach(function (path) {
						var p = path.split("\\").join("/").replace(new RegExp(localPath.replace(/(\(|\)|\$)/g, '\\$1'), 'i'), ""); //windows fix
						if (filter(p)) {
							if (p.charAt(p.length - 1) !== "/") {
								self.addFile(zipPath + p, fs$3.readFileSync(path), "", 0);
							} else {
								self.addFile(zipPath + p, Buffer.alloc(0), "", 0);
							}
						}
					});
				}
			} else {
				throw new Error(util.Errors.FILE_NOT_FOUND.replace("%s", localPath));
			}
		},

		/**
		 * Asynchronous addLocalFile
		 * @param localPath
		 * @param callback
		 * @param zipPath optional path inside zip
		 * @param filter optional RegExp or Function if files match will
		 *               be included.
		 */
		addLocalFolderAsync: function (/*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {
			if (filter === undefined) {
				filter = function () {
					return true;
				};
			} else if (filter instanceof RegExp) {
				filter = function (filter) {
					return function (filename) {
						return filter.test(filename);
					}
				}(filter);
			}

			if (zipPath) {
				zipPath = zipPath.split("\\").join("/");
				if (zipPath.charAt(zipPath.length - 1) !== "/") {
					zipPath += "/";
				}
			} else {
				zipPath = "";
			}
			// normalize the path first
			localPath = path$2.normalize(localPath);
			localPath = localPath.split("\\").join("/"); //windows fix
			if (localPath.charAt(localPath.length - 1) !== "/")
				localPath += "/";

			var self = this;
			fs$3.open(localPath, 'r', function (err, fd) {
				if (err && err.code === 'ENOENT') {
					callback(undefined, util.Errors.FILE_NOT_FOUND.replace("%s", localPath));
				} else if (err) {
					callback(undefined, err);
				} else {
					var items = util.findFiles(localPath);
					var i = -1;

					var next = function () {
						i += 1;
						if (i < items.length) {
							var p = items[i].split("\\").join("/").replace(new RegExp(localPath.replace(/(\(|\))/g, '\\$1'), 'i'), ""); //windows fix
							p = p.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^\x20-\x7E]/g, ''); // accent fix
							if (filter(p)) {
								if (p.charAt(p.length - 1) !== "/") {
									fs$3.readFile(items[i], function (err, data) {
										if (err) {
											callback(undefined, err);
										} else {
											self.addFile(zipPath + p, data, '', 0);
											next();
										}
									});
								} else {
									self.addFile(zipPath + p, Buffer.alloc(0), "", 0);
									next();
								}
							} else {
								next();
							}

						} else {
							callback(true, undefined);
						}
					};

					next();
				}
			});
		},

		/**
		 * Allows you to create a entry (file or directory) in the zip file.
		 * If you want to create a directory the entryName must end in / and a null buffer should be provided.
		 * Comment and attributes are optional
		 *
		 * @param entryName
		 * @param content
		 * @param comment
		 * @param attr
		 */
		addFile: function (/**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {
			var entry = new zipEntry();
			entry.entryName = entryName;
			entry.comment = comment || "";

			if (!attr) {
				if (entry.isDirectory) {
					attr = (0o40755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)
				} else {
					attr = 0o644 << 16; // permissions -r-wr--r--
				}
			}

			entry.attr = attr;

			entry.setData(content);
			_zip.setEntry(entry);
		},

		/**
		 * Returns an array of ZipEntry objects representing the files and folders inside the archive
		 *
		 * @return Array
		 */
		getEntries: function () {
			if (_zip) {
				return _zip.entries;
			} else {
				return [];
			}
		},

		/**
		 * Returns a ZipEntry object representing the file or folder specified by ``name``.
		 *
		 * @param name
		 * @return ZipEntry
		 */
		getEntry: function (/**String*/name) {
			return getEntry(name);
		},

		getEntryCount: function() {
			return _zip.getEntryCount();
		},

		forEach: function(callback) {
			return _zip.forEach(callback);
		},

		/**
		 * Extracts the given entry to the given targetPath
		 * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
		 *
		 * @param entry ZipEntry object or String with the full path of the entry
		 * @param targetPath Target folder where to write the file
		 * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
		 *                          will be created in targetPath as well. Default is TRUE
		 * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
		 *                  Default is FALSE
		 *
		 * @return Boolean
		 */
		extractEntryTo: function (/**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {
			overwrite = overwrite || false;
			maintainEntryPath = typeof maintainEntryPath === "undefined" ? true : maintainEntryPath;

			var item = getEntry(entry);
			if (!item) {
				throw new Error(util.Errors.NO_ENTRY);
			}

			var entryName = item.entryName;

			var target = sanitize(targetPath, maintainEntryPath ? entryName : path$2.basename(entryName));

			if (item.isDirectory) {
				target = path$2.resolve(target, "..");
				var children = _zip.getEntryChildren(item);
				children.forEach(function (child) {
					if (child.isDirectory) return;
					var content = child.getData();
					if (!content) {
						throw new Error(util.Errors.CANT_EXTRACT_FILE);
					}
					var childName = sanitize(targetPath, maintainEntryPath ? child.entryName : path$2.basename(child.entryName));

					util.writeFileTo(childName, content, overwrite);
				});
				return true;
			}

			var content = item.getData();
			if (!content) throw new Error(util.Errors.CANT_EXTRACT_FILE);

			if (fs$3.existsSync(target) && !overwrite) {
				throw new Error(util.Errors.CANT_OVERRIDE);
			}
			util.writeFileTo(target, content, overwrite);

			return true;
		},

		/**
		 * Test the archive
		 *
		 */
		test: function () {
			if (!_zip) {
				return false;
			}

			for (var entry in _zip.entries) {
				try {
					if (entry.isDirectory) {
						continue;
					}
					var content = _zip.entries[entry].getData();
					if (!content) {
						return false;
					}
				} catch (err) {
					return false;
				}
			}
			return true;
		},

		/**
		 * Extracts the entire archive to the given location
		 *
		 * @param targetPath Target location
		 * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
		 *                  Default is FALSE
		 */
		extractAllTo: function (/**String*/targetPath, /**Boolean*/overwrite) {
			overwrite = overwrite || false;
			if (!_zip) {
				throw new Error(util.Errors.NO_ZIP);
			}
			_zip.entries.forEach(function (entry) {
				var entryName = sanitize(targetPath, entry.entryName.toString());
				if (entry.isDirectory) {
					util.makeDir(entryName);
					return;
				}
				var content = entry.getData();
				if (!content) {
					throw new Error(util.Errors.CANT_EXTRACT_FILE);
				}
				util.writeFileTo(entryName, content, overwrite);
				try {
					fs$3.utimesSync(entryName, entry.header.time, entry.header.time);
				} catch (err) {
					throw new Error(util.Errors.CANT_EXTRACT_FILE);
				}
			});
		},

		/**
		 * Asynchronous extractAllTo
		 *
		 * @param targetPath Target location
		 * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
		 *                  Default is FALSE
		 * @param callback
		 */
		extractAllToAsync: function (/**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {
			if (!callback) {
				callback = function() {};
			}
			overwrite = overwrite || false;
			if (!_zip) {
				callback(new Error(util.Errors.NO_ZIP));
				return;
			}

			var entries = _zip.entries;
			var i = entries.length;
			entries.forEach(function (entry) {
				if (i <= 0) return; // Had an error already

				var entryName = path$2.normalize(entry.entryName.toString());

				if (entry.isDirectory) {
					util.makeDir(sanitize(targetPath, entryName));
					if (--i === 0)
						callback(undefined);
					return;
				}
				entry.getDataAsync(function (content, err) {
					if (i <= 0) return;
					if (err) {
						callback(new Error(err));
						return;
					}
					if (!content) {
						i = 0;
						callback(new Error(util.Errors.CANT_EXTRACT_FILE));
						return;
					}

					util.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {
						try {
							fs$3.utimesSync(path$2.resolve(targetPath, entryName), entry.header.time, entry.header.time);
						} catch (err) {
							callback(new Error('Unable to set utimes'));
						}
						if (i <= 0) return;
						if (!succ) {
							i = 0;
							callback(new Error('Unable to write'));
							return;
						}
						if (--i === 0)
							callback(undefined);
					});
				});
			});
		},

		/**
		 * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
		 *
		 * @param targetFileName
		 * @param callback
		 */
		writeZip: function (/**String*/targetFileName, /**Function*/callback) {
			if (arguments.length === 1) {
				if (typeof targetFileName === "function") {
					callback = targetFileName;
					targetFileName = "";
				}
			}

			if (!targetFileName && _filename) {
				targetFileName = _filename;
			}
			if (!targetFileName) return;

			var zipData = _zip.compressToBuffer();
			if (zipData) {
				var ok = util.writeFileTo(targetFileName, zipData, true);
				if (typeof callback === 'function') callback(!ok ? new Error("failed") : null, "");
			}
		},

		/**
		 * Returns the content of the entire zip file as a Buffer object
		 *
		 * @return Buffer
		 */
		toBuffer: function (/**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {
			this.valueOf = 2;
			if (typeof onSuccess === "function") {
				_zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
				return null;
			}
			return _zip.compressToBuffer()
		}
	}
};

function download(updateFolder) {

    return new Promise((resolve, reject)=>{

        updating.set(true);
        const updatefilename = "update.zip";

        const zipFile = path.resolve(updateFolder, updatefilename);

        const response = https.get(get_store_value(urlzip), (res) => {

            console.log(`URL: ${get_store_value(urlzip)}`);
            console.log('statusCode:', res.statusCode);
            console.log('headers:', res.headers);
            res.pipe(fs.createWriteStream(zipFile));
            console.log("File downloaded");
        });

        response.on("close", () => {
            console.log("Downloading Completed");
            console.log("Extracting files");

            setTimeout(()=>{

                let zip = new admZip(zipFile);
                zip.extractAllTo(updateFolder, /*overwrite*/true);
                console.log("File Extracted");
                resolve("File extracted");
                window.createToast("Downloading Completed");
            }, 1600);
        
        });
    })
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
var raw = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing$1 = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing$1 = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush$1() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing$1 = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = domain$1;
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing$1 && hasSetImmediate) {
        setImmediate(flush$1);
    } else {
        process.nextTick(flush$1);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}

function noop$1() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

var core = Promise$1;

function Promise$1(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('Promise constructor\'s argument is not a function');
  }
  this._40 = 0;
  this._65 = 0;
  this._55 = null;
  this._72 = null;
  if (fn === noop$1) return;
  doResolve(fn, this);
}
Promise$1._37 = null;
Promise$1._87 = null;
Promise$1._61 = noop$1;

Promise$1.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise$1) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise$1(noop$1);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise$1(noop$1);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
}
function handle(self, deferred) {
  while (self._65 === 3) {
    self = self._55;
  }
  if (Promise$1._37) {
    Promise$1._37(self);
  }
  if (self._65 === 0) {
    if (self._40 === 0) {
      self._40 = 1;
      self._72 = deferred;
      return;
    }
    if (self._40 === 1) {
      self._40 = 2;
      self._72 = [self._72, deferred];
      return;
    }
    self._72.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  raw(function() {
    var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._65 === 1) {
        resolve(deferred.promise, self._55);
      } else {
        reject(deferred.promise, self._55);
      }
      return;
    }
    var ret = tryCallOne(cb, self._55);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise$1
    ) {
      self._65 = 3;
      self._55 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._65 = 1;
  self._55 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._65 = 2;
  self._55 = newValue;
  if (Promise$1._87) {
    Promise$1._87(self, newValue);
  }
  finale(self);
}
function finale(self) {
  if (self._40 === 1) {
    handle(self, self._72);
    self._72 = null;
  }
  if (self._40 === 2) {
    for (var i = 0; i < self._72.length; i++) {
      handle(self, self._72[i]);
    }
    self._72 = null;
  }
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  });
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

core.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

core.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return core.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return core.resolve(f()).then(function () {
      throw err;
    });
  });
};

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new core(core._61);
  p._65 = 1;
  p._55 = value;
  return p;
}
core.resolve = function (value) {
  if (value instanceof core) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new core(then.bind(value));
      }
    } catch (ex) {
      return new core(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

core.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new core(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof core && val.then === core.prototype.then) {
          while (val._65 === 3) {
            val = val._55;
          }
          if (val._65 === 1) return res(i, val._55);
          if (val._65 === 2) reject(val._55);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new core(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

core.reject = function (value) {
  return new core(function (resolve, reject) {
    reject(value);
  });
};

core.race = function (values) {
  return new core(function (resolve, reject) {
    values.forEach(function(value){
      core.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

core.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

var freeTasks = [];

/**
 * Calls a task as soon as possible after returning, in its own event, with
 * priority over IO events. An exception thrown in a task can be handled by
 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
 * crash the process. If the error is handled, all subsequent tasks will
 * resume.
 *
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
var asap_1 = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawTask.domain = process.domain;
    raw(rawTask);
}

function RawTask() {
    this.task = null;
    this.domain = null;
}

RawTask.prototype.call = function () {
    if (this.domain) {
        this.domain.enter();
    }
    var threw = true;
    try {
        this.task.call();
        threw = false;
        // If the task throws an exception (presumably) Node.js restores the
        // domain stack for the next event.
        if (this.domain) {
            this.domain.exit();
        }
    } finally {
        // We use try/finally and a threw flag to avoid messing up stack traces
        // when we catch and release errors.
        if (threw) {
            // In Node.js, uncaught exceptions are considered fatal errors.
            // Re-throw them to interrupt flushing!
            // Ensure that flushing continues if an uncaught exception is
            // suppressed listening process.on("uncaughtException") or
            // domain.on("error").
            raw.requestFlush();
        }
        // If the task threw an error, we do not want to exit the domain here.
        // Exiting the domain would prevent the domain from catching the error.
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
    }
};

/* Static Functions */

core.denodeify = function (fn, argumentCount) {
  if (
    typeof argumentCount === 'number' && argumentCount !== Infinity
  ) {
    return denodeifyWithCount(fn, argumentCount);
  } else {
    return denodeifyWithoutCount(fn);
  }
};

var callbackFn = (
  'function (err, res) {' +
  'if (err) { rj(err); } else { rs(res); }' +
  '}'
);
function denodeifyWithCount(fn, argumentCount) {
  var args = [];
  for (var i = 0; i < argumentCount; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'return new Promise(function (rs, rj) {',
    'var res = fn.call(',
    ['self'].concat(args).concat([callbackFn]).join(','),
    ');',
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');
  return Function(['Promise', 'fn'], body)(core, fn);
}
function denodeifyWithoutCount(fn) {
  var fnLength = Math.max(fn.length - 1, 3);
  var args = [];
  for (var i = 0; i < fnLength; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'var args;',
    'var argLength = arguments.length;',
    'if (arguments.length > ' + fnLength + ') {',
    'args = new Array(arguments.length + 1);',
    'for (var i = 0; i < arguments.length; i++) {',
    'args[i] = arguments[i];',
    '}',
    '}',
    'return new Promise(function (rs, rj) {',
    'var cb = ' + callbackFn + ';',
    'var res;',
    'switch (argLength) {',
    args.concat(['extra']).map(function (_, index) {
      return (
        'case ' + (index) + ':' +
        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
        'break;'
      );
    }).join(''),
    'default:',
    'args[argLength] = cb;',
    'res = fn.apply(self, args);',
    '}',
    
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');

  return Function(
    ['Promise', 'fn'],
    body
  )(core, fn);
}

core.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new core(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap_1(function () {
          callback.call(ctx, ex);
        });
      }
    }
  }
};

core.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap_1(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap_1(function () {
      callback.call(ctx, err);
    });
  });
};

core.enableSynchronous = function () {
  core.prototype.isPending = function() {
    return this.getState() == 0;
  };

  core.prototype.isFulfilled = function() {
    return this.getState() == 1;
  };

  core.prototype.isRejected = function() {
    return this.getState() == 2;
  };

  core.prototype.getValue = function () {
    if (this._65 === 3) {
      return this._55.getValue();
    }

    if (!this.isFulfilled()) {
      throw new Error('Cannot get a value of an unfulfilled promise.');
    }

    return this._55;
  };

  core.prototype.getReason = function () {
    if (this._65 === 3) {
      return this._55.getReason();
    }

    if (!this.isRejected()) {
      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
    }

    return this._55;
  };

  core.prototype.getState = function () {
    if (this._65 === 3) {
      return this._55.getState();
    }
    if (this._65 === -1 || this._65 === -2) {
      return 0;
    }

    return this._65;
  };
};

core.disableSynchronous = function() {
  core.prototype.isPending = undefined;
  core.prototype.isFulfilled = undefined;
  core.prototype.isRejected = undefined;
  core.prototype.getValue = undefined;
  core.prototype.getReason = undefined;
  core.prototype.getState = undefined;
};

var lib = core;

var promise$1 = lib;

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function(d) {
  cwd = null;
  chdir.call(process, d);
};

var polyfills = patch;

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants$1.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read;
    return read
  })(fs.read);

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs.readSync);

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants$1.O_WRONLY | constants$1.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err);
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2);
          });
        });
      });
    };

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true;
      var ret;
      try {
        ret = fs.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret
    };
  }

  function patchLutimes (fs) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants$1.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er);
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2);
            });
          });
        });
      };

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret
      };

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
      fs.lutimesSync = function () {};
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

var Stream = stream.Stream;

var legacyStreams = legacy;

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var clone_1 = clone;

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var gracefulFs = createCommonjsModule(function (module) {
/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue;
var previousSymbol;

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue');
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous');
} else {
  gracefulQueue = '___graceful-fs.queue';
  previousSymbol = '___graceful-fs.previous';
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  });
}

var debug = noop;
if (util$1.debuglog)
  debug = util$1.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

// Once time initialization
if (!fs$4[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$4, queue);

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs$4.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs$4, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry();
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments);
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close
  })(fs$4.close);

  fs$4.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs$4, arguments);
      retry();
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync
  })(fs$4.closeSync);

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs$4[gracefulQueue]);
      assert.equal(fs$4[gracefulQueue].length, 0);
    });
  }
}

if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$4[gracefulQueue]);
}

module.exports = patch(clone_1(fs$4));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$4.__patched) {
    module.exports = patch(fs$4);
    fs$4.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;

  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile)
    fs.appendFile = appendFile;
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir (path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]]);

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacyStreams(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }

  var fs$WriteStream = fs.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  // legacy names
  var FileReadStream = ReadStream;
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open;
  fs.open = open;
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  fs$4[gracefulQueue].push(elem);
}

function retry () {
  var elem = fs$4[gracefulQueue].shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}
});

var pify_1 = createCommonjsModule(function (module) {

var processFn = function (fn, P, opts) {
	return function () {
		var that = this;
		var args = new Array(arguments.length);

		for (var i = 0; i < arguments.length; i++) {
			args[i] = arguments[i];
		}

		return new P(function (resolve, reject) {
			args.push(function (err, result) {
				if (err) {
					reject(err);
				} else if (opts.multiArgs) {
					var results = new Array(arguments.length - 1);

					for (var i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});

			fn.apply(that, args);
		});
	};
};

var pify = module.exports = function (obj, P, opts) {
	if (typeof P !== 'function') {
		opts = P;
		P = Promise;
	}

	opts = opts || {};
	opts.exclude = opts.exclude || [/.+Sync$/];

	var filter = function (key) {
		var match = function (pattern) {
			return typeof pattern === 'string' ? key === pattern : pattern.test(key);
		};

		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	var ret = typeof obj === 'function' ? function () {
		if (opts.excludeMain) {
			return obj.apply(this, arguments);
		}

		return processFn(obj, P, opts).apply(this, arguments);
	} : {};

	return Object.keys(obj).reduce(function (ret, key) {
		var x = obj[key];

		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;

		return ret;
	}, ret);
};

pify.all = pify;
});

var _0777 = parseInt('0777', 8);

var mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs$4;
    
    if (mode === undefined) {
        mode = _0777;
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path$2.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                if (path$2.dirname(p) === p) return cb(er);
                mkdirP(path$2.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made);
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs$4;
    
    if (mode === undefined) {
        mode = _0777;
    }
    if (!made) made = null;

    p = path$2.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path$2.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var NOOP = function () {};
var isNode = typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.process !== 'undefined' && typeof commonjsGlobal.process.emit === 'function';

var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
	// run promise callbacks
	for (var i = 0; i < asyncQueue.length; i++) {
		asyncQueue[i][0](asyncQueue[i][1]);
	}

	// reset async asyncQueue
	asyncQueue = [];
	asyncTimer = false;
}

function asyncCall(callback, arg) {
	asyncQueue.push([callback, arg]);

	if (!asyncTimer) {
		asyncTimer = true;
		asyncSetTimer(asyncFlush, 0);
	}
}

function invokeResolver(resolver, promise) {
	function resolvePromise(value) {
		resolve$1(promise, value);
	}

	function rejectPromise(reason) {
		reject$1(promise, reason);
	}

	try {
		resolver(resolvePromise, rejectPromise);
	} catch (e) {
		rejectPromise(e);
	}
}

function invokeCallback(subscriber) {
	var owner = subscriber.owner;
	var settled = owner._state;
	var value = owner._data;
	var callback = subscriber[settled];
	var promise = subscriber.then;

	if (typeof callback === 'function') {
		settled = FULFILLED;
		try {
			value = callback(value);
		} catch (e) {
			reject$1(promise, e);
		}
	}

	if (!handleThenable(promise, value)) {
		if (settled === FULFILLED) {
			resolve$1(promise, value);
		}

		if (settled === REJECTED) {
			reject$1(promise, value);
		}
	}
}

function handleThenable(promise, value) {
	var resolved;

	try {
		if (promise === value) {
			throw new TypeError('A promises callback cannot return that same promise.');
		}

		if (value && (typeof value === 'function' || typeof value === 'object')) {
			// then should be retrieved only once
			var then = value.then;

			if (typeof then === 'function') {
				then.call(value, function (val) {
					if (!resolved) {
						resolved = true;

						if (value === val) {
							fulfill(promise, val);
						} else {
							resolve$1(promise, val);
						}
					}
				}, function (reason) {
					if (!resolved) {
						resolved = true;

						reject$1(promise, reason);
					}
				});

				return true;
			}
		}
	} catch (e) {
		if (!resolved) {
			reject$1(promise, e);
		}

		return true;
	}

	return false;
}

function resolve$1(promise, value) {
	if (promise === value || !handleThenable(promise, value)) {
		fulfill(promise, value);
	}
}

function fulfill(promise, value) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = value;

		asyncCall(publishFulfillment, promise);
	}
}

function reject$1(promise, reason) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = reason;

		asyncCall(publishRejection, promise);
	}
}

function publish(promise) {
	promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
	promise._state = FULFILLED;
	publish(promise);
}

function publishRejection(promise) {
	promise._state = REJECTED;
	publish(promise);
	if (!promise._handled && isNode) {
		commonjsGlobal.process.emit('unhandledRejection', promise._data, promise);
	}
}

function notifyRejectionHandled(promise) {
	commonjsGlobal.process.emit('rejectionHandled', promise);
}

/**
 * @class
 */
function Promise$2(resolver) {
	if (typeof resolver !== 'function') {
		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
	}

	if (this instanceof Promise$2 === false) {
		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
	}

	this._then = [];

	invokeResolver(resolver, this);
}

Promise$2.prototype = {
	constructor: Promise$2,

	_state: PENDING,
	_then: null,
	_data: undefined,
	_handled: false,

	then: function (onFulfillment, onRejection) {
		var subscriber = {
			owner: this,
			then: new this.constructor(NOOP),
			fulfilled: onFulfillment,
			rejected: onRejection
		};

		if ((onRejection || onFulfillment) && !this._handled) {
			this._handled = true;
			if (this._state === REJECTED && isNode) {
				asyncCall(notifyRejectionHandled, this);
			}
		}

		if (this._state === FULFILLED || this._state === REJECTED) {
			// already resolved, call callback async
			asyncCall(invokeCallback, subscriber);
		} else {
			// subscribe
			this._then.push(subscriber);
		}

		return subscriber.then;
	},

	catch: function (onRejection) {
		return this.then(null, onRejection);
	}
};

Promise$2.all = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.all().');
	}

	return new Promise$2(function (resolve, reject) {
		var results = [];
		var remaining = 0;

		function resolver(index) {
			remaining++;
			return function (value) {
				results[index] = value;
				if (!--remaining) {
					resolve(results);
				}
			};
		}

		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolver(i), reject);
			} else {
				results[i] = promise;
			}
		}

		if (!remaining) {
			resolve(results);
		}
	});
};

Promise$2.race = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.race().');
	}

	return new Promise$2(function (resolve, reject) {
		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolve, reject);
			} else {
				resolve(promise);
			}
		}
	});
};

Promise$2.resolve = function (value) {
	if (value && typeof value === 'object' && value.constructor === Promise$2) {
		return value;
	}

	return new Promise$2(function (resolve) {
		resolve(value);
	});
};

Promise$2.reject = function (reason) {
	return new Promise$2(function (resolve, reject) {
		reject(reason);
	});
};

var pinkie = Promise$2;

var pinkiePromise = typeof Promise === 'function' ? Promise : pinkie;

var arrayUniq = createCommonjsModule(function (module) {

// there's 3 implementations written in increasing order of efficiency

// 1 - no Set type is defined
function uniqNoSet(arr) {
	var ret = [];

	for (var i = 0; i < arr.length; i++) {
		if (ret.indexOf(arr[i]) === -1) {
			ret.push(arr[i]);
		}
	}

	return ret;
}

// 2 - a simple Set type is defined
function uniqSet(arr) {
	var seen = new Set();
	return arr.filter(function (el) {
		if (!seen.has(el)) {
			seen.add(el);
			return true;
		}

		return false;
	});
}

// 3 - a standard Set type is defined and it has a forEach method
function uniqSetWithForEach(arr) {
	var ret = [];

	(new Set(arr)).forEach(function (el) {
		ret.push(el);
	});

	return ret;
}

// V8 currently has a broken implementation
// https://github.com/joyent/node/issues/8449
function doesForEachActuallyWork() {
	var ret = false;

	(new Set([true])).forEach(function (el) {
		ret = el;
	});

	return ret === true;
}

if ('Set' in commonjsGlobal) {
	if (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {
		module.exports = uniqSetWithForEach;
	} else {
		module.exports = uniqSet;
	}
} else {
	module.exports = uniqNoSet;
}
});

var arrayUnion = function () {
	return arrayUniq([].concat.apply([], arguments));
};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty$1.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var isWindows = process.platform === 'win32';


// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = path$2.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

var realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = path$2.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs$4.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs$4.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs$4.statSync(base);
        linkTarget = fs$4.readlinkSync(base);
      }
      resolvedLink = path$2.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = path$2.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


var realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = path$2.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs$4.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs$4.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs$4.stat(base, function(err) {
      if (err) return cb(err);

      fs$4.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = path$2.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = path$2.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

var old = {
	realpathSync: realpathSync,
	realpath: realpath
};

var fs_realpath = realpath$1;
realpath$1.realpath = realpath$1;
realpath$1.sync = realpathSync$1;
realpath$1.realpathSync = realpathSync$1;
realpath$1.monkeypatch = monkeypatch;
realpath$1.unmonkeypatch = unmonkeypatch;


var origRealpath = fs$4.realpath;
var origRealpathSync = fs$4.realpathSync;

var version = process.version;
var ok = /^v[0-5]\./.test(version);


function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath$1 (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function realpathSync$1 (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs$4.realpath = realpath$1;
  fs$4.realpathSync = realpathSync$1;
}

function unmonkeypatch () {
  fs$4.realpath = origRealpath;
  fs$4.realpathSync = origRealpathSync;
}

var concatMap = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var balancedMatch = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

var braceExpansion = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balancedMatch('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balancedMatch('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}

var minimatch_1 = minimatch;
minimatch.Minimatch = Minimatch;

var path$1 = { sep: '/' };
try {
  path$1 = path$2;
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};


var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/;

minimatch.filter = filter;
function filter (pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch;

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  };

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  };

  return m
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
};

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (path$1.sep !== '/') {
    pattern = pattern.split(path$1.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make;
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return
  }
  if (!pattern) {
    this.empty = true;
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;
function parseNegate () {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return braceExpansion(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)';
  var self = this;

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
        break
        case '?':
          re += qmark;
          hasMagic = true;
        break
        default:
          re += '\\' + stateChar;
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar();
        escaping = true;
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
      continue

      case '(':
        if (inClass) {
          re += '(';
          continue
        }

        if (!stateChar) {
          re += '\\(';
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue
        }

        clearStateChar();
        re += '|';
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    });

    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
};

Minimatch.prototype.makeRe = makeRe;
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f)
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list
};

Minimatch.prototype.match = match;
function match (f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options;

  // windows: need to use /, not \
  if (path$1.sep !== '/') {
    f = f.split(path$1.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr);
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
};

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util = util$1;
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

var pathIsAbsolute = process.platform === 'win32' ? win32 : posix;
var posix_1 = posix;
var win32_1 = win32;
pathIsAbsolute.posix = posix_1;
pathIsAbsolute.win32 = win32_1;

var alphasort_1 = alphasort;
var alphasorti_1 = alphasorti;
var setopts_1 = setopts;
var ownProp_1 = ownProp;
var makeAbs_1 = makeAbs;
var finish_1 = finish;
var mark_1 = mark;
var isIgnored_1 = isIgnored;
var childrenIgnored_1 = childrenIgnored;

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}




var Minimatch$1 = minimatch_1.Minimatch;

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap);
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
    gmatcher = new Minimatch$1(gpattern, { dot: true });
  }

  return {
    matcher: new Minimatch$1(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {};

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir)
    self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  setupIgnores(self, options);

  self.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp(options, "cwd"))
    self.cwd = cwd;
  else {
    self.cwd = path$2.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || path$2.resolve(self.cwd, "/");
  self.root = path$2.resolve(self.root);
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/");

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = pathIsAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
  self.nomount = !!options.nomount;

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true;
  options.nocomment = true;

  self.minimatch = new Minimatch$1(pattern, options);
  self.options = self.minimatch.options;
}

function finish (self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou)
          all.push(literal);
        else
          all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function (m) {
          all[m] = true;
        });
    }
  }

  if (!nou)
    all = Object.keys(all);

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort);

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e));
        var c = self.cache[e] || self.cache[makeAbs(self, e)];
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir
      });
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    });

  self.found = all;
}

function mark (self, p) {
  var abs = makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';

    if (isDir && !slash)
      m += '/';
    else if (!isDir && slash)
      m = m.slice(0, -1);

    if (m !== p) {
      var mabs = makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f;
  if (f.charAt(0) === '/') {
    abs = path$2.join(self.root, f);
  } else if (pathIsAbsolute(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = path$2.resolve(self.cwd, f);
  } else {
    abs = path$2.resolve(f);
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/');

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

var common = {
	alphasort: alphasort_1,
	alphasorti: alphasorti_1,
	setopts: setopts_1,
	ownProp: ownProp_1,
	makeAbs: makeAbs_1,
	finish: finish_1,
	mark: mark_1,
	isIgnored: isIgnored_1,
	childrenIgnored: childrenIgnored_1
};

var sync = globSync;
globSync.GlobSync = GlobSync;
var setopts$1 = common.setopts;
var ownProp$1 = common.ownProp;
var childrenIgnored$1 = common.childrenIgnored;
var isIgnored$1 = common.isIgnored;

function globSync(pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n' +
      'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync(pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n' +
      'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts$1(this, pattern, options);

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length;
  this.matches = new Array(n);
  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false);
  }
  this._finish();
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync);
  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);
      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = fs_realpath.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true;
          else
            throw er
        }
      }
    });
  }
  common.finish(this);
};


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync);

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n++;
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip processing
  if (childrenIgnored$1(this, read))
    return

  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar);

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$2.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix)
      newPattern = [prefix, e];
    else
      newPattern = [e];
    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored$1(this, e))
    return

  var abs = this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute) {
    e = abs;
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  if (this.stat)
    this._stat(e);
};


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries;
  var lstat;
  try {
    lstat = fs$4.lstatSync(abs);
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink();
  this.symlinks[abs] = isSym;

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE';
  else
    entries = this._readdir(abs, false);

  return entries
};

GlobSync.prototype._readdir = function (abs, inGlobStar) {

  if (inGlobStar && !ownProp$1(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs$4.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er);
    return null
  }
};

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;

  // mark and cache dir-ness
  return entries
};

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er);
      break
  }
};

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar);

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs];

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true);
  }
};

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path$2.join(this.root, prefix);
    } else {
      prefix = path$2.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
};

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }
  var stat = this.statCache[abs];
  if (!stat) {
    var lstat;
    try {
      lstat = fs$4.lstatSync(abs);
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs$4.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';

  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return false

  return c
};

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
};

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy;
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var once_1 = wrappy_1(once);
var strict = wrappy_1(onceStrict);

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}
once_1.strict = strict;

var reqs = Object.create(null);


var inflight_1 = wrappy_1(inflight);

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null
  } else {
    reqs[key] = [cb];
    return makeres(key)
  }
}

function makeres (key) {
  return once_1(function RES () {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice(arguments);

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len);
        process.nextTick(function () {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  })
}

function slice (args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];
  return array
}

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

var glob_1 = glob;

var EE = events$2.EventEmitter;
var setopts$2 = common.setopts;
var ownProp$2 = common.ownProp;


var childrenIgnored$2 = common.childrenIgnored;
var isIgnored$2 = common.isIgnored;



function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return sync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = sync;
var GlobSync$1 = glob.GlobSync = sync.GlobSync;

// old api surface
glob.glob = glob;

function extend$1 (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend$1({}, options_);
  options.noprocess = true;

  var g = new Glob(pattern, options);
  var set = g.minimatch.set;

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
};

glob.Glob = Glob;
inherits(Glob, EE);
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync$1(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts$2(this, pattern, options);
  this._didRealPath = false;

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length;

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = once_1(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  this._processing = 0;

  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true;
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done);
  }
  sync = false;

  function done () {
    --self._processing;
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob);
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this);
  this.emit('end', this.found);
};

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true;

  var n = this.matches.length;
  if (n === 0)
    return this._finish()

  var self = this;
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next);

  function next () {
    if (--n === 0)
      self._finish();
  }
};

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset)
    return cb()

  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    fs_realpath.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true;
      else if (er.syscall === 'stat')
        set[p] = true;
      else
        self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
};

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
};

Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);
      this._emitQueue.length = 0;
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i];
        this._emitMatch(e[0], e[1]);
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);
      this._processQueue.length = 0;
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i];
        this._processing--;
        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob);
  assert(typeof cb === 'function');

  if (this.aborted)
    return

  this._processing++;
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n ++;
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip _processing
  if (childrenIgnored$2(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  });
};

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$2.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i];
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e;
      else
        e = prefix + e;
    }
    this._process([e].concat(remain), index, inGlobStar, cb);
  }
  cb();
};

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored$2(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e]);
    return
  }

  var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute)
    e = abs;

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  var st = this.statCache[abs];
  if (st)
    this.emit('stat', e, st);

  this.emit('match', e);
};

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = inflight_1(lstatkey, lstatcb_);

  if (lstatcb)
    fs$4.lstat(abs, lstatcb);

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink();
    self.symlinks[abs] = isSym;

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else
      self._readdir(abs, false, cb);
  }
};

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight_1('readdir\0'+abs+'\0'+inGlobStar, cb);
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp$2(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }
  fs$4.readdir(abs, readdirCb(this, abs, cb));
};

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb);
    else
      self._readdirEntries(abs, entries, cb);
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries)
};

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) {
        this.emit('error', er);
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort();
      }
      if (!this.silent)
        console.error('glob error', er);
      break
  }

  return cb()
};

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [ prefix ] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length;

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true, cb);
  }

  cb();
};

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path$2.join(this.root, prefix);
    } else {
      prefix = path$2.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
  cb();
};

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }
  var stat = this.statCache[abs];
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this;
  var statcb = inflight_1('stat\0' + abs, lstatcb_);
  if (statcb)
    fs$4.lstat(abs, statcb);

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs$4.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb);
        else
          self._stat2(f, abs, er, stat, cb);
      })
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false;
    return cb()
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
};

var arrify = function (val) {
	if (val === null || val === undefined) {
		return [];
	}

	return Array.isArray(val) ? val : [val];
};

var globP = pify_1(glob_1, pinkiePromise).bind(glob_1);

function isNegative(pattern) {
	return pattern[0] === '!';
}

function generateGlobTasks(patterns, opts) {
	var globTasks = [];

	patterns = arrify(patterns);
	opts = objectAssign({
		cache: Object.create(null),
		statCache: Object.create(null),
		realpathCache: Object.create(null),
		symlinks: Object.create(null),
		ignore: []
	}, opts);

	patterns.forEach(function (pattern, i) {
		if (isNegative(pattern)) {
			return;
		}

		var ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {
			return pattern.slice(1);
		});

		globTasks.push({
			pattern: pattern,
			opts: objectAssign({}, opts, {
				ignore: opts.ignore.concat(ignore)
			})
		});
	});

	return globTasks;
}

var globby = function (patterns, opts) {
	var globTasks = generateGlobTasks(patterns, opts);

	return pinkiePromise.all(globTasks.map(function (task) {
		return globP(task.pattern, task.opts);
	})).then(function (paths) {
		return arrayUnion.apply(null, paths);
	});
};

var sync$1 = function (patterns, opts) {
	var globTasks = generateGlobTasks(patterns, opts);

	return globTasks.reduce(function (matches, task) {
		return arrayUnion(matches, glob_1.sync(task.pattern, task.opts));
	}, []);
};

var generateGlobTasks_1 = generateGlobTasks;
globby.sync = sync$1;
globby.generateGlobTasks = generateGlobTasks_1;

var isPathCwd = function (str) {
	return path$2.resolve(str) === path$2.resolve(process.cwd());
};

var pathIsInside = function (thePath, potentialParent) {
    // For inside-directory checking, we want to allow trailing slashes, so normalize.
    thePath = stripTrailingSep(thePath);
    potentialParent = stripTrailingSep(potentialParent);

    // Node treats only Windows as case-insensitive in its path module; we follow those conventions.
    if (process.platform === "win32") {
        thePath = thePath.toLowerCase();
        potentialParent = potentialParent.toLowerCase();
    }

    return thePath.lastIndexOf(potentialParent, 0) === 0 &&
		(
			thePath[potentialParent.length] === path$2.sep ||
			thePath[potentialParent.length] === undefined
		);
};

function stripTrailingSep(thePath) {
    if (thePath[thePath.length - 1] === path$2.sep) {
        return thePath.slice(0, -1);
    }
    return thePath;
}

var isPathInside = function (a, b) {
	a = path$2.resolve(a);
	b = path$2.resolve(b);

	if (a === b) {
		return false;
	}

	return pathIsInside(a, b);
};

var isPathInCwd = function (str) {
	return isPathInside(str, process.cwd());
};

var rimraf_1 = rimraf;
rimraf.sync = rimrafSync;




var glob$1 = undefined;
try {
  glob$1 = glob_1;
} catch (_err) {
  // treat glob as optional.
}
var _0666 = parseInt('666', 8);

var defaultGlobOpts = {
  nosort: true,
  silent: true
};

// for EMFILE handling
var timeout = 0;

var isWindows$1 = (process.platform === "win32");

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(function(m) {
    options[m] = options[m] || fs$4[m];
    m = m + 'Sync';
    options[m] = options[m] || fs$4[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
  options.emfileWait = options.emfileWait || 1000;
  if (options.glob === false) {
    options.disableGlob = true;
  }
  if (options.disableGlob !== true && glob$1 === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false;
  options.glob = options.glob || defaultGlobOpts;
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  var busyTries = 0;
  var errState = null;
  var n = 0;

  if (options.disableGlob || !glob$1.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob$1(p, options.glob, afterGlob);
  });

  function next (er) {
    errState = errState || er;
    if (--n === 0)
      cb(errState);
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length;
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++;
            var time = busyTries * 100;
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB);
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB);
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null;
        }

        timeout = 0;
        next(er);
      });
    });
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows$1)
      fixWinEPERM(p, options, er, cb);

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows$1)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');
  if (er)
    assert(er instanceof Error);

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er);
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er);
        else if (stats.isDirectory())
          rmdir(p, options, er, cb);
        else
          options.unlink(p, cb);
      });
  });
}

function fixWinEPERMSync (p, options, er) {
  assert(p);
  assert(options);
  if (er)
    assert(er instanceof Error);

  try {
    options.chmodSync(p, _0666);
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er);
  else
    options.unlinkSync(p);
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr)
    assert(originalEr instanceof Error);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb);
    else if (er && er.code === "ENOTDIR")
      cb(originalEr);
    else
      cb(er);
  });
}

function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length;
    if (n === 0)
      return options.rmdir(p, cb)
    var errState;
    files.forEach(function (f) {
      rimraf(path$2.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb);
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  var results;

  if (options.disableGlob || !glob$1.hasMagic(p)) {
    results = [p];
  } else {
    try {
      options.lstatSync(p);
      results = [p];
    } catch (er) {
      results = glob$1.sync(p, options.glob);
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i];

    try {
      var st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows$1)
        fixWinEPERMSync(p, options, er);
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null);
      else
        options.unlinkSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows$1 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er);
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr)
    assert(originalEr instanceof Error);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options);
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path$2.join(p, f), options);
  });

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows$1 ? 100 : 1;
  var i = 0;
  do {
    var threw = true;
    try {
      var ret = options.rmdirSync(p, options);
      threw = false;
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

var rimrafP = pify_1(rimraf_1, pinkiePromise);

function safeCheck(file) {
	if (isPathCwd(file)) {
		throw new Error('Cannot delete the current working directory. Can be overriden with the `force` option.');
	}

	if (!isPathInCwd(file)) {
		throw new Error('Cannot delete files/folders outside the current working directory. Can be overriden with the `force` option.');
	}
}

var del = function (patterns, opts) {
	opts = objectAssign({}, opts);

	var force = opts.force;
	delete opts.force;

	var dryRun = opts.dryRun;
	delete opts.dryRun;

	return globby(patterns, opts).then(function (files) {
		return pinkiePromise.all(files.map(function (file) {
			if (!force) {
				safeCheck(file);
			}

			file = path$2.resolve(opts.cwd || '', file);

			if (dryRun) {
				return pinkiePromise.resolve(file);
			}

			return rimrafP(file).then(function () {
				return file;
			});
		}));
	});
};

var sync$2 = function (patterns, opts) {
	opts = objectAssign({}, opts);

	var force = opts.force;
	delete opts.force;

	var dryRun = opts.dryRun;
	delete opts.dryRun;

	return globby.sync(patterns, opts).map(function (file) {
		if (!force) {
			safeCheck(file);
		}

		file = path$2.resolve(opts.cwd || '', file);

		if (!dryRun) {
			rimraf_1.sync(file);
		}

		return file;
	});
};
del.sync = sync$2;

var junk = createCommonjsModule(function (module, exports) {

// // All
// /^npm-debug\.log$/,   // npm error log
// /^\..*\.swp$/,        // vim state
// // macOS
// /^\.DS_Store$/,       // stores custom folder attributes
// /^\.AppleDouble$/,    // stores additional file resources
// /^\.LSOverride$/,     // contains the absolute path to the app to be used
// /^Icon\r$/,           // custom Finder icon: http://superuser.com/questions/298785/icon-file-on-os-x-desktop
// /^\._.*/,             // thumbnail
// /^\.Spotlight-V100$/,  // file that might appear on external disk
// /\.Trashes/,          // file that might appear on external disk
// /^__MACOSX$/,         // resource fork
// // Linux
// /~$/,                 // backup file
// // Windows
// /^Thumbs\.db$/,       // image file cache
// /^ehthumbs\.db$/,     // folder config file
// /^Desktop\.ini$/      // stores custom folder attributes

exports.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon\r$|^\._.*|^\.Spotlight-V100$|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$/;

exports.is = function (filename) {
	return exports.re.test(filename);
};

exports.not = exports.isnt = function (filename) {
	return !exports.is(filename);
};
});
var junk_1 = junk.re;
var junk_2 = junk.is;
var junk_3 = junk.not;
var junk_4 = junk.isnt;

var prr = createCommonjsModule(function (module) {
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if ( module.exports)
    module.exports = definition();
  else
    context[name] = definition();
})('prr', commonjsGlobal, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options);
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value;
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            };

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k;

        options = makeOptions(value, options);

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k];
              setProperty(obj, k, options);
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      };

  return prr
});
});

function init$1 (type, message, cause) {
  if (!!message && typeof message != 'string') {
    message = message.message || message.name;
  }
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : message
  }, 'ewr');
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this);
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor);
  init$1.call(this, 'CustomError', message, cause);
}

CustomError.prototype = new Error();

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init$1.call(this, type, message, cause);
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code;
      this.path    = this.cause.path;
      this.errno   = this.cause.errno;
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '');
    }
    Error.call(this);
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, err);
  };
  err.prototype = !!proto ? new proto() : new CustomError();
  return err
}

var custom = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  };
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
};

var errno = createCommonjsModule(function (module) {
var all = module.exports.all = [
  {
    errno: -2,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: -1,
    code: 'UNKNOWN',
    description: 'unknown error'
  },
  {
    errno: 0,
    code: 'OK',
    description: 'success'
  },
  {
    errno: 1,
    code: 'EOF',
    description: 'end of file'
  },
  {
    errno: 2,
    code: 'EADDRINFO',
    description: 'getaddrinfo error'
  },
  {
    errno: 3,
    code: 'EACCES',
    description: 'permission denied'
  },
  {
    errno: 4,
    code: 'EAGAIN',
    description: 'resource temporarily unavailable'
  },
  {
    errno: 5,
    code: 'EADDRINUSE',
    description: 'address already in use'
  },
  {
    errno: 6,
    code: 'EADDRNOTAVAIL',
    description: 'address not available'
  },
  {
    errno: 7,
    code: 'EAFNOSUPPORT',
    description: 'address family not supported'
  },
  {
    errno: 8,
    code: 'EALREADY',
    description: 'connection already in progress'
  },
  {
    errno: 9,
    code: 'EBADF',
    description: 'bad file descriptor'
  },
  {
    errno: 10,
    code: 'EBUSY',
    description: 'resource busy or locked'
  },
  {
    errno: 11,
    code: 'ECONNABORTED',
    description: 'software caused connection abort'
  },
  {
    errno: 12,
    code: 'ECONNREFUSED',
    description: 'connection refused'
  },
  {
    errno: 13,
    code: 'ECONNRESET',
    description: 'connection reset by peer'
  },
  {
    errno: 14,
    code: 'EDESTADDRREQ',
    description: 'destination address required'
  },
  {
    errno: 15,
    code: 'EFAULT',
    description: 'bad address in system call argument'
  },
  {
    errno: 16,
    code: 'EHOSTUNREACH',
    description: 'host is unreachable'
  },
  {
    errno: 17,
    code: 'EINTR',
    description: 'interrupted system call'
  },
  {
    errno: 18,
    code: 'EINVAL',
    description: 'invalid argument'
  },
  {
    errno: 19,
    code: 'EISCONN',
    description: 'socket is already connected'
  },
  {
    errno: 20,
    code: 'EMFILE',
    description: 'too many open files'
  },
  {
    errno: 21,
    code: 'EMSGSIZE',
    description: 'message too long'
  },
  {
    errno: 22,
    code: 'ENETDOWN',
    description: 'network is down'
  },
  {
    errno: 23,
    code: 'ENETUNREACH',
    description: 'network is unreachable'
  },
  {
    errno: 24,
    code: 'ENFILE',
    description: 'file table overflow'
  },
  {
    errno: 25,
    code: 'ENOBUFS',
    description: 'no buffer space available'
  },
  {
    errno: 26,
    code: 'ENOMEM',
    description: 'not enough memory'
  },
  {
    errno: 27,
    code: 'ENOTDIR',
    description: 'not a directory'
  },
  {
    errno: 28,
    code: 'EISDIR',
    description: 'illegal operation on a directory'
  },
  {
    errno: 29,
    code: 'ENONET',
    description: 'machine is not on the network'
  },
  {
    errno: 31,
    code: 'ENOTCONN',
    description: 'socket is not connected'
  },
  {
    errno: 32,
    code: 'ENOTSOCK',
    description: 'socket operation on non-socket'
  },
  {
    errno: 33,
    code: 'ENOTSUP',
    description: 'operation not supported on socket'
  },
  {
    errno: 34,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: 35,
    code: 'ENOSYS',
    description: 'function not implemented'
  },
  {
    errno: 36,
    code: 'EPIPE',
    description: 'broken pipe'
  },
  {
    errno: 37,
    code: 'EPROTO',
    description: 'protocol error'
  },
  {
    errno: 38,
    code: 'EPROTONOSUPPORT',
    description: 'protocol not supported'
  },
  {
    errno: 39,
    code: 'EPROTOTYPE',
    description: 'protocol wrong type for socket'
  },
  {
    errno: 40,
    code: 'ETIMEDOUT',
    description: 'connection timed out'
  },
  {
    errno: 41,
    code: 'ECHARSET',
    description: 'invalid Unicode character'
  },
  {
    errno: 42,
    code: 'EAIFAMNOSUPPORT',
    description: 'address family for hostname not supported'
  },
  {
    errno: 44,
    code: 'EAISERVICE',
    description: 'servname not supported for ai_socktype'
  },
  {
    errno: 45,
    code: 'EAISOCKTYPE',
    description: 'ai_socktype not supported'
  },
  {
    errno: 46,
    code: 'ESHUTDOWN',
    description: 'cannot send after transport endpoint shutdown'
  },
  {
    errno: 47,
    code: 'EEXIST',
    description: 'file already exists'
  },
  {
    errno: 48,
    code: 'ESRCH',
    description: 'no such process'
  },
  {
    errno: 49,
    code: 'ENAMETOOLONG',
    description: 'name too long'
  },
  {
    errno: 50,
    code: 'EPERM',
    description: 'operation not permitted'
  },
  {
    errno: 51,
    code: 'ELOOP',
    description: 'too many symbolic links encountered'
  },
  {
    errno: 52,
    code: 'EXDEV',
    description: 'cross-device link not permitted'
  },
  {
    errno: 53,
    code: 'ENOTEMPTY',
    description: 'directory not empty'
  },
  {
    errno: 54,
    code: 'ENOSPC',
    description: 'no space left on device'
  },
  {
    errno: 55,
    code: 'EIO',
    description: 'i/o error'
  },
  {
    errno: 56,
    code: 'EROFS',
    description: 'read-only file system'
  },
  {
    errno: 57,
    code: 'ENODEV',
    description: 'no such device'
  },
  {
    errno: 58,
    code: 'ESPIPE',
    description: 'invalid seek'
  },
  {
    errno: 59,
    code: 'ECANCELED',
    description: 'operation canceled'
  }
];

module.exports.errno = {};
module.exports.code = {};

all.forEach(function (error) {
  module.exports.errno[error.errno] = error;
  module.exports.code[error.code] = error;
});

module.exports.custom = custom(module.exports);
module.exports.create = module.exports.custom.createError;
});
var errno_1 = errno.all;
var errno_2 = errno.errno;
var errno_3 = errno.code;
var errno_4 = errno.custom;
var errno_5 = errno.create;

var arrayDiffer = function (arr) {
	var rest = [].concat.apply([], [].slice.call(arguments, 1));
	return arr.filter(function (el) {
		return rest.indexOf(el) === -1;
	});
};

var maximatch = function (list, patterns, options) {
	list = arrify(list);
	patterns = arrify(patterns);

	if (list.length === 0 || patterns.length === 0) {
		return [];
	}

	options = options || {};

	return patterns.reduce(function (ret, pattern) {
		if (typeof pattern === 'function') {

			return arrayUnion(ret, list.filter(pattern));

		} else if (pattern instanceof RegExp) {

			return arrayUnion(ret, list.filter(function(item) {
				return pattern.test(item);
			}));

		} else {
			var process = arrayUnion;

			if (pattern[0] === '!') {
				pattern = pattern.slice(1);
				process = arrayDiffer;
			}

			return process(ret, minimatch_1.match(list, pattern, options));
		}
	}, []);
};

var slash = function (str) {
	var isExtendedLengthPath = /^\\\\\?\\/.test(str);
	var hasNonAscii = /[^\x00-\x80]+/.test(str);

	if (isExtendedLengthPath || hasNonAscii) {
		return str;
	}

	return str.replace(/\\/g, '/');
};

/**
 * dependencies.
 */

var Emitter = events$2.EventEmitter
  , proto = Emitter.prototype;

/**
 * expsoe `mixin`
 *
 * @param {Object} obj
 */

var emitterMixin = function (obj) {

  // mixin

  for (var k in proto) {
    obj[k] = proto[k];
  }

  // events getter.

  obj.__defineGetter__('_events', function () {
    return this.__events || (this.__events = {});
  });

  // events setter.

  obj.__defineSetter__('_events', function (val) {
    this.__events = val;
  });

  /**
   * Remove all listeners for `event`.
   *
   * if the method is executed without
   * arguments it will remove all listeners,
   * otherwise you can supply `event` or
   * `event` with `fn` for more specific stuff.
   *
   * example:
   *
   *          obj.on('foo', console.log)._events;
   *          // > { foo: fn, }
   *          obj.on('foo', console.dir)._events;
   *          // > { foo: [fn, fn] }
   *          obj.off('foo', console.log)._events;
   *          // > { foo: [fn] }
   *          obj.off('foo');
   *          // > {}
   *          obj.off();
   *          // > {}
   *
   * @param {String} event
   * @param {Function} fn
   * @return {self}
   */

  obj.off = function (event, fn) {
    switch (arguments.length) {
      case 2:
        this.removeListener(event, fn);
        return this;
      case 1:
        this.removeAllListeners(event);
        return this;
      case 0:
        this.removeAllListeners();
        return this;
    }
  };


  // all done
  return obj;
};

var Promise$3 = commonjsGlobal.Promise || promise$1;



var EventEmitter = events$2.EventEmitter;









var CopyError = errno.custom.createError('CopyError');

var EVENT_ERROR = 'error';
var EVENT_COMPLETE = 'complete';
var EVENT_CREATE_DIRECTORY_START = 'createDirectoryStart';
var EVENT_CREATE_DIRECTORY_ERROR = 'createDirectoryError';
var EVENT_CREATE_DIRECTORY_COMPLETE = 'createDirectoryComplete';
var EVENT_CREATE_SYMLINK_START = 'createSymlinkStart';
var EVENT_CREATE_SYMLINK_ERROR = 'createSymlinkError';
var EVENT_CREATE_SYMLINK_COMPLETE = 'createSymlinkComplete';
var EVENT_COPY_FILE_START = 'copyFileStart';
var EVENT_COPY_FILE_ERROR = 'copyFileError';
var EVENT_COPY_FILE_COMPLETE = 'copyFileComplete';

var mkdir = pify_1(mkdirp, Promise$3);
var stat = pify_1(gracefulFs.stat, Promise$3);
var lstat = pify_1(gracefulFs.lstat, Promise$3);
var readlink = pify_1(gracefulFs.readlink, Promise$3);
var symlink = pify_1(gracefulFs.symlink, Promise$3);
var readdir = pify_1(gracefulFs.readdir, Promise$3);

var copy_1 = function(src, dest, options, callback) {
	if ((arguments.length === 3) && (typeof options === 'function')) {
		callback = options;
		options = undefined;
	}
	options = options || {};

	var parentDirectory = path$2.dirname(dest);
	var shouldExpandSymlinks = Boolean(options.expand);

	var emitter;
	var hasFinished = false;
	if (options.debug) { log('Ensuring output directory exists…'); }
	var promise = ensureDirectoryExists(parentDirectory)
		.then(function() {
			if (options.debug) { log('Fetching source paths…'); }
			return getFilePaths(src, shouldExpandSymlinks)
		})
		.then(function(filePaths) {
			if (options.debug) { log('Filtering source paths…'); }
			var relativePaths = filePaths.map(function(filePath) {
				return path$2.relative(src, filePath);
			});
			var filteredPaths = getFilteredPaths(relativePaths, options.filter, {
				dot: options.dot,
				junk: options.junk
			});
			return filteredPaths.map(function(relativePath) {
				var inputPath = relativePath;
				var outputPath = options.rename ? options.rename(inputPath) : inputPath;
				return {
					src: path$2.join(src, inputPath),
					dest: path$2.join(dest, outputPath)
				};
			})
		})
		.then(function(operations) {
			if (options.debug) { log('Copying files…'); }
			var hasFinishedGetter = function() { return hasFinished; };
			var emitEvent = function() { emitter.emit.apply(emitter, arguments); };
			return batch(operations, function(operation) {
				return copy(operation.src, operation.dest, hasFinishedGetter, emitEvent, options);
			}, {
				results: options.results !== false,
				concurrency: options.concurrency || 255
			});
		})
		.catch(function(error) {
			if (options.debug) { log('Copy failed'); }
			if (error instanceof CopyError) {
				emitter.emit(EVENT_ERROR, error.error, error.data);
				throw error.error;
			} else {
				throw error;
			}
		})
		.then(function(results) {
			if (options.debug) { log('Copy complete'); }
			emitter.emit(EVENT_COMPLETE, results);
			return results;
		})
		.then(function(results) {
			hasFinished = true;
			return results;
		})
		.catch(function(error) {
			hasFinished = true;
			throw error;
		});

	if (typeof callback === 'function') {
		promise.then(function(results) {
			callback(null, results);
		})
		.catch(function(error) {
			callback(error);
		});
		emitter = new EventEmitter();
	} else {
		emitter = emitterMixin(promise);
	}

	return emitter;
};

function batch(inputs, iteratee, options) {
	var results = options.results ? [] : undefined;
	if (inputs.length === 0) { return Promise$3.resolve(results); }
	return new Promise$3(function(resolve, reject) {
		var currentIndex = -1;
		var activeWorkers = 0;
		while (currentIndex < Math.min(inputs.length, options.concurrency) - 1) {
			startWorker(inputs[++currentIndex]);
		}

		function startWorker(input) {
			++activeWorkers;
			iteratee(input).then(function(result) {
				--activeWorkers;
				if (results) { results.push(result); }
				if (currentIndex < inputs.length - 1) {
					startWorker(inputs[++currentIndex]);
				} else if (activeWorkers === 0) {
					resolve(results);
				}
			}).catch(reject);
		}
	});
}

function getFilePaths(src, shouldExpandSymlinks) {
	return (shouldExpandSymlinks ? stat : lstat)(src)
		.then(function(stats) {
			if (stats.isDirectory()) {
				return getFileListing(src, shouldExpandSymlinks)
					.then(function(filenames) {
						return [src].concat(filenames);
					});
			} else {
				return [src];
			}
		});
}

function getFilteredPaths(paths, filter, options) {
	var useDotFilter = !options.dot;
	var useJunkFilter = !options.junk;
	if (!filter && !useDotFilter && !useJunkFilter) { return paths; }
	return paths.filter(function(path) {
		return (!useDotFilter || dotFilter(path)) && (!useJunkFilter || junkFilter(path)) && (!filter || (maximatch(slash(path), filter, options).length > 0));
	});
}

function dotFilter(relativePath) {
	var filename = path$2.basename(relativePath);
	return filename.charAt(0) !== '.';
}

function junkFilter(relativePath) {
	var filename = path$2.basename(relativePath);
	return !junk.is(filename);
}

function ensureDirectoryExists(path) {
	return mkdir(path);
}

function getFileListing(srcPath, shouldExpandSymlinks) {
	return readdir(srcPath)
		.then(function(filenames) {
			return Promise$3.all(
				filenames.map(function(filename) {
					var filePath = path$2.join(srcPath, filename);
					return (shouldExpandSymlinks ? stat : lstat)(filePath)
						.then(function(stats) {
							if (stats.isDirectory()) {
								return getFileListing(filePath, shouldExpandSymlinks)
									.then(function(childPaths) {
										return [filePath].concat(childPaths);
									});
							} else {
								return [filePath];
							}
						});
				})
			)
			.then(function mergeArrays(arrays) {
				return Array.prototype.concat.apply([], arrays);
			});
		});
}

function copy(srcPath, destPath, hasFinished, emitEvent, options) {
	if (options.debug) { log('Preparing to copy ' + srcPath + '…'); }
	return prepareForCopy(srcPath, destPath, options)
		.then(function(stats) {
			if (options.debug) { log('Copying ' + srcPath + '…'); }
			var copyFunction = getCopyFunction(stats, hasFinished, emitEvent);
			return copyFunction(srcPath, destPath, stats, options);
		})
		.catch(function(error) {
			if (error instanceof CopyError) {
				throw error;
			}
			var copyError = new CopyError(error.message);
			copyError.error = error;
			copyError.data = {
				src: srcPath,
				dest: destPath
			};
			throw copyError;
		})
		.then(function(result) {
			if (options.debug) { log('Copied ' + srcPath); }
			return result;
		});
}

function prepareForCopy(srcPath, destPath, options) {
	var shouldExpandSymlinks = Boolean(options.expand);
	var shouldOverwriteExistingFiles = Boolean(options.overwrite);
	return (shouldExpandSymlinks ? stat : lstat)(srcPath)
		.then(function(stats) {
			return ensureDestinationIsWritable(destPath, stats, shouldOverwriteExistingFiles)
				.then(function() {
					return stats;
				});
		});
}

function ensureDestinationIsWritable(destPath, srcStats, shouldOverwriteExistingFiles) {
	return lstat(destPath)
		.catch(function(error) {
			var shouldIgnoreError = error.code === 'ENOENT';
			if (shouldIgnoreError) { return null; }
			throw error;
		})
		.then(function(destStats) {
			var destExists = Boolean(destStats);
			if (!destExists) { return true; }

			var isMergePossible = srcStats.isDirectory() && destStats.isDirectory();
			if (isMergePossible) { return true; }

			if (shouldOverwriteExistingFiles) {
				return del(destPath, { force: true })
					.then(function(paths) {
						return true;
					});
			} else {
				throw fsError('EEXIST', destPath);
			}
		});
}

function getCopyFunction(stats, hasFinished, emitEvent) {
	if (stats.isDirectory()) {
		return createCopyFunction(copyDirectory, stats, hasFinished, emitEvent, {
			startEvent: EVENT_CREATE_DIRECTORY_START,
			completeEvent: EVENT_CREATE_DIRECTORY_COMPLETE,
			errorEvent: EVENT_CREATE_DIRECTORY_ERROR
		});
	} else if (stats.isSymbolicLink()) {
		return createCopyFunction(copySymlink, stats, hasFinished, emitEvent, {
			startEvent: EVENT_CREATE_SYMLINK_START,
			completeEvent: EVENT_CREATE_SYMLINK_COMPLETE,
			errorEvent: EVENT_CREATE_SYMLINK_ERROR
		});
	} else {
		return createCopyFunction(copyFile, stats, hasFinished, emitEvent, {
			startEvent: EVENT_COPY_FILE_START,
			completeEvent: EVENT_COPY_FILE_COMPLETE,
			errorEvent: EVENT_COPY_FILE_ERROR
		});
	}
}

function createCopyFunction(fn, stats, hasFinished, emitEvent, events) {
	var startEvent = events.startEvent;
	var completeEvent = events.completeEvent;
	var errorEvent = events.errorEvent;
	return function(srcPath, destPath, stats, options) {
		// Multiple chains of promises are fired in parallel,
		// so when one fails we need to prevent any future
		// copy operations
		if (hasFinished()) { return Promise$3.reject(); }
		var metadata = {
			src: srcPath,
			dest: destPath,
			stats: stats
		};
		emitEvent(startEvent, metadata);
		var parentDirectory = path$2.dirname(destPath);
		return ensureDirectoryExists(parentDirectory)
			.then(function() {
				return fn(srcPath, destPath, stats, options);
			})
			.then(function() {
				if (!hasFinished()) { emitEvent(completeEvent, metadata); }
				return metadata;
			})
			.catch(function(error) {
				if (!hasFinished()) { emitEvent(errorEvent, error, metadata); }
				throw error;
			});
	};
}

function copyFile(srcPath, destPath, stats, options) {
	return new Promise$3(function(resolve, reject) {
		var hasFinished = false;

		var read = gracefulFs.createReadStream(srcPath);
		read.on('error', handleCopyFailed);

		var write = gracefulFs.createWriteStream(destPath, {
			flags: 'w',
			mode: stats.mode
		});
		write.on('error', handleCopyFailed);
		write.on('finish', function() {
			gracefulFs.utimes(destPath, stats.atime, stats.mtime, function() {
				hasFinished = true;
				resolve();
			});
		});

		var transformStream = null;
		if (options.transform) {
			transformStream = options.transform(srcPath, destPath, stats);
			if (transformStream) {
				transformStream.on('error', handleCopyFailed);
				read.pipe(transformStream).pipe(write);
			} else {
				read.pipe(write);
			}
		} else {
			read.pipe(write);
		}


		function handleCopyFailed(error) {
			if (hasFinished) { return; }
			hasFinished = true;
			if (typeof read.close === 'function') {
				read.close();
			}
			if (typeof write.close === 'function') {
				write.close();
			}
			return reject(error);
		}
	});
}

function copySymlink(srcPath, destPath, stats, options) {
	return readlink(srcPath)
		.then(function(link) {
			return symlink(link, destPath);
		});
}

function copyDirectory(srcPath, destPath, stats, options) {
	return mkdir(destPath)
		.catch(function(error) {
			var shouldIgnoreError = error.code === 'EEXIST';
			if (shouldIgnoreError) { return; }
			throw error;
		});
}

function fsError(code, path) {
	var errorType = errno.code[code];
	var message = errorType.code + ', ' + errorType.description + ' ' + path;
	var error = new Error(message);
	error.errno = errorType.errno;
	error.code = errorType.code;
	error.path = path;
	return error;
}

function log(message) {
	process.stdout.write(message + '\n');
}

var events$1 = {
	ERROR: EVENT_ERROR,
	COMPLETE: EVENT_COMPLETE,
	CREATE_DIRECTORY_START: EVENT_CREATE_DIRECTORY_START,
	CREATE_DIRECTORY_ERROR: EVENT_CREATE_DIRECTORY_ERROR,
	CREATE_DIRECTORY_COMPLETE: EVENT_CREATE_DIRECTORY_COMPLETE,
	CREATE_SYMLINK_START: EVENT_CREATE_SYMLINK_START,
	CREATE_SYMLINK_ERROR: EVENT_CREATE_SYMLINK_ERROR,
	CREATE_SYMLINK_COMPLETE: EVENT_CREATE_SYMLINK_COMPLETE,
	COPY_FILE_START: EVENT_COPY_FILE_START,
	COPY_FILE_ERROR: EVENT_COPY_FILE_ERROR,
	COPY_FILE_COMPLETE: EVENT_COPY_FILE_COMPLETE
};
copy_1.events = events$1;

var recursiveCopy = copy_1;

function transferFiles({dest, src, includeNode=true}={}) {
    return new Promise((resolve, reject)=>{


        // const filter = fs.readdirSync(src).filter((file) => {return file !== "node_modules" && file !== "python3"})

        // const options = {overwrite: true, filter: includeNode ?  fs.readdirSync(src) : filter}
        
        // console.log(options)

        recursiveCopy(src, dest, {overwrite: true}, function(error, results) {
        
            if (error) {
        
                console.error('Copy failed: ' + error);
                window.createToast("Update failed.\nMaybe the user doesn't have necessary persmission to write files in the disk", "danger");

                reject(error);
            } else {
                console.info('Copied ' + results.length + ' files');

                window.createToast("Transfer completed.", "success");
                resolve(results);
            }
        });
    })
}

function backupRestore({event, method="backup"}={}) {

    return new Promise((resolve, reject)=> {
        
        let target = event.target;

        target.classList.toggle("is-loading");

        browse({dir:true})

            .then( async (result) =>{
                let folderName;
                if (!result.canceled) { folderName = result.filePaths[0]; } else {return console.log("Cancelled")}
                
        
                console.log("Selected folder: ", folderName);
        
                let dest, src;
                if(method === "backup") {

                    dest = path.resolve(folderName, get_store_value(backupName));
                    src = path.resolve(__dirname, "..");
                } else {

                    dest = path.resolve(__dirname, "..");
                    src = path.resolve(folderName);
                }
                console.info(`Destination: ${dest}\nSource: ${src}\n`);

                await transferFiles({dest, src, includeNode:false});
                resolve();
            })

            .catch(err=>{

                console.log(err);
                reject(err.stack);

            })

            .finally(()=>target.classList.toggle("is-loading"));

    })

}

const restart_program = () => {
    let response = window.showinfo(remote.getCurrentWindow(), { title: "FELion_GUI3", type: "info", message: "Update succesfull", buttons: ["Restart", "Restart later"] });
    response === 0 ? remote.getCurrentWindow().reload() : console.log("Restarting later");

};

function InstallUpdate(target, updateFolder) {

    let src = path.resolve(updateFolder, `${get_store_value(github).repo}-${get_store_value(github).branch}`);

    let dest = path.resolve(__dirname, "..");

    transferFiles({ dest, src })
        .then(() => {console.log("Copying downloaded files");})
        .catch((err) => { window.createToast("Error occured while copying downloaded files"); throw err; })
        .finally(() => { target.classList.toggle("is-loading"); updating.set(false); restart_program(); });
}

const updateEvent = new CustomEvent('update', { bubbles: false });

function checkWithCurrentVersion({new_version, developer_version, info}={}) {

    if (window.currentVersion === new_version) {
        if (developer_version) {
                if (info) {window.createToast(`CAUTION! You are checking with developer branch which has experimental features. Take backup before updating.`, "danger");}
            } else { if (info) {

                window.createToast("No stable update available", "warning");
                updateAvailable.set(false);
                window.changelogNewContent = "";

            }}
    
    } else if (window.currentVersion < new_version) {
        
        const changelogContentFile = get_store_value(githubRepo)+"/CHANGELOG.md";

        window.changelogNewContent = "";
        fetch(changelogContentFile)
            .then(response => response.text())
            .then(result => {
                window.changelogNewContent=result;
                updateAvailable.set(true);
                activateChangelog.set(true);
                newVersion.set(new_version);
                console.log(window.changelogNewContent);
            })
            .catch(error=> window.createToast(error, "danger"));
            
    }

}

function updateCheck({info=true}={}){
    
    let target = document.getElementById("updateCheckBtn");

    target.classList.toggle("is-loading");
    if (!navigator.onLine) {if (info) {window.createToast("No Internet Connection!", "warning");} return}

    console.log(`URL_Package: ${get_store_value(versionJson)}`);
    let developer_version = false;

    let new_version = "";

    fetch(get_store_value(versionJson))

        .then(response => {
            if(response.ok) return response.json()
            throw new Error("URL Invalid")


        })

        .then(data => {
            console.log(`Received package:`, data);

            new_version = data.version;
            developer_version = data.developer;
            console.log(`Version available ${new_version}`);

            console.log(`Current version ${window.currentVersion}`);

            checkWithCurrentVersion({new_version, developer_version, info});
        })

        .catch(error=> window.createToast(error, "danger"))
        .finally(()=>{
            console.log("Update check completed");

            target.classList.toggle("is-loading");
            
        });
}

// Renaming old python path (if exists)
function renamePy() {

    console.log("Checking for python old path");

    const oldPath = path.resolve(__dirname, "../python3.7");
    const newPath = path.resolve(__dirname, "../python3");

    if (fs.existsSync(oldPath)) {

        fs.rename(oldPath, newPath, function(err) {

            if (err) throw console.log(err)
            
            console.log("Successfully renamed the directory.");
        });
    }
}
renamePy();

function resetPyConfig() {

    localStorage["pythonscript"] = path.resolve(__dirname, "assets/python_files");
    pythonscript.set(localStorage["pythonscript"]);
    const defaultPy = path.resolve(__dirname, "../python3/python");


    localStorage["pythonpath"] = defaultPy;

    checkPython({defaultPy})
        .then((version)=>{
    
            pyVersion.set(version);
            pythonpath.set(localStorage["pythonpath"]); 
            window.createToast("Location resetted", "warning");
    
        });
    
}


function updatePyConfig(){
    checkPython()
        .then(version=>{
            pyVersion.set(version);
            localStorage["pythonpath"] = get_store_value(pythonpath);
            window.createToast("Location updated", "success");
        });
        localStorage["pythonscript"] = get_store_value(pythonscript);
        
}

/* src\components\Terminal.svelte generated by Svelte v3.31.2 */
const file$1h = "src\\components\\Terminal.svelte";

function get_each_context$d(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i].color;
	child_ctx[23] = list[i].results;
	return child_ctx;
}

// (118:4) {#if commandInputDiv}
function create_if_block$z(ctx) {
	let div2;
	let button;
	let t1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t2;
	let div1;
	let iconbutton0;
	let t3;
	let customswitch;
	let updating_selected;
	let t4;
	let textfield;
	let updating_value;
	let t5;
	let iconbutton1;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$d, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*installPythonPackagesMode*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	iconbutton0 = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$f] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton0.$on("click", /*terminalShell*/ ctx[11]);

	function customswitch_selected_binding(value) {
		/*customswitch_selected_binding*/ ctx[18].call(null, value);
	}

	let customswitch_props = { style: "margin: 0 1em;", label: "Shell" };

	if (/*openShellTerminal*/ ctx[7] !== void 0) {
		customswitch_props.selected = /*openShellTerminal*/ ctx[7];
	}

	customswitch = new CustomSwitch({
			props: customswitch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch, "selected", customswitch_selected_binding));

	function textfield_value_binding_1(value) {
		/*textfield_value_binding_1*/ ctx[19].call(null, value);
	}

	let textfield_props = {
		type: "number",
		step: "1",
		min: "0",
		variant: "outlined",
		style: "width:7em",
		label: "Font Size"
	};

	if (/*teminalFontSize*/ ctx[3] !== void 0) {
		textfield_props.value = /*teminalFontSize*/ ctx[3];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding_1));

	iconbutton1 = new IconButton({
			props: {
				class: "material-icons is-pulled-right",
				style: "background: #f14668; border-radius: 2em;",
				$$slots: { default: [create_default_slot$A] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton1.$on("click", /*click_handler*/ ctx[20]);

	const block = {
		c: function create() {
			div2 = element("div");
			button = element("button");
			button.textContent = "Python package installation";
			t1 = space();
			div0 = element("div");
			if_block.c();
			t2 = space();
			div1 = element("div");
			create_component(iconbutton0.$$.fragment);
			t3 = space();
			create_component(customswitch.$$.fragment);
			t4 = space();
			create_component(textfield.$$.fragment);
			t5 = space();
			create_component(iconbutton1.$$.fragment);
			attr_dev(button, "class", "button is-link");
			add_location(button, file$1h, 121, 12, 3731);
			attr_dev(div0, "class", "run");
			set_style(div0, "display", "flex");
			set_style(div0, "align-items", "center");
			set_style(div0, "margin-bottom", "1em");
			add_location(div0, file$1h, 123, 12, 3847);
			attr_dev(div1, "class", "run");
			set_style(div1, "display", "flex");
			set_style(div1, "align-items", "center");
			set_style(div1, "margin-bottom", "1em");
			add_location(div1, file$1h, 139, 12, 4345);
			attr_dev(div2, "class", "commandInput");
			add_location(div2, file$1h, 119, 8, 3681);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, button);
			append_dev(div2, t1);
			append_dev(div2, div0);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			mount_component(iconbutton0, div1, null);
			append_dev(div1, t3);
			mount_component(customswitch, div1, null);
			append_dev(div1, t4);
			mount_component(textfield, div1, null);
			append_dev(div1, t5);
			mount_component(iconbutton1, div1, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*installPythonPackages*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const iconbutton0_changes = {};

			if (dirty & /*$$scope*/ 67108864) {
				iconbutton0_changes.$$scope = { dirty, ctx };
			}

			iconbutton0.$set(iconbutton0_changes);
			const customswitch_changes = {};

			if (!updating_selected && dirty & /*openShellTerminal*/ 128) {
				updating_selected = true;
				customswitch_changes.selected = /*openShellTerminal*/ ctx[7];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch.$set(customswitch_changes);
			const textfield_changes = {};

			if (!updating_value && dirty & /*teminalFontSize*/ 8) {
				updating_value = true;
				textfield_changes.value = /*teminalFontSize*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
			const iconbutton1_changes = {};

			if (dirty & /*$$scope*/ 67108864) {
				iconbutton1_changes.$$scope = { dirty, ctx };
			}

			iconbutton1.$set(iconbutton1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(iconbutton0.$$.fragment, local);
			transition_in(customswitch.$$.fragment, local);
			transition_in(textfield.$$.fragment, local);
			transition_in(iconbutton1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(customswitch.$$.fragment, local);
			transition_out(textfield.$$.fragment, local);
			transition_out(iconbutton1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if_blocks[current_block_type_index].d();
			destroy_component(iconbutton0);
			destroy_component(customswitch);
			destroy_component(textfield);
			destroy_component(iconbutton1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$z.name,
		type: "if",
		source: "(118:4) {#if commandInputDiv}",
		ctx
	});

	return block;
}

// (129:16) {:else}
function create_else_block$d(ctx) {
	let textfield0;
	let updating_value;
	let t;
	let textfield1;
	let updating_value_1;
	let current;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[16].call(null, value);
	}

	let textfield0_props = { label: "Enter command to run" };

	if (/*commandToRun*/ ctx[0] !== void 0) {
		textfield0_props.value = /*commandToRun*/ ctx[0];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[17].call(null, value);
	}

	let textfield1_props = { label: "Enter command-arg" };

	if (/*commandArgsToRun*/ ctx[1] !== void 0) {
		textfield1_props.value = /*commandArgsToRun*/ ctx[1];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	const block = {
		c: function create() {
			create_component(textfield0.$$.fragment);
			t = space();
			create_component(textfield1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(textfield1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty & /*commandToRun*/ 1) {
				updating_value = true;
				textfield0_changes.value = /*commandToRun*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*commandArgsToRun*/ 2) {
				updating_value_1 = true;
				textfield1_changes.value = /*commandArgsToRun*/ ctx[1];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(textfield1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$d.name,
		type: "else",
		source: "(129:16) {:else}",
		ctx
	});

	return block;
}

// (126:16) {#if installPythonPackagesMode}
function create_if_block_1$d(ctx) {
	let textfield;
	let updating_value;
	let current;

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[15].call(null, value);
	}

	let textfield_props = { label: "Enter packages name(s)" };

	if (/*packagesName*/ ctx[9] !== void 0) {
		textfield_props.value = /*packagesName*/ ctx[9];
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};

			if (!updating_value && dirty & /*packagesName*/ 512) {
				updating_value = true;
				textfield_changes.value = /*packagesName*/ ctx[9];
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$d.name,
		type: "if",
		source: "(126:16) {#if installPythonPackagesMode}",
		ctx
	});

	return block;
}

// (141:16) <IconButton class="material-icons" on:click={terminalShell}>
function create_default_slot_1$f(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("play_arrow");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$f.name,
		type: "slot",
		source: "(141:16) <IconButton class=\\\"material-icons\\\" on:click={terminalShell}>",
		ctx
	});

	return block;
}

// (146:16) <IconButton class="material-icons is-pulled-right" style="background: #f14668; border-radius: 2em;" on:click="{()=>commandResults=[{color:colorSets.normal, results:`>> cleared`}] }">
function create_default_slot$A(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("clear");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$A.name,
		type: "slot",
		source: "(146:16) <IconButton class=\\\"material-icons is-pulled-right\\\" style=\\\"background: #f14668; border-radius: 2em;\\\" on:click=\\\"{()=>commandResults=[{color:colorSets.normal, results:`>> cleared`}] }\\\">",
		ctx
	});

	return block;
}

// (155:8) {#each commandResults as {color, results}}
function create_each_block$d(ctx) {
	let h1;
	let t_value = /*results*/ ctx[23] + "";
	let t;

	const block = {
		c: function create() {
			h1 = element("h1");
			t = text(t_value);
			attr_dev(h1, "class", "subtitle");
			set_style(h1, "color", /*color*/ ctx[22]);
			set_style(h1, "font-size", /*teminalFontSize*/ ctx[3] + "px");
			set_style(h1, "white-space", "pre-wrap");
			add_location(h1, file$1h, 155, 12, 5199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*commandResults*/ 4 && t_value !== (t_value = /*results*/ ctx[23] + "")) set_data_dev(t, t_value);

			if (dirty & /*commandResults*/ 4) {
				set_style(h1, "color", /*color*/ ctx[22]);
			}

			if (dirty & /*teminalFontSize*/ 8) {
				set_style(h1, "font-size", /*teminalFontSize*/ ctx[3] + "px");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$d.name,
		type: "each",
		source: "(155:8) {#each commandResults as {color, results}}",
		ctx
	});

	return block;
}

function create_fragment$1o(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let div1;
	let t1;
	let div0;
	let current;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[14].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[6] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[6];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));
	let if_block = /*commandInputDiv*/ ctx[4] && create_if_block$z(ctx);
	let each_value = /*commandResults*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			div1 = element("div");
			if (if_block) if_block.c();
			t1 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", "box terminal svelte-18aq4ui");
			attr_dev(div0, "id", /*id*/ ctx[5]);
			set_style(div0, "height", (/*commandInputDiv*/ ctx[4] ? 75 : 90) + "%");
			add_location(div0, file$1h, 152, 4, 5054);
			attr_dev(div1, "class", "content contentBox terminalBox svelte-18aq4ui");
			add_location(div1, file$1h, 115, 0, 3595);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const premodal_changes = {};

			if (!updating_preModal && dirty & /*preModal*/ 64) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[6];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);

			if (/*commandInputDiv*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*commandInputDiv*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$z(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*commandResults, teminalFontSize*/ 12) {
				each_value = /*commandResults*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$d(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$d(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*id*/ 32) {
				attr_dev(div0, "id", /*id*/ ctx[5]);
			}

			if (!current || dirty & /*commandInputDiv*/ 16) {
				set_style(div0, "height", (/*commandInputDiv*/ ctx[4] ? 75 : 90) + "%");
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1o($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Terminal", slots, []);

	const colorSets = {
		warning: "#ffdd57",
		danger: "#f14668",
		info: "#2098d1",
		normal: "#fafafa",
		success: "#20f996"
	};

	let { commandToRun = localStorage["pythonpath"] || "" } = $$props,
		{ commandArgsToRun = "-m pip" } = $$props,
		{ commandResults = [{ color: colorSets.normal, results: ">> " }] } = $$props,
		{ teminalFontSize = 20 } = $$props;

	let { commandInputDiv = true } = $$props,
		{ runShell = false } = $$props,
		{ id = "terminal" } = $$props;

	let preModal = {};
	let openShellTerminal = false;

	const srollTerminalDiv = async () => {
		const terminalDiv = document.getElementById(id);
		await tick();
		const scrollTo = terminalDiv.scrollHeight - terminalDiv.clientHeight;
		terminalDiv.scrollTo({ top: scrollTo, behavior: "smooth" });
	};

	async function terminalShell() {
		$$invalidate(13, runShell = false);
		await tick();
		srollTerminalDiv();

		if (!commandToRun) {
			return window.createToast("No command entered", "warning");
		}

		$$invalidate(2, commandResults = [
			...commandResults,
			{
				color: colorSets.normal,
				results: `>> ${commandToRun} ${commandArgsToRun.split(",").join(" ")}`
			}
		]);

		let ls;

		try {
			$$invalidate(1, commandArgsToRun += ` ${packagesName}`);

			ls = spawn(commandToRun, commandArgsToRun.split(" ").map(arg => arg.trim()), {
				detached: true,
				stdio: "pipe",
				shell: openShellTerminal
			});
		} catch(err) {
			$$invalidate(6, preModal.modalContent = err.stack, preModal);
			$$invalidate(6, preModal.open = true, preModal);
		}

		ls.stdout.on("data", data => {
			$$invalidate(2, commandResults = [
				...commandResults,
				{
					color: colorSets.info,
					results: `>> ${data || ""}`
				}
			]);

			srollTerminalDiv();
		});

		ls.stderr.on("data", data => {
			$$invalidate(2, commandResults = [
				...commandResults,
				{
					color: colorSets.danger,
					results: `>> ${data || ""}`
				}
			]);

			srollTerminalDiv();
		});

		ls.on("close", code => {
			$$invalidate(2, commandResults = [
				...commandResults,
				{
					color: code === 1 ? colorSets.danger : colorSets.success,
					results: `>> child process exited with code ${code}`
				}
			]);

			srollTerminalDiv();
			const outputLog = `${new Date().toLocaleString()}\n\n-----------------------------------------\nRunning terminal commands\n${commandResults.map(cmd => cmd.results).join("")}\n-----------------------------------------\n`;

			try {
				fs.writeFileSync(path.resolve(__dirname, "output.log"), outputLog);
			} catch(error) {
				window.createToast("Could not save the outputs to file: output.log", "warning");
			}
		});
	}

	let installPythonPackagesMode = false, packagesName = "";

	const installPythonPackages = () => {
		$$invalidate(0, commandToRun = localStorage["pythonpath"]);
		$$invalidate(1, commandArgsToRun = "-m pip install");
		$$invalidate(8, installPythonPackagesMode = !installPythonPackagesMode);
	};

	const writable_props = [
		"commandToRun",
		"commandArgsToRun",
		"commandResults",
		"teminalFontSize",
		"commandInputDiv",
		"runShell",
		"id"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Terminal> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(6, preModal);
	}

	function textfield_value_binding(value) {
		packagesName = value;
		$$invalidate(9, packagesName);
	}

	function textfield0_value_binding(value) {
		commandToRun = value;
		$$invalidate(0, commandToRun);
	}

	function textfield1_value_binding(value) {
		commandArgsToRun = value;
		$$invalidate(1, commandArgsToRun);
	}

	function customswitch_selected_binding(value) {
		openShellTerminal = value;
		$$invalidate(7, openShellTerminal);
	}

	function textfield_value_binding_1(value) {
		teminalFontSize = value;
		$$invalidate(3, teminalFontSize);
	}

	const click_handler = () => $$invalidate(2, commandResults = [
		{
			color: colorSets.normal,
			results: `>> cleared`
		}
	]);

	$$self.$$set = $$props => {
		if ("commandToRun" in $$props) $$invalidate(0, commandToRun = $$props.commandToRun);
		if ("commandArgsToRun" in $$props) $$invalidate(1, commandArgsToRun = $$props.commandArgsToRun);
		if ("commandResults" in $$props) $$invalidate(2, commandResults = $$props.commandResults);
		if ("teminalFontSize" in $$props) $$invalidate(3, teminalFontSize = $$props.teminalFontSize);
		if ("commandInputDiv" in $$props) $$invalidate(4, commandInputDiv = $$props.commandInputDiv);
		if ("runShell" in $$props) $$invalidate(13, runShell = $$props.runShell);
		if ("id" in $$props) $$invalidate(5, id = $$props.id);
	};

	$$self.$capture_state = () => ({
		IconButton,
		PreModal,
		tick,
		Textfield,
		CustomSwitch,
		colorSets,
		commandToRun,
		commandArgsToRun,
		commandResults,
		teminalFontSize,
		commandInputDiv,
		runShell,
		id,
		preModal,
		openShellTerminal,
		srollTerminalDiv,
		terminalShell,
		installPythonPackagesMode,
		packagesName,
		installPythonPackages
	});

	$$self.$inject_state = $$props => {
		if ("commandToRun" in $$props) $$invalidate(0, commandToRun = $$props.commandToRun);
		if ("commandArgsToRun" in $$props) $$invalidate(1, commandArgsToRun = $$props.commandArgsToRun);
		if ("commandResults" in $$props) $$invalidate(2, commandResults = $$props.commandResults);
		if ("teminalFontSize" in $$props) $$invalidate(3, teminalFontSize = $$props.teminalFontSize);
		if ("commandInputDiv" in $$props) $$invalidate(4, commandInputDiv = $$props.commandInputDiv);
		if ("runShell" in $$props) $$invalidate(13, runShell = $$props.runShell);
		if ("id" in $$props) $$invalidate(5, id = $$props.id);
		if ("preModal" in $$props) $$invalidate(6, preModal = $$props.preModal);
		if ("openShellTerminal" in $$props) $$invalidate(7, openShellTerminal = $$props.openShellTerminal);
		if ("installPythonPackagesMode" in $$props) $$invalidate(8, installPythonPackagesMode = $$props.installPythonPackagesMode);
		if ("packagesName" in $$props) $$invalidate(9, packagesName = $$props.packagesName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*runShell*/ 8192) {
			 if (runShell) terminalShell();
		}
	};

	return [
		commandToRun,
		commandArgsToRun,
		commandResults,
		teminalFontSize,
		commandInputDiv,
		id,
		preModal,
		openShellTerminal,
		installPythonPackagesMode,
		packagesName,
		colorSets,
		terminalShell,
		installPythonPackages,
		runShell,
		premodal_preModal_binding,
		textfield_value_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		customswitch_selected_binding,
		textfield_value_binding_1,
		click_handler
	];
}

class Terminal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
			commandToRun: 0,
			commandArgsToRun: 1,
			commandResults: 2,
			teminalFontSize: 3,
			commandInputDiv: 4,
			runShell: 13,
			id: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Terminal",
			options,
			id: create_fragment$1o.name
		});
	}

	get commandToRun() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set commandToRun(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get commandArgsToRun() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set commandArgsToRun(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get commandResults() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set commandResults(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get teminalFontSize() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set teminalFontSize(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get commandInputDiv() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set commandInputDiv(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get runShell() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set runShell(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Terminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Terminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Pages\Settings.svelte generated by Svelte v3.31.2 */

const { console: console_1$e } = globals;
const file$1i = "src\\Pages\\Settings.svelte";

function create_fragment$1p(ctx) {
	let premodal;
	let updating_preModal;
	let t0;
	let customdialog;
	let updating_dialog;
	let t1;
	let changelog;
	let t2;
	let section;
	let div17;
	let div5;
	let div4;
	let div0;
	let t4;
	let div1;
	let t6;
	let div2;
	let t8;
	let div3;
	let t10;
	let div16;
	let div15;
	let div7;
	let h10;
	let t12;
	let div6;
	let t13;
	let t14;
	let textfield0;
	let updating_value;
	let t15;
	let textfield1;
	let updating_value_1;
	let t16;
	let button0;
	let t18;
	let button1;
	let t20;
	let div12;
	let h11;
	let t22;
	let div8;
	let t25;
	let div9;
	let textfield2;
	let updating_value_2;
	let t26;
	let textfield3;
	let updating_value_3;
	let t27;
	let customselect;
	let updating_picked;
	let t28;
	let div10;
	let button2;
	let t30;
	let button3;
	let t32;
	let button4;
	let t34;
	let div11;
	let textfield4;
	let updating_value_4;
	let t35;
	let button5;
	let t37;
	let button6;
	let t39;
	let div13;
	let h12;
	let t41;
	let terminal;
	let updating_commandToRun;
	let updating_commandArgsToRun;
	let t42;
	let div14;
	let h13;
	let current;
	let mounted;
	let dispose;

	function premodal_preModal_binding(value) {
		/*premodal_preModal_binding*/ ctx[16].call(null, value);
	}

	let premodal_props = {};

	if (/*preModal*/ ctx[2] !== void 0) {
		premodal_props.preModal = /*preModal*/ ctx[2];
	}

	premodal = new PreModal({ props: premodal_props, $$inline: true });
	binding_callbacks.push(() => bind(premodal, "preModal", premodal_preModal_binding));

	function customdialog_dialog_binding(value) {
		/*customdialog_dialog_binding*/ ctx[17].call(null, value);
	}

	let customdialog_props = {
		id: "pythonpath_Check",
		title: "Python path is not valid",
		content: "Change it in Settings --> Configuration",
		label1: "Okay",
		label2: "Cancel"
	};

	if (/*pythonpathCheck*/ ctx[1] !== void 0) {
		customdialog_props.dialog = /*pythonpathCheck*/ ctx[1];
	}

	customdialog = new CustomDialog({
			props: customdialog_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customdialog, "dialog", customdialog_dialog_binding));
	customdialog.$on("response", /*handlepythonPathCheck*/ ctx[14]);
	changelog = new Changelog({ $$inline: true });

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[18].call(null, value);
	}

	let textfield0_props = {
		style: "margin-bottom:1em;",
		label: "Python path"
	};

	if (/*$pythonpath*/ ctx[6] !== void 0) {
		textfield0_props.value = /*$pythonpath*/ ctx[6];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[19].call(null, value);
	}

	let textfield1_props = {
		style: "margin-bottom:1em;",
		label: "Python script path"
	};

	if (/*$pythonscript*/ ctx[7] !== void 0) {
		textfield1_props.value = /*$pythonscript*/ ctx[7];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[20].call(null, value);
	}

	let textfield2_props = {
		style: "width:7em; margin-right:2em;",
		label: "Github username"
	};

	if (/*$github*/ ctx[8].username !== void 0) {
		textfield2_props.value = /*$github*/ ctx[8].username;
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[21].call(null, value);
	}

	let textfield3_props = {
		style: "width:7em; margin-right:2em;",
		label: "Github Repo"
	};

	if (/*$github*/ ctx[8].repo !== void 0) {
		textfield3_props.value = /*$github*/ ctx[8].repo;
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));

	function customselect_picked_binding(value) {
		/*customselect_picked_binding*/ ctx[22].call(null, value);
	}

	let customselect_props = {
		label: "Github branch",
		options: ["master", "developer"]
	};

	if (/*$github*/ ctx[8].branch !== void 0) {
		customselect_props.picked = /*$github*/ ctx[8].branch;
	}

	customselect = new CustomSelect({
			props: customselect_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customselect, "picked", customselect_picked_binding));

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[24].call(null, value);
	}

	let textfield4_props = {
		style: "width:30%; margin-right:2em;",
		label: "Github username"
	};

	if (/*$backupName*/ ctx[10] !== void 0) {
		textfield4_props.value = /*$backupName*/ ctx[10];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));

	function terminal_commandToRun_binding(value) {
		/*terminal_commandToRun_binding*/ ctx[25].call(null, value);
	}

	function terminal_commandArgsToRun_binding(value) {
		/*terminal_commandArgsToRun_binding*/ ctx[26].call(null, value);
	}

	let terminal_props = { id: "Terminal-settings" };

	if (/*commandToRun*/ ctx[3] !== void 0) {
		terminal_props.commandToRun = /*commandToRun*/ ctx[3];
	}

	if (/*commandArgsToRun*/ ctx[4] !== void 0) {
		terminal_props.commandArgsToRun = /*commandArgsToRun*/ ctx[4];
	}

	terminal = new Terminal({ props: terminal_props, $$inline: true });
	binding_callbacks.push(() => bind(terminal, "commandToRun", terminal_commandToRun_binding));
	binding_callbacks.push(() => bind(terminal, "commandArgsToRun", terminal_commandArgsToRun_binding));

	const block = {
		c: function create() {
			create_component(premodal.$$.fragment);
			t0 = space();
			create_component(customdialog.$$.fragment);
			t1 = space();
			create_component(changelog.$$.fragment);
			t2 = space();
			section = element("section");
			div17 = element("div");
			div5 = element("div");
			div4 = element("div");
			div0 = element("div");
			div0.textContent = "Configuration";
			t4 = space();
			div1 = element("div");
			div1.textContent = "Update";
			t6 = space();
			div2 = element("div");
			div2.textContent = "Terminal";
			t8 = space();
			div3 = element("div");
			div3.textContent = "About";
			t10 = space();
			div16 = element("div");
			div15 = element("div");
			div7 = element("div");
			h10 = element("h1");
			h10.textContent = "Configuration";
			t12 = space();
			div6 = element("div");
			t13 = text(/*$pyVersion*/ ctx[5]);
			t14 = space();
			create_component(textfield0.$$.fragment);
			t15 = space();
			create_component(textfield1.$$.fragment);
			t16 = space();
			button0 = element("button");
			button0.textContent = "Reset";
			t18 = space();
			button1 = element("button");
			button1.textContent = "Save";
			t20 = space();
			div12 = element("div");
			h11 = element("h1");
			h11.textContent = "Update";
			t22 = space();
			div8 = element("div");
			div8.textContent = `Current Version ${window.currentVersion}`;
			t25 = space();
			div9 = element("div");
			create_component(textfield2.$$.fragment);
			t26 = space();
			create_component(textfield3.$$.fragment);
			t27 = space();
			create_component(customselect.$$.fragment);
			t28 = space();
			div10 = element("div");
			button2 = element("button");
			button2.textContent = "Check update";
			t30 = space();
			button3 = element("button");
			button3.textContent = "Update";
			t32 = space();
			button4 = element("button");
			button4.textContent = "What's New";
			t34 = space();
			div11 = element("div");
			create_component(textfield4.$$.fragment);
			t35 = space();
			button5 = element("button");
			button5.textContent = "Backup";
			t37 = space();
			button6 = element("button");
			button6.textContent = "Restore";
			t39 = space();
			div13 = element("div");
			h12 = element("h1");
			h12.textContent = "Terminal";
			t41 = space();
			create_component(terminal.$$.fragment);
			t42 = space();
			div14 = element("div");
			h13 = element("h1");
			h13.textContent = "About";
			attr_dev(div0, "class", "title nav hvr-glow svelte-3kstg5");
			toggle_class(div0, "clicked", /*selected*/ ctx[0] === "Configuration");
			add_location(div0, file$1i, 146, 16, 4090);
			attr_dev(div1, "class", "title nav hvr-glow svelte-3kstg5");
			toggle_class(div1, "clicked", /*selected*/ ctx[0] === "Update");
			add_location(div1, file$1i, 147, 16, 4222);
			attr_dev(div2, "class", "title nav hvr-glow svelte-3kstg5");
			toggle_class(div2, "clicked", /*selected*/ ctx[0] === "Terminal");
			add_location(div2, file$1i, 148, 16, 4340);
			attr_dev(div3, "class", "title nav hvr-glow svelte-3kstg5");
			toggle_class(div3, "clicked", /*selected*/ ctx[0] === "About");
			add_location(div3, file$1i, 149, 16, 4462);
			attr_dev(div4, "class", "container left svelte-3kstg5");
			add_location(div4, file$1i, 145, 12, 4044);
			attr_dev(div5, "class", "column side-panel is-2-widescreen is-3-desktop is-4-tablet box adjust-right svelte-3kstg5");
			add_location(div5, file$1i, 144, 8, 3941);
			attr_dev(h10, "class", "title svelte-3kstg5");
			add_location(h10, file$1i, 157, 20, 4806);
			attr_dev(div6, "class", "subtitle svelte-3kstg5");
			add_location(div6, file$1i, 158, 20, 4864);
			attr_dev(button0, "class", "button is-link svelte-3kstg5");
			add_location(button0, file$1i, 161, 20, 5149);
			attr_dev(button1, "class", "button is-link svelte-3kstg5");
			add_location(button1, file$1i, 162, 20, 5241);
			attr_dev(div7, "class", "content animated fadeIn svelte-3kstg5");
			toggle_class(div7, "hide", /*selected*/ ctx[0] !== "Configuration");
			add_location(div7, file$1i, 156, 16, 4707);
			attr_dev(h11, "class", "title svelte-3kstg5");
			add_location(h11, file$1i, 166, 20, 5447);
			attr_dev(div8, "class", "subtitle svelte-3kstg5");
			add_location(div8, file$1i, 168, 20, 5500);
			attr_dev(div9, "class", "content svelte-3kstg5");
			add_location(div9, file$1i, 169, 20, 5589);
			attr_dev(button2, "class", "button is-link svelte-3kstg5");
			attr_dev(button2, "id", "updateCheckBtn");
			add_location(button2, file$1i, 176, 24, 6087);
			attr_dev(button3, "class", "button is-link svelte-3kstg5");
			attr_dev(button3, "id", "updateBtn");
			add_location(button3, file$1i, 177, 24, 6229);
			attr_dev(button4, "class", "button is-warning svelte-3kstg5");
			add_location(button4, file$1i, 179, 24, 6360);
			attr_dev(div10, "class", "content svelte-3kstg5");
			add_location(div10, file$1i, 175, 20, 6040);
			attr_dev(button5, "class", "button is-link svelte-3kstg5");
			add_location(button5, file$1i, 185, 24, 6684);
			attr_dev(button6, "class", "button is-link svelte-3kstg5");
			add_location(button6, file$1i, 186, 24, 6774);
			attr_dev(div11, "class", "content svelte-3kstg5");
			add_location(div11, file$1i, 183, 20, 6512);
			attr_dev(div12, "class", "content animated fadeIn svelte-3kstg5");
			toggle_class(div12, "hide", /*selected*/ ctx[0] !== "Update");
			add_location(div12, file$1i, 165, 16, 5355);
			attr_dev(h12, "class", "title svelte-3kstg5");
			add_location(h12, file$1i, 192, 20, 7028);
			attr_dev(div13, "class", "content animated fadeIn svelte-3kstg5");
			toggle_class(div13, "hide", /*selected*/ ctx[0] !== "Terminal");
			add_location(div13, file$1i, 191, 16, 6934);
			attr_dev(h13, "class", "title svelte-3kstg5");
			add_location(h13, file$1i, 197, 20, 7306);
			attr_dev(div14, "class", "content animated fadeIn svelte-3kstg5");
			toggle_class(div14, "hide", /*selected*/ ctx[0] !== "About");
			add_location(div14, file$1i, 196, 16, 7215);
			attr_dev(div15, "class", "container right svelte-3kstg5");
			add_location(div15, file$1i, 154, 12, 4657);
			attr_dev(div16, "class", "column main-panel box svelte-3kstg5");
			add_location(div16, file$1i, 153, 8, 4608);
			attr_dev(div17, "class", "columns svelte-3kstg5");
			add_location(div17, file$1i, 143, 4, 3910);
			attr_dev(section, "class", "section animated fadeIn svelte-3kstg5");
			attr_dev(section, "id", "Settings");
			set_style(section, "display", "none");
			add_location(section, file$1i, 141, 0, 3826);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(premodal, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(customdialog, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(changelog, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div17);
			append_dev(div17, div5);
			append_dev(div5, div4);
			append_dev(div4, div0);
			append_dev(div4, t4);
			append_dev(div4, div1);
			append_dev(div4, t6);
			append_dev(div4, div2);
			append_dev(div4, t8);
			append_dev(div4, div3);
			append_dev(div17, t10);
			append_dev(div17, div16);
			append_dev(div16, div15);
			append_dev(div15, div7);
			append_dev(div7, h10);
			append_dev(div7, t12);
			append_dev(div7, div6);
			append_dev(div6, t13);
			append_dev(div7, t14);
			mount_component(textfield0, div7, null);
			append_dev(div7, t15);
			mount_component(textfield1, div7, null);
			append_dev(div7, t16);
			append_dev(div7, button0);
			append_dev(div7, t18);
			append_dev(div7, button1);
			append_dev(div15, t20);
			append_dev(div15, div12);
			append_dev(div12, h11);
			append_dev(div12, t22);
			append_dev(div12, div8);
			append_dev(div12, t25);
			append_dev(div12, div9);
			mount_component(textfield2, div9, null);
			append_dev(div9, t26);
			mount_component(textfield3, div9, null);
			append_dev(div9, t27);
			mount_component(customselect, div9, null);
			append_dev(div12, t28);
			append_dev(div12, div10);
			append_dev(div10, button2);
			append_dev(div10, t30);
			append_dev(div10, button3);
			append_dev(div10, t32);
			append_dev(div10, button4);
			append_dev(div12, t34);
			append_dev(div12, div11);
			mount_component(textfield4, div11, null);
			append_dev(div11, t35);
			append_dev(div11, button5);
			append_dev(div11, t37);
			append_dev(div11, button6);
			append_dev(div15, t39);
			append_dev(div15, div13);
			append_dev(div13, h12);
			append_dev(div13, t41);
			mount_component(terminal, div13, null);
			append_dev(div15, t42);
			append_dev(div15, div14);
			append_dev(div14, h13);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*navigate*/ ctx[13], false, false, false),
					listen_dev(div1, "click", /*navigate*/ ctx[13], false, false, false),
					listen_dev(div2, "click", /*navigate*/ ctx[13], false, false, false),
					listen_dev(div3, "click", /*navigate*/ ctx[13], false, false, false),
					listen_dev(button0, "click", resetPyConfig, false, false, false),
					listen_dev(button1, "click", updatePyConfig, false, false, false),
					listen_dev(button2, "click", updateCheck, false, false, false),
					listen_dev(button2, "update", /*update*/ ctx[15], false, false, false),
					listen_dev(button3, "click", /*update*/ ctx[15], false, false, false),
					listen_dev(button4, "click", /*click_handler*/ ctx[23], false, false, false),
					listen_dev(button5, "click", /*backup*/ ctx[11], false, false, false),
					listen_dev(button6, "click", /*restore*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const premodal_changes = {};

			if (!updating_preModal && dirty & /*preModal*/ 4) {
				updating_preModal = true;
				premodal_changes.preModal = /*preModal*/ ctx[2];
				add_flush_callback(() => updating_preModal = false);
			}

			premodal.$set(premodal_changes);
			const customdialog_changes = {};

			if (!updating_dialog && dirty & /*pythonpathCheck*/ 2) {
				updating_dialog = true;
				customdialog_changes.dialog = /*pythonpathCheck*/ ctx[1];
				add_flush_callback(() => updating_dialog = false);
			}

			customdialog.$set(customdialog_changes);

			if (dirty & /*selected*/ 1) {
				toggle_class(div0, "clicked", /*selected*/ ctx[0] === "Configuration");
			}

			if (dirty & /*selected*/ 1) {
				toggle_class(div1, "clicked", /*selected*/ ctx[0] === "Update");
			}

			if (dirty & /*selected*/ 1) {
				toggle_class(div2, "clicked", /*selected*/ ctx[0] === "Terminal");
			}

			if (dirty & /*selected*/ 1) {
				toggle_class(div3, "clicked", /*selected*/ ctx[0] === "About");
			}

			if (!current || dirty & /*$pyVersion*/ 32) set_data_dev(t13, /*$pyVersion*/ ctx[5]);
			const textfield0_changes = {};

			if (!updating_value && dirty & /*$pythonpath*/ 64) {
				updating_value = true;
				textfield0_changes.value = /*$pythonpath*/ ctx[6];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty & /*$pythonscript*/ 128) {
				updating_value_1 = true;
				textfield1_changes.value = /*$pythonscript*/ ctx[7];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);

			if (dirty & /*selected*/ 1) {
				toggle_class(div7, "hide", /*selected*/ ctx[0] !== "Configuration");
			}

			const textfield2_changes = {};

			if (!updating_value_2 && dirty & /*$github*/ 256) {
				updating_value_2 = true;
				textfield2_changes.value = /*$github*/ ctx[8].username;
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty & /*$github*/ 256) {
				updating_value_3 = true;
				textfield3_changes.value = /*$github*/ ctx[8].repo;
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const customselect_changes = {};

			if (!updating_picked && dirty & /*$github*/ 256) {
				updating_picked = true;
				customselect_changes.picked = /*$github*/ ctx[8].branch;
				add_flush_callback(() => updating_picked = false);
			}

			customselect.$set(customselect_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty & /*$backupName*/ 1024) {
				updating_value_4 = true;
				textfield4_changes.value = /*$backupName*/ ctx[10];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);

			if (dirty & /*selected*/ 1) {
				toggle_class(div12, "hide", /*selected*/ ctx[0] !== "Update");
			}

			const terminal_changes = {};

			if (!updating_commandToRun && dirty & /*commandToRun*/ 8) {
				updating_commandToRun = true;
				terminal_changes.commandToRun = /*commandToRun*/ ctx[3];
				add_flush_callback(() => updating_commandToRun = false);
			}

			if (!updating_commandArgsToRun && dirty & /*commandArgsToRun*/ 16) {
				updating_commandArgsToRun = true;
				terminal_changes.commandArgsToRun = /*commandArgsToRun*/ ctx[4];
				add_flush_callback(() => updating_commandArgsToRun = false);
			}

			terminal.$set(terminal_changes);

			if (dirty & /*selected*/ 1) {
				toggle_class(div13, "hide", /*selected*/ ctx[0] !== "Terminal");
			}

			if (dirty & /*selected*/ 1) {
				toggle_class(div14, "hide", /*selected*/ ctx[0] !== "About");
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(premodal.$$.fragment, local);
			transition_in(customdialog.$$.fragment, local);
			transition_in(changelog.$$.fragment, local);
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(customselect.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);
			transition_in(terminal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(premodal.$$.fragment, local);
			transition_out(customdialog.$$.fragment, local);
			transition_out(changelog.$$.fragment, local);
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(customselect.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			transition_out(terminal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(premodal, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(customdialog, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(changelog, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(section);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(customselect);
			destroy_component(textfield4);
			destroy_component(terminal);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1p($$self, $$props, $$invalidate) {
	let $pyVersion;
	let $pythonpath;
	let $pythonscript;
	let $github;
	let $activateChangelog;
	let $backupName;
	validate_store(pyVersion, "pyVersion");
	component_subscribe($$self, pyVersion, $$value => $$invalidate(5, $pyVersion = $$value));
	validate_store(pythonpath, "pythonpath");
	component_subscribe($$self, pythonpath, $$value => $$invalidate(6, $pythonpath = $$value));
	validate_store(pythonscript, "pythonscript");
	component_subscribe($$self, pythonscript, $$value => $$invalidate(7, $pythonscript = $$value));
	validate_store(github, "github");
	component_subscribe($$self, github, $$value => $$invalidate(8, $github = $$value));
	validate_store(activateChangelog, "activateChangelog");
	component_subscribe($$self, activateChangelog, $$value => $$invalidate(9, $activateChangelog = $$value));
	validate_store(backupName, "backupName");
	component_subscribe($$self, backupName, $$value => $$invalidate(10, $backupName = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Settings", slots, []);

	const backup = event => {
		backupRestore({ event, method: "backup" }).then(() => console.log("Backup Completed")).catch(err => {
			$$invalidate(2, preModal.modalContent = err, preModal);
			$$invalidate(2, preModal.open = true, preModal);
		});
	};

	const restore = event => {
		backupRestore({ event, method: "restore" }).then(() => console.log("Restore Completed")).catch(err => {
			$$invalidate(2, preModal.modalContent = err, preModal);
			$$invalidate(2, preModal.open = true, preModal);
		});
	};

	let selected = "Update";

	const navigate = e => {
		$$invalidate(0, selected = e.target.innerHTML);
	};

	let pythonpathCheck;

	onMount(() => {
		setTimeout(
			async () => {
				await tick();

				checkPython().then(res => {
					set_store_value(pyVersion, $pyVersion = res, $pyVersion);
					console.log("Python path is valid");
				}).catch(() => pythonpathCheck.open());
			},
			1000
		);

		updateCheck({ info: false });

		setInterval(
			() => {
				updateCheck({ info: false });
			},
			1 * 1000 * 60 * 15
		);
	});

	const handlepythonPathCheck = () => {
		console.log("Python path checking done");
	};

	const update = async () => {
		try {
			const updateFolder = path.resolve(__dirname, "..", "update");
			let target = document.getElementById("updateBtn");
			target.classList.toggle("is-loading");

			if (!fs.existsSync(updateFolder)) {
				fs.mkdirSync(updateFolder);
			}

			await download(updateFolder);
			InstallUpdate(target, updateFolder);
		} catch(err) {
			$$invalidate(2, preModal.modalContent = err.stack, preModal);
			$$invalidate(2, preModal.open = true, preModal);
		}
	};

	let preModal = {};
	let commandToRun = "", commandArgsToRun = "";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<Settings> was created with unknown prop '${key}'`);
	});

	function premodal_preModal_binding(value) {
		preModal = value;
		$$invalidate(2, preModal);
	}

	function customdialog_dialog_binding(value) {
		pythonpathCheck = value;
		$$invalidate(1, pythonpathCheck);
	}

	function textfield0_value_binding(value) {
		$pythonpath = value;
		pythonpath.set($pythonpath);
	}

	function textfield1_value_binding(value) {
		$pythonscript = value;
		pythonscript.set($pythonscript);
	}

	function textfield2_value_binding(value) {
		$github.username = value;
		github.set($github);
	}

	function textfield3_value_binding(value) {
		$github.repo = value;
		github.set($github);
	}

	function customselect_picked_binding(value) {
		$github.branch = value;
		github.set($github);
	}

	const click_handler = () => {
		set_store_value(activateChangelog, $activateChangelog = true, $activateChangelog);
	};

	function textfield4_value_binding(value) {
		$backupName = value;
		backupName.set($backupName);
	}

	function terminal_commandToRun_binding(value) {
		commandToRun = value;
		$$invalidate(3, commandToRun);
	}

	function terminal_commandArgsToRun_binding(value) {
		commandArgsToRun = value;
		$$invalidate(4, commandArgsToRun);
	}

	$$self.$capture_state = () => ({
		pythonpath,
		pythonscript,
		pyVersion,
		github,
		backupName,
		activateChangelog,
		Textfield,
		onMount,
		fade,
		CustomDialog,
		CustomSelect,
		PreModal,
		Changelog,
		download,
		InstallUpdate,
		updateCheck,
		resetPyConfig,
		updatePyConfig,
		backupRestore,
		tick,
		Terminal,
		backup,
		restore,
		selected,
		navigate,
		pythonpathCheck,
		handlepythonPathCheck,
		update,
		preModal,
		commandToRun,
		commandArgsToRun,
		$pyVersion,
		$pythonpath,
		$pythonscript,
		$github,
		$activateChangelog,
		$backupName
	});

	$$self.$inject_state = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("pythonpathCheck" in $$props) $$invalidate(1, pythonpathCheck = $$props.pythonpathCheck);
		if ("preModal" in $$props) $$invalidate(2, preModal = $$props.preModal);
		if ("commandToRun" in $$props) $$invalidate(3, commandToRun = $$props.commandToRun);
		if ("commandArgsToRun" in $$props) $$invalidate(4, commandArgsToRun = $$props.commandArgsToRun);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selected,
		pythonpathCheck,
		preModal,
		commandToRun,
		commandArgsToRun,
		$pyVersion,
		$pythonpath,
		$pythonscript,
		$github,
		$activateChangelog,
		$backupName,
		backup,
		restore,
		navigate,
		handlepythonPathCheck,
		update,
		premodal_preModal_binding,
		customdialog_dialog_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		textfield2_value_binding,
		textfield3_value_binding,
		customselect_picked_binding,
		click_handler,
		textfield4_value_binding,
		terminal_commandToRun_binding,
		terminal_commandArgsToRun_binding
	];
}

class Settings extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Settings",
			options,
			id: create_fragment$1p.name
		});
	}
}

/* src\Pages\Misc.svelte generated by Svelte v3.31.2 */
const file$1j = "src\\Pages\\Misc.svelte";

// (96:24) <Label>
function create_default_slot_2$e(ctx) {
	let t_value = /*tab*/ ctx[51] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[1] & /*tab*/ 1048576 && t_value !== (t_value = /*tab*/ ctx[51] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$e.name,
		type: "slot",
		source: "(96:24) <Label>",
		ctx
	});

	return block;
}

// (96:12) <Tab {tab}>
function create_default_slot_1$g(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_2$e] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty[1] & /*$$scope, tab*/ 3145728) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$g.name,
		type: "slot",
		source: "(96:12) <Tab {tab}>",
		ctx
	});

	return block;
}

// (95:8) <TabBar tabs={navItems} let:tab bind:active>
function create_default_slot$B(ctx) {
	let tab;
	let current;

	tab = new Tab({
			props: {
				tab: /*tab*/ ctx[51],
				$$slots: { default: [create_default_slot_1$g] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tab.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tab, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tab_changes = {};
			if (dirty[1] & /*tab*/ 1048576) tab_changes.tab = /*tab*/ ctx[51];

			if (dirty[1] & /*$$scope, tab*/ 3145728) {
				tab_changes.$$scope = { dirty, ctx };
			}

			tab.$set(tab_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tab, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$B.name,
		type: "slot",
		source: "(95:8) <TabBar tabs={navItems} let:tab bind:active>",
		ctx
	});

	return block;
}

// (160:4) {:else}
function create_else_block$e(ctx) {
	let terminal;
	let current;
	terminal = new Terminal({ $$inline: true });

	const block = {
		c: function create() {
			create_component(terminal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(terminal, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(terminal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(terminal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(terminal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$e.name,
		type: "else",
		source: "(160:4) {:else}",
		ctx
	});

	return block;
}

// (100:4) {#if active=="Unit Conversion"}
function create_if_block$A(ctx) {
	let div8;
	let div3;
	let div0;
	let t1;
	let hr0;
	let t2;
	let div2;
	let textfield0;
	let updating_value;
	let t3;
	let textfield1;
	let updating_value_1;
	let t4;
	let textfield2;
	let updating_value_2;
	let t5;
	let textfield3;
	let updating_value_3;
	let t6;
	let textfield4;
	let updating_value_4;
	let t7;
	let textfield5;
	let updating_value_5;
	let t8;
	let textfield6;
	let updating_value_6;
	let t9;
	let textfield7;
	let updating_value_7;
	let t10;
	let hr1;
	let t11;
	let div1;
	let t13;
	let customswitch0;
	let updating_selected;
	let t14;
	let textfield8;
	let updating_value_8;
	let t15;
	let textfield9;
	let updating_value_9;
	let t16;
	let textfield10;
	let updating_value_10;
	let t17;
	let textfield11;
	let updating_value_11;
	let t18;
	let div7;
	let div4;
	let t20;
	let hr2;
	let t21;
	let div6;
	let div5;
	let t23;
	let textfield12;
	let updating_value_12;
	let t24;
	let textfield13;
	let updating_value_13;
	let t25;
	let textfield14;
	let updating_value_14;
	let t26;
	let textfield15;
	let updating_value_15;
	let t27;
	let hr3;
	let t28;
	let customswitch1;
	let updating_selected_1;
	let t29;
	let textfield16;
	let updating_value_16;
	let t30;
	let textfield17;
	let updating_value_17;
	let current;

	function textfield0_value_binding(value) {
		/*textfield0_value_binding*/ ctx[24].call(null, value);
	}

	let textfield0_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "Hz"
	};

	if (/*hz*/ ctx[4] !== void 0) {
		textfield0_props.value = /*hz*/ ctx[4];
	}

	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

	function textfield1_value_binding(value) {
		/*textfield1_value_binding*/ ctx[25].call(null, value);
	}

	let textfield1_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "GHz"
	};

	if (/*ghz*/ ctx[15] !== void 0) {
		textfield1_props.value = /*ghz*/ ctx[15];
	}

	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));
	textfield1.$on("change", /*change_handler*/ ctx[26]);

	function textfield2_value_binding(value) {
		/*textfield2_value_binding*/ ctx[27].call(null, value);
	}

	let textfield2_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "Micron"
	};

	if (/*um*/ ctx[14] !== void 0) {
		textfield2_props.value = /*um*/ ctx[14];
	}

	textfield2 = new Textfield({ props: textfield2_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield2, "value", textfield2_value_binding));
	textfield2.$on("change", /*change_handler_1*/ ctx[28]);

	function textfield3_value_binding(value) {
		/*textfield3_value_binding*/ ctx[29].call(null, value);
	}

	let textfield3_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "cm-1"
	};

	if (/*cm_1*/ ctx[13] !== void 0) {
		textfield3_props.value = /*cm_1*/ ctx[13];
	}

	textfield3 = new Textfield({ props: textfield3_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield3, "value", textfield3_value_binding));
	textfield3.$on("change", /*change_handler_2*/ ctx[30]);

	function textfield4_value_binding(value) {
		/*textfield4_value_binding*/ ctx[31].call(null, value);
	}

	let textfield4_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "Kelvin"
	};

	if (/*kelvin*/ ctx[12] !== void 0) {
		textfield4_props.value = /*kelvin*/ ctx[12];
	}

	textfield4 = new Textfield({ props: textfield4_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield4, "value", textfield4_value_binding));
	textfield4.$on("change", /*change_handler_3*/ ctx[32]);

	function textfield5_value_binding(value) {
		/*textfield5_value_binding*/ ctx[33].call(null, value);
	}

	let textfield5_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "eV"
	};

	if (/*eV*/ ctx[11] !== void 0) {
		textfield5_props.value = /*eV*/ ctx[11];
	}

	textfield5 = new Textfield({ props: textfield5_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield5, "value", textfield5_value_binding));
	textfield5.$on("change", /*change_handler_4*/ ctx[34]);

	function textfield6_value_binding(value) {
		/*textfield6_value_binding*/ ctx[35].call(null, value);
	}

	let textfield6_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "Joule"
	};

	if (/*J*/ ctx[17] !== void 0) {
		textfield6_props.value = /*J*/ ctx[17];
	}

	textfield6 = new Textfield({ props: textfield6_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield6, "value", textfield6_value_binding));
	textfield6.$on("change", /*change_handler_5*/ ctx[36]);

	function textfield7_value_binding(value) {
		/*textfield7_value_binding*/ ctx[37].call(null, value);
	}

	let textfield7_props = {
		style: "width:25%; margin-right:0.5em;",
		label: "nm"
	};

	if (/*nm*/ ctx[16] !== void 0) {
		textfield7_props.value = /*nm*/ ctx[16];
	}

	textfield7 = new Textfield({ props: textfield7_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield7, "value", textfield7_value_binding));
	textfield7.$on("change", /*change_handler_6*/ ctx[38]);

	function customswitch0_selected_binding(value) {
		/*customswitch0_selected_binding*/ ctx[39].call(null, value);
	}

	let customswitch0_props = { style: "margin: 0 1em;", label: "Edit" };

	if (/*edit_constants*/ ctx[18] !== void 0) {
		customswitch0_props.selected = /*edit_constants*/ ctx[18];
	}

	customswitch0 = new CustomSwitch({
			props: customswitch0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch0, "selected", customswitch0_selected_binding));

	function textfield8_value_binding(value) {
		/*textfield8_value_binding*/ ctx[40].call(null, value);
	}

	let textfield8_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_constants*/ ctx[18],
		label: "Speed of light in vaccum"
	};

	if (/*c*/ ctx[0] !== void 0) {
		textfield8_props.value = /*c*/ ctx[0];
	}

	textfield8 = new Textfield({ props: textfield8_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield8, "value", textfield8_value_binding));

	function textfield9_value_binding(value) {
		/*textfield9_value_binding*/ ctx[41].call(null, value);
	}

	let textfield9_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_constants*/ ctx[18],
		label: "Boltzman constant"
	};

	if (/*boltzman_constant*/ ctx[2] !== void 0) {
		textfield9_props.value = /*boltzman_constant*/ ctx[2];
	}

	textfield9 = new Textfield({ props: textfield9_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield9, "value", textfield9_value_binding));

	function textfield10_value_binding(value) {
		/*textfield10_value_binding*/ ctx[42].call(null, value);
	}

	let textfield10_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_constants*/ ctx[18],
		label: "Plank's constant"
	};

	if (/*plank_constant*/ ctx[1] !== void 0) {
		textfield10_props.value = /*plank_constant*/ ctx[1];
	}

	textfield10 = new Textfield({ props: textfield10_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield10, "value", textfield10_value_binding));

	function textfield11_value_binding(value) {
		/*textfield11_value_binding*/ ctx[43].call(null, value);
	}

	let textfield11_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_constants*/ ctx[18],
		label: "Electric charge"
	};

	if (/*electron_charge*/ ctx[3] !== void 0) {
		textfield11_props.value = /*electron_charge*/ ctx[3];
	}

	textfield11 = new Textfield({ props: textfield11_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield11, "value", textfield11_value_binding));

	function textfield12_value_binding(value) {
		/*textfield12_value_binding*/ ctx[44].call(null, value);
	}

	let textfield12_props = {
		style: "width:90%; margin-right:0.5em;",
		label: "Before letting in gas"
	};

	if (/*pq1_before*/ ctx[5] !== void 0) {
		textfield12_props.value = /*pq1_before*/ ctx[5];
	}

	textfield12 = new Textfield({ props: textfield12_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield12, "value", textfield12_value_binding));

	function textfield13_value_binding(value) {
		/*textfield13_value_binding*/ ctx[45].call(null, value);
	}

	let textfield13_props = {
		style: "width:90%; margin-right:0.5em;",
		label: "After letting in gas"
	};

	if (/*pq1_after*/ ctx[6] !== void 0) {
		textfield13_props.value = /*pq1_after*/ ctx[6];
	}

	textfield13 = new Textfield({ props: textfield13_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield13, "value", textfield13_value_binding));

	function textfield14_value_binding(value) {
		/*textfield14_value_binding*/ ctx[46].call(null, value);
	}

	let textfield14_props = {
		style: "width:90%; margin-right:0.5em;",
		label: "Temperature"
	};

	if (/*temperature*/ ctx[7] !== void 0) {
		textfield14_props.value = /*temperature*/ ctx[7];
	}

	textfield14 = new Textfield({ props: textfield14_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield14, "value", textfield14_value_binding));

	function textfield15_value_binding(value) {
		/*textfield15_value_binding*/ ctx[47].call(null, value);
	}

	let textfield15_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: true,
		label: "Number density"
	};

	if (/*ndensity*/ ctx[20] !== void 0) {
		textfield15_props.value = /*ndensity*/ ctx[20];
	}

	textfield15 = new Textfield({ props: textfield15_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield15, "value", textfield15_value_binding));

	function customswitch1_selected_binding(value) {
		/*customswitch1_selected_binding*/ ctx[48].call(null, value);
	}

	let customswitch1_props = { style: "margin: 0 1em;", label: "Edit" };

	if (/*edit_numberDensity_constants*/ ctx[19] !== void 0) {
		customswitch1_props.selected = /*edit_numberDensity_constants*/ ctx[19];
	}

	customswitch1 = new CustomSwitch({
			props: customswitch1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(customswitch1, "selected", customswitch1_selected_binding));

	function textfield16_value_binding(value) {
		/*textfield16_value_binding*/ ctx[49].call(null, value);
	}

	let textfield16_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_numberDensity_constants*/ ctx[19],
		label: "Calibration Factor"
	};

	if (/*calibration_factor*/ ctx[8] !== void 0) {
		textfield16_props.value = /*calibration_factor*/ ctx[8];
	}

	textfield16 = new Textfield({ props: textfield16_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield16, "value", textfield16_value_binding));

	function textfield17_value_binding(value) {
		/*textfield17_value_binding*/ ctx[50].call(null, value);
	}

	let textfield17_props = {
		style: "width:90%; margin-right:0.5em;",
		disabled: !/*edit_numberDensity_constants*/ ctx[19],
		label: "Chamber Temperature (RT)"
	};

	if (/*rt*/ ctx[9] !== void 0) {
		textfield17_props.value = /*rt*/ ctx[9];
	}

	textfield17 = new Textfield({ props: textfield17_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield17, "value", textfield17_value_binding));

	const block = {
		c: function create() {
			div8 = element("div");
			div3 = element("div");
			div0 = element("div");
			div0.textContent = "Energy Conversion";
			t1 = space();
			hr0 = element("hr");
			t2 = space();
			div2 = element("div");
			create_component(textfield0.$$.fragment);
			t3 = space();
			create_component(textfield1.$$.fragment);
			t4 = space();
			create_component(textfield2.$$.fragment);
			t5 = space();
			create_component(textfield3.$$.fragment);
			t6 = space();
			create_component(textfield4.$$.fragment);
			t7 = space();
			create_component(textfield5.$$.fragment);
			t8 = space();
			create_component(textfield6.$$.fragment);
			t9 = space();
			create_component(textfield7.$$.fragment);
			t10 = space();
			hr1 = element("hr");
			t11 = space();
			div1 = element("div");
			div1.textContent = "Fundamental constants";
			t13 = space();
			create_component(customswitch0.$$.fragment);
			t14 = space();
			create_component(textfield8.$$.fragment);
			t15 = space();
			create_component(textfield9.$$.fragment);
			t16 = space();
			create_component(textfield10.$$.fragment);
			t17 = space();
			create_component(textfield11.$$.fragment);
			t18 = space();
			div7 = element("div");
			div4 = element("div");
			div4.textContent = "Number Density";
			t20 = space();
			hr2 = element("hr");
			t21 = space();
			div6 = element("div");
			div5 = element("div");
			div5.textContent = "Main Chamber Press.";
			t23 = space();
			create_component(textfield12.$$.fragment);
			t24 = space();
			create_component(textfield13.$$.fragment);
			t25 = space();
			create_component(textfield14.$$.fragment);
			t26 = space();
			create_component(textfield15.$$.fragment);
			t27 = space();
			hr3 = element("hr");
			t28 = space();
			create_component(customswitch1.$$.fragment);
			t29 = space();
			create_component(textfield16.$$.fragment);
			t30 = space();
			create_component(textfield17.$$.fragment);
			attr_dev(div0, "class", "title svelte-10jrpmw");
			add_location(div0, file$1j, 104, 16, 2610);
			attr_dev(hr0, "class", "svelte-10jrpmw");
			add_location(hr0, file$1j, 106, 16, 2672);
			attr_dev(hr1, "class", "svelte-10jrpmw");
			add_location(hr1, file$1j, 122, 20, 3931);
			attr_dev(div1, "class", "subtitle is-pulled-left svelte-10jrpmw");
			add_location(div1, file$1j, 124, 20, 3959);
			attr_dev(div2, "class", "unit_conversion_contents svelte-10jrpmw");
			add_location(div2, file$1j, 108, 16, 2696);
			attr_dev(div3, "class", "column box is-4 unit_converter_column svelte-10jrpmw");
			add_location(div3, file$1j, 102, 12, 2539);
			attr_dev(div4, "class", "title svelte-10jrpmw");
			add_location(div4, file$1j, 137, 16, 4889);
			attr_dev(hr2, "class", "svelte-10jrpmw");
			add_location(hr2, file$1j, 138, 16, 4946);
			attr_dev(div5, "class", "subtitle svelte-10jrpmw");
			add_location(div5, file$1j, 142, 20, 5032);
			attr_dev(hr3, "class", "svelte-10jrpmw");
			add_location(hr3, file$1j, 147, 20, 5609);
			attr_dev(div6, "class", "unit_conversion_contents svelte-10jrpmw");
			add_location(div6, file$1j, 140, 16, 4970);
			attr_dev(div7, "class", "column box is-4 unit_converter_column svelte-10jrpmw");
			add_location(div7, file$1j, 135, 12, 4806);
			attr_dev(div8, "class", "columns is-multiline contentBox svelte-10jrpmw");
			attr_dev(div8, "id", "unit_conversion_table");
			add_location(div8, file$1j, 100, 8, 2451);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div8, anchor);
			append_dev(div8, div3);
			append_dev(div3, div0);
			append_dev(div3, t1);
			append_dev(div3, hr0);
			append_dev(div3, t2);
			append_dev(div3, div2);
			mount_component(textfield0, div2, null);
			append_dev(div2, t3);
			mount_component(textfield1, div2, null);
			append_dev(div2, t4);
			mount_component(textfield2, div2, null);
			append_dev(div2, t5);
			mount_component(textfield3, div2, null);
			append_dev(div2, t6);
			mount_component(textfield4, div2, null);
			append_dev(div2, t7);
			mount_component(textfield5, div2, null);
			append_dev(div2, t8);
			mount_component(textfield6, div2, null);
			append_dev(div2, t9);
			mount_component(textfield7, div2, null);
			append_dev(div2, t10);
			append_dev(div2, hr1);
			append_dev(div2, t11);
			append_dev(div2, div1);
			append_dev(div2, t13);
			mount_component(customswitch0, div2, null);
			append_dev(div2, t14);
			mount_component(textfield8, div2, null);
			append_dev(div2, t15);
			mount_component(textfield9, div2, null);
			append_dev(div2, t16);
			mount_component(textfield10, div2, null);
			append_dev(div2, t17);
			mount_component(textfield11, div2, null);
			append_dev(div8, t18);
			append_dev(div8, div7);
			append_dev(div7, div4);
			append_dev(div7, t20);
			append_dev(div7, hr2);
			append_dev(div7, t21);
			append_dev(div7, div6);
			append_dev(div6, div5);
			append_dev(div6, t23);
			mount_component(textfield12, div6, null);
			append_dev(div6, t24);
			mount_component(textfield13, div6, null);
			append_dev(div6, t25);
			mount_component(textfield14, div6, null);
			append_dev(div6, t26);
			mount_component(textfield15, div6, null);
			append_dev(div6, t27);
			append_dev(div6, hr3);
			append_dev(div6, t28);
			mount_component(customswitch1, div6, null);
			append_dev(div6, t29);
			mount_component(textfield16, div6, null);
			append_dev(div6, t30);
			mount_component(textfield17, div6, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (!updating_value && dirty[0] & /*hz*/ 16) {
				updating_value = true;
				textfield0_changes.value = /*hz*/ ctx[4];
				add_flush_callback(() => updating_value = false);
			}

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (!updating_value_1 && dirty[0] & /*ghz*/ 32768) {
				updating_value_1 = true;
				textfield1_changes.value = /*ghz*/ ctx[15];
				add_flush_callback(() => updating_value_1 = false);
			}

			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (!updating_value_2 && dirty[0] & /*um*/ 16384) {
				updating_value_2 = true;
				textfield2_changes.value = /*um*/ ctx[14];
				add_flush_callback(() => updating_value_2 = false);
			}

			textfield2.$set(textfield2_changes);
			const textfield3_changes = {};

			if (!updating_value_3 && dirty[0] & /*cm_1*/ 8192) {
				updating_value_3 = true;
				textfield3_changes.value = /*cm_1*/ ctx[13];
				add_flush_callback(() => updating_value_3 = false);
			}

			textfield3.$set(textfield3_changes);
			const textfield4_changes = {};

			if (!updating_value_4 && dirty[0] & /*kelvin*/ 4096) {
				updating_value_4 = true;
				textfield4_changes.value = /*kelvin*/ ctx[12];
				add_flush_callback(() => updating_value_4 = false);
			}

			textfield4.$set(textfield4_changes);
			const textfield5_changes = {};

			if (!updating_value_5 && dirty[0] & /*eV*/ 2048) {
				updating_value_5 = true;
				textfield5_changes.value = /*eV*/ ctx[11];
				add_flush_callback(() => updating_value_5 = false);
			}

			textfield5.$set(textfield5_changes);
			const textfield6_changes = {};

			if (!updating_value_6 && dirty[0] & /*J*/ 131072) {
				updating_value_6 = true;
				textfield6_changes.value = /*J*/ ctx[17];
				add_flush_callback(() => updating_value_6 = false);
			}

			textfield6.$set(textfield6_changes);
			const textfield7_changes = {};

			if (!updating_value_7 && dirty[0] & /*nm*/ 65536) {
				updating_value_7 = true;
				textfield7_changes.value = /*nm*/ ctx[16];
				add_flush_callback(() => updating_value_7 = false);
			}

			textfield7.$set(textfield7_changes);
			const customswitch0_changes = {};

			if (!updating_selected && dirty[0] & /*edit_constants*/ 262144) {
				updating_selected = true;
				customswitch0_changes.selected = /*edit_constants*/ ctx[18];
				add_flush_callback(() => updating_selected = false);
			}

			customswitch0.$set(customswitch0_changes);
			const textfield8_changes = {};
			if (dirty[0] & /*edit_constants*/ 262144) textfield8_changes.disabled = !/*edit_constants*/ ctx[18];

			if (!updating_value_8 && dirty[0] & /*c*/ 1) {
				updating_value_8 = true;
				textfield8_changes.value = /*c*/ ctx[0];
				add_flush_callback(() => updating_value_8 = false);
			}

			textfield8.$set(textfield8_changes);
			const textfield9_changes = {};
			if (dirty[0] & /*edit_constants*/ 262144) textfield9_changes.disabled = !/*edit_constants*/ ctx[18];

			if (!updating_value_9 && dirty[0] & /*boltzman_constant*/ 4) {
				updating_value_9 = true;
				textfield9_changes.value = /*boltzman_constant*/ ctx[2];
				add_flush_callback(() => updating_value_9 = false);
			}

			textfield9.$set(textfield9_changes);
			const textfield10_changes = {};
			if (dirty[0] & /*edit_constants*/ 262144) textfield10_changes.disabled = !/*edit_constants*/ ctx[18];

			if (!updating_value_10 && dirty[0] & /*plank_constant*/ 2) {
				updating_value_10 = true;
				textfield10_changes.value = /*plank_constant*/ ctx[1];
				add_flush_callback(() => updating_value_10 = false);
			}

			textfield10.$set(textfield10_changes);
			const textfield11_changes = {};
			if (dirty[0] & /*edit_constants*/ 262144) textfield11_changes.disabled = !/*edit_constants*/ ctx[18];

			if (!updating_value_11 && dirty[0] & /*electron_charge*/ 8) {
				updating_value_11 = true;
				textfield11_changes.value = /*electron_charge*/ ctx[3];
				add_flush_callback(() => updating_value_11 = false);
			}

			textfield11.$set(textfield11_changes);
			const textfield12_changes = {};

			if (!updating_value_12 && dirty[0] & /*pq1_before*/ 32) {
				updating_value_12 = true;
				textfield12_changes.value = /*pq1_before*/ ctx[5];
				add_flush_callback(() => updating_value_12 = false);
			}

			textfield12.$set(textfield12_changes);
			const textfield13_changes = {};

			if (!updating_value_13 && dirty[0] & /*pq1_after*/ 64) {
				updating_value_13 = true;
				textfield13_changes.value = /*pq1_after*/ ctx[6];
				add_flush_callback(() => updating_value_13 = false);
			}

			textfield13.$set(textfield13_changes);
			const textfield14_changes = {};

			if (!updating_value_14 && dirty[0] & /*temperature*/ 128) {
				updating_value_14 = true;
				textfield14_changes.value = /*temperature*/ ctx[7];
				add_flush_callback(() => updating_value_14 = false);
			}

			textfield14.$set(textfield14_changes);
			const textfield15_changes = {};

			if (!updating_value_15 && dirty[0] & /*ndensity*/ 1048576) {
				updating_value_15 = true;
				textfield15_changes.value = /*ndensity*/ ctx[20];
				add_flush_callback(() => updating_value_15 = false);
			}

			textfield15.$set(textfield15_changes);
			const customswitch1_changes = {};

			if (!updating_selected_1 && dirty[0] & /*edit_numberDensity_constants*/ 524288) {
				updating_selected_1 = true;
				customswitch1_changes.selected = /*edit_numberDensity_constants*/ ctx[19];
				add_flush_callback(() => updating_selected_1 = false);
			}

			customswitch1.$set(customswitch1_changes);
			const textfield16_changes = {};
			if (dirty[0] & /*edit_numberDensity_constants*/ 524288) textfield16_changes.disabled = !/*edit_numberDensity_constants*/ ctx[19];

			if (!updating_value_16 && dirty[0] & /*calibration_factor*/ 256) {
				updating_value_16 = true;
				textfield16_changes.value = /*calibration_factor*/ ctx[8];
				add_flush_callback(() => updating_value_16 = false);
			}

			textfield16.$set(textfield16_changes);
			const textfield17_changes = {};
			if (dirty[0] & /*edit_numberDensity_constants*/ 524288) textfield17_changes.disabled = !/*edit_numberDensity_constants*/ ctx[19];

			if (!updating_value_17 && dirty[0] & /*rt*/ 512) {
				updating_value_17 = true;
				textfield17_changes.value = /*rt*/ ctx[9];
				add_flush_callback(() => updating_value_17 = false);
			}

			textfield17.$set(textfield17_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			transition_in(textfield4.$$.fragment, local);
			transition_in(textfield5.$$.fragment, local);
			transition_in(textfield6.$$.fragment, local);
			transition_in(textfield7.$$.fragment, local);
			transition_in(customswitch0.$$.fragment, local);
			transition_in(textfield8.$$.fragment, local);
			transition_in(textfield9.$$.fragment, local);
			transition_in(textfield10.$$.fragment, local);
			transition_in(textfield11.$$.fragment, local);
			transition_in(textfield12.$$.fragment, local);
			transition_in(textfield13.$$.fragment, local);
			transition_in(textfield14.$$.fragment, local);
			transition_in(textfield15.$$.fragment, local);
			transition_in(customswitch1.$$.fragment, local);
			transition_in(textfield16.$$.fragment, local);
			transition_in(textfield17.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			transition_out(textfield4.$$.fragment, local);
			transition_out(textfield5.$$.fragment, local);
			transition_out(textfield6.$$.fragment, local);
			transition_out(textfield7.$$.fragment, local);
			transition_out(customswitch0.$$.fragment, local);
			transition_out(textfield8.$$.fragment, local);
			transition_out(textfield9.$$.fragment, local);
			transition_out(textfield10.$$.fragment, local);
			transition_out(textfield11.$$.fragment, local);
			transition_out(textfield12.$$.fragment, local);
			transition_out(textfield13.$$.fragment, local);
			transition_out(textfield14.$$.fragment, local);
			transition_out(textfield15.$$.fragment, local);
			transition_out(customswitch1.$$.fragment, local);
			transition_out(textfield16.$$.fragment, local);
			transition_out(textfield17.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div8);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(textfield2);
			destroy_component(textfield3);
			destroy_component(textfield4);
			destroy_component(textfield5);
			destroy_component(textfield6);
			destroy_component(textfield7);
			destroy_component(customswitch0);
			destroy_component(textfield8);
			destroy_component(textfield9);
			destroy_component(textfield10);
			destroy_component(textfield11);
			destroy_component(textfield12);
			destroy_component(textfield13);
			destroy_component(textfield14);
			destroy_component(textfield15);
			destroy_component(customswitch1);
			destroy_component(textfield16);
			destroy_component(textfield17);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$A.name,
		type: "if",
		source: "(100:4) {#if active==\\\"Unit Conversion\\\"}",
		ctx
	});

	return block;
}

function create_fragment$1q(ctx) {
	let section;
	let div;
	let tabbar;
	let updating_active;
	let t;
	let current_block_type_index;
	let if_block;
	let current;

	function tabbar_active_binding(value) {
		/*tabbar_active_binding*/ ctx[23].call(null, value);
	}

	let tabbar_props = {
		tabs: /*navItems*/ ctx[21],
		$$slots: {
			default: [
				create_default_slot$B,
				({ tab }) => ({ 51: tab }),
				({ tab }) => [0, tab ? 1048576 : 0]
			]
		},
		$$scope: { ctx }
	};

	if (/*active*/ ctx[10] !== void 0) {
		tabbar_props.active = /*active*/ ctx[10];
	}

	tabbar = new TabBar({ props: tabbar_props, $$inline: true });
	binding_callbacks.push(() => bind(tabbar, "active", tabbar_active_binding));
	const if_block_creators = [create_if_block$A, create_else_block$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*active*/ ctx[10] == "Unit Conversion") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(tabbar.$$.fragment);
			t = space();
			if_block.c();
			attr_dev(div, "class", "misc-nav box animated fadeInDown svelte-10jrpmw");
			attr_dev(div, "id", "navbar");
			add_location(div, file$1j, 93, 4, 2205);
			attr_dev(section, "class", "animated fadeIn section svelte-10jrpmw");
			attr_dev(section, "id", "Misc");
			set_style(section, "display", "none");
			add_location(section, file$1j, 91, 0, 2125);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(tabbar, div, null);
			append_dev(section, t);
			if_blocks[current_block_type_index].m(section, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tabbar_changes = {};

			if (dirty[1] & /*$$scope, tab*/ 3145728) {
				tabbar_changes.$$scope = { dirty, ctx };
			}

			if (!updating_active && dirty[0] & /*active*/ 1024) {
				updating_active = true;
				tabbar_changes.active = /*active*/ ctx[10];
				add_flush_callback(() => updating_active = false);
			}

			tabbar.$set(tabbar_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(section, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabbar.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabbar.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(tabbar);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1q($$self, $$props, $$invalidate) {
	let c;
	let plank_constant;
	let boltzman_constant;
	let electron_charge;
	let hz;
	let eV;
	let kelvin;
	let cm_1;
	let um;
	let ghz;
	let nm;
	let J;
	let edit_constants;
	let edit_numberDensity_constants;
	let pq1_before;
	let pq1_after;
	let temperature;
	let calibration_factor;
	let rt;
	let ndensity_temp;
	let ndensity;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Misc", slots, []);
	let active = "Unit Conversion";
	const navItems = ["Unit Conversion", "Terminal"];
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Misc> was created with unknown prop '${key}'`);
	});

	function tabbar_active_binding(value) {
		active = value;
		$$invalidate(10, active);
	}

	function textfield0_value_binding(value) {
		hz = value;
		$$invalidate(4, hz);
	}

	function textfield1_value_binding(value) {
		ghz = value;
		($$invalidate(15, ghz), $$invalidate(4, hz));
	}

	const change_handler = () => $$invalidate(4, hz = ghz * 1000000000);

	function textfield2_value_binding(value) {
		um = value;
		(($$invalidate(14, um), $$invalidate(0, c)), $$invalidate(4, hz));
	}

	const change_handler_1 = () => $$invalidate(4, hz = c / um * 1000000);

	function textfield3_value_binding(value) {
		cm_1 = value;
		(($$invalidate(13, cm_1), $$invalidate(4, hz)), $$invalidate(0, c));
	}

	const change_handler_2 = () => $$invalidate(4, hz = cm_1 * c * 100);

	function textfield4_value_binding(value) {
		kelvin = value;
		((($$invalidate(12, kelvin), $$invalidate(1, plank_constant)), $$invalidate(2, boltzman_constant)), $$invalidate(4, hz));
	}

	const change_handler_3 = () => $$invalidate(4, hz = boltzman_constant / plank_constant * kelvin);

	function textfield5_value_binding(value) {
		eV = value;
		((($$invalidate(11, eV), $$invalidate(1, plank_constant)), $$invalidate(3, electron_charge)), $$invalidate(4, hz));
	}

	const change_handler_4 = () => $$invalidate(4, hz = electron_charge / plank_constant * eV);

	function textfield6_value_binding(value) {
		J = value;
		(($$invalidate(17, J), $$invalidate(1, plank_constant)), $$invalidate(4, hz));
	}

	const change_handler_5 = () => $$invalidate(4, hz = J / plank_constant);

	function textfield7_value_binding(value) {
		nm = value;
		(($$invalidate(16, nm), $$invalidate(0, c)), $$invalidate(4, hz));
	}

	const change_handler_6 = () => $$invalidate(4, hz = c / nm * 1000000000);

	function customswitch0_selected_binding(value) {
		edit_constants = value;
		$$invalidate(18, edit_constants);
	}

	function textfield8_value_binding(value) {
		c = value;
		$$invalidate(0, c);
	}

	function textfield9_value_binding(value) {
		boltzman_constant = value;
		$$invalidate(2, boltzman_constant);
	}

	function textfield10_value_binding(value) {
		plank_constant = value;
		$$invalidate(1, plank_constant);
	}

	function textfield11_value_binding(value) {
		electron_charge = value;
		$$invalidate(3, electron_charge);
	}

	function textfield12_value_binding(value) {
		pq1_before = value;
		$$invalidate(5, pq1_before);
	}

	function textfield13_value_binding(value) {
		pq1_after = value;
		$$invalidate(6, pq1_after);
	}

	function textfield14_value_binding(value) {
		temperature = value;
		$$invalidate(7, temperature);
	}

	function textfield15_value_binding(value) {
		ndensity = value;
		((((((($$invalidate(20, ndensity), $$invalidate(22, ndensity_temp)), $$invalidate(8, calibration_factor)), $$invalidate(2, boltzman_constant)), $$invalidate(9, rt)), $$invalidate(6, pq1_after)), $$invalidate(5, pq1_before)), $$invalidate(7, temperature));
	}

	function customswitch1_selected_binding(value) {
		edit_numberDensity_constants = value;
		$$invalidate(19, edit_numberDensity_constants);
	}

	function textfield16_value_binding(value) {
		calibration_factor = value;
		$$invalidate(8, calibration_factor);
	}

	function textfield17_value_binding(value) {
		rt = value;
		$$invalidate(9, rt);
	}

	$$self.$capture_state = () => ({
		Textfield,
		CustomSwitch,
		Terminal,
		Tab,
		Label,
		TabBar,
		active,
		navItems,
		c,
		plank_constant,
		boltzman_constant,
		electron_charge,
		hz,
		eV,
		kelvin,
		cm_1,
		um,
		ghz,
		nm,
		J,
		edit_constants,
		edit_numberDensity_constants,
		pq1_before,
		pq1_after,
		temperature,
		calibration_factor,
		rt,
		ndensity_temp,
		ndensity
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(10, active = $$props.active);
		if ("c" in $$props) $$invalidate(0, c = $$props.c);
		if ("plank_constant" in $$props) $$invalidate(1, plank_constant = $$props.plank_constant);
		if ("boltzman_constant" in $$props) $$invalidate(2, boltzman_constant = $$props.boltzman_constant);
		if ("electron_charge" in $$props) $$invalidate(3, electron_charge = $$props.electron_charge);
		if ("hz" in $$props) $$invalidate(4, hz = $$props.hz);
		if ("eV" in $$props) $$invalidate(11, eV = $$props.eV);
		if ("kelvin" in $$props) $$invalidate(12, kelvin = $$props.kelvin);
		if ("cm_1" in $$props) $$invalidate(13, cm_1 = $$props.cm_1);
		if ("um" in $$props) $$invalidate(14, um = $$props.um);
		if ("ghz" in $$props) $$invalidate(15, ghz = $$props.ghz);
		if ("nm" in $$props) $$invalidate(16, nm = $$props.nm);
		if ("J" in $$props) $$invalidate(17, J = $$props.J);
		if ("edit_constants" in $$props) $$invalidate(18, edit_constants = $$props.edit_constants);
		if ("edit_numberDensity_constants" in $$props) $$invalidate(19, edit_numberDensity_constants = $$props.edit_numberDensity_constants);
		if ("pq1_before" in $$props) $$invalidate(5, pq1_before = $$props.pq1_before);
		if ("pq1_after" in $$props) $$invalidate(6, pq1_after = $$props.pq1_after);
		if ("temperature" in $$props) $$invalidate(7, temperature = $$props.temperature);
		if ("calibration_factor" in $$props) $$invalidate(8, calibration_factor = $$props.calibration_factor);
		if ("rt" in $$props) $$invalidate(9, rt = $$props.rt);
		if ("ndensity_temp" in $$props) $$invalidate(22, ndensity_temp = $$props.ndensity_temp);
		if ("ndensity" in $$props) $$invalidate(20, ndensity = $$props.ndensity);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*plank_constant, electron_charge, hz*/ 26) {
			 $$invalidate(11, eV = plank_constant / electron_charge * hz);
		}

		if ($$self.$$.dirty[0] & /*plank_constant, boltzman_constant, hz*/ 22) {
			 $$invalidate(12, kelvin = plank_constant / boltzman_constant * hz);
		}

		if ($$self.$$.dirty[0] & /*hz, c*/ 17) {
			 $$invalidate(13, cm_1 = hz / (c * 100));
		}

		if ($$self.$$.dirty[0] & /*c, hz*/ 17) {
			 $$invalidate(14, um = c / hz * 1000000);
		}

		if ($$self.$$.dirty[0] & /*hz*/ 16) {
			 $$invalidate(15, ghz = hz * 1e-9);
		}

		if ($$self.$$.dirty[0] & /*c, hz*/ 17) {
			 $$invalidate(16, nm = c / hz * 1000000000);
		}

		if ($$self.$$.dirty[0] & /*plank_constant, hz*/ 18) {
			 $$invalidate(17, J = plank_constant * hz);
		}

		if ($$self.$$.dirty[0] & /*calibration_factor, boltzman_constant, rt, pq1_after, pq1_before, temperature*/ 996) {
			 $$invalidate(22, ndensity_temp = calibration_factor / (boltzman_constant * 10000 * rt ** 0.5) * ((pq1_after - pq1_before) / temperature ** 0.5));
		}

		if ($$self.$$.dirty[0] & /*ndensity_temp*/ 4194304) {
			 $$invalidate(20, ndensity = ndensity_temp.toExponential(4));
		}
	};

	 $$invalidate(0, c = 299792458); // m/s
	 $$invalidate(1, plank_constant = 6.62607004e-34); // Js
	 $$invalidate(2, boltzman_constant = 1.380649e-23); // J/K
	 $$invalidate(3, electron_charge = 1.602176565e-19); // C or eV = J
	 $$invalidate(4, hz = (1000000000000).toExponential(4));
	 $$invalidate(18, edit_constants = false);
	 $$invalidate(19, edit_numberDensity_constants = false);

	// Number density
	 $$invalidate(5, pq1_before = 1e-8);

	 $$invalidate(6, pq1_after = 0.00001);
	 $$invalidate(7, temperature = 5);
	 $$invalidate(8, calibration_factor = 205.54);
	 $$invalidate(9, rt = 300);

	return [
		c,
		plank_constant,
		boltzman_constant,
		electron_charge,
		hz,
		pq1_before,
		pq1_after,
		temperature,
		calibration_factor,
		rt,
		active,
		eV,
		kelvin,
		cm_1,
		um,
		ghz,
		nm,
		J,
		edit_constants,
		edit_numberDensity_constants,
		ndensity,
		navItems,
		ndensity_temp,
		tabbar_active_binding,
		textfield0_value_binding,
		textfield1_value_binding,
		change_handler,
		textfield2_value_binding,
		change_handler_1,
		textfield3_value_binding,
		change_handler_2,
		textfield4_value_binding,
		change_handler_3,
		textfield5_value_binding,
		change_handler_4,
		textfield6_value_binding,
		change_handler_5,
		textfield7_value_binding,
		change_handler_6,
		customswitch0_selected_binding,
		textfield8_value_binding,
		textfield9_value_binding,
		textfield10_value_binding,
		textfield11_value_binding,
		textfield12_value_binding,
		textfield13_value_binding,
		textfield14_value_binding,
		textfield15_value_binding,
		customswitch1_selected_binding,
		textfield16_value_binding,
		textfield17_value_binding
	];
}

class Misc extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Misc",
			options,
			id: create_fragment$1q.name
		});
	}
}

/* src\App.svelte generated by Svelte v3.31.2 */

const { console: console_1$f } = globals;
const file$1k = "src\\App.svelte";

function create_fragment$1r(ctx) {
	let navbar;
	let t0;
	let home;
	let t1;
	let div;
	let normline;
	let t2;
	let masspec;
	let t3;
	let timescan;
	let t4;
	let thz;
	let t5;
	let powerfile;
	let t6;
	let misc;
	let t7;
	let settings;
	let t8;
	let footer;
	let current;

	navbar = new Navbar({
			props: { navItems: /*navItems*/ ctx[0] },
			$$inline: true
		});

	home = new Home({ $$inline: true });
	normline = new Normline({ $$inline: true });
	masspec = new Masspec({ $$inline: true });
	timescan = new Timescan({ $$inline: true });
	thz = new THz({ $$inline: true });
	powerfile = new Powerfile({ $$inline: true });
	misc = new Misc({ $$inline: true });
	settings = new Settings({ $$inline: true });
	footer = new Footer({ $$inline: true });

	const block = {
		c: function create() {
			create_component(navbar.$$.fragment);
			t0 = space();
			create_component(home.$$.fragment);
			t1 = space();
			div = element("div");
			create_component(normline.$$.fragment);
			t2 = space();
			create_component(masspec.$$.fragment);
			t3 = space();
			create_component(timescan.$$.fragment);
			t4 = space();
			create_component(thz.$$.fragment);
			t5 = space();
			create_component(powerfile.$$.fragment);
			t6 = space();
			create_component(misc.$$.fragment);
			t7 = space();
			create_component(settings.$$.fragment);
			t8 = space();
			create_component(footer.$$.fragment);
			attr_dev(div, "class", "pageContainer");
			set_style(div, "overflow", "hidden");
			add_location(div, file$1k, 50, 0, 1593);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(navbar, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(home, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			mount_component(normline, div, null);
			append_dev(div, t2);
			mount_component(masspec, div, null);
			append_dev(div, t3);
			mount_component(timescan, div, null);
			append_dev(div, t4);
			mount_component(thz, div, null);
			append_dev(div, t5);
			mount_component(powerfile, div, null);
			append_dev(div, t6);
			mount_component(misc, div, null);
			append_dev(div, t7);
			mount_component(settings, div, null);
			insert_dev(target, t8, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(home.$$.fragment, local);
			transition_in(normline.$$.fragment, local);
			transition_in(masspec.$$.fragment, local);
			transition_in(timescan.$$.fragment, local);
			transition_in(thz.$$.fragment, local);
			transition_in(powerfile.$$.fragment, local);
			transition_in(misc.$$.fragment, local);
			transition_in(settings.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(home.$$.fragment, local);
			transition_out(normline.$$.fragment, local);
			transition_out(masspec.$$.fragment, local);
			transition_out(timescan.$$.fragment, local);
			transition_out(thz.$$.fragment, local);
			transition_out(powerfile.$$.fragment, local);
			transition_out(misc.$$.fragment, local);
			transition_out(settings.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(home, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_component(normline);
			destroy_component(masspec);
			destroy_component(timescan);
			destroy_component(thz);
			destroy_component(powerfile);
			destroy_component(misc);
			destroy_component(settings);
			if (detaching) detach_dev(t8);
			destroy_component(footer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1r($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("App", slots, []);

	onMount(() => {
		let allbuttons = Array.from(document.querySelectorAll(".button"));
		allbuttons.forEach(button => button.classList.add("hvr-glow"));
	});

	const navItems = [
		"Home",
		"Normline",
		"Masspec",
		"Timescan",
		"THz",
		"Powerfile",
		"Misc",
		"Settings"
	];

	let { version } = $$props;
	console.log("Svelte: ", version);
	window.Menu = remote.Menu;
	window.MenuItem = remote.MenuItem;
	let menu = new Menu();
	let rightClickPosition;
	menu.append(new MenuItem({ label: "Reload", role: "reload" }));

	menu.append(new MenuItem({
			label: "DevTools",
			role: "toggledevtools"
		}));

	menu.append(new MenuItem({
			label: "Inspect Element",
			click() {
				remote.getCurrentWindow().inspectElement(rightClickPosition.x, rightClickPosition.y);
			}
		}));

	window.addEventListener(
		"contextmenu",
		e => {
			e.preventDefault();
			rightClickPosition = { x: e.x, y: e.y };
			menu.popup(remote.getCurrentWindow());
		},
		false
	);

	const writable_props = ["version"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("version" in $$props) $$invalidate(1, version = $$props.version);
	};

	$$self.$capture_state = () => ({
		Navbar,
		Footer,
		Home,
		Powerfile,
		Normline,
		Masspec,
		Timescan,
		THz,
		Settings,
		Misc,
		onMount,
		navItems,
		version,
		menu,
		rightClickPosition
	});

	$$self.$inject_state = $$props => {
		if ("version" in $$props) $$invalidate(1, version = $$props.version);
		if ("menu" in $$props) menu = $$props.menu;
		if ("rightClickPosition" in $$props) rightClickPosition = $$props.rightClickPosition;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [navItems, version];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, { version: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$1r.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*version*/ ctx[1] === undefined && !("version" in props)) {
			console_1$f.warn("<App> was created without expected prop 'version'");
		}
	}

	get version() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const app = new App({
	target: document.body,
	props: { version: "" }
});

module.exports = app;
//# sourceMappingURL=bundle.js.map
